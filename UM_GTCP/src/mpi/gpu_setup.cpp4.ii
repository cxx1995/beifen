# 1 "gpu_setup.cu"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/usr/local/cuda-8.0/include/cuda_runtime.h" 1
# 56 "/usr/local/cuda-8.0/include/cuda_runtime.h"
#pragma GCC diagnostic push


#pragma GCC diagnostic ignored "-Wunused-function"
# 78 "/usr/local/cuda-8.0/include/cuda_runtime.h"
# 1 "/usr/local/cuda-8.0/include/host_config.h" 1
# 173 "/usr/local/cuda-8.0/include/host_config.h"
# 1 "/usr/include/features.h" 1 3 4
# 375 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 392 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 393 "/usr/include/sys/cdefs.h" 2 3 4
# 376 "/usr/include/features.h" 2 3 4
# 399 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4




# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 6 "/usr/include/gnu/stubs.h" 2 3 4
# 14 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64-v2.h" 1 3 4
# 15 "/usr/include/gnu/stubs.h" 2 3 4
# 400 "/usr/include/features.h" 2 3 4
# 174 "/usr/local/cuda-8.0/include/host_config.h" 2
# 79 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2







# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 56 "/usr/local/cuda-8.0/include/builtin_types.h"
# 1 "/usr/local/cuda-8.0/include/device_types.h" 1
# 53 "/usr/local/cuda-8.0/include/device_types.h"
# 1 "/usr/local/cuda-8.0/include/host_defines.h" 1
# 54 "/usr/local/cuda-8.0/include/device_types.h" 2







enum __attribute__((device_builtin)) cudaRoundMode
{
    cudaRoundNearest,
    cudaRoundZero,
    cudaRoundPosInf,
    cudaRoundMinInf
};
# 57 "/usr/local/cuda-8.0/include/builtin_types.h" 2


# 1 "/usr/local/cuda-8.0/include/driver_types.h" 1
# 71 "/usr/local/cuda-8.0/include/driver_types.h"
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/limits.h" 3 4
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/limits.h" 1 3 4
# 168 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 144 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/bits/local_lim.h" 2 3 4
# 161 "/usr/include/bits/posix1_lim.h" 2 3 4
# 145 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 149 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 33 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 2 3 4
# 153 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/limits.h" 2 3 4
# 72 "/usr/local/cuda-8.0/include/driver_types.h" 2
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 212 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 73 "/usr/local/cuda-8.0/include/driver_types.h" 2
# 156 "/usr/local/cuda-8.0/include/driver_types.h"
enum __attribute__((device_builtin)) cudaError
{





    cudaSuccess = 0,





    cudaErrorMissingConfiguration = 1,





    cudaErrorMemoryAllocation = 2,





    cudaErrorInitializationError = 3,
# 191 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorLaunchFailure = 4,
# 200 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorPriorLaunchFailure = 5,
# 210 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorLaunchTimeout = 6,
# 219 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorLaunchOutOfResources = 7,





    cudaErrorInvalidDeviceFunction = 8,
# 234 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorInvalidConfiguration = 9,





    cudaErrorInvalidDevice = 10,





    cudaErrorInvalidValue = 11,





    cudaErrorInvalidPitchValue = 12,





    cudaErrorInvalidSymbol = 13,




    cudaErrorMapBufferObjectFailed = 14,




    cudaErrorUnmapBufferObjectFailed = 15,





    cudaErrorInvalidHostPointer = 16,





    cudaErrorInvalidDevicePointer = 17,





    cudaErrorInvalidTexture = 18,





    cudaErrorInvalidTextureBinding = 19,






    cudaErrorInvalidChannelDescriptor = 20,





    cudaErrorInvalidMemcpyDirection = 21,
# 315 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorAddressOfConstant = 22,
# 324 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorTextureFetchFailed = 23,
# 333 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorTextureNotBound = 24,
# 342 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorSynchronizationError = 25,





    cudaErrorInvalidFilterSetting = 26,





    cudaErrorInvalidNormSetting = 27,







    cudaErrorMixedDeviceExecution = 28,






    cudaErrorCudartUnloading = 29,




    cudaErrorUnknown = 30,







    cudaErrorNotYetImplemented = 31,
# 391 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorMemoryValueTooLarge = 32,






    cudaErrorInvalidResourceHandle = 33,







    cudaErrorNotReady = 34,






    cudaErrorInsufficientDriver = 35,
# 426 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorSetOnActiveProcess = 36,





    cudaErrorInvalidSurface = 37,





    cudaErrorNoDevice = 38,





    cudaErrorECCUncorrectable = 39,




    cudaErrorSharedObjectSymbolNotFound = 40,




    cudaErrorSharedObjectInitFailed = 41,





    cudaErrorUnsupportedLimit = 42,





    cudaErrorDuplicateVariableName = 43,





    cudaErrorDuplicateTextureName = 44,





    cudaErrorDuplicateSurfaceName = 45,
# 488 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorDevicesUnavailable = 46,




    cudaErrorInvalidKernelImage = 47,







    cudaErrorNoKernelImageForDevice = 48,
# 514 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorIncompatibleDriverContext = 49,






    cudaErrorPeerAccessAlreadyEnabled = 50,






    cudaErrorPeerAccessNotEnabled = 51,





    cudaErrorDeviceAlreadyInUse = 54,






    cudaErrorProfilerDisabled = 55,







    cudaErrorProfilerNotInitialized = 56,






    cudaErrorProfilerAlreadyStarted = 57,






     cudaErrorProfilerAlreadyStopped = 58,







    cudaErrorAssert = 59,






    cudaErrorTooManyPeers = 60,





    cudaErrorHostMemoryAlreadyRegistered = 61,





    cudaErrorHostMemoryNotRegistered = 62,




    cudaErrorOperatingSystem = 63,





    cudaErrorPeerAccessUnsupported = 64,






    cudaErrorLaunchMaxDepthExceeded = 65,







    cudaErrorLaunchFileScopedTex = 66,







    cudaErrorLaunchFileScopedSurf = 67,
# 639 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorSyncDepthExceeded = 68,
# 651 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorLaunchPendingCountExceeded = 69,




    cudaErrorNotPermitted = 70,





    cudaErrorNotSupported = 71,
# 671 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorHardwareStackError = 72,







    cudaErrorIllegalInstruction = 73,
# 688 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorMisalignedAddress = 74,
# 699 "/usr/local/cuda-8.0/include/driver_types.h"
    cudaErrorInvalidAddressSpace = 75,







    cudaErrorInvalidPc = 76,







    cudaErrorIllegalAddress = 77,





    cudaErrorInvalidPtx = 78,




    cudaErrorInvalidGraphicsContext = 79,





    cudaErrorNvlinkUncorrectable = 80,




    cudaErrorStartupFailure = 0x7f,







    cudaErrorApiFailureBase = 10000
};




enum __attribute__((device_builtin)) cudaChannelFormatKind
{
    cudaChannelFormatKindSigned = 0,
    cudaChannelFormatKindUnsigned = 1,
    cudaChannelFormatKindFloat = 2,
    cudaChannelFormatKindNone = 3
};




struct __attribute__((device_builtin)) cudaChannelFormatDesc
{
    int x;
    int y;
    int z;
    int w;
    enum cudaChannelFormatKind f;
};




typedef struct cudaArray *cudaArray_t;




typedef const struct cudaArray *cudaArray_const_t;

struct cudaArray;




typedef struct cudaMipmappedArray *cudaMipmappedArray_t;




typedef const struct cudaMipmappedArray *cudaMipmappedArray_const_t;

struct cudaMipmappedArray;




enum __attribute__((device_builtin)) cudaMemoryType
{
    cudaMemoryTypeHost = 1,
    cudaMemoryTypeDevice = 2
};




enum __attribute__((device_builtin)) cudaMemcpyKind
{
    cudaMemcpyHostToHost = 0,
    cudaMemcpyHostToDevice = 1,
    cudaMemcpyDeviceToHost = 2,
    cudaMemcpyDeviceToDevice = 3,
    cudaMemcpyDefault = 4
};






struct __attribute__((device_builtin)) cudaPitchedPtr
{
    void *ptr;
    size_t pitch;
    size_t xsize;
    size_t ysize;
};






struct __attribute__((device_builtin)) cudaExtent
{
    size_t width;
    size_t height;
    size_t depth;
};






struct __attribute__((device_builtin)) cudaPos
{
    size_t x;
    size_t y;
    size_t z;
};




struct __attribute__((device_builtin)) cudaMemcpy3DParms
{
    cudaArray_t srcArray;
    struct cudaPos srcPos;
    struct cudaPitchedPtr srcPtr;

    cudaArray_t dstArray;
    struct cudaPos dstPos;
    struct cudaPitchedPtr dstPtr;

    struct cudaExtent extent;
    enum cudaMemcpyKind kind;
};




struct __attribute__((device_builtin)) cudaMemcpy3DPeerParms
{
    cudaArray_t srcArray;
    struct cudaPos srcPos;
    struct cudaPitchedPtr srcPtr;
    int srcDevice;

    cudaArray_t dstArray;
    struct cudaPos dstPos;
    struct cudaPitchedPtr dstPtr;
    int dstDevice;

    struct cudaExtent extent;
};




struct cudaGraphicsResource;




enum __attribute__((device_builtin)) cudaGraphicsRegisterFlags
{
    cudaGraphicsRegisterFlagsNone = 0,
    cudaGraphicsRegisterFlagsReadOnly = 1,
    cudaGraphicsRegisterFlagsWriteDiscard = 2,
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,
    cudaGraphicsRegisterFlagsTextureGather = 8
};




enum __attribute__((device_builtin)) cudaGraphicsMapFlags
{
    cudaGraphicsMapFlagsNone = 0,
    cudaGraphicsMapFlagsReadOnly = 1,
    cudaGraphicsMapFlagsWriteDiscard = 2
};




enum __attribute__((device_builtin)) cudaGraphicsCubeFace
{
    cudaGraphicsCubeFacePositiveX = 0x00,
    cudaGraphicsCubeFaceNegativeX = 0x01,
    cudaGraphicsCubeFacePositiveY = 0x02,
    cudaGraphicsCubeFaceNegativeY = 0x03,
    cudaGraphicsCubeFacePositiveZ = 0x04,
    cudaGraphicsCubeFaceNegativeZ = 0x05
};




enum __attribute__((device_builtin)) cudaResourceType
{
    cudaResourceTypeArray = 0x00,
    cudaResourceTypeMipmappedArray = 0x01,
    cudaResourceTypeLinear = 0x02,
    cudaResourceTypePitch2D = 0x03
};




enum __attribute__((device_builtin)) cudaResourceViewFormat
{
    cudaResViewFormatNone = 0x00,
    cudaResViewFormatUnsignedChar1 = 0x01,
    cudaResViewFormatUnsignedChar2 = 0x02,
    cudaResViewFormatUnsignedChar4 = 0x03,
    cudaResViewFormatSignedChar1 = 0x04,
    cudaResViewFormatSignedChar2 = 0x05,
    cudaResViewFormatSignedChar4 = 0x06,
    cudaResViewFormatUnsignedShort1 = 0x07,
    cudaResViewFormatUnsignedShort2 = 0x08,
    cudaResViewFormatUnsignedShort4 = 0x09,
    cudaResViewFormatSignedShort1 = 0x0a,
    cudaResViewFormatSignedShort2 = 0x0b,
    cudaResViewFormatSignedShort4 = 0x0c,
    cudaResViewFormatUnsignedInt1 = 0x0d,
    cudaResViewFormatUnsignedInt2 = 0x0e,
    cudaResViewFormatUnsignedInt4 = 0x0f,
    cudaResViewFormatSignedInt1 = 0x10,
    cudaResViewFormatSignedInt2 = 0x11,
    cudaResViewFormatSignedInt4 = 0x12,
    cudaResViewFormatHalf1 = 0x13,
    cudaResViewFormatHalf2 = 0x14,
    cudaResViewFormatHalf4 = 0x15,
    cudaResViewFormatFloat1 = 0x16,
    cudaResViewFormatFloat2 = 0x17,
    cudaResViewFormatFloat4 = 0x18,
    cudaResViewFormatUnsignedBlockCompressed1 = 0x19,
    cudaResViewFormatUnsignedBlockCompressed2 = 0x1a,
    cudaResViewFormatUnsignedBlockCompressed3 = 0x1b,
    cudaResViewFormatUnsignedBlockCompressed4 = 0x1c,
    cudaResViewFormatSignedBlockCompressed4 = 0x1d,
    cudaResViewFormatUnsignedBlockCompressed5 = 0x1e,
    cudaResViewFormatSignedBlockCompressed5 = 0x1f,
    cudaResViewFormatUnsignedBlockCompressed6H = 0x20,
    cudaResViewFormatSignedBlockCompressed6H = 0x21,
    cudaResViewFormatUnsignedBlockCompressed7 = 0x22
};




struct __attribute__((device_builtin)) cudaResourceDesc {
 enum cudaResourceType resType;

 union {
  struct {
   cudaArray_t array;
  } array;
        struct {
            cudaMipmappedArray_t mipmap;
        } mipmap;
  struct {
   void *devPtr;
   struct cudaChannelFormatDesc desc;
   size_t sizeInBytes;
  } linear;
  struct {
   void *devPtr;
   struct cudaChannelFormatDesc desc;
   size_t width;
   size_t height;
   size_t pitchInBytes;
  } pitch2D;
 } res;
};




struct __attribute__((device_builtin)) cudaResourceViewDesc
{
    enum cudaResourceViewFormat format;
    size_t width;
    size_t height;
    size_t depth;
    unsigned int firstMipmapLevel;
    unsigned int lastMipmapLevel;
    unsigned int firstLayer;
    unsigned int lastLayer;
};




struct __attribute__((device_builtin)) cudaPointerAttributes
{




    enum cudaMemoryType memoryType;
# 1044 "/usr/local/cuda-8.0/include/driver_types.h"
    int device;





    void *devicePointer;





    void *hostPointer;




    int isManaged;
};




struct __attribute__((device_builtin)) cudaFuncAttributes
{





   size_t sharedSizeBytes;





   size_t constSizeBytes;




   size_t localSizeBytes;






   int maxThreadsPerBlock;




   int numRegs;






   int ptxVersion;






   int binaryVersion;





   int cacheModeCA;
};




enum __attribute__((device_builtin)) cudaFuncCache
{
    cudaFuncCachePreferNone = 0,
    cudaFuncCachePreferShared = 1,
    cudaFuncCachePreferL1 = 2,
    cudaFuncCachePreferEqual = 3
};





enum __attribute__((device_builtin)) cudaSharedMemConfig
{
    cudaSharedMemBankSizeDefault = 0,
    cudaSharedMemBankSizeFourByte = 1,
    cudaSharedMemBankSizeEightByte = 2
};




enum __attribute__((device_builtin)) cudaComputeMode
{
    cudaComputeModeDefault = 0,
    cudaComputeModeExclusive = 1,
    cudaComputeModeProhibited = 2,
    cudaComputeModeExclusiveProcess = 3
};




enum __attribute__((device_builtin)) cudaLimit
{
    cudaLimitStackSize = 0x00,
    cudaLimitPrintfFifoSize = 0x01,
    cudaLimitMallocHeapSize = 0x02,
    cudaLimitDevRuntimeSyncDepth = 0x03,
    cudaLimitDevRuntimePendingLaunchCount = 0x04
};




enum __attribute__((device_builtin)) cudaMemoryAdvise
{
    cudaMemAdviseSetReadMostly = 1,
    cudaMemAdviseUnsetReadMostly = 2,
    cudaMemAdviseSetPreferredLocation = 3,
    cudaMemAdviseUnsetPreferredLocation = 4,
    cudaMemAdviseSetAccessedBy = 5,
    cudaMemAdviseUnsetAccessedBy = 6
};




enum __attribute__((device_builtin)) cudaMemRangeAttribute
{
    cudaMemRangeAttributeReadMostly = 1,
    cudaMemRangeAttributePreferredLocation = 2,
    cudaMemRangeAttributeAccessedBy = 3,
    cudaMemRangeAttributeLastPrefetchLocation = 4
};




enum __attribute__((device_builtin)) cudaOutputMode
{
    cudaKeyValuePair = 0x00,
    cudaCSV = 0x01
};




enum __attribute__((device_builtin)) cudaDeviceAttr
{
    cudaDevAttrMaxThreadsPerBlock = 1,
    cudaDevAttrMaxBlockDimX = 2,
    cudaDevAttrMaxBlockDimY = 3,
    cudaDevAttrMaxBlockDimZ = 4,
    cudaDevAttrMaxGridDimX = 5,
    cudaDevAttrMaxGridDimY = 6,
    cudaDevAttrMaxGridDimZ = 7,
    cudaDevAttrMaxSharedMemoryPerBlock = 8,
    cudaDevAttrTotalConstantMemory = 9,
    cudaDevAttrWarpSize = 10,
    cudaDevAttrMaxPitch = 11,
    cudaDevAttrMaxRegistersPerBlock = 12,
    cudaDevAttrClockRate = 13,
    cudaDevAttrTextureAlignment = 14,
    cudaDevAttrGpuOverlap = 15,
    cudaDevAttrMultiProcessorCount = 16,
    cudaDevAttrKernelExecTimeout = 17,
    cudaDevAttrIntegrated = 18,
    cudaDevAttrCanMapHostMemory = 19,
    cudaDevAttrComputeMode = 20,
    cudaDevAttrMaxTexture1DWidth = 21,
    cudaDevAttrMaxTexture2DWidth = 22,
    cudaDevAttrMaxTexture2DHeight = 23,
    cudaDevAttrMaxTexture3DWidth = 24,
    cudaDevAttrMaxTexture3DHeight = 25,
    cudaDevAttrMaxTexture3DDepth = 26,
    cudaDevAttrMaxTexture2DLayeredWidth = 27,
    cudaDevAttrMaxTexture2DLayeredHeight = 28,
    cudaDevAttrMaxTexture2DLayeredLayers = 29,
    cudaDevAttrSurfaceAlignment = 30,
    cudaDevAttrConcurrentKernels = 31,
    cudaDevAttrEccEnabled = 32,
    cudaDevAttrPciBusId = 33,
    cudaDevAttrPciDeviceId = 34,
    cudaDevAttrTccDriver = 35,
    cudaDevAttrMemoryClockRate = 36,
    cudaDevAttrGlobalMemoryBusWidth = 37,
    cudaDevAttrL2CacheSize = 38,
    cudaDevAttrMaxThreadsPerMultiProcessor = 39,
    cudaDevAttrAsyncEngineCount = 40,
    cudaDevAttrUnifiedAddressing = 41,
    cudaDevAttrMaxTexture1DLayeredWidth = 42,
    cudaDevAttrMaxTexture1DLayeredLayers = 43,
    cudaDevAttrMaxTexture2DGatherWidth = 45,
    cudaDevAttrMaxTexture2DGatherHeight = 46,
    cudaDevAttrMaxTexture3DWidthAlt = 47,
    cudaDevAttrMaxTexture3DHeightAlt = 48,
    cudaDevAttrMaxTexture3DDepthAlt = 49,
    cudaDevAttrPciDomainId = 50,
    cudaDevAttrTexturePitchAlignment = 51,
    cudaDevAttrMaxTextureCubemapWidth = 52,
    cudaDevAttrMaxTextureCubemapLayeredWidth = 53,
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54,
    cudaDevAttrMaxSurface1DWidth = 55,
    cudaDevAttrMaxSurface2DWidth = 56,
    cudaDevAttrMaxSurface2DHeight = 57,
    cudaDevAttrMaxSurface3DWidth = 58,
    cudaDevAttrMaxSurface3DHeight = 59,
    cudaDevAttrMaxSurface3DDepth = 60,
    cudaDevAttrMaxSurface1DLayeredWidth = 61,
    cudaDevAttrMaxSurface1DLayeredLayers = 62,
    cudaDevAttrMaxSurface2DLayeredWidth = 63,
    cudaDevAttrMaxSurface2DLayeredHeight = 64,
    cudaDevAttrMaxSurface2DLayeredLayers = 65,
    cudaDevAttrMaxSurfaceCubemapWidth = 66,
    cudaDevAttrMaxSurfaceCubemapLayeredWidth = 67,
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68,
    cudaDevAttrMaxTexture1DLinearWidth = 69,
    cudaDevAttrMaxTexture2DLinearWidth = 70,
    cudaDevAttrMaxTexture2DLinearHeight = 71,
    cudaDevAttrMaxTexture2DLinearPitch = 72,
    cudaDevAttrMaxTexture2DMipmappedWidth = 73,
    cudaDevAttrMaxTexture2DMipmappedHeight = 74,
    cudaDevAttrComputeCapabilityMajor = 75,
    cudaDevAttrComputeCapabilityMinor = 76,
    cudaDevAttrMaxTexture1DMipmappedWidth = 77,
    cudaDevAttrStreamPrioritiesSupported = 78,
    cudaDevAttrGlobalL1CacheSupported = 79,
    cudaDevAttrLocalL1CacheSupported = 80,
    cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81,
    cudaDevAttrMaxRegistersPerMultiprocessor = 82,
    cudaDevAttrManagedMemory = 83,
    cudaDevAttrIsMultiGpuBoard = 84,
    cudaDevAttrMultiGpuBoardGroupID = 85,
    cudaDevAttrHostNativeAtomicSupported = 86,
    cudaDevAttrSingleToDoublePrecisionPerfRatio = 87,
    cudaDevAttrPageableMemoryAccess = 88,
    cudaDevAttrConcurrentManagedAccess = 89,
    cudaDevAttrComputePreemptionSupported = 90,
    cudaDevAttrCanUseHostPointerForRegisteredMem = 91
};





enum __attribute__((device_builtin)) cudaDeviceP2PAttr {
    cudaDevP2PAttrPerformanceRank = 1,
    cudaDevP2PAttrAccessSupported = 2,
    cudaDevP2PAttrNativeAtomicSupported = 3
};



struct __attribute__((device_builtin)) cudaDeviceProp
{
    char name[256];
    size_t totalGlobalMem;
    size_t sharedMemPerBlock;
    int regsPerBlock;
    int warpSize;
    size_t memPitch;
    int maxThreadsPerBlock;
    int maxThreadsDim[3];
    int maxGridSize[3];
    int clockRate;
    size_t totalConstMem;
    int major;
    int minor;
    size_t textureAlignment;
    size_t texturePitchAlignment;
    int deviceOverlap;
    int multiProcessorCount;
    int kernelExecTimeoutEnabled;
    int integrated;
    int canMapHostMemory;
    int computeMode;
    int maxTexture1D;
    int maxTexture1DMipmap;
    int maxTexture1DLinear;
    int maxTexture2D[2];
    int maxTexture2DMipmap[2];
    int maxTexture2DLinear[3];
    int maxTexture2DGather[2];
    int maxTexture3D[3];
    int maxTexture3DAlt[3];
    int maxTextureCubemap;
    int maxTexture1DLayered[2];
    int maxTexture2DLayered[3];
    int maxTextureCubemapLayered[2];
    int maxSurface1D;
    int maxSurface2D[2];
    int maxSurface3D[3];
    int maxSurface1DLayered[2];
    int maxSurface2DLayered[3];
    int maxSurfaceCubemap;
    int maxSurfaceCubemapLayered[2];
    size_t surfaceAlignment;
    int concurrentKernels;
    int ECCEnabled;
    int pciBusID;
    int pciDeviceID;
    int pciDomainID;
    int tccDriver;
    int asyncEngineCount;
    int unifiedAddressing;
    int memoryClockRate;
    int memoryBusWidth;
    int l2CacheSize;
    int maxThreadsPerMultiProcessor;
    int streamPrioritiesSupported;
    int globalL1CacheSupported;
    int localL1CacheSupported;
    size_t sharedMemPerMultiprocessor;
    int regsPerMultiprocessor;
    int managedMemory;
    int isMultiGpuBoard;
    int multiGpuBoardGroupID;
    int hostNativeAtomicSupported;
    int singleToDoublePrecisionPerfRatio;
    int pageableMemoryAccess;
    int concurrentManagedAccess;
};
# 1455 "/usr/local/cuda-8.0/include/driver_types.h"
typedef __attribute__((device_builtin)) struct __attribute__((device_builtin)) cudaIpcEventHandle_st
{
    char reserved[64];
}cudaIpcEventHandle_t;




typedef __attribute__((device_builtin)) struct __attribute__((device_builtin)) cudaIpcMemHandle_st
{
    char reserved[64];
}cudaIpcMemHandle_t;
# 1477 "/usr/local/cuda-8.0/include/driver_types.h"
typedef __attribute__((device_builtin)) enum cudaError cudaError_t;




typedef __attribute__((device_builtin)) struct CUstream_st *cudaStream_t;




typedef __attribute__((device_builtin)) struct CUevent_st *cudaEvent_t;




typedef __attribute__((device_builtin)) struct cudaGraphicsResource *cudaGraphicsResource_t;




typedef __attribute__((device_builtin)) struct CUuuid_st cudaUUID_t;




typedef __attribute__((device_builtin)) enum cudaOutputMode cudaOutputMode_t;
# 60 "/usr/local/cuda-8.0/include/builtin_types.h" 2


# 1 "/usr/local/cuda-8.0/include/surface_types.h" 1
# 84 "/usr/local/cuda-8.0/include/surface_types.h"
enum __attribute__((device_builtin)) cudaSurfaceBoundaryMode
{
    cudaBoundaryModeZero = 0,
    cudaBoundaryModeClamp = 1,
    cudaBoundaryModeTrap = 2
};




enum __attribute__((device_builtin)) cudaSurfaceFormatMode
{
    cudaFormatModeForced = 0,
    cudaFormatModeAuto = 1
};




struct __attribute__((device_builtin)) surfaceReference
{



    struct cudaChannelFormatDesc channelDesc;
};




typedef __attribute__((device_builtin)) unsigned long long cudaSurfaceObject_t;
# 63 "/usr/local/cuda-8.0/include/builtin_types.h" 2
# 1 "/usr/local/cuda-8.0/include/texture_types.h" 1
# 84 "/usr/local/cuda-8.0/include/texture_types.h"
enum __attribute__((device_builtin)) cudaTextureAddressMode
{
    cudaAddressModeWrap = 0,
    cudaAddressModeClamp = 1,
    cudaAddressModeMirror = 2,
    cudaAddressModeBorder = 3
};




enum __attribute__((device_builtin)) cudaTextureFilterMode
{
    cudaFilterModePoint = 0,
    cudaFilterModeLinear = 1
};




enum __attribute__((device_builtin)) cudaTextureReadMode
{
    cudaReadModeElementType = 0,
    cudaReadModeNormalizedFloat = 1
};




struct __attribute__((device_builtin)) textureReference
{



    int normalized;



    enum cudaTextureFilterMode filterMode;



    enum cudaTextureAddressMode addressMode[3];



    struct cudaChannelFormatDesc channelDesc;



    int sRGB;



    unsigned int maxAnisotropy;



    enum cudaTextureFilterMode mipmapFilterMode;



    float mipmapLevelBias;



    float minMipmapLevelClamp;



    float maxMipmapLevelClamp;
    int __cudaReserved[15];
};




struct __attribute__((device_builtin)) cudaTextureDesc
{



    enum cudaTextureAddressMode addressMode[3];



    enum cudaTextureFilterMode filterMode;



    enum cudaTextureReadMode readMode;



    int sRGB;



    float borderColor[4];



    int normalizedCoords;



    unsigned int maxAnisotropy;



    enum cudaTextureFilterMode mipmapFilterMode;



    float mipmapLevelBias;



    float minMipmapLevelClamp;



    float maxMipmapLevelClamp;
};




typedef __attribute__((device_builtin)) unsigned long long cudaTextureObject_t;
# 64 "/usr/local/cuda-8.0/include/builtin_types.h" 2
# 1 "/usr/local/cuda-8.0/include/vector_types.h" 1
# 61 "/usr/local/cuda-8.0/include/vector_types.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 64 "/usr/local/cuda-8.0/include/builtin_types.h"
# 1 "/usr/local/cuda-8.0/include/vector_types.h" 1
# 64 "/usr/local/cuda-8.0/include/builtin_types.h" 2
# 62 "/usr/local/cuda-8.0/include/vector_types.h" 2
# 98 "/usr/local/cuda-8.0/include/vector_types.h"
struct __attribute__((device_builtin)) char1
{
    signed char x;
};

struct __attribute__((device_builtin)) uchar1
{
    unsigned char x;
};


struct __attribute__((device_builtin)) __attribute__((aligned(2))) char2
{
    signed char x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(2))) uchar2
{
    unsigned char x, y;
};

struct __attribute__((device_builtin)) char3
{
    signed char x, y, z;
};

struct __attribute__((device_builtin)) uchar3
{
    unsigned char x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) char4
{
    signed char x, y, z, w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) uchar4
{
    unsigned char x, y, z, w;
};

struct __attribute__((device_builtin)) short1
{
    short x;
};

struct __attribute__((device_builtin)) ushort1
{
    unsigned short x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) short2
{
    short x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) ushort2
{
    unsigned short x, y;
};

struct __attribute__((device_builtin)) short3
{
    short x, y, z;
};

struct __attribute__((device_builtin)) ushort3
{
    unsigned short x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(8))) short4 { short x; short y; short z; short w; };
struct __attribute__((device_builtin)) __attribute__((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; };

struct __attribute__((device_builtin)) int1
{
    int x;
};

struct __attribute__((device_builtin)) uint1
{
    unsigned int x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(8))) int2 { int x; int y; };
struct __attribute__((device_builtin)) __attribute__((aligned(8))) uint2 { unsigned int x; unsigned int y; };

struct __attribute__((device_builtin)) int3
{
    int x, y, z;
};

struct __attribute__((device_builtin)) uint3
{
    unsigned int x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) int4
{
    int x, y, z, w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) uint4
{
    unsigned int x, y, z, w;
};

struct __attribute__((device_builtin)) long1
{
    long int x;
};

struct __attribute__((device_builtin)) ulong1
{
    unsigned long x;
};






struct __attribute__((device_builtin)) __attribute__((aligned(2*sizeof(long int)))) long2
{
    long int x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(2*sizeof(unsigned long int)))) ulong2
{
    unsigned long int x, y;
};



struct __attribute__((device_builtin)) long3
{
    long int x, y, z;
};

struct __attribute__((device_builtin)) ulong3
{
    unsigned long int x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) long4
{
    long int x, y, z, w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) ulong4
{
    unsigned long int x, y, z, w;
};

struct __attribute__((device_builtin)) float1
{
    float x;
};
# 274 "/usr/local/cuda-8.0/include/vector_types.h"
struct __attribute__((device_builtin)) __attribute__((aligned(8))) float2 { float x; float y; };




struct __attribute__((device_builtin)) float3
{
    float x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) float4
{
    float x, y, z, w;
};

struct __attribute__((device_builtin)) longlong1
{
    long long int x;
};

struct __attribute__((device_builtin)) ulonglong1
{
    unsigned long long int x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) longlong2
{
    long long int x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) ulonglong2
{
    unsigned long long int x, y;
};

struct __attribute__((device_builtin)) longlong3
{
    long long int x, y, z;
};

struct __attribute__((device_builtin)) ulonglong3
{
    unsigned long long int x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) longlong4
{
    long long int x, y, z ,w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) ulonglong4
{
    unsigned long long int x, y, z, w;
};

struct __attribute__((device_builtin)) double1
{
    double x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) double2
{
    double x, y;
};

struct __attribute__((device_builtin)) double3
{
    double x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) double4
{
    double x, y, z, w;
};
# 362 "/usr/local/cuda-8.0/include/vector_types.h"
typedef __attribute__((device_builtin)) struct char1 char1;
typedef __attribute__((device_builtin)) struct uchar1 uchar1;
typedef __attribute__((device_builtin)) struct char2 char2;
typedef __attribute__((device_builtin)) struct uchar2 uchar2;
typedef __attribute__((device_builtin)) struct char3 char3;
typedef __attribute__((device_builtin)) struct uchar3 uchar3;
typedef __attribute__((device_builtin)) struct char4 char4;
typedef __attribute__((device_builtin)) struct uchar4 uchar4;
typedef __attribute__((device_builtin)) struct short1 short1;
typedef __attribute__((device_builtin)) struct ushort1 ushort1;
typedef __attribute__((device_builtin)) struct short2 short2;
typedef __attribute__((device_builtin)) struct ushort2 ushort2;
typedef __attribute__((device_builtin)) struct short3 short3;
typedef __attribute__((device_builtin)) struct ushort3 ushort3;
typedef __attribute__((device_builtin)) struct short4 short4;
typedef __attribute__((device_builtin)) struct ushort4 ushort4;
typedef __attribute__((device_builtin)) struct int1 int1;
typedef __attribute__((device_builtin)) struct uint1 uint1;
typedef __attribute__((device_builtin)) struct int2 int2;
typedef __attribute__((device_builtin)) struct uint2 uint2;
typedef __attribute__((device_builtin)) struct int3 int3;
typedef __attribute__((device_builtin)) struct uint3 uint3;
typedef __attribute__((device_builtin)) struct int4 int4;
typedef __attribute__((device_builtin)) struct uint4 uint4;
typedef __attribute__((device_builtin)) struct long1 long1;
typedef __attribute__((device_builtin)) struct ulong1 ulong1;
typedef __attribute__((device_builtin)) struct long2 long2;
typedef __attribute__((device_builtin)) struct ulong2 ulong2;
typedef __attribute__((device_builtin)) struct long3 long3;
typedef __attribute__((device_builtin)) struct ulong3 ulong3;
typedef __attribute__((device_builtin)) struct long4 long4;
typedef __attribute__((device_builtin)) struct ulong4 ulong4;
typedef __attribute__((device_builtin)) struct float1 float1;
typedef __attribute__((device_builtin)) struct float2 float2;
typedef __attribute__((device_builtin)) struct float3 float3;
typedef __attribute__((device_builtin)) struct float4 float4;
typedef __attribute__((device_builtin)) struct longlong1 longlong1;
typedef __attribute__((device_builtin)) struct ulonglong1 ulonglong1;
typedef __attribute__((device_builtin)) struct longlong2 longlong2;
typedef __attribute__((device_builtin)) struct ulonglong2 ulonglong2;
typedef __attribute__((device_builtin)) struct longlong3 longlong3;
typedef __attribute__((device_builtin)) struct ulonglong3 ulonglong3;
typedef __attribute__((device_builtin)) struct longlong4 longlong4;
typedef __attribute__((device_builtin)) struct ulonglong4 ulonglong4;
typedef __attribute__((device_builtin)) struct double1 double1;
typedef __attribute__((device_builtin)) struct double2 double2;
typedef __attribute__((device_builtin)) struct double3 double3;
typedef __attribute__((device_builtin)) struct double4 double4;







struct __attribute__((device_builtin)) dim3
{
    unsigned int x, y, z;

    __attribute__((host)) __attribute__((device)) dim3(unsigned int vx = 1, unsigned int vy = 1, unsigned int vz = 1) : x(vx), y(vy), z(vz) {}
    __attribute__((host)) __attribute__((device)) dim3(uint3 v) : x(v.x), y(v.y), z(v.z) {}
    __attribute__((host)) __attribute__((device)) operator uint3(void) { uint3 t; t.x = x; t.y = y; t.z = z; return t; }

};

typedef __attribute__((device_builtin)) struct dim3 dim3;
# 64 "/usr/local/cuda-8.0/include/builtin_types.h" 2
# 87 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-8.0/include/library_types.h" 1
# 54 "/usr/local/cuda-8.0/include/library_types.h"
typedef enum cudaDataType_t
{
 CUDA_R_16F= 2,
 CUDA_C_16F= 6,
 CUDA_R_32F= 0,
 CUDA_C_32F= 4,
 CUDA_R_64F= 1,
 CUDA_C_64F= 5,
 CUDA_R_8I = 3,
 CUDA_C_8I = 7,
 CUDA_R_8U = 8,
 CUDA_C_8U = 9,
 CUDA_R_32I= 10,
 CUDA_C_32I= 11,
 CUDA_R_32U= 12,
 CUDA_C_32U= 13
} cudaDataType;


typedef enum libraryPropertyType_t
{
 MAJOR_VERSION,
 MINOR_VERSION,
 PATCH_LEVEL
} libraryPropertyType;
# 88 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2


# 1 "/usr/local/cuda-8.0/include/channel_descriptor.h" 1
# 62 "/usr/local/cuda-8.0/include/channel_descriptor.h"
# 1 "/usr/local/cuda-8.0/include/cuda_runtime_api.h" 1
# 134 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 135 "/usr/local/cuda-8.0/include/cuda_runtime_api.h" 2


# 1 "/usr/local/cuda-8.0/include/cuda_device_runtime_api.h" 1
# 104 "/usr/local/cuda-8.0/include/cuda_device_runtime_api.h"
extern "C"
{
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceSynchronize(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaGetLastError(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaPeekAtLastError(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) const char* cudaGetErrorString(cudaError_t error);
extern __attribute__((device)) __attribute__((cudart_builtin)) const char* cudaGetErrorName(cudaError_t error);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaGetDeviceCount(int *count);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaGetDevice(int *device);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamDestroy(cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventDestroy(cudaEvent_t event);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaFree(void *devPtr);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMalloc(void **devPtr, size_t size);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpyAsync_ptsz(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy2DAsync_ptsz(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy3DAsync_ptsz(const struct cudaMemcpy3DParms *p, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemsetAsync_ptsz(void *devPtr, int value, size_t count, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset2DAsync_ptsz(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset3DAsync_ptsz(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaRuntimeGetVersion(int *runtimeVersion);
# 161 "/usr/local/cuda-8.0/include/cuda_device_runtime_api.h"
extern __attribute__((device)) __attribute__((cudart_builtin)) void * cudaGetParameterBuffer(size_t alignment, size_t size);
# 189 "/usr/local/cuda-8.0/include/cuda_device_runtime_api.h"
extern __attribute__((device)) __attribute__((cudart_builtin)) void * cudaGetParameterBufferV2(void *func, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDevice_ptsz(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDeviceV2_ptsz(void *parameterBuffer, cudaStream_t stream);
# 209 "/usr/local/cuda-8.0/include/cuda_device_runtime_api.h"
    extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDevice(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize, cudaStream_t stream);
    extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDeviceV2(void *parameterBuffer, cudaStream_t stream);


extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize, unsigned int flags);

}

template <typename T> static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMalloc(T **devPtr, size_t size);
template <typename T> static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, T *entry);
template <typename T> static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, T func, int blockSize, size_t dynamicSmemSize);
template <typename T> static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned int flags);
# 138 "/usr/local/cuda-8.0/include/cuda_runtime_api.h" 2
# 219 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern "C" {
# 252 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceReset(void);
# 269 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceSynchronize(void);
# 344 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetLimit(enum cudaLimit limit, size_t value);
# 373 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);
# 404 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);
# 439 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetStreamPriorityRange(int *leastPriority, int *greatestPriority);
# 481 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetCacheConfig(enum cudaFuncCache cacheConfig);
# 510 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);
# 552 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetSharedMemConfig(enum cudaSharedMemConfig config);
# 575 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetByPCIBusId(int *device, const char *pciBusId);
# 602 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetPCIBusId(char *pciBusId, int len, int device);
# 644 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t *handle, cudaEvent_t event);
# 679 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcOpenEventHandle(cudaEvent_t *event, cudaIpcEventHandle_t handle);
# 717 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t *handle, void *devPtr);
# 767 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcOpenMemHandle(void **devPtr, cudaIpcMemHandle_t handle, unsigned int flags);
# 797 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcCloseMemHandle(void *devPtr);
# 837 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadExit(void);
# 861 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadSynchronize(void);
# 908 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadSetLimit(enum cudaLimit limit, size_t value);
# 939 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadGetLimit(size_t *pValue, enum cudaLimit limit);
# 974 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadGetCacheConfig(enum cudaFuncCache *pCacheConfig);
# 1020 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadSetCacheConfig(enum cudaFuncCache cacheConfig);
# 1074 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetLastError(void);
# 1115 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaPeekAtLastError(void);
# 1130 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) const char* cudaGetErrorName(cudaError_t error);
# 1145 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) const char* cudaGetErrorString(cudaError_t error);
# 1175 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetDeviceCount(int *count);
# 1421 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetDeviceProperties(struct cudaDeviceProp *prop, int device);
# 1593 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);
# 1628 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetP2PAttribute(int *value, enum cudaDeviceP2PAttr attr, int srcDevice, int dstDevice);
# 1647 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaChooseDevice(int *device, const struct cudaDeviceProp *prop);
# 1681 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDevice(int device);
# 1698 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetDevice(int *device);
# 1727 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetValidDevices(int *device_arr, int len);
# 1789 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDeviceFlags( unsigned int flags );
# 1830 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetDeviceFlags( unsigned int *flags );
# 1867 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamCreate(cudaStream_t *pStream);
# 1896 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);
# 1939 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCreateWithPriority(cudaStream_t *pStream, unsigned int flags, int priority);
# 1963 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamGetPriority(cudaStream_t hStream, int *priority);
# 1984 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamGetFlags(cudaStream_t hStream, unsigned int *flags);
# 2005 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamDestroy(cudaStream_t stream);
# 2037 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
# 2051 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
typedef void ( *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void *userData);
# 2108 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamAddCallback(cudaStream_t stream,
        cudaStreamCallback_t callback, void *userData, unsigned int flags);
# 2128 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamSynchronize(cudaStream_t stream);
# 2149 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamQuery(cudaStream_t stream);
# 2220 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamAttachMemAsync(cudaStream_t stream, void *devPtr, size_t length = 0, unsigned int flags = 0x04);
# 2256 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventCreate(cudaEvent_t *event);
# 2290 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);
# 2321 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0);
# 2353 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventQuery(cudaEvent_t event);
# 2385 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventSynchronize(cudaEvent_t event);
# 2410 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventDestroy(cudaEvent_t event);
# 2451 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventElapsedTime(float *ms, cudaEvent_t start, cudaEvent_t end);
# 2510 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream);
# 2560 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFuncSetCacheConfig(const void *func, enum cudaFuncCache cacheConfig);
# 2614 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFuncSetSharedMemConfig(const void *func, enum cudaSharedMemConfig config);
# 2648 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);
# 2671 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDoubleForDevice(double *d);
# 2694 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDoubleForHost(double *d);
# 2750 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSMemSize);
# 2794 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, const void *func, int blockSize, size_t dynamicSMemSize, unsigned int flags);
# 2845 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0);
# 2874 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetupArgument(const void *arg, size_t size, size_t offset);
# 2912 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaLaunch(const void *func);
# 3030 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMallocManaged(void **devPtr, size_t size, unsigned int flags = 0x01);
# 3056 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMalloc(void **devPtr, size_t size);
# 3085 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocHost(void **ptr, size_t size);
# 3124 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocPitch(void **devPtr, size_t *pitch, size_t width, size_t height);
# 3166 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocArray(cudaArray_t *array, const struct cudaChannelFormatDesc *desc, size_t width, size_t height = 0, unsigned int flags = 0);
# 3193 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaFree(void *devPtr);
# 3213 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeHost(void *ptr);
# 3235 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeArray(cudaArray_t array);
# 3257 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray);
# 3316 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostAlloc(void **pHost, size_t size, unsigned int flags);
# 3393 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostRegister(void *ptr, size_t size, unsigned int flags);
# 3412 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostUnregister(void *ptr);
# 3454 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);
# 3473 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostGetFlags(unsigned int *pFlags, void *pHost);
# 3508 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMalloc3D(struct cudaPitchedPtr* pitchedDevPtr, struct cudaExtent extent);
# 3643 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMalloc3DArray(cudaArray_t *array, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int flags = 0);
# 3764 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocMipmappedArray(cudaMipmappedArray_t *mipmappedArray, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int numLevels, unsigned int flags = 0);
# 3790 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetMipmappedArrayLevel(cudaArray_t *levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned int level);
# 3890 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy3D(const struct cudaMemcpy3DParms *p);
# 3918 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy3DPeer(const struct cudaMemcpy3DPeerParms *p);
# 4029 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream = 0);
# 4052 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy3DPeerAsync(const struct cudaMemcpy3DPeerParms *p, cudaStream_t stream = 0);
# 4071 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemGetInfo(size_t *free, size_t *total);
# 4092 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaArrayGetInfo(struct cudaChannelFormatDesc *desc, struct cudaExtent *extent, unsigned int *flags, cudaArray_t array);
# 4130 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind);
# 4162 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyPeer(void *dst, int dstDevice, const void *src, int srcDevice, size_t count);
# 4200 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind);
# 4237 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromArray(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind);
# 4275 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
# 4320 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2D(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
# 4366 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
# 4412 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DFromArray(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind);
# 4455 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
# 4493 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToSymbol(const void *symbol, const void *src, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyHostToDevice);
# 4531 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromSymbol(void *dst, const void *symbol, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost);
# 4582 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4614 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyPeerAsync(void *dst, int dstDevice, const void *src, int srcDevice, size_t count, cudaStream_t stream = 0);
# 4660 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4705 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromArrayAsync(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4765 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4820 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4874 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DFromArrayAsync(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4920 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToSymbolAsync(const void *symbol, const void *src, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4966 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromSymbolAsync(void *dst, const void *symbol, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4992 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemset(void *devPtr, int value, size_t count);
# 5022 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemset2D(void *devPtr, size_t pitch, int value, size_t width, size_t height);
# 5065 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemset3D(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent);
# 5097 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream = 0);
# 5134 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0);
# 5184 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream = 0);
# 5207 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSymbolAddress(void **devPtr, const void *symbol);
# 5229 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSymbolSize(size_t *size, const void *symbol);
# 5296 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPrefetchAsync(const void *devPtr, size_t count, int dstDevice, cudaStream_t stream = 0);
# 5382 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemAdvise(const void *devPtr, size_t count, enum cudaMemoryAdvise advice, int device);
# 5438 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemRangeGetAttribute(void *data, size_t dataSize, enum cudaMemRangeAttribute attribute, const void *devPtr, size_t count);
# 5474 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemRangeGetAttributes(void **data, size_t *dataSizes, enum cudaMemRangeAttribute *attributes, size_t numAttributes, const void *devPtr, size_t count);
# 5627 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaPointerGetAttributes(struct cudaPointerAttributes *attributes, const void *ptr);
# 5665 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceCanAccessPeer(int *canAccessPeer, int device, int peerDevice);
# 5704 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceEnablePeerAccess(int peerDevice, unsigned int flags);
# 5723 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceDisablePeerAccess(int peerDevice);
# 5783 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource);
# 5815 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned int flags);
# 5851 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsMapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);
# 5883 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);
# 5912 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsResourceGetMappedPointer(void **devPtr, size_t *size, cudaGraphicsResource_t resource);
# 5946 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsSubResourceGetMappedArray(cudaArray_t *array, cudaGraphicsResource_t resource, unsigned int arrayIndex, unsigned int mipLevel);
# 5971 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t *mipmappedArray, cudaGraphicsResource_t resource);
# 6011 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetChannelDesc(struct cudaChannelFormatDesc *desc, cudaArray_const_t array);
# 6046 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) struct cudaChannelFormatDesc cudaCreateChannelDesc(int x, int y, int z, int w, enum cudaChannelFormatKind f);
# 6093 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindTexture(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t size = (2147483647 * 2U + 1U));
# 6144 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindTexture2D(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t width, size_t height, size_t pitch);
# 6172 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindTextureToArray(const struct textureReference *texref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);
# 6200 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindTextureToMipmappedArray(const struct textureReference *texref, cudaMipmappedArray_const_t mipmappedArray, const struct cudaChannelFormatDesc *desc);
# 6221 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaUnbindTexture(const struct textureReference *texref);
# 6246 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureAlignmentOffset(size_t *offset, const struct textureReference *texref);
# 6271 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureReference(const struct textureReference **texref, const void *symbol);
# 6311 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindSurfaceToArray(const struct surfaceReference *surfref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);
# 6330 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSurfaceReference(const struct surfaceReference **surfref, const void *symbol);
# 6556 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaCreateTextureObject(cudaTextureObject_t *pTexObject, const struct cudaResourceDesc *pResDesc, const struct cudaTextureDesc *pTexDesc, const struct cudaResourceViewDesc *pResViewDesc);
# 6571 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDestroyTextureObject(cudaTextureObject_t texObject);
# 6587 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaTextureObject_t texObject);
# 6603 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureObjectTextureDesc(struct cudaTextureDesc *pTexDesc, cudaTextureObject_t texObject);
# 6620 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureObjectResourceViewDesc(struct cudaResourceViewDesc *pResViewDesc, cudaTextureObject_t texObject);
# 6659 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t *pSurfObject, const struct cudaResourceDesc *pResDesc);
# 6674 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject);
# 6689 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSurfaceObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaSurfaceObject_t surfObject);
# 6716 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDriverGetVersion(int *driverVersion);
# 6733 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaRuntimeGetVersion(int *runtimeVersion);




extern __attribute__((host)) cudaError_t cudaGetExportTable(const void **ppExportTable, const cudaUUID_t *pExportTableId);
# 6964 "/usr/local/cuda-8.0/include/cuda_runtime_api.h"
}
# 63 "/usr/local/cuda-8.0/include/channel_descriptor.h" 2
# 107 "/usr/local/cuda-8.0/include/channel_descriptor.h"
template<class T> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc(void)
{
  return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf1(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf2(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf4(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char>(void)
{
  int e = (int)sizeof(char) * 8;


  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);



}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<signed char>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned char>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char1>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uchar1>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char2>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uchar2>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char4>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uchar4>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned short>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short1>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<ushort1>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short2>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<ushort2>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short4>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<ushort4>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned int>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int1>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uint1>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int2>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uint2>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int4>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uint4>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}
# 379 "/usr/local/cuda-8.0/include/channel_descriptor.h"
template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float1>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float2>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float4>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}
# 91 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2

# 1 "/usr/local/cuda-8.0/include/driver_functions.h" 1
# 53 "/usr/local/cuda-8.0/include/driver_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 54 "/usr/local/cuda-8.0/include/driver_functions.h" 2
# 79 "/usr/local/cuda-8.0/include/driver_functions.h"
static __inline__ __attribute__((host)) struct cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz)
{
  struct cudaPitchedPtr s;

  s.ptr = d;
  s.pitch = p;
  s.xsize = xsz;
  s.ysize = ysz;

  return s;
}
# 106 "/usr/local/cuda-8.0/include/driver_functions.h"
static __inline__ __attribute__((host)) struct cudaPos make_cudaPos(size_t x, size_t y, size_t z)
{
  struct cudaPos p;

  p.x = x;
  p.y = y;
  p.z = z;

  return p;
}
# 132 "/usr/local/cuda-8.0/include/driver_functions.h"
static __inline__ __attribute__((host)) struct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d)
{
  struct cudaExtent e;

  e.width = w;
  e.height = h;
  e.depth = d;

  return e;
}
# 93 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2



# 1 "/usr/local/cuda-8.0/include/vector_functions.h" 1
# 59 "/usr/local/cuda-8.0/include/vector_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 60 "/usr/local/cuda-8.0/include/vector_functions.h" 2
# 176 "/usr/local/cuda-8.0/include/vector_functions.h"
# 1 "/usr/local/cuda-8.0/include/vector_functions.hpp" 1
# 59 "/usr/local/cuda-8.0/include/vector_functions.hpp"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 60 "/usr/local/cuda-8.0/include/vector_functions.hpp" 2
# 75 "/usr/local/cuda-8.0/include/vector_functions.hpp"
static __inline__ __attribute__((host)) __attribute__((device)) char1 make_char1(signed char x)
{
  char1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar1 make_uchar1(unsigned char x)
{
  uchar1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) char2 make_char2(signed char x, signed char y)
{
  char2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar2 make_uchar2(unsigned char x, unsigned char y)
{
  uchar2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) char3 make_char3(signed char x, signed char y, signed char z)
{
  char3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z)
{
  uchar3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) char4 make_char4(signed char x, signed char y, signed char z, signed char w)
{
  char4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w)
{
  uchar4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short1 make_short1(short x)
{
  short1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort1 make_ushort1(unsigned short x)
{
  ushort1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short2 make_short2(short x, short y)
{
  short2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort2 make_ushort2(unsigned short x, unsigned short y)
{
  ushort2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short3 make_short3(short x,short y, short z)
{
  short3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z)
{
  ushort3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short4 make_short4(short x, short y, short z, short w)
{
  short4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w)
{
  ushort4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int1 make_int1(int x)
{
  int1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint1 make_uint1(unsigned int x)
{
  uint1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int2 make_int2(int x, int y)
{
  int2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint2 make_uint2(unsigned int x, unsigned int y)
{
  uint2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int3 make_int3(int x, int y, int z)
{
  int3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint3 make_uint3(unsigned int x, unsigned int y, unsigned int z)
{
  uint3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int4 make_int4(int x, int y, int z, int w)
{
  int4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint4 make_uint4(unsigned int x, unsigned int y, unsigned int z, unsigned int w)
{
  uint4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long1 make_long1(long int x)
{
  long1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong1 make_ulong1(unsigned long int x)
{
  ulong1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long2 make_long2(long int x, long int y)
{
  long2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong2 make_ulong2(unsigned long int x, unsigned long int y)
{
  ulong2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long3 make_long3(long int x, long int y, long int z)
{
  long3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong3 make_ulong3(unsigned long int x, unsigned long int y, unsigned long int z)
{
  ulong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long4 make_long4(long int x, long int y, long int z, long int w)
{
  long4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong4 make_ulong4(unsigned long int x, unsigned long int y, unsigned long int z, unsigned long int w)
{
  ulong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float1 make_float1(float x)
{
  float1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float2 make_float2(float x, float y)
{
  float2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float3 make_float3(float x, float y, float z)
{
  float3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float4 make_float4(float x, float y, float z, float w)
{
  float4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong1 make_longlong1(long long int x)
{
  longlong1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong1 make_ulonglong1(unsigned long long int x)
{
  ulonglong1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong2 make_longlong2(long long int x, long long int y)
{
  longlong2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong2 make_ulonglong2(unsigned long long int x, unsigned long long int y)
{
  ulonglong2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong3 make_longlong3(long long int x, long long int y, long long int z)
{
  longlong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong3 make_ulonglong3(unsigned long long int x, unsigned long long int y, unsigned long long int z)
{
  ulonglong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong4 make_longlong4(long long int x, long long int y, long long int z, long long int w)
{
  longlong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong4 make_ulonglong4(unsigned long long int x, unsigned long long int y, unsigned long long int z, unsigned long long int w)
{
  ulonglong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double1 make_double1(double x)
{
  double1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double2 make_double2(double x, double y)
{
  double2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double3 make_double3(double x, double y, double z)
{
  double3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double4 make_double4(double x, double y, double z, double w)
{
  double4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}
# 177 "/usr/local/cuda-8.0/include/vector_functions.h" 2
# 97 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2
# 116 "/usr/local/cuda-8.0/include/cuda_runtime.h"
# 1 "/usr/local/cuda-8.0/include/common_functions.h" 1
# 61 "/usr/local/cuda-8.0/include/common_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 62 "/usr/local/cuda-8.0/include/common_functions.h" 2



# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const void *
memchr (const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 160 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 207 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strchr (const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strrchr (const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strpbrk (char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strpbrk (const char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strstr (char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strstr (const char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 378 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 434 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
index (char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
index (const char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
rindex (char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
rindex (const char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 642 "/usr/include/string.h" 3 4
}
# 66 "/usr/local/cuda-8.0/include/common_functions.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 26 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 130 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 131 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 27 "/usr/include/bits/time.h" 2 3 4



struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 86 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 25 "/usr/include/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 42 "/usr/include/time.h" 2 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };








struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 67 "/usr/local/cuda-8.0/include/common_functions.h" 2

extern "C"
{

extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) clock_t clock(void) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) void* memset(void*, int, size_t) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) void* memcpy(void*, const void*, size_t) throw ();

}
# 249 "/usr/local/cuda-8.0/include/common_functions.h"
# 1 "/usr/local/cuda-8.0/include/math_functions.h" 1
# 83 "/usr/local/cuda-8.0/include/math_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 84 "/usr/local/cuda-8.0/include/math_functions.h" 2
# 93 "/usr/local/cuda-8.0/include/math_functions.h"
extern "C"
{
# 164 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) int abs(int) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) long int labs(long int) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) long long int llabs(long long int) throw ();
# 216 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fabs(double x) throw ();
# 257 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fabsf(float x) throw ();



extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int min(int, int);

extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned int umin(unsigned int, unsigned int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llmin(long long int, long long int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned long long int ullmin(unsigned long long int, unsigned long long int);
# 286 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fminf(float x, float y) throw ();
# 306 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fmin(double x, double y) throw ();






extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int max(int, int);

extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned int umax(unsigned int, unsigned int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llmax(long long int, long long int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned long long int ullmax(unsigned long long int, unsigned long long int);
# 338 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fmaxf(float x, float y) throw ();
# 358 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fmax(double, double) throw ();
# 402 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sin(double x) throw ();
# 435 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cos(double x) throw ();
# 454 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincos(double x, double *sptr, double *cptr) throw ();
# 470 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincosf(float x, float *sptr, float *cptr) throw ();
# 515 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double tan(double x) throw ();
# 584 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sqrt(double x) throw ();
# 656 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rsqrt(double x);
# 726 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rsqrtf(float x);
# 782 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log2(double x) throw ();
# 807 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double exp2(double x) throw ();
# 832 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float exp2f(float x) throw ();
# 859 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double exp10(double x) throw ();
# 882 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float exp10f(float x) throw ();
# 928 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double expm1(double x) throw ();
# 973 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float expm1f(float x) throw ();
# 1028 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float log2f(float x) throw ();
# 1082 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log10(double x) throw ();
# 1153 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log(double x) throw ();
# 1247 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log1p(double x) throw ();
# 1344 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float log1pf(float x) throw ();
# 1419 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double floor(double x) throw ();
# 1458 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double exp(double x) throw ();
# 1489 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cosh(double x) throw ();
# 1519 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sinh(double x) throw ();
# 1549 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double tanh(double x) throw ();
# 1584 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double acosh(double x) throw ();
# 1622 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float acoshf(float x) throw ();
# 1638 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double asinh(double x) throw ();
# 1654 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float asinhf(float x) throw ();
# 1708 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double atanh(double x) throw ();
# 1762 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float atanhf(float x) throw ();
# 1821 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double ldexp(double x, int exp) throw ();
# 1877 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float ldexpf(float x, int exp) throw ();
# 1929 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double logb(double x) throw ();
# 1984 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float logbf(float x) throw ();
# 2014 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int ilogb(double x) throw ();
# 2044 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int ilogbf(float x) throw ();
# 2120 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double scalbn(double x, int n) throw ();
# 2196 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float scalbnf(float x, int n) throw ();
# 2272 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double scalbln(double x, long int n) throw ();
# 2348 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float scalblnf(float x, long int n) throw ();
# 2426 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double frexp(double x, int *nptr) throw ();
# 2501 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float frexpf(float x, int *nptr) throw ();
# 2515 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double round(double x) throw ();
# 2532 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float roundf(float x) throw ();
# 2550 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lround(double x) throw ();
# 2568 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lroundf(float x) throw ();
# 2586 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llround(double x) throw ();
# 2604 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llroundf(float x) throw ();
# 2656 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rintf(float x) throw ();
# 2672 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lrint(double x) throw ();
# 2688 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lrintf(float x) throw ();
# 2704 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llrint(double x) throw ();
# 2720 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llrintf(float x) throw ();
# 2773 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double nearbyint(double x) throw ();
# 2826 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float nearbyintf(float x) throw ();
# 2888 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double ceil(double x) throw ();
# 2900 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double trunc(double x) throw ();
# 2915 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float truncf(float x) throw ();
# 2941 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fdim(double x, double y) throw ();
# 2967 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fdimf(float x, float y) throw ();
# 3003 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double atan2(double y, double x) throw ();
# 3034 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double atan(double x) throw ();
# 3057 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double acos(double x) throw ();
# 3089 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double asin(double x) throw ();
# 3135 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double hypot(double x, double y) throw ();
# 3187 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rhypot(double x, double y) throw ();
# 3233 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float hypotf(float x, float y) throw ();
# 3285 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rhypotf(float x, float y) throw ();
# 3332 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double norm3d(double a, double b, double c) throw ();
# 3383 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rnorm3d(double a, double b, double c) throw ();
# 3432 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double norm4d(double a, double b, double c, double d) throw ();
# 3488 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rnorm4d(double a, double b, double c, double d) throw ();
# 3533 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double norm(int dim, double const * t) throw ();
# 3584 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rnorm(int dim, double const * t) throw ();
# 3636 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rnormf(int dim, float const * a) throw ();
# 3680 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float normf(int dim, float const * a) throw ();
# 3725 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float norm3df(float a, float b, float c) throw ();
# 3776 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rnorm3df(float a, float b, float c) throw ();
# 3825 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float norm4df(float a, float b, float c, float d) throw ();
# 3881 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rnorm4df(float a, float b, float c, float d) throw ();
# 3965 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cbrt(double x) throw ();
# 4051 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cbrtf(float x) throw ();
# 4106 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rcbrt(double x);
# 4156 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rcbrtf(float x);
# 4216 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sinpi(double x);
# 4276 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sinpif(float x);
# 4328 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cospi(double x);
# 4380 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cospif(float x);
# 4410 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincospi(double x, double *sptr, double *cptr);
# 4440 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincospif(float x, float *sptr, float *cptr);
# 4752 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double pow(double x, double y) throw ();
# 4808 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double modf(double x, double *iptr) throw ();
# 4867 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fmod(double x, double y) throw ();
# 4953 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double remainder(double x, double y) throw ();
# 5043 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float remainderf(float x, float y) throw ();
# 5097 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double remquo(double x, double y, int *quo) throw ();
# 5151 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float remquof(float x, float y, int *quo) throw ();
# 5192 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double j0(double x) throw ();
# 5234 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float j0f(float x) throw ();
# 5295 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double j1(double x) throw ();
# 5356 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float j1f(float x) throw ();
# 5399 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double jn(int n, double x) throw ();
# 5442 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float jnf(int n, float x) throw ();
# 5494 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double y0(double x) throw ();
# 5546 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float y0f(float x) throw ();
# 5598 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double y1(double x) throw ();
# 5650 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float y1f(float x) throw ();
# 5703 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double yn(int n, double x) throw ();
# 5756 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float ynf(int n, float x) throw ();
# 5783 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cyl_bessel_i0(double x) throw ();
# 5809 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cyl_bessel_i0f(float x) throw ();
# 5836 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cyl_bessel_i1(double x) throw ();
# 5862 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cyl_bessel_i1f(float x) throw ();
# 5945 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erf(double x) throw ();
# 6027 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erff(float x) throw ();
# 6091 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfinv(double y);
# 6148 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfinvf(float y);
# 6187 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfc(double x) throw ();
# 6225 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfcf(float x) throw ();
# 6353 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double lgamma(double x) throw ();
# 6416 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfcinv(double y);
# 6472 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfcinvf(float y);
# 6530 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double normcdfinv(double y);
# 6588 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float normcdfinvf(float y);
# 6631 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double normcdf(double y);
# 6674 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float normcdff(float y);
# 6749 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfcx(double x);
# 6824 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfcxf(float x);
# 6958 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float lgammaf(float x) throw ();
# 7067 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double tgamma(double x) throw ();
# 7176 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float tgammaf(float x) throw ();
# 7189 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double copysign(double x, double y) throw ();
# 7202 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float copysignf(float x, float y) throw ();
# 7239 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double nextafter(double x, double y) throw ();
# 7276 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float nextafterf(float x, float y) throw ();
# 7292 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double nan(const char *tagp) throw ();
# 7308 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float nanf(const char *tagp) throw ();






extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isinff(float) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isnanf(float) throw ();
# 7326 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __finite(double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __finitef(float) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __signbit(double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isnan(double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isinf(double) throw ();


extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __signbitf(float) throw ();
# 7492 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fma(double x, double y, double z) throw ();
# 7650 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fmaf(float x, float y, float z) throw ();
# 7661 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __signbitl(long double) throw ();





extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __finitel(long double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isinfl(long double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isnanl(long double) throw ();
# 7719 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float acosf(float x) throw ();
# 7759 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float asinf(float x) throw ();
# 7799 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float atanf(float x) throw ();
# 7832 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float atan2f(float y, float x) throw ();
# 7856 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cosf(float x) throw ();
# 7898 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sinf(float x) throw ();
# 7940 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float tanf(float x) throw ();
# 7964 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float coshf(float x) throw ();
# 8005 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sinhf(float x) throw ();
# 8035 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float tanhf(float x) throw ();
# 8086 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float logf(float x) throw ();
# 8136 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float expf(float x) throw ();
# 8187 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float log10f(float x) throw ();
# 8242 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float modff(float x, float *iptr) throw ();
# 8550 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float powf(float x, float y) throw ();
# 8619 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sqrtf(float x) throw ();
# 8678 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float ceilf(float x) throw ();
# 8750 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float floorf(float x) throw ();
# 8809 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fmodf(float x, float y) throw ();
# 8823 "/usr/local/cuda-8.0/include/math_functions.h"
}



# 1 "/usr/include/math.h" 1 3 4
# 29 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 34 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 40 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 43 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 34 "/usr/include/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 47 "/usr/include/math.h" 2 3 4
# 70 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                           ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 71 "/usr/include/math.h" 2 3 4
# 89 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                           ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 90 "/usr/include/math.h" 2 3 4
# 133 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                           ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 134 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
extern int signgam;
# 190 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 288 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 311 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 413 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathinline.h" 1 3 4
# 62 "/usr/include/bits/mathinline.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __signbitf (float __x) throw ()
{

  return __builtin_signbitf (__x);




}
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __signbit (double __x) throw ()
{

  return __builtin_signbit (__x);




}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __signbitl (long double __x) throw ()
{
  return __signbit ((double) __x);
}
# 117 "/usr/include/bits/mathinline.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double fdim (double __x, double __y) throw ();
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__leaf__)) fdim (double __x, double __y) throw ()
{
  return __x <= __y ? 0 : __x - __y;
}

extern __inline __attribute__ ((__gnu_inline__)) float fdimf (float __x, float __y) throw ();
extern __inline __attribute__ ((__gnu_inline__)) float
__attribute__ ((__leaf__)) fdimf (float __x, float __y) throw ()
{
  return __x <= __y ? 0 : __x - __y;
}
# 414 "/usr/include/math.h" 2 3 4
# 475 "/usr/include/math.h" 3 4
}
# 8828 "/usr/local/cuda-8.0/include/math_functions.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 64 "/usr/include/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 34 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/byteswap-16.h" 1 3 4
# 35 "/usr/include/bits/byteswap.h" 2 3 4
# 43 "/usr/include/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 74 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 65 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

# 239 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}

# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 104 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 136 "/usr/include/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 147 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;







# 1 "/usr/include/bits/time.h" 1 3 4
# 46 "/usr/include/sys/select.h" 2 3 4
# 54 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 64 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/sys/select.h" 3 4
extern "C" {
# 106 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/sys/select.h" 3 4
}
# 220 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 29 "/usr/include/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__leaf__)) gnu_dev_major (unsigned long long int __dev) throw ()
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__leaf__)) gnu_dev_minor (unsigned long long int __dev) throw ()
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned long long int
__attribute__ ((__leaf__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}

}
# 223 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 49 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 79 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
# 104 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;
  } __data;
# 190 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/sys/types.h" 2 3 4


}
# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 492 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__, __alloc_size__ (2)));




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 605 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 619 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 629 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 641 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 651 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 673 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 683 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 693 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 807 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 895 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/bits/stdlib-float.h" 3 4

extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__leaf__)) atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}

# 952 "/usr/include/stdlib.h" 2 3 4
# 964 "/usr/include/stdlib.h" 3 4
}
# 8829 "/usr/local/cuda-8.0/include/math_functions.h" 2


# 1 "/usr/include/c++/4.8.2/cmath" 1 3
# 39 "/usr/include/c++/4.8.2/cmath" 3
       
# 40 "/usr/include/c++/4.8.2/cmath" 3

# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++config.h" 1 3
# 184 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;




}
# 346 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++config.h" 3
namespace std
{
  inline namespace __gnu_cxx_ldbl128 { }
}
# 426 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++config.h" 3
# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/os_defines.h" 1 3
# 427 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++config.h" 2 3


# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/cpu_defines.h" 1 3
# 430 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++config.h" 2 3
# 42 "/usr/include/c++/4.8.2/cmath" 2 3
# 1 "/usr/include/c++/4.8.2/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/4.8.2/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/4.8.2/bits/cpp_type_traits.h" 3
# 68 "/usr/include/c++/4.8.2/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 198 "/usr/include/c++/4.8.2/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 421 "/usr/include/c++/4.8.2/bits/cpp_type_traits.h" 3

}
# 43 "/usr/include/c++/4.8.2/cmath" 2 3
# 1 "/usr/include/c++/4.8.2/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/4.8.2/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/4.8.2/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline
   
# 150 "/usr/include/c++/4.8.2/ext/type_traits.h" 3
   
# 149 "/usr/include/c++/4.8.2/ext/type_traits.h" 3
           bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline
   
# 155 "/usr/include/c++/4.8.2/ext/type_traits.h" 3
   
# 154 "/usr/include/c++/4.8.2/ext/type_traits.h" 3
           bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 44 "/usr/include/c++/4.8.2/cmath" 2 3
# 75 "/usr/include/c++/4.8.2/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }




  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }



  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 555 "/usr/include/c++/4.8.2/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 805 "/usr/include/c++/4.8.2/cmath" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(0, 1, 4,
      3, 2, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }




}
# 8832 "/usr/local/cuda-8.0/include/math_functions.h" 2
# 1 "/usr/include/c++/4.8.2/cstdlib" 1 3
# 39 "/usr/include/c++/4.8.2/cstdlib" 3
       
# 40 "/usr/include/c++/4.8.2/cstdlib" 3
# 114 "/usr/include/c++/4.8.2/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }



  inline __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }



}
# 196 "/usr/include/c++/4.8.2/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 228 "/usr/include/c++/4.8.2/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 8833 "/usr/local/cuda-8.0/include/math_functions.h" 2
# 8925 "/usr/local/cuda-8.0/include/math_functions.h"
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int signbit(float x);



__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int signbit(double x);

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int signbit(long double x);

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isfinite(float x);



__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isfinite(double x);

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isfinite(long double x);

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(float x);



__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(double x) throw();

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(long double x);

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(float x);



__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(double x) throw();

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(long double x);
# 9002 "/usr/local/cuda-8.0/include/math_functions.h"
namespace std
{
  template<typename T> extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) T __pow_helper(T, int);
  template<typename T> extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) T __cmath_power(T, unsigned int);
}

using std::abs;
using std::fabs;
using std::ceil;
using std::floor;
using std::sqrt;
using std::pow;
using std::log;
using std::log10;
using std::fmod;
using std::modf;
using std::exp;
using std::frexp;
using std::ldexp;
using std::asin;
using std::sin;
using std::sinh;
using std::acos;
using std::cos;
using std::cosh;
using std::atan;
using std::atan2;
using std::tan;
using std::tanh;
# 9393 "/usr/local/cuda-8.0/include/math_functions.h"
namespace std {
# 9406 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long long int abs(long long int);





extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long int abs(long int);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float abs(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double abs(double);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float fabs(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float ceil(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float floor(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sqrt(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float pow(float, float);
# 9428 "/usr/local/cuda-8.0/include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float pow(float, int);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double pow(double, int);




extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float log(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float log10(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float fmod(float, float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float modf(float, float*);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float exp(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float frexp(float, int*);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float ldexp(float, int);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float asin(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sin(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sinh(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float acos(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float cos(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float cosh(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float atan(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float atan2(float, float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float tan(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float tanh(float);
# 9518 "/usr/local/cuda-8.0/include/math_functions.h"
}
# 9609 "/usr/local/cuda-8.0/include/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) float logb(float a);

static inline __attribute__((host)) __attribute__((device)) int ilogb(float a);

static inline __attribute__((host)) __attribute__((device)) float scalbn(float a, int b);

static inline __attribute__((host)) __attribute__((device)) float scalbln(float a, long int b);

static inline __attribute__((host)) __attribute__((device)) float exp2(float a);

static inline __attribute__((host)) __attribute__((device)) float expm1(float a);

static inline __attribute__((host)) __attribute__((device)) float log2(float a);

static inline __attribute__((host)) __attribute__((device)) float log1p(float a);

static inline __attribute__((host)) __attribute__((device)) float acosh(float a);

static inline __attribute__((host)) __attribute__((device)) float asinh(float a);

static inline __attribute__((host)) __attribute__((device)) float atanh(float a);

static inline __attribute__((host)) __attribute__((device)) float hypot(float a, float b);

static inline __attribute__((host)) __attribute__((device)) float norm3d(float a, float b, float c);

static inline __attribute__((host)) __attribute__((device)) float norm4d(float a, float b, float c, float d);

static inline __attribute__((host)) __attribute__((device)) float cbrt(float a);

static inline __attribute__((host)) __attribute__((device)) float erf(float a);

static inline __attribute__((host)) __attribute__((device)) float erfc(float a);

static inline __attribute__((host)) __attribute__((device)) float lgamma(float a);

static inline __attribute__((host)) __attribute__((device)) float tgamma(float a);

static inline __attribute__((host)) __attribute__((device)) float copysign(float a, float b);

static inline __attribute__((host)) __attribute__((device)) float nextafter(float a, float b);

static inline __attribute__((host)) __attribute__((device)) float remainder(float a, float b);

static inline __attribute__((host)) __attribute__((device)) float remquo(float a, float b, int *quo);

static inline __attribute__((host)) __attribute__((device)) float round(float a);

static inline __attribute__((host)) __attribute__((device)) long int lround(float a);

static inline __attribute__((host)) __attribute__((device)) long long int llround(float a);

static inline __attribute__((host)) __attribute__((device)) float trunc(float a);

static inline __attribute__((host)) __attribute__((device)) float rint(float a);

static inline __attribute__((host)) __attribute__((device)) long int lrint(float a);

static inline __attribute__((host)) __attribute__((device)) long long int llrint(float a);

static inline __attribute__((host)) __attribute__((device)) float nearbyint(float a);

static inline __attribute__((host)) __attribute__((device)) float fdim(float a, float b);

static inline __attribute__((host)) __attribute__((device)) float fma(float a, float b, float c);

static inline __attribute__((host)) __attribute__((device)) float fmax(float a, float b);

static inline __attribute__((host)) __attribute__((device)) float fmin(float a, float b);
# 9718 "/usr/local/cuda-8.0/include/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) float exp10(float a);

static inline __attribute__((host)) __attribute__((device)) float rsqrt(float a);

static inline __attribute__((host)) __attribute__((device)) float rcbrt(float a);

static inline __attribute__((host)) __attribute__((device)) float sinpi(float a);

static inline __attribute__((host)) __attribute__((device)) float cospi(float a);

static inline __attribute__((host)) __attribute__((device)) void sincospi(float a, float *sptr, float *cptr);

static inline __attribute__((host)) __attribute__((device)) void sincos(float a, float *sptr, float *cptr);

static inline __attribute__((host)) __attribute__((device)) float j0(float a);

static inline __attribute__((host)) __attribute__((device)) float j1(float a);

static inline __attribute__((host)) __attribute__((device)) float jn(int n, float a);

static inline __attribute__((host)) __attribute__((device)) float y0(float a);

static inline __attribute__((host)) __attribute__((device)) float y1(float a);

static inline __attribute__((host)) __attribute__((device)) float yn(int n, float a);

static inline __attribute__((host)) __attribute__((device)) float cyl_bessel_i0(float a);

static inline __attribute__((host)) __attribute__((device)) float cyl_bessel_i1(float a);

static inline __attribute__((host)) __attribute__((device)) float erfinv(float a);

static inline __attribute__((host)) __attribute__((device)) float erfcinv(float a);

static inline __attribute__((host)) __attribute__((device)) float normcdfinv(float a);

static inline __attribute__((host)) __attribute__((device)) float normcdf(float a);

static inline __attribute__((host)) __attribute__((device)) float erfcx(float a);

static inline __attribute__((host)) __attribute__((device)) double copysign(double a, float b);

static inline __attribute__((host)) __attribute__((device)) float copysign(float a, double b);

static inline __attribute__((host)) __attribute__((device)) unsigned int min(unsigned int a, unsigned int b);

static inline __attribute__((host)) __attribute__((device)) unsigned int min(int a, unsigned int b);

static inline __attribute__((host)) __attribute__((device)) unsigned int min(unsigned int a, int b);

static inline __attribute__((host)) __attribute__((device)) long int min(long int a, long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long int min(unsigned long int a, unsigned long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long int min(long int a, unsigned long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long int min(unsigned long int a, long int b);

static inline __attribute__((host)) __attribute__((device)) long long int min(long long int a, long long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long long int min(unsigned long long int a, unsigned long long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long long int min(long long int a, unsigned long long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long long int min(unsigned long long int a, long long int b);

static inline __attribute__((host)) __attribute__((device)) float min(float a, float b);

static inline __attribute__((host)) __attribute__((device)) double min(double a, double b);

static inline __attribute__((host)) __attribute__((device)) double min(float a, double b);

static inline __attribute__((host)) __attribute__((device)) double min(double a, float b);

static inline __attribute__((host)) __attribute__((device)) unsigned int max(unsigned int a, unsigned int b);

static inline __attribute__((host)) __attribute__((device)) unsigned int max(int a, unsigned int b);

static inline __attribute__((host)) __attribute__((device)) unsigned int max(unsigned int a, int b);

static inline __attribute__((host)) __attribute__((device)) long int max(long int a, long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long int max(unsigned long int a, unsigned long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long int max(long int a, unsigned long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long int max(unsigned long int a, long int b);

static inline __attribute__((host)) __attribute__((device)) long long int max(long long int a, long long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long long int max(unsigned long long int a, unsigned long long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long long int max(long long int a, unsigned long long int b);

static inline __attribute__((host)) __attribute__((device)) unsigned long long int max(unsigned long long int a, long long int b);

static inline __attribute__((host)) __attribute__((device)) float max(float a, float b);

static inline __attribute__((host)) __attribute__((device)) double max(double a, double b);

static inline __attribute__((host)) __attribute__((device)) double max(float a, double b);

static inline __attribute__((host)) __attribute__((device)) double max(double a, float b);
# 10327 "/usr/local/cuda-8.0/include/math_functions.h"
# 1 "/usr/local/cuda-8.0/include/math_functions.hpp" 1
# 67 "/usr/local/cuda-8.0/include/math_functions.hpp"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 68 "/usr/local/cuda-8.0/include/math_functions.hpp" 2
# 248 "/usr/local/cuda-8.0/include/math_functions.hpp"
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int signbit(float x) { return __signbitf(x); }



__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int signbit(double x) { return __signbit(x); }

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int signbit(long double x) { return __signbitl(x);}
# 265 "/usr/local/cuda-8.0/include/math_functions.hpp"
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isfinite(float x) { return __finitef(x); }
# 280 "/usr/local/cuda-8.0/include/math_functions.hpp"
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isfinite(double x) { return __finite(x); }
# 293 "/usr/local/cuda-8.0/include/math_functions.hpp"
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isfinite(long double x) { return __finitel(x); }


__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(float x) { return __isnanf(x); }



__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(double x) throw() { return __isnan(x); }

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(long double x) { return __isnanl(x); }

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(float x) { return __isinff(x); }



__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(double x) throw() { return __isinf(x); }

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(long double x) { return __isinfl(x); }
# 503 "/usr/local/cuda-8.0/include/math_functions.hpp"
static inline __attribute__((host)) __attribute__((device)) float logb(float a)
{
  return logbf(a);
}

static inline __attribute__((host)) __attribute__((device)) int ilogb(float a)
{
  return ilogbf(a);
}

static inline __attribute__((host)) __attribute__((device)) float scalbn(float a, int b)
{
  return scalbnf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) float scalbln(float a, long int b)
{
  return scalblnf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) float exp2(float a)
{
  return exp2f(a);
}

static inline __attribute__((host)) __attribute__((device)) float expm1(float a)
{
  return expm1f(a);
}

static inline __attribute__((host)) __attribute__((device)) float log2(float a)
{
  return log2f(a);
}

static inline __attribute__((host)) __attribute__((device)) float log1p(float a)
{
  return log1pf(a);
}

static inline __attribute__((host)) __attribute__((device)) float acosh(float a)
{
  return acoshf(a);
}

static inline __attribute__((host)) __attribute__((device)) float asinh(float a)
{
  return asinhf(a);
}

static inline __attribute__((host)) __attribute__((device)) float atanh(float a)
{
  return atanhf(a);
}

static inline __attribute__((host)) __attribute__((device)) float hypot(float a, float b)
{
  return hypotf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) float norm3d(float a, float b, float c)
{
  return norm3df(a, b, c);
}

static inline __attribute__((host)) __attribute__((device)) float norm4d(float a, float b, float c, float d)
{
  return norm4df(a, b, c, d);
}

static inline __attribute__((host)) __attribute__((device)) float cbrt(float a)
{
  return cbrtf(a);
}

static inline __attribute__((host)) __attribute__((device)) float erf(float a)
{
  return erff(a);
}

static inline __attribute__((host)) __attribute__((device)) float erfc(float a)
{
  return erfcf(a);
}

static inline __attribute__((host)) __attribute__((device)) float lgamma(float a)
{
  return lgammaf(a);
}

static inline __attribute__((host)) __attribute__((device)) float tgamma(float a)
{
  return tgammaf(a);
}

static inline __attribute__((host)) __attribute__((device)) float copysign(float a, float b)
{
  return copysignf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) float nextafter(float a, float b)
{
  return nextafterf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) float remainder(float a, float b)
{
  return remainderf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) float remquo(float a, float b, int *quo)
{
  return remquof(a, b, quo);
}

static inline __attribute__((host)) __attribute__((device)) float round(float a)
{
  return roundf(a);
}

static inline __attribute__((host)) __attribute__((device)) long int lround(float a)
{
  return lroundf(a);
}

static inline __attribute__((host)) __attribute__((device)) long long int llround(float a)
{
  return llroundf(a);
}

static inline __attribute__((host)) __attribute__((device)) float trunc(float a)
{
  return truncf(a);
}

static inline __attribute__((host)) __attribute__((device)) float rint(float a)
{
  return rintf(a);
}

static inline __attribute__((host)) __attribute__((device)) long int lrint(float a)
{
  return lrintf(a);
}

static inline __attribute__((host)) __attribute__((device)) long long int llrint(float a)
{
  return llrintf(a);
}

static inline __attribute__((host)) __attribute__((device)) float nearbyint(float a)
{
  return nearbyintf(a);
}

static inline __attribute__((host)) __attribute__((device)) float fdim(float a, float b)
{
  return fdimf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) float fma(float a, float b, float c)
{
  return fmaf(a, b, c);
}

static inline __attribute__((host)) __attribute__((device)) float fmax(float a, float b)
{
  return fmaxf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) float fmin(float a, float b)
{
  return fminf(a, b);
}




static inline __attribute__((host)) __attribute__((device)) float exp10(float a)
{
  return exp10f(a);
}

static inline __attribute__((host)) __attribute__((device)) float rsqrt(float a)
{
  return rsqrtf(a);
}

static inline __attribute__((host)) __attribute__((device)) float rcbrt(float a)
{
  return rcbrtf(a);
}

static inline __attribute__((host)) __attribute__((device)) float sinpi(float a)
{
  return sinpif(a);
}

static inline __attribute__((host)) __attribute__((device)) float cospi(float a)
{
  return cospif(a);
}

static inline __attribute__((host)) __attribute__((device)) void sincospi(float a, float *sptr, float *cptr)
{
  sincospif(a, sptr, cptr);
}

static inline __attribute__((host)) __attribute__((device)) void sincos(float a, float *sptr, float *cptr)
{
  sincosf(a, sptr, cptr);
}

static inline __attribute__((host)) __attribute__((device)) float j0(float a)
{
  return j0f(a);
}

static inline __attribute__((host)) __attribute__((device)) float j1(float a)
{
  return j1f(a);
}

static inline __attribute__((host)) __attribute__((device)) float jn(int n, float a)
{
  return jnf(n, a);
}

static inline __attribute__((host)) __attribute__((device)) float y0(float a)
{
  return y0f(a);
}

static inline __attribute__((host)) __attribute__((device)) float y1(float a)
{
  return y1f(a);
}

static inline __attribute__((host)) __attribute__((device)) float yn(int n, float a)
{
  return ynf(n, a);
}

static inline __attribute__((host)) __attribute__((device)) float cyl_bessel_i0(float a)
{
  return cyl_bessel_i0f(a);
}

static inline __attribute__((host)) __attribute__((device)) float cyl_bessel_i1(float a)
{
  return cyl_bessel_i1f(a);
}

static inline __attribute__((host)) __attribute__((device)) float erfinv(float a)
{
  return erfinvf(a);
}

static inline __attribute__((host)) __attribute__((device)) float erfcinv(float a)
{
  return erfcinvf(a);
}

static inline __attribute__((host)) __attribute__((device)) float normcdfinv(float a)
{
  return normcdfinvf(a);
}

static inline __attribute__((host)) __attribute__((device)) float normcdf(float a)
{
  return normcdff(a);
}

static inline __attribute__((host)) __attribute__((device)) float erfcx(float a)
{
  return erfcxf(a);
}

static inline __attribute__((host)) __attribute__((device)) double copysign(double a, float b)
{
  return copysign(a, (double)b);
}

static inline __attribute__((host)) __attribute__((device)) float copysign(float a, double b)
{
  return copysignf(a, (float)b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int min(unsigned int a, unsigned int b)
{
  return umin(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int min(int a, unsigned int b)
{
  return umin((unsigned int)a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int min(unsigned int a, int b)
{
  return umin(a, (unsigned int)b);
}

static inline __attribute__((host)) __attribute__((device)) long int min(long int a, long int b)
{





  if (sizeof(long int) == sizeof(int)) {



    return (long int)min((int)a, (int)b);
  } else {
    return (long int)llmin((long long int)a, (long long int)b);
  }
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int min(unsigned long int a, unsigned long int b)
{



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    return (unsigned long int)umin((unsigned int)a, (unsigned int)b);
  } else {
    return (unsigned long int)ullmin((unsigned long long int)a, (unsigned long long int)b);
  }
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int min(long int a, unsigned long int b)
{



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    return (unsigned long int)umin((unsigned int)a, (unsigned int)b);
  } else {
    return (unsigned long int)ullmin((unsigned long long int)a, (unsigned long long int)b);
  }
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int min(unsigned long int a, long int b)
{



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    return (unsigned long int)umin((unsigned int)a, (unsigned int)b);
  } else {
    return (unsigned long int)ullmin((unsigned long long int)a, (unsigned long long int)b);
  }
}

static inline __attribute__((host)) __attribute__((device)) long long int min(long long int a, long long int b)
{
  return llmin(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int min(unsigned long long int a, unsigned long long int b)
{
  return ullmin(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int min(long long int a, unsigned long long int b)
{
  return ullmin((unsigned long long int)a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int min(unsigned long long int a, long long int b)
{
  return ullmin(a, (unsigned long long int)b);
}

static inline __attribute__((host)) __attribute__((device)) float min(float a, float b)
{
  return fminf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) double min(double a, double b)
{
  return fmin(a, b);
}

static inline __attribute__((host)) __attribute__((device)) double min(float a, double b)
{
  return fmin((double)a, b);
}

static inline __attribute__((host)) __attribute__((device)) double min(double a, float b)
{
  return fmin(a, (double)b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int max(unsigned int a, unsigned int b)
{
  return umax(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int max(int a, unsigned int b)
{
  return umax((unsigned int)a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int max(unsigned int a, int b)
{
  return umax(a, (unsigned int)b);
}

static inline __attribute__((host)) __attribute__((device)) long int max(long int a, long int b)
{




  if (sizeof(long int) == sizeof(int)) {



    return (long int)max((int)a, (int)b);
  } else {
    return (long int)llmax((long long int)a, (long long int)b);
  }
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int max(unsigned long int a, unsigned long int b)
{



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    return (unsigned long int)umax((unsigned int)a, (unsigned int)b);
  } else {
    return (unsigned long int)ullmax((unsigned long long int)a, (unsigned long long int)b);
  }
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int max(long int a, unsigned long int b)
{



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    return (unsigned long int)umax((unsigned int)a, (unsigned int)b);
  } else {
    return (unsigned long int)ullmax((unsigned long long int)a, (unsigned long long int)b);
  }
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int max(unsigned long int a, long int b)
{



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    return (unsigned long int)umax((unsigned int)a, (unsigned int)b);
  } else {
    return (unsigned long int)ullmax((unsigned long long int)a, (unsigned long long int)b);
  }
}

static inline __attribute__((host)) __attribute__((device)) long long int max(long long int a, long long int b)
{
  return llmax(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int max(unsigned long long int a, unsigned long long int b)
{
  return ullmax(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int max(long long int a, unsigned long long int b)
{
  return ullmax((unsigned long long int)a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int max(unsigned long long int a, long long int b)
{
  return ullmax(a, (unsigned long long int)b);
}

static inline __attribute__((host)) __attribute__((device)) float max(float a, float b)
{
  return fmaxf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) double max(double a, double b)
{
  return fmax(a, b);
}

static inline __attribute__((host)) __attribute__((device)) double max(float a, double b)
{
  return fmax((double)a, b);
}

static inline __attribute__((host)) __attribute__((device)) double max(double a, float b)
{
  return fmax(a, (double)b);
}
# 1033 "/usr/local/cuda-8.0/include/math_functions.hpp"
inline __attribute__((host)) __attribute__((device)) int min(int a, int b)
{
  return a < b ? a : b;
}

inline __attribute__((host)) __attribute__((device)) unsigned umin(unsigned int a, unsigned int b)
{
  return a < b ? a : b;
}

inline __attribute__((host)) __attribute__((device)) long long int llmin(long long int a, long long int b)
{
  return a < b ? a : b;
}

inline __attribute__((host)) __attribute__((device)) unsigned long long int ullmin(unsigned long long int a,
                                              unsigned long long int b)
{
  return a < b ? a : b;
}

inline __attribute__((host)) __attribute__((device)) int max(int a, int b)
{
  return a > b ? a : b;
}

inline __attribute__((host)) __attribute__((device)) unsigned int umax(unsigned int a, unsigned int b)
{
  return a > b ? a : b;
}

inline __attribute__((host)) __attribute__((device)) long long int llmax(long long int a, long long int b)
{
  return a > b ? a : b;
}

inline __attribute__((host)) __attribute__((device)) unsigned long long int ullmax(unsigned long long int a,
                                                    unsigned long long int b)
{
  return a > b ? a : b;
}
# 10328 "/usr/local/cuda-8.0/include/math_functions.h" 2



# 1 "/usr/local/cuda-8.0/include/math_functions_dbl_ptx3.h" 1
# 270 "/usr/local/cuda-8.0/include/math_functions_dbl_ptx3.h"
# 1 "/usr/local/cuda-8.0/include/math_functions_dbl_ptx3.hpp" 1
# 271 "/usr/local/cuda-8.0/include/math_functions_dbl_ptx3.h" 2
# 10332 "/usr/local/cuda-8.0/include/math_functions.h" 2
# 250 "/usr/local/cuda-8.0/include/common_functions.h" 2
# 117 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-8.0/include/cuda_surface_types.h" 1
# 61 "/usr/local/cuda-8.0/include/cuda_surface_types.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 62 "/usr/local/cuda-8.0/include/cuda_surface_types.h" 2
# 77 "/usr/local/cuda-8.0/include/cuda_surface_types.h"
template<class T, int dim = 1>
struct __attribute__((device_builtin_surface_type)) surface : public surfaceReference
{

  __attribute__((host)) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<T>();
  }

  __attribute__((host)) surface(struct cudaChannelFormatDesc desc)
  {
    channelDesc = desc;
  }

};

template<int dim>
struct __attribute__((device_builtin_surface_type)) surface<void, dim> : public surfaceReference
{

  __attribute__((host)) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<void>();
  }

};
# 118 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-8.0/include/cuda_texture_types.h" 1
# 61 "/usr/local/cuda-8.0/include/cuda_texture_types.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 62 "/usr/local/cuda-8.0/include/cuda_texture_types.h" 2
# 77 "/usr/local/cuda-8.0/include/cuda_texture_types.h"
template<class T, int texType = 0x01, enum cudaTextureReadMode mode = cudaReadModeElementType>
struct __attribute__((device_builtin_texture_type)) texture : public textureReference
{

  __attribute__((host)) texture(int norm = 0,
                   enum cudaTextureFilterMode fMode = cudaFilterModePoint,
                   enum cudaTextureAddressMode aMode = cudaAddressModeClamp)
  {
    normalized = norm;
    filterMode = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc = cudaCreateChannelDesc<T>();
    sRGB = 0;
  }

  __attribute__((host)) texture(int norm,
                   enum cudaTextureFilterMode fMode,
                   enum cudaTextureAddressMode aMode,
                   struct cudaChannelFormatDesc desc)
  {
    normalized = norm;
    filterMode = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc = desc;
    sRGB = 0;
  }

};
# 119 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-8.0/include/device_functions.h" 1
# 80 "/usr/local/cuda-8.0/include/device_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 81 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 90 "/usr/local/cuda-8.0/include/device_functions.h"
extern "C"
{
# 101 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __mulhi(int x, int y);
# 111 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __umulhi(unsigned int x, unsigned int y);
# 121 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __mul64hi(long long int x, long long int y);
# 131 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __umul64hi(unsigned long long int x, unsigned long long int y);
# 140 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int_as_float(int x);
# 149 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float_as_int(float x);
# 158 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint_as_float(unsigned int x);
# 167 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float_as_uint(float x);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __syncthreads(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __prof_trigger(int);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __threadfence(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __threadfence_block(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __trap(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __brkpt(int c = 0);
# 196 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __saturatef(float x);
# 265 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __sad(int x, int y, unsigned int z);
# 333 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __usad(unsigned int x, unsigned int y, unsigned int z);
# 343 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __mul24(int x, int y);
# 353 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __umul24(unsigned int x, unsigned int y);
# 366 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float fdividef(float x, float y);
# 441 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdividef(float x, float y);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) double fdivide(double x, double y);
# 454 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __sinf(float x) throw ();
# 466 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __cosf(float x) throw ();
# 480 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __tanf(float x) throw ();
# 495 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) void __sincosf(float x, float *sptr, float *cptr) throw ();
# 545 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __expf(float x) throw ();
# 577 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __exp10f(float x) throw ();
# 603 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __log2f(float x) throw ();
# 631 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __log10f(float x) throw ();
# 675 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __logf(float x) throw ();
# 718 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __powf(float x, float y) throw ();
# 727 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float2int_rn(float x);
# 736 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float2int_rz(float x);
# 745 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float2int_ru(float);
# 754 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float2int_rd(float x);
# 763 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float2uint_rn(float x);
# 772 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float2uint_rz(float x);
# 781 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float2uint_ru(float x);
# 790 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float2uint_rd(float x);
# 799 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int2float_rn(int x);
# 808 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int2float_rz(int x);
# 817 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int2float_ru(int x);
# 826 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int2float_rd(int x);
# 835 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint2float_rn(unsigned int x);
# 844 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint2float_rz(unsigned int x);
# 853 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint2float_ru(unsigned int x);
# 862 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint2float_rd(unsigned int x);
# 871 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __float2ll_rn(float x);
# 880 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __float2ll_rz(float x);
# 889 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __float2ll_ru(float x);
# 898 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __float2ll_rd(float x);
# 907 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __float2ull_rn(float x);
# 916 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __float2ull_rz(float x);
# 925 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __float2ull_ru(float x);
# 934 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __float2ull_rd(float x);
# 943 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ll2float_rn(long long int x);
# 952 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ll2float_rz(long long int x);
# 961 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ll2float_ru(long long int x);
# 970 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ll2float_rd(long long int x);
# 979 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ull2float_rn(unsigned long long int x);
# 988 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ull2float_rz(unsigned long long int x);
# 997 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ull2float_ru(unsigned long long int x);
# 1006 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ull2float_rd(unsigned long long int x);
# 1015 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned short __float2half_rn(float x);
# 1024 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __half2float(unsigned short x);
# 1036 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fadd_rn(float x, float y);
# 1048 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fadd_rz(float x, float y);
# 1060 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fadd_ru(float x, float y);
# 1072 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fadd_rd(float x, float y);
# 1084 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsub_rn(float x, float y);
# 1096 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsub_rz(float x, float y);
# 1108 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsub_ru(float x, float y);
# 1120 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsub_rd(float x, float y);
# 1132 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmul_rn(float x, float y);
# 1144 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmul_rz(float x, float y);
# 1156 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmul_ru(float x, float y);
# 1168 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmul_rd(float x, float y);
# 1321 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmaf_rn(float x, float y, float z);
# 1474 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmaf_rz(float x, float y, float z);
# 1627 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmaf_ru(float x, float y, float z);
# 1780 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmaf_rd(float x, float y, float z);
# 1813 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frcp_rn(float x);
# 1846 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frcp_rz(float x);
# 1879 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frcp_ru(float x);
# 1912 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frcp_rd(float x);
# 1943 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsqrt_rn(float x);
# 1974 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsqrt_rz(float x);
# 2005 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsqrt_ru(float x);
# 2036 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsqrt_rd(float x);
# 2075 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frsqrt_rn(float x);
# 2086 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdiv_rn(float x, float y);
# 2097 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdiv_rz(float x, float y);
# 2108 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdiv_ru(float x, float y);
# 2119 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdiv_rd(float x, float y);
# 2128 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __clz(int x);
# 2139 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __ffs(int x);
# 2148 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __popc(unsigned int x);
# 2157 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __brev(unsigned int x);
# 2166 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __clzll(long long int x);
# 2177 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __ffsll(long long int x);
# 2188 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __popcll(unsigned long long int x);
# 2197 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __brevll(unsigned long long int x);
# 2221 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __byte_perm(unsigned int x, unsigned int y, unsigned int s);
# 2233 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __hadd(int, int);
# 2246 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __rhadd(int, int);
# 2258 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __uhadd(unsigned int, unsigned int);
# 2271 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __urhadd(unsigned int, unsigned int);
# 2281 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __double2int_rz(double);
# 2290 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __double2uint_rz(double);
# 2299 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __double2ll_rz(double);
# 2308 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __double2ull_rz(double);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __pm0(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __pm1(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __pm2(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __pm3(void);
# 2338 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabs2(unsigned int a);
# 2349 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsss2(unsigned int a);
# 2360 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vadd2(unsigned int a, unsigned int b);
# 2371 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vaddss2 (unsigned int a, unsigned int b);
# 2381 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vaddus2 (unsigned int a, unsigned int b);
# 2392 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vavgs2(unsigned int a, unsigned int b);
# 2403 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vavgu2(unsigned int a, unsigned int b);
# 2414 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vhaddu2(unsigned int a, unsigned int b);
# 2425 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpeq2(unsigned int a, unsigned int b);
# 2436 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpges2(unsigned int a, unsigned int b);
# 2447 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgeu2(unsigned int a, unsigned int b);
# 2458 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgts2(unsigned int a, unsigned int b);
# 2469 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgtu2(unsigned int a, unsigned int b);
# 2480 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmples2(unsigned int a, unsigned int b);
# 2492 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpleu2(unsigned int a, unsigned int b);
# 2503 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmplts2(unsigned int a, unsigned int b);
# 2514 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpltu2(unsigned int a, unsigned int b);
# 2525 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpne2(unsigned int a, unsigned int b);
# 2536 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsdiffu2(unsigned int a, unsigned int b);
# 2547 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmaxs2(unsigned int a, unsigned int b);
# 2558 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmaxu2(unsigned int a, unsigned int b);
# 2569 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmins2(unsigned int a, unsigned int b);
# 2580 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vminu2(unsigned int a, unsigned int b);
# 2591 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vseteq2(unsigned int a, unsigned int b);
# 2602 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetges2(unsigned int a, unsigned int b);
# 2613 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgeu2(unsigned int a, unsigned int b);
# 2624 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgts2(unsigned int a, unsigned int b);
# 2635 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgtu2(unsigned int a, unsigned int b);
# 2646 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetles2(unsigned int a, unsigned int b);
# 2657 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetleu2(unsigned int a, unsigned int b);
# 2668 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetlts2(unsigned int a, unsigned int b);
# 2679 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetltu2(unsigned int a, unsigned int b);
# 2690 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetne2(unsigned int a, unsigned int b);
# 2701 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsadu2(unsigned int a, unsigned int b);
# 2712 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsub2(unsigned int a, unsigned int b);
# 2723 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsubss2 (unsigned int a, unsigned int b);
# 2734 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsubus2 (unsigned int a, unsigned int b);
# 2744 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vneg2(unsigned int a);
# 2754 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vnegss2(unsigned int a);
# 2765 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsdiffs2(unsigned int a, unsigned int b);
# 2776 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsads2(unsigned int a, unsigned int b);
# 2786 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabs4(unsigned int a);
# 2797 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsss4(unsigned int a);
# 2808 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vadd4(unsigned int a, unsigned int b);
# 2819 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vaddss4 (unsigned int a, unsigned int b);
# 2829 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vaddus4 (unsigned int a, unsigned int b);
# 2840 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vavgs4(unsigned int a, unsigned int b);
# 2851 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vavgu4(unsigned int a, unsigned int b);
# 2862 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vhaddu4(unsigned int a, unsigned int b);
# 2873 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpeq4(unsigned int a, unsigned int b);
# 2884 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpges4(unsigned int a, unsigned int b);
# 2895 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgeu4(unsigned int a, unsigned int b);
# 2906 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgts4(unsigned int a, unsigned int b);
# 2917 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgtu4(unsigned int a, unsigned int b);
# 2928 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmples4(unsigned int a, unsigned int b);
# 2939 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpleu4(unsigned int a, unsigned int b);
# 2950 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmplts4(unsigned int a, unsigned int b);
# 2961 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpltu4(unsigned int a, unsigned int b);
# 2972 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpne4(unsigned int a, unsigned int b);
# 2983 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsdiffu4(unsigned int a, unsigned int b);
# 2994 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmaxs4(unsigned int a, unsigned int b);
# 3005 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmaxu4(unsigned int a, unsigned int b);
# 3016 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmins4(unsigned int a, unsigned int b);
# 3027 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vminu4(unsigned int a, unsigned int b);
# 3038 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vseteq4(unsigned int a, unsigned int b);
# 3049 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetles4(unsigned int a, unsigned int b);
# 3060 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetleu4(unsigned int a, unsigned int b);
# 3071 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetlts4(unsigned int a, unsigned int b);
# 3082 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetltu4(unsigned int a, unsigned int b);
# 3093 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetges4(unsigned int a, unsigned int b);
# 3104 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgeu4(unsigned int a, unsigned int b);
# 3115 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgts4(unsigned int a, unsigned int b);
# 3126 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgtu4(unsigned int a, unsigned int b);
# 3137 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetne4(unsigned int a, unsigned int b);
# 3148 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsadu4(unsigned int a, unsigned int b);
# 3159 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsub4(unsigned int a, unsigned int b);
# 3170 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsubss4(unsigned int a, unsigned int b);
# 3181 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsubus4(unsigned int a, unsigned int b);
# 3191 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vneg4(unsigned int a);
# 3201 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vnegss4(unsigned int a);
# 3212 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsdiffs4(unsigned int a, unsigned int b);
# 3223 "/usr/local/cuda-8.0/include/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsads4(unsigned int a, unsigned int b);






}







static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) int mulhi(int a, int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) unsigned int mulhi(unsigned int a, unsigned int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) unsigned int mulhi(int a, unsigned int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) unsigned int mulhi(unsigned int a, int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) long long int mul64hi(long long int a, long long int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long int mul64hi(unsigned long long int a, unsigned long long int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long int mul64hi(long long int a, unsigned long long int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long int mul64hi(unsigned long long int a, long long int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) int float_as_int(float a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) float int_as_float(int a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) unsigned int float_as_uint(float a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) float uint_as_float(unsigned int a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) float saturate(float a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) int mul24(int a, int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) unsigned int umul24(unsigned int a, unsigned int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute((deprecated("Please use __trap() instead."))) void trap(void);


static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute((deprecated("Please use __brkpt() instead."))) void brkpt(int c = 0);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute((deprecated("Please use __syncthreads() instead."))) void syncthreads(void);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute((deprecated("Please use __prof_trigger() instead."))) void prof_trigger(int e);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute((deprecated("Please use __threadfence() instead."))) void threadfence(bool global = true);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) int float2int(float a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) unsigned int float2uint(float a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) float int2float(int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) float uint2float(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest);
# 4511 "/usr/local/cuda-8.0/include/device_functions.h"
# 1 "/usr/local/cuda-8.0/include/device_functions.hpp" 1
# 72 "/usr/local/cuda-8.0/include/device_functions.hpp"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 73 "/usr/local/cuda-8.0/include/device_functions.hpp" 2
# 83 "/usr/local/cuda-8.0/include/device_functions.hpp"
static __inline__ __attribute__((device)) int mulhi(int a, int b)
{
  return __mulhi(a, b);
}

static __inline__ __attribute__((device)) unsigned int mulhi(unsigned int a, unsigned int b)
{
  return __umulhi(a, b);
}

static __inline__ __attribute__((device)) unsigned int mulhi(int a, unsigned int b)
{
  return __umulhi((unsigned int)a, b);
}

static __inline__ __attribute__((device)) unsigned int mulhi(unsigned int a, int b)
{
  return __umulhi(a, (unsigned int)b);
}

static __inline__ __attribute__((device)) long long int mul64hi(long long int a, long long int b)
{
  return __mul64hi(a, b);
}

static __inline__ __attribute__((device)) unsigned long long int mul64hi(unsigned long long int a, unsigned long long int b)
{
  return __umul64hi(a, b);
}

static __inline__ __attribute__((device)) unsigned long long int mul64hi(long long int a, unsigned long long int b)
{
  return __umul64hi((unsigned long long int)a, b);
}

static __inline__ __attribute__((device)) unsigned long long int mul64hi(unsigned long long int a, long long int b)
{
  return __umul64hi(a, (unsigned long long int)b);
}

static __inline__ __attribute__((device)) int float_as_int(float a)
{
  return __float_as_int(a);
}

static __inline__ __attribute__((device)) float int_as_float(int a)
{
  return __int_as_float(a);
}

static __inline__ __attribute__((device)) unsigned int float_as_uint(float a)
{
  return __float_as_uint(a);
}

static __inline__ __attribute__((device)) float uint_as_float(unsigned int a)
{
  return __uint_as_float(a);
}
static __inline__ __attribute__((device)) float saturate(float a)
{
  return __saturatef(a);
}

static __inline__ __attribute__((device)) int mul24(int a, int b)
{
  return __mul24(a, b);
}

static __inline__ __attribute__((device)) unsigned int umul24(unsigned int a, unsigned int b)
{
  return __umul24(a, b);
}

static __inline__ __attribute__((device)) void trap(void)
{
  __trap();
}


static __inline__ __attribute__((device)) void brkpt(int c)
{
  __brkpt(c);
}

static __inline__ __attribute__((device)) void syncthreads(void)
{
  __syncthreads();
}

static __inline__ __attribute__((device)) void prof_trigger(int e)
{
       if (e == 0) __prof_trigger( 0);
  else if (e == 1) __prof_trigger( 1);
  else if (e == 2) __prof_trigger( 2);
  else if (e == 3) __prof_trigger( 3);
  else if (e == 4) __prof_trigger( 4);
  else if (e == 5) __prof_trigger( 5);
  else if (e == 6) __prof_trigger( 6);
  else if (e == 7) __prof_trigger( 7);
  else if (e == 8) __prof_trigger( 8);
  else if (e == 9) __prof_trigger( 9);
  else if (e == 10) __prof_trigger(10);
  else if (e == 11) __prof_trigger(11);
  else if (e == 12) __prof_trigger(12);
  else if (e == 13) __prof_trigger(13);
  else if (e == 14) __prof_trigger(14);
  else if (e == 15) __prof_trigger(15);
}

static __inline__ __attribute__((device)) void threadfence(bool global)
{
  global ? __threadfence() : __threadfence_block();
}

static __inline__ __attribute__((device)) int float2int(float a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __float2int_rn(a) :
         mode == cudaRoundPosInf ? __float2int_ru(a) :
         mode == cudaRoundMinInf ? __float2int_rd(a) :
                                    __float2int_rz(a);
}

static __inline__ __attribute__((device)) unsigned int float2uint(float a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __float2uint_rn(a) :
         mode == cudaRoundPosInf ? __float2uint_ru(a) :
         mode == cudaRoundMinInf ? __float2uint_rd(a) :
                                    __float2uint_rz(a);
}

static __inline__ __attribute__((device)) float int2float(int a, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __int2float_rz(a) :
         mode == cudaRoundPosInf ? __int2float_ru(a) :
         mode == cudaRoundMinInf ? __int2float_rd(a) :
                                   __int2float_rn(a);
}

static __inline__ __attribute__((device)) float uint2float(unsigned int a, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __uint2float_rz(a) :
         mode == cudaRoundPosInf ? __uint2float_ru(a) :
         mode == cudaRoundMinInf ? __uint2float_rd(a) :
                                   __uint2float_rn(a);
}
# 4512 "/usr/local/cuda-8.0/include/device_functions.h" 2


# 1 "/usr/local/cuda-8.0/include/device_atomic_functions.h" 1
# 67 "/usr/local/cuda-8.0/include/device_atomic_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 68 "/usr/local/cuda-8.0/include/device_atomic_functions.h" 2
# 111 "/usr/local/cuda-8.0/include/device_atomic_functions.h"
static __inline__ __attribute__((device)) int atomicAdd(int *address, int val) { }

static __inline__ __attribute__((device)) unsigned int atomicAdd(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) int atomicSub(int *address, int val) { }

static __inline__ __attribute__((device)) unsigned int atomicSub(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) int atomicExch(int *address, int val) { }

static __inline__ __attribute__((device)) unsigned int atomicExch(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) float atomicExch(float *address, float val) { }

static __inline__ __attribute__((device)) int atomicMin(int *address, int val) { }

static __inline__ __attribute__((device)) unsigned int atomicMin(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) int atomicMax(int *address, int val) { }

static __inline__ __attribute__((device)) unsigned int atomicMax(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) unsigned int atomicInc(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) unsigned int atomicDec(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) int atomicAnd(int *address, int val) { }

static __inline__ __attribute__((device)) unsigned int atomicAnd(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) int atomicOr(int *address, int val) { }

static __inline__ __attribute__((device)) unsigned int atomicOr(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) int atomicXor(int *address, int val) { }

static __inline__ __attribute__((device)) unsigned int atomicXor(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device)) int atomicCAS(int *address, int compare, int val) { }

static __inline__ __attribute__((device)) unsigned int atomicCAS(unsigned int *address, unsigned int compare, unsigned int val) { }







# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 160 "/usr/local/cuda-8.0/include/device_atomic_functions.h" 2




extern "C"
{






extern __attribute__((device)) __attribute__((device_builtin)) int __any(int cond);
extern __attribute__((device)) __attribute__((device_builtin)) int __all(int cond);

}
# 185 "/usr/local/cuda-8.0/include/device_atomic_functions.h"
static __inline__ __attribute__((device)) unsigned long long int atomicAdd(unsigned long long int *address, unsigned long long int val) { }

static __inline__ __attribute__((device)) unsigned long long int atomicExch(unsigned long long int *address, unsigned long long int val) { }

static __inline__ __attribute__((device)) unsigned long long int atomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val) { }

static __inline__ __attribute__((device)) bool any(bool cond) { }

static __inline__ __attribute__((device)) bool all(bool cond) { }
# 4515 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/device_double_functions.h" 1
# 75 "/usr/local/cuda-8.0/include/device_double_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 76 "/usr/local/cuda-8.0/include/device_double_functions.h" 2




extern "C"
{
# 91 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double_as_longlong(double x);
# 100 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __longlong_as_double(long long int x);
# 257 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rn(double x, double y, double z);
# 414 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rz(double x, double y, double z);
# 571 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_ru(double x, double y, double z);
# 728 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rd(double x, double y, double z);
# 740 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rn(double x, double y);
# 752 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rz(double x, double y);
# 764 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_ru(double x, double y);
# 776 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rd(double x, double y);
# 788 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rn(double x, double y);
# 800 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rz(double x, double y);
# 812 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_ru(double x, double y);
# 824 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rd(double x, double y);
# 836 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rn(double x, double y);
# 848 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rz(double x, double y);
# 860 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_ru(double x, double y);
# 872 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rd(double x, double y);
# 881 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rn(double x);
# 890 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rz(double x);
# 899 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_ru(double x);
# 908 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rd(double x);
# 917 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rn(double x);
# 926 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_ru(double x);
# 935 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rd(double x);
# 944 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rn(double x);
# 953 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_ru(double x);
# 962 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rd(double x);
# 971 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rn(double x);
# 980 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_ru(double x);
# 989 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rd(double x);
# 998 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rn(double x);
# 1007 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_ru(double x);
# 1016 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rd(double x);







extern __attribute__((device)) __attribute__((device_builtin)) double __int2double_rn(int x);







extern __attribute__((device)) __attribute__((device_builtin)) double __uint2double_rn(unsigned int x);
# 1041 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rn(long long int x);
# 1050 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rz(long long int x);
# 1059 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_ru(long long int x);
# 1068 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rd(long long int x);
# 1077 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rn(unsigned long long int x);
# 1086 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rz(unsigned long long int x);
# 1095 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_ru(unsigned long long int x);
# 1104 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rd(unsigned long long int x);
# 1113 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2hiint(double x);
# 1122 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2loint(double x);
# 1132 "/usr/local/cuda-8.0/include/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __hiloint2double(int hi, int lo);

}
# 1143 "/usr/local/cuda-8.0/include/device_double_functions.h"
static __inline__ __attribute__((device)) double fma(double a, double b, double c, enum cudaRoundMode mode);

static __inline__ __attribute__((device)) double dmul(double a, double b, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double dadd(double a, double b, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double dsub(double a, double b, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) int double2int(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) unsigned int double2uint(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) long long int double2ll(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) unsigned long long int double2ull(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) double ll2double(long long int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double ull2double(unsigned long long int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double int2double(int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double uint2double(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double float2double(float a, enum cudaRoundMode mode = cudaRoundNearest);
# 1195 "/usr/local/cuda-8.0/include/device_double_functions.h"
# 1 "/usr/local/cuda-8.0/include/device_double_functions.hpp" 1
# 75 "/usr/local/cuda-8.0/include/device_double_functions.hpp"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 76 "/usr/local/cuda-8.0/include/device_double_functions.hpp" 2
# 85 "/usr/local/cuda-8.0/include/device_double_functions.hpp"
static __inline__ __attribute__((device)) double fma(double a, double b, double c, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __fma_rz(a, b, c) :
         mode == cudaRoundPosInf ? __fma_ru(a, b, c) :
         mode == cudaRoundMinInf ? __fma_rd(a, b, c) :
                                   __fma_rn(a, b, c);
}

static __inline__ __attribute__((device)) double dmul(double a, double b, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __dmul_rz(a, b) :
         mode == cudaRoundPosInf ? __dmul_ru(a, b) :
         mode == cudaRoundMinInf ? __dmul_rd(a, b) :
                                   __dmul_rn(a, b);
}

static __inline__ __attribute__((device)) double dadd(double a, double b, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __dadd_rz(a, b) :
         mode == cudaRoundPosInf ? __dadd_ru(a, b) :
         mode == cudaRoundMinInf ? __dadd_rd(a, b) :
                                   __dadd_rn(a, b);
}

static __inline__ __attribute__((device)) double dsub(double a, double b, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __dsub_rz(a, b) :
         mode == cudaRoundPosInf ? __dsub_ru(a, b) :
         mode == cudaRoundMinInf ? __dsub_rd(a, b) :
                                   __dsub_rn(a, b);
}

static __inline__ __attribute__((device)) int double2int(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2int_rn(a) :
         mode == cudaRoundPosInf ? __double2int_ru(a) :
         mode == cudaRoundMinInf ? __double2int_rd(a) :
                                    __double2int_rz(a);
}

static __inline__ __attribute__((device)) unsigned int double2uint(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2uint_rn(a) :
         mode == cudaRoundPosInf ? __double2uint_ru(a) :
         mode == cudaRoundMinInf ? __double2uint_rd(a) :
                                    __double2uint_rz(a);
}

static __inline__ __attribute__((device)) long long int double2ll(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2ll_rn(a) :
         mode == cudaRoundPosInf ? __double2ll_ru(a) :
         mode == cudaRoundMinInf ? __double2ll_rd(a) :
                                    __double2ll_rz(a);
}

static __inline__ __attribute__((device)) unsigned long long int double2ull(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2ull_rn(a) :
         mode == cudaRoundPosInf ? __double2ull_ru(a) :
         mode == cudaRoundMinInf ? __double2ull_rd(a) :
                                    __double2ull_rz(a);
}

static __inline__ __attribute__((device)) double ll2double(long long int a, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __ll2double_rz(a) :
         mode == cudaRoundPosInf ? __ll2double_ru(a) :
         mode == cudaRoundMinInf ? __ll2double_rd(a) :
                                   __ll2double_rn(a);
}

static __inline__ __attribute__((device)) double ull2double(unsigned long long int a, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __ull2double_rz(a) :
         mode == cudaRoundPosInf ? __ull2double_ru(a) :
         mode == cudaRoundMinInf ? __ull2double_rd(a) :
                                   __ull2double_rn(a);
}

static __inline__ __attribute__((device)) double int2double(int a, enum cudaRoundMode mode)
{
  return (double)a;
}

static __inline__ __attribute__((device)) double uint2double(unsigned int a, enum cudaRoundMode mode)
{
  return (double)a;
}

static __inline__ __attribute__((device)) double float2double(float a, enum cudaRoundMode mode)
{
  return (double)a;
}
# 1196 "/usr/local/cuda-8.0/include/device_double_functions.h" 2
# 4516 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/sm_20_atomic_functions.h" 1
# 67 "/usr/local/cuda-8.0/include/sm_20_atomic_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 68 "/usr/local/cuda-8.0/include/sm_20_atomic_functions.h" 2
# 94 "/usr/local/cuda-8.0/include/sm_20_atomic_functions.h"
static __inline__ __attribute__((device)) float atomicAdd(float *address, float val) { }
# 4517 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/sm_32_atomic_functions.h" 1
# 69 "/usr/local/cuda-8.0/include/sm_32_atomic_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 70 "/usr/local/cuda-8.0/include/sm_32_atomic_functions.h" 2
# 102 "/usr/local/cuda-8.0/include/sm_32_atomic_functions.h"
static __inline__ __attribute__((device)) long long atomicMin(long long *address, long long val) { }

static __inline__ __attribute__((device)) long long atomicMax(long long *address, long long val) { }

static __inline__ __attribute__((device)) unsigned long long atomicMin(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device)) unsigned long long atomicMax(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device)) unsigned long long atomicAnd(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device)) unsigned long long atomicOr(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device)) unsigned long long atomicXor(unsigned long long *address, unsigned long long val) { }
# 4518 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/sm_35_atomic_functions.h" 1
# 4519 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/sm_60_atomic_functions.h" 1
# 70 "/usr/local/cuda-8.0/include/sm_60_atomic_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 71 "/usr/local/cuda-8.0/include/sm_60_atomic_functions.h" 2
# 308 "/usr/local/cuda-8.0/include/sm_60_atomic_functions.h"
static __inline__ __attribute__((device)) double atomicAdd(double *address, double val) { }

static __inline__ __attribute__((device))
int atomicAdd_block(int *address, int val) { }

static __inline__ __attribute__((device))
int atomicAdd_system(int *address, int val) { }

static __inline__ __attribute__((device))
unsigned int atomicAdd_block(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicAdd_system(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned long long atomicAdd_block(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
unsigned long long atomicAdd_system(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
float atomicAdd_block(float *address, float val) { }

static __inline__ __attribute__((device))
float atomicAdd_system(float *address, float val) { }

static __inline__ __attribute__((device))
double atomicAdd_block(double *address, double val) { }

static __inline__ __attribute__((device))
double atomicAdd_system(double *address, double val) { }

static __inline__ __attribute__((device))
int atomicExch_block(int *address, int val) { }

static __inline__ __attribute__((device))
int atomicExch_system(int *address, int val) { }

static __inline__ __attribute__((device))
unsigned int atomicExch_block(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicExch_system(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned long long atomicExch_block(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
unsigned long long atomicExch_system(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
float atomicExch_block(float *address, float val) { }

static __inline__ __attribute__((device))
float atomicExch_system(float *address, float val) { }

static __inline__ __attribute__((device))
int atomicMin_block(int *address, int val) { }

static __inline__ __attribute__((device))
int atomicMin_system(int *address, int val) { }

static __inline__ __attribute__((device))
long long atomicMin_block(long long *address, long long val) { }

static __inline__ __attribute__((device))
long long atomicMin_system(long long *address, long long val) { }

static __inline__ __attribute__((device))
unsigned int atomicMin_block(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicMin_system(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned long long atomicMin_block(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
unsigned long long atomicMin_system(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
int atomicMax_block(int *address, int val) { }

static __inline__ __attribute__((device))
int atomicMax_system(int *address, int val) { }

static __inline__ __attribute__((device))
long long atomicMax_block(long long *address, long long val) { }

static __inline__ __attribute__((device))
long long atomicMax_system(long long *address, long long val) { }

static __inline__ __attribute__((device))
unsigned int atomicMax_block(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicMax_system(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned long long atomicMax_block(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
unsigned long long atomicMax_system(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
unsigned int atomicInc_block(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicInc_system(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicDec_block(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicDec_system(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
int atomicCAS_block(int *address, int compare, int val) { }

static __inline__ __attribute__((device))
int atomicCAS_system(int *address, int compare, int val) { }

static __inline__ __attribute__((device))
unsigned int atomicCAS_block(unsigned int *address, unsigned int compare,
                             unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicCAS_system(unsigned int *address, unsigned int compare,
                              unsigned int val) { }

static __inline__ __attribute__((device))
unsigned long long int atomicCAS_block(unsigned long long int *address,
                                       unsigned long long int compare,
                                       unsigned long long int val) { }

static __inline__ __attribute__((device))
unsigned long long int atomicCAS_system(unsigned long long int *address,
                                        unsigned long long int compare,
                                        unsigned long long int val) { }

static __inline__ __attribute__((device))
int atomicAnd_block(int *address, int val) { }

static __inline__ __attribute__((device))
int atomicAnd_system(int *address, int val) { }

static __inline__ __attribute__((device))
long long atomicAnd_block(long long *address, long long val) { }

static __inline__ __attribute__((device))
long long atomicAnd_system(long long *address, long long val) { }

static __inline__ __attribute__((device))
unsigned int atomicAnd_block(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicAnd_system(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned long long atomicAnd_block(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
unsigned long long atomicAnd_system(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
int atomicOr_block(int *address, int val) { }

static __inline__ __attribute__((device))
int atomicOr_system(int *address, int val) { }

static __inline__ __attribute__((device))
long long atomicOr_block(long long *address, long long val) { }

static __inline__ __attribute__((device))
long long atomicOr_system(long long *address, long long val) { }

static __inline__ __attribute__((device))
unsigned int atomicOr_block(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicOr_system(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned long long atomicOr_block(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
unsigned long long atomicOr_system(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
int atomicXor_block(int *address, int val) { }

static __inline__ __attribute__((device))
int atomicXor_system(int *address, int val) { }

static __inline__ __attribute__((device))
long long atomicXor_block(long long *address, long long val) { }

static __inline__ __attribute__((device))
long long atomicXor_system(long long *address, long long val) { }

static __inline__ __attribute__((device))
unsigned int atomicXor_block(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned int atomicXor_system(unsigned int *address, unsigned int val) { }

static __inline__ __attribute__((device))
unsigned long long atomicXor_block(unsigned long long *address, unsigned long long val) { }

static __inline__ __attribute__((device))
unsigned long long atomicXor_system(unsigned long long *address, unsigned long long val) { }
# 4520 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h" 1
# 67 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 68 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h" 2
# 79 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern "C"
{

extern __attribute__((device)) __attribute__((device_builtin)) void __threadfence_system(void);
# 94 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_rn(double x, double y);
# 106 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_rz(double x, double y);
# 118 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_ru(double x, double y);
# 130 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_rd(double x, double y);
# 164 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_rn(double x);
# 198 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_rz(double x);
# 232 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_ru(double x);
# 266 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_rd(double x);
# 298 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_rn(double x);
# 330 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_rz(double x);
# 362 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_ru(double x);
# 394 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_rd(double x);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __ballot(int);
extern __attribute__((device)) __attribute__((device_builtin)) int __syncthreads_count(int);
extern __attribute__((device)) __attribute__((device_builtin)) int __syncthreads_and(int);
extern __attribute__((device)) __attribute__((device_builtin)) int __syncthreads_or(int);
extern __attribute__((device)) __attribute__((device_builtin)) long long int clock64(void);






extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_rn(float, float, float);
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_rz(float, float, float);
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_ru(float, float, float);
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_rd(float, float, float);
# 421 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double_as_longlong(double x);
# 430 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __longlong_as_double(long long int x);
# 587 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rn(double x, double y, double z);
# 744 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rz(double x, double y, double z);
# 901 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_ru(double x, double y, double z);
# 1058 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rd(double x, double y, double z);
# 1070 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rn(double x, double y);
# 1082 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rz(double x, double y);
# 1094 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_ru(double x, double y);
# 1106 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rd(double x, double y);
# 1118 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rn(double x, double y);
# 1130 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rz(double x, double y);
# 1142 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_ru(double x, double y);
# 1154 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rd(double x, double y);
# 1166 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rn(double x, double y);
# 1178 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rz(double x, double y);
# 1190 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_ru(double x, double y);
# 1202 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rd(double x, double y);
# 1211 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rn(double x);
# 1220 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rz(double x);
# 1229 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_ru(double x);
# 1238 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rd(double x);
# 1247 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rn(double x);
# 1256 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_ru(double x);
# 1265 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rd(double x);
# 1274 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rn(double x);
# 1283 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_ru(double x);
# 1292 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rd(double x);
# 1301 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rn(double x);
# 1310 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_ru(double x);
# 1319 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rd(double x);
# 1328 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rn(double x);
# 1337 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_ru(double x);
# 1346 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rd(double x);







extern __attribute__((device)) __attribute__((device_builtin)) double __int2double_rn(int x);







extern __attribute__((device)) __attribute__((device_builtin)) double __uint2double_rn(unsigned int x);
# 1371 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rn(long long int x);
# 1380 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rz(long long int x);
# 1389 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_ru(long long int x);
# 1398 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rd(long long int x);
# 1407 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rn(unsigned long long int x);
# 1416 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rz(unsigned long long int x);
# 1425 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_ru(unsigned long long int x);
# 1434 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rd(unsigned long long int x);
# 1443 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2hiint(double x);
# 1452 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2loint(double x);
# 1462 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __hiloint2double(int hi, int lo);



}
# 1475 "/usr/local/cuda-8.0/include/sm_20_intrinsics.h"
static __inline__ __attribute__((device)) unsigned int ballot(bool pred) { }

static __inline__ __attribute__((device)) int syncthreads_count(bool pred) { }

static __inline__ __attribute__((device)) bool syncthreads_and(bool pred) { }

static __inline__ __attribute__((device)) bool syncthreads_or(bool pred) { }




static __inline__ __attribute__((device)) unsigned int __isGlobal(const void *ptr) { }
# 4521 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/sm_30_intrinsics.h" 1
# 69 "/usr/local/cuda-8.0/include/sm_30_intrinsics.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 70 "/usr/local/cuda-8.0/include/sm_30_intrinsics.h" 2
# 98 "/usr/local/cuda-8.0/include/sm_30_intrinsics.h"
static __attribute__((device)) __inline__ int __shfl(int var, int srcLane, int width=32) { }

static __attribute__((device)) __inline__ unsigned int __shfl(unsigned int var, int srcLane, int width=32) { }

static __attribute__((device)) __inline__ int __shfl_up(int var, unsigned int delta, int width=32) { }
static __attribute__((device)) __inline__ unsigned int __shfl_up(unsigned int var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ int __shfl_down(int var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ unsigned int __shfl_down(unsigned int var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ int __shfl_xor(int var, int laneMask, int width=32) { }

static __attribute__((device)) __inline__ unsigned int __shfl_xor(unsigned int var, int laneMask, int width=32) { }

static __attribute__((device)) __inline__ float __shfl(float var, int srcLane, int width=32) { }

static __attribute__((device)) __inline__ float __shfl_up(float var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ float __shfl_down(float var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ float __shfl_xor(float var, int laneMask, int width=32) { }


static __attribute__((device)) __inline__ long long __shfl(long long var, int srcLane, int width=32) { }

static __attribute__((device)) __inline__ unsigned long long __shfl(unsigned long long var, int srcLane, int width=32) { }

static __attribute__((device)) __inline__ long long __shfl_up(long long var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ unsigned long long __shfl_up(unsigned long long var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ long long __shfl_down(long long var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ unsigned long long __shfl_down(unsigned long long var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ long long __shfl_xor(long long var, int laneMask, int width=32) { }

static __attribute__((device)) __inline__ unsigned long long __shfl_xor(unsigned long long var, int laneMask, int width=32) { }

static __attribute__((device)) __inline__ double __shfl(double var, int srcLane, int width=32) { }

static __attribute__((device)) __inline__ double __shfl_up(double var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ double __shfl_down(double var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ double __shfl_xor(double var, int laneMask, int width=32) { }



static __attribute__((device)) __inline__ long __shfl(long var, int srcLane, int width=32) { }

static __attribute__((device)) __inline__ unsigned long __shfl(unsigned long var, int srcLane, int width=32) { }

static __attribute__((device)) __inline__ long __shfl_up(long var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ unsigned long __shfl_up(unsigned long var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ long __shfl_down(long var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ unsigned long __shfl_down(unsigned long var, unsigned int delta, int width=32) { }

static __attribute__((device)) __inline__ long __shfl_xor(long var, int laneMask, int width=32) { }

static __attribute__((device)) __inline__ unsigned long __shfl_xor(unsigned long var, int laneMask, int width=32) { }
# 4522 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/sm_32_intrinsics.h" 1
# 69 "/usr/local/cuda-8.0/include/sm_32_intrinsics.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 70 "/usr/local/cuda-8.0/include/sm_32_intrinsics.h" 2
# 89 "/usr/local/cuda-8.0/include/sm_32_intrinsics.h"
static __attribute__((device)) __inline__ long __ldg(const long *ptr) { }
static __attribute__((device)) __inline__ unsigned long __ldg(const unsigned long *ptr) { }

static __attribute__((device)) __inline__ char __ldg(const char *ptr) { }
static __attribute__((device)) __inline__ signed char __ldg(const signed char *ptr) { }
static __attribute__((device)) __inline__ short __ldg(const short *ptr) { }
static __attribute__((device)) __inline__ int __ldg(const int *ptr) { }
static __attribute__((device)) __inline__ long long __ldg(const long long *ptr) { }
static __attribute__((device)) __inline__ char2 __ldg(const char2 *ptr) { }
static __attribute__((device)) __inline__ char4 __ldg(const char4 *ptr) { }
static __attribute__((device)) __inline__ short2 __ldg(const short2 *ptr) { }
static __attribute__((device)) __inline__ short4 __ldg(const short4 *ptr) { }
static __attribute__((device)) __inline__ int2 __ldg(const int2 *ptr) { }
static __attribute__((device)) __inline__ int4 __ldg(const int4 *ptr) { }
static __attribute__((device)) __inline__ longlong2 __ldg(const longlong2 *ptr) { }

static __attribute__((device)) __inline__ unsigned char __ldg(const unsigned char *ptr) { }
static __attribute__((device)) __inline__ unsigned short __ldg(const unsigned short *ptr) { }
static __attribute__((device)) __inline__ unsigned int __ldg(const unsigned int *ptr) { }
static __attribute__((device)) __inline__ unsigned long long __ldg(const unsigned long long *ptr) { }
static __attribute__((device)) __inline__ uchar2 __ldg(const uchar2 *ptr) { }
static __attribute__((device)) __inline__ uchar4 __ldg(const uchar4 *ptr) { }
static __attribute__((device)) __inline__ ushort2 __ldg(const ushort2 *ptr) { }
static __attribute__((device)) __inline__ ushort4 __ldg(const ushort4 *ptr) { }
static __attribute__((device)) __inline__ uint2 __ldg(const uint2 *ptr) { }
static __attribute__((device)) __inline__ uint4 __ldg(const uint4 *ptr) { }
static __attribute__((device)) __inline__ ulonglong2 __ldg(const ulonglong2 *ptr) { }

static __attribute__((device)) __inline__ float __ldg(const float *ptr) { }
static __attribute__((device)) __inline__ double __ldg(const double *ptr) { }
static __attribute__((device)) __inline__ float2 __ldg(const float2 *ptr) { }
static __attribute__((device)) __inline__ float4 __ldg(const float4 *ptr) { }
static __attribute__((device)) __inline__ double2 __ldg(const double2 *ptr) { }



static __attribute__((device)) __inline__ long __ldcg(const long *ptr) { }
static __attribute__((device)) __inline__ unsigned long __ldcg(const unsigned long *ptr) { }

static __attribute__((device)) __inline__ char __ldcg(const char *ptr) { }
static __attribute__((device)) __inline__ signed char __ldcg(const signed char *ptr) { }
static __attribute__((device)) __inline__ short __ldcg(const short *ptr) { }
static __attribute__((device)) __inline__ int __ldcg(const int *ptr) { }
static __attribute__((device)) __inline__ long long __ldcg(const long long *ptr) { }
static __attribute__((device)) __inline__ char2 __ldcg(const char2 *ptr) { }
static __attribute__((device)) __inline__ char4 __ldcg(const char4 *ptr) { }
static __attribute__((device)) __inline__ short2 __ldcg(const short2 *ptr) { }
static __attribute__((device)) __inline__ short4 __ldcg(const short4 *ptr) { }
static __attribute__((device)) __inline__ int2 __ldcg(const int2 *ptr) { }
static __attribute__((device)) __inline__ int4 __ldcg(const int4 *ptr) { }
static __attribute__((device)) __inline__ longlong2 __ldcg(const longlong2 *ptr) { }

static __attribute__((device)) __inline__ unsigned char __ldcg(const unsigned char *ptr) { }
static __attribute__((device)) __inline__ unsigned short __ldcg(const unsigned short *ptr) { }
static __attribute__((device)) __inline__ unsigned int __ldcg(const unsigned int *ptr) { }
static __attribute__((device)) __inline__ unsigned long long __ldcg(const unsigned long long *ptr) { }
static __attribute__((device)) __inline__ uchar2 __ldcg(const uchar2 *ptr) { }
static __attribute__((device)) __inline__ uchar4 __ldcg(const uchar4 *ptr) { }
static __attribute__((device)) __inline__ ushort2 __ldcg(const ushort2 *ptr) { }
static __attribute__((device)) __inline__ ushort4 __ldcg(const ushort4 *ptr) { }
static __attribute__((device)) __inline__ uint2 __ldcg(const uint2 *ptr) { }
static __attribute__((device)) __inline__ uint4 __ldcg(const uint4 *ptr) { }
static __attribute__((device)) __inline__ ulonglong2 __ldcg(const ulonglong2 *ptr) { }

static __attribute__((device)) __inline__ float __ldcg(const float *ptr) { }
static __attribute__((device)) __inline__ double __ldcg(const double *ptr) { }
static __attribute__((device)) __inline__ float2 __ldcg(const float2 *ptr) { }
static __attribute__((device)) __inline__ float4 __ldcg(const float4 *ptr) { }
static __attribute__((device)) __inline__ double2 __ldcg(const double2 *ptr) { }



static __attribute__((device)) __inline__ long __ldca(const long *ptr) { }
static __attribute__((device)) __inline__ unsigned long __ldca(const unsigned long *ptr) { }

static __attribute__((device)) __inline__ char __ldca(const char *ptr) { }
static __attribute__((device)) __inline__ signed char __ldca(const signed char *ptr) { }
static __attribute__((device)) __inline__ short __ldca(const short *ptr) { }
static __attribute__((device)) __inline__ int __ldca(const int *ptr) { }
static __attribute__((device)) __inline__ long long __ldca(const long long *ptr) { }
static __attribute__((device)) __inline__ char2 __ldca(const char2 *ptr) { }
static __attribute__((device)) __inline__ char4 __ldca(const char4 *ptr) { }
static __attribute__((device)) __inline__ short2 __ldca(const short2 *ptr) { }
static __attribute__((device)) __inline__ short4 __ldca(const short4 *ptr) { }
static __attribute__((device)) __inline__ int2 __ldca(const int2 *ptr) { }
static __attribute__((device)) __inline__ int4 __ldca(const int4 *ptr) { }
static __attribute__((device)) __inline__ longlong2 __ldca(const longlong2 *ptr) { }

static __attribute__((device)) __inline__ unsigned char __ldca(const unsigned char *ptr) { }
static __attribute__((device)) __inline__ unsigned short __ldca(const unsigned short *ptr) { }
static __attribute__((device)) __inline__ unsigned int __ldca(const unsigned int *ptr) { }
static __attribute__((device)) __inline__ unsigned long long __ldca(const unsigned long long *ptr) { }
static __attribute__((device)) __inline__ uchar2 __ldca(const uchar2 *ptr) { }
static __attribute__((device)) __inline__ uchar4 __ldca(const uchar4 *ptr) { }
static __attribute__((device)) __inline__ ushort2 __ldca(const ushort2 *ptr) { }
static __attribute__((device)) __inline__ ushort4 __ldca(const ushort4 *ptr) { }
static __attribute__((device)) __inline__ uint2 __ldca(const uint2 *ptr) { }
static __attribute__((device)) __inline__ uint4 __ldca(const uint4 *ptr) { }
static __attribute__((device)) __inline__ ulonglong2 __ldca(const ulonglong2 *ptr) { }

static __attribute__((device)) __inline__ float __ldca(const float *ptr) { }
static __attribute__((device)) __inline__ double __ldca(const double *ptr) { }
static __attribute__((device)) __inline__ float2 __ldca(const float2 *ptr) { }
static __attribute__((device)) __inline__ float4 __ldca(const float4 *ptr) { }
static __attribute__((device)) __inline__ double2 __ldca(const double2 *ptr) { }



static __attribute__((device)) __inline__ long __ldcs(const long *ptr) { }
static __attribute__((device)) __inline__ unsigned long __ldcs(const unsigned long *ptr) { }

static __attribute__((device)) __inline__ char __ldcs(const char *ptr) { }
static __attribute__((device)) __inline__ signed char __ldcs(const signed char *ptr) { }
static __attribute__((device)) __inline__ short __ldcs(const short *ptr) { }
static __attribute__((device)) __inline__ int __ldcs(const int *ptr) { }
static __attribute__((device)) __inline__ long long __ldcs(const long long *ptr) { }
static __attribute__((device)) __inline__ char2 __ldcs(const char2 *ptr) { }
static __attribute__((device)) __inline__ char4 __ldcs(const char4 *ptr) { }
static __attribute__((device)) __inline__ short2 __ldcs(const short2 *ptr) { }
static __attribute__((device)) __inline__ short4 __ldcs(const short4 *ptr) { }
static __attribute__((device)) __inline__ int2 __ldcs(const int2 *ptr) { }
static __attribute__((device)) __inline__ int4 __ldcs(const int4 *ptr) { }
static __attribute__((device)) __inline__ longlong2 __ldcs(const longlong2 *ptr) { }

static __attribute__((device)) __inline__ unsigned char __ldcs(const unsigned char *ptr) { }
static __attribute__((device)) __inline__ unsigned short __ldcs(const unsigned short *ptr) { }
static __attribute__((device)) __inline__ unsigned int __ldcs(const unsigned int *ptr) { }
static __attribute__((device)) __inline__ unsigned long long __ldcs(const unsigned long long *ptr) { }
static __attribute__((device)) __inline__ uchar2 __ldcs(const uchar2 *ptr) { }
static __attribute__((device)) __inline__ uchar4 __ldcs(const uchar4 *ptr) { }
static __attribute__((device)) __inline__ ushort2 __ldcs(const ushort2 *ptr) { }
static __attribute__((device)) __inline__ ushort4 __ldcs(const ushort4 *ptr) { }
static __attribute__((device)) __inline__ uint2 __ldcs(const uint2 *ptr) { }
static __attribute__((device)) __inline__ uint4 __ldcs(const uint4 *ptr) { }
static __attribute__((device)) __inline__ ulonglong2 __ldcs(const ulonglong2 *ptr) { }

static __attribute__((device)) __inline__ float __ldcs(const float *ptr) { }
static __attribute__((device)) __inline__ double __ldcs(const double *ptr) { }
static __attribute__((device)) __inline__ float2 __ldcs(const float2 *ptr) { }
static __attribute__((device)) __inline__ float4 __ldcs(const float4 *ptr) { }
static __attribute__((device)) __inline__ double2 __ldcs(const double2 *ptr) { }






static __attribute__((device)) __inline__ unsigned int __funnelshift_l(unsigned int lo, unsigned int hi, unsigned int shift) { }
static __attribute__((device)) __inline__ unsigned int __funnelshift_lc(unsigned int lo, unsigned int hi, unsigned int shift) { }


static __attribute__((device)) __inline__ unsigned int __funnelshift_r(unsigned int lo, unsigned int hi, unsigned int shift) { }
static __attribute__((device)) __inline__ unsigned int __funnelshift_rc(unsigned int lo, unsigned int hi, unsigned int shift) { }
# 4523 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/sm_35_intrinsics.h" 1
# 4524 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/sm_61_intrinsics.h" 1
# 69 "/usr/local/cuda-8.0/include/sm_61_intrinsics.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 70 "/usr/local/cuda-8.0/include/sm_61_intrinsics.h" 2
# 91 "/usr/local/cuda-8.0/include/sm_61_intrinsics.h"
static __attribute__((device)) __inline__ int __dp2a_lo(int srcA, int srcB, int c) { }
static __attribute__((device)) __inline__ unsigned int __dp2a_lo(unsigned int srcA, unsigned int srcB, unsigned int c) { }

static __attribute__((device)) __inline__ int __dp2a_lo(short2 srcA, char4 srcB, int c) { }
static __attribute__((device)) __inline__ unsigned int __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned int c) { }

static __attribute__((device)) __inline__ int __dp2a_hi(int srcA, int srcB, int c) { }
static __attribute__((device)) __inline__ unsigned int __dp2a_hi(unsigned int srcA, unsigned int srcB, unsigned int c) { }

static __attribute__((device)) __inline__ int __dp2a_hi(short2 srcA, char4 srcB, int c) { }
static __attribute__((device)) __inline__ unsigned int __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned int c) { }






static __attribute__((device)) __inline__ int __dp4a(int srcA, int srcB, int c) { }
static __attribute__((device)) __inline__ unsigned int __dp4a(unsigned int srcA, unsigned int srcB, unsigned int c) { }

static __attribute__((device)) __inline__ int __dp4a(char4 srcA, char4 srcB, int c) { }
static __attribute__((device)) __inline__ unsigned int __dp4a(uchar4 srcA, uchar4 srcB, unsigned int c) { }
# 4525 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/surface_functions.h" 1
# 68 "/usr/local/cuda-8.0/include/surface_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 69 "/usr/local/cuda-8.0/include/surface_functions.h" 2
# 100 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf1Dread(T *res, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 111 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{







}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf1Dread(T *res, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 260 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 271 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{







}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 422 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 433 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{







}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 582 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 593 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{







}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 768 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 779 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{







}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 919 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 930 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{







}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 1070 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 1081 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{







}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 1232 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 1254 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 1377 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 1399 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 1520 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 1542 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 1666 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
static __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 1688 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
static __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 1822 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
 __attribute__((device)) __inline__ __attribute__((always_inline)) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 1844 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 1958 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 1980 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 2093 "/usr/local/cuda-8.0/include/surface_functions.h"
template<class T>
static __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
# 2115 "/usr/local/cuda-8.0/include/surface_functions.h"
}

template<class T>
static __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{



}
# 4526 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/texture_fetch_functions.h" 1
# 62 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 63 "/usr/local/cuda-8.0/include/texture_fetch_functions.h" 2







template <typename T>
static __attribute__((device)) T tex1Dfetch(texture<T, 0x01, cudaReadModeElementType>, int) { }

template <typename T>
struct __nv_tex_rmnf_ret { };

template <> struct __nv_tex_rmnf_ret<char> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<signed char> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<unsigned char> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<short> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<unsigned short> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<char1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<uchar1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<short1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<ushort1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<char2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<uchar2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<short2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<ushort2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<char4> { typedef float4 type; };
template <> struct __nv_tex_rmnf_ret<uchar4> { typedef float4 type; };
template <> struct __nv_tex_rmnf_ret<short4> { typedef float4 type; };
template <> struct __nv_tex_rmnf_ret<ushort4> { typedef float4 type; };

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1Dfetch(texture<T, 0x01, cudaReadModeNormalizedFloat>, int) { }
# 215 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex1D(texture<T, 0x01, cudaReadModeElementType>, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1D(texture<T, 0x01, cudaReadModeNormalizedFloat>, float) { }
# 345 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex2D(texture<T, 0x02, cudaReadModeElementType>, float, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2D(texture<T, 0x02, cudaReadModeNormalizedFloat>, float, float) { }
# 475 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex1DLayered(texture<T, 0xF1, cudaReadModeElementType>, float, int) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DLayered(texture<T, 0xF1, cudaReadModeNormalizedFloat>, float, int) { }
# 603 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex2DLayered(texture<T, 0xF2, cudaReadModeElementType>, float, float, int) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DLayered(texture<T, 0xF2, cudaReadModeNormalizedFloat>, float, float, int) { }
# 735 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex3D(texture<T, 0x03, cudaReadModeElementType>, float, float, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex3D(texture<T, 0x03, cudaReadModeNormalizedFloat>, float, float, float) { }
# 864 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T texCubemap(texture<T, 0x0C, cudaReadModeElementType>, float, float, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemap(texture<T, 0x0C, cudaReadModeNormalizedFloat>, float, float, float) { }
# 992 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T texCubemapLayered(texture<T, 0xFC, cudaReadModeElementType>, float, float, float, int) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemapLayered(texture<T, 0xFC, cudaReadModeNormalizedFloat>, float, float, float, int) { }
# 1121 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
struct __nv_tex2dgather_ret { };
template <> struct __nv_tex2dgather_ret<char> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<signed char> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char1> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char2> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char3> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char4> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<unsigned char> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar1> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar2> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar3> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar4> { typedef uchar4 type; };

template <> struct __nv_tex2dgather_ret<short> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short1> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short2> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short3> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short4> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<unsigned short> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort1> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort2> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort3> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort4> { typedef ushort4 type; };

template <> struct __nv_tex2dgather_ret<int> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int1> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int2> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int3> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int4> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<unsigned int> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint1> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint2> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint3> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint4> { typedef uint4 type; };

template <> struct __nv_tex2dgather_ret<float> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float1> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float2> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float3> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float4> { typedef float4 type; };

template <typename T>
static __attribute__((device)) typename __nv_tex2dgather_ret<T>::type tex2Dgather(texture<T, 0x02, cudaReadModeElementType>, float, float, int=0) { }

template <typename T>
static __attribute__((device)) float4 tex2Dgather(texture<T, 0x02, cudaReadModeNormalizedFloat>, float, float, int = 0) { }
# 1232 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex1DLod(texture<T, 0x01, cudaReadModeElementType>, float, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DLod(texture<T, 0x01, cudaReadModeNormalizedFloat>, float, float) { }
# 1360 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex2DLod(texture<T, 0x02, cudaReadModeElementType>, float, float, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DLod(texture<T, 0x02, cudaReadModeNormalizedFloat>, float, float, float) { }
# 1484 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex1DLayeredLod(texture<T, 0xF1, cudaReadModeElementType>, float, int, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DLayeredLod(texture<T, 0xF1, cudaReadModeNormalizedFloat>, float, int, float) { }
# 1612 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex2DLayeredLod(texture<T, 0xF2, cudaReadModeElementType>, float, float, int, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DLayeredLod(texture<T, 0xF2, cudaReadModeNormalizedFloat>, float, float, int, float) { }
# 1740 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex3DLod(texture<T, 0x03, cudaReadModeElementType>, float, float, float, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex3DLod(texture<T, 0x03, cudaReadModeNormalizedFloat>, float, float, float, float) { }
# 1868 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T texCubemapLod(texture<T, 0x0C, cudaReadModeElementType>, float, float, float, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemapLod(texture<T, 0x0C, cudaReadModeNormalizedFloat>, float, float, float, float) { }
# 1996 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T texCubemapLayeredLod(texture<T, 0xFC, cudaReadModeElementType>, float, float, float, int, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemapLayeredLod(texture<T, 0xFC, cudaReadModeNormalizedFloat>, float, float, float, int, float) { }
# 2124 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex1DGrad(texture<T, 0x01, cudaReadModeElementType>, float, float, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DGrad(texture<T, 0x01, cudaReadModeNormalizedFloat>, float, float, float) { }
# 2252 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex2DGrad(texture<T, 0x02, cudaReadModeElementType>, float, float, float2, float2) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DGrad(texture<T, 0x02, cudaReadModeNormalizedFloat>, float, float, float2, float2) { }
# 2380 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex1DLayeredGrad(texture<T, 0xF1, cudaReadModeElementType>, float, int, float, float) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DLayeredGrad(texture<T, 0xF1, cudaReadModeNormalizedFloat>, float, int, float, float) { }
# 2509 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex2DLayeredGrad(texture<T, 0xF2, cudaReadModeElementType>, float, float, int, float2, float2) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DLayeredGrad(texture<T, 0xF2, cudaReadModeNormalizedFloat>, float, float, int, float2, float2) { }
# 2637 "/usr/local/cuda-8.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((device)) T tex3DGrad(texture<T, 0x03, cudaReadModeElementType>, float, float, float, float4, float4) { }

template <typename T>
static __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex3DGrad(texture<T, 0x03, cudaReadModeNormalizedFloat>, float, float, float, float4, float4) { }
# 4527 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/texture_indirect_functions.h" 1
# 57 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 58 "/usr/local/cuda-8.0/include/texture_indirect_functions.h" 2
# 67 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void tex1Dfetch(T *, cudaTextureObject_t, int) { }
# 121 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex1Dfetch(cudaTextureObject_t texObject, int x)
{
  T ret;
  tex1Dfetch(&ret, texObject, x);
  return ret;
}







template <typename T>
static __attribute__((device)) void tex1D(T *, cudaTextureObject_t, float) { }
# 190 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex1D(cudaTextureObject_t texObject, float x)
{
  T ret;
  tex1D(&ret, texObject, x);
  return ret;
}
# 205 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void tex2D(T *, cudaTextureObject_t, float, float) { }
# 258 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex2D(cudaTextureObject_t texObject, float x, float y)
{
  T ret;
  tex2D(&ret, texObject, x, y);
  return ret;
}







template <typename T>
static __attribute__((device)) void tex3D(T *, cudaTextureObject_t, float, float, float) { }
# 325 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex3D(cudaTextureObject_t texObject, float x, float y, float z)
{
  T ret;
  tex3D(&ret, texObject, x, y, z);
  return ret;
}
# 340 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void tex1DLayered(T *, cudaTextureObject_t, float, int) { }
# 393 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex1DLayered(cudaTextureObject_t texObject, float x, int layer)
{
  T ret;
  tex1DLayered(&ret, texObject, x, layer);
  return ret;
}
# 408 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void tex2DLayered(T *, cudaTextureObject_t, float, float, int) { }
# 461 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer)
{
  T ret;
  tex2DLayered(&ret, texObject, x, y, layer);
  return ret;
}
# 476 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void texCubemap(T *, cudaTextureObject_t, float, float, float) { }
# 529 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T texCubemap(cudaTextureObject_t texObject, float x, float y, float z)
{
  T ret;
  texCubemap(&ret, texObject, x, y, z);
  return ret;
}
# 544 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void texCubemapLayered(T *, cudaTextureObject_t, float, float, float, int) { }
# 598 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
  T ret;
  texCubemapLayered(&ret, texObject, x, y, z, layer);
  return ret;
}
# 613 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void tex2Dgather(T *, cudaTextureObject_t, float, float, int = 0) { }
# 660 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0)
{
  T ret;
  tex2Dgather(&ret, to, x, y, comp);
  return ret;
}
# 675 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void tex1DLod(T *, cudaTextureObject_t, float, float) { }
# 728 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex1DLod(cudaTextureObject_t texObject, float x, float level)
{
  T ret;
  tex1DLod(&ret, texObject, x, level);
  return ret;
}
# 743 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void tex2DLod(T *, cudaTextureObject_t, float, float, float) { }
# 797 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex2DLod(cudaTextureObject_t texObject, float x, float y, float level)
{
  T ret;
  tex2DLod(&ret, texObject, x, y, level);
  return ret;
}
# 812 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void tex3DLod(T *, cudaTextureObject_t, float, float, float, float) { }
# 865 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{
  T ret;
  tex3DLod(&ret, texObject, x, y, z, level);
  return ret;
}







template <typename T>
static __attribute__((device)) void tex1DLayeredLod(T *, cudaTextureObject_t, float, int, float) { }
# 932 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level)
{
  T ret;
  tex1DLayeredLod(&ret, texObject, x, layer, level);
  return ret;
}
# 947 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) void tex2DLayeredLod(T *, cudaTextureObject_t, float, float, int, float) { }
# 1000 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
  T ret;
  tex2DLayeredLod(&ret, texObject, x, y, layer, level);
  return ret;
}







template <typename T>
static __attribute__((device)) void texCubemapLod(T *, cudaTextureObject_t, float, float, float, float) { }
# 1067 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{
  T ret;
  texCubemapLod(&ret, texObject, x, y, z, level);
  return ret;
}







template <typename T>
static __attribute__((device)) void texCubemapLayeredLod(T *, cudaTextureObject_t, float, float, float, int, float) { }
# 1134 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
  T ret;
  texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level);
  return ret;
}







template <typename T>
static __attribute__((device)) void tex1DGrad(T *, cudaTextureObject_t, float, float, float) { }
# 1202 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
  T ret;
  tex1DGrad(&ret, texObject, x, dPdx, dPdy);
  return ret;
}







template <typename T>
static __attribute__((device)) void tex2DGrad(T *, cudaTextureObject_t, float, float, float2, float2) { }
# 1269 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
  T ret;
  tex2DGrad(&ret, texObject, x, y, dPdx, dPdy);
  return ret;
}







template <typename T>
static __attribute__((device)) void tex3DGrad(T *, cudaTextureObject_t, float, float, float, float4, float4) { }
# 1336 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  T ret;
  tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy);
  return ret;
}







template <typename T>
static __attribute__((device)) void tex1DLayeredGrad(T *, cudaTextureObject_t, float, int, float, float) { }
# 1404 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
  T ret;
  tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy);
  return ret;
}







template <typename T>
static __attribute__((device)) void tex2DLayeredGrad(T *, cudaTextureObject_t, float, float, int, float2, float2) { }
# 1471 "/usr/local/cuda-8.0/include/texture_indirect_functions.h"
template <class T>
static __attribute__((device)) T tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  T ret;
  tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy);
  return ret;
}
# 4528 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 1 "/usr/local/cuda-8.0/include/surface_indirect_functions.h" 1
# 57 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
# 1 "/usr/local/cuda-8.0/include/builtin_types.h" 1
# 58 "/usr/local/cuda-8.0/include/surface_indirect_functions.h" 2
# 68 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <typename T>
static __attribute__((device)) void surf1Dread(T *, cudaSurfaceObject_t, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 111 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <class T>
static __attribute__((device)) T surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{





}
# 128 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <typename T>
static __attribute__((device)) void surf2Dread(T *, cudaSurfaceObject_t, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 172 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <class T>
static __attribute__((device)) T surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{





}
# 189 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <typename T>
static __attribute__((device)) void surf3Dread(T *, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 231 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <class T>
static __attribute__((device)) T surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{





}







template <typename T>
static __attribute__((device)) void surf1DLayeredread(T *, cudaSurfaceObject_t, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 290 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <class T>
static __attribute__((device)) T surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{





}







template <typename T>
static __attribute__((device)) void surf2DLayeredread(T *, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 348 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <class T>
static __attribute__((device)) T surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{





}







template <typename T>
static __attribute__((device)) void surfCubemapread(T *, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 406 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <class T>
static __attribute__((device)) T surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{





}







template <typename T>
static __attribute__((device)) void surfCubemapLayeredread(T *, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 464 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <class T>
static __attribute__((device)) T surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{





}







template <typename T>
static __attribute__((device)) void surf1Dwrite(T, cudaSurfaceObject_t, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 528 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <typename T>
static __attribute__((device)) void surf2Dwrite(T, cudaSurfaceObject_t, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 576 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <typename T>
static __attribute__((device)) void surf3Dwrite(T, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 626 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <typename T>
static __attribute__((device)) void surf1DLayeredwrite(T, cudaSurfaceObject_t, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 675 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <typename T>
static __attribute__((device)) void surf2DLayeredwrite(T, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 723 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <typename T>
static __attribute__((device)) void surfCubemapwrite(T, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 771 "/usr/local/cuda-8.0/include/surface_indirect_functions.h"
template <typename T>
static __attribute__((device)) void surfCubemapLayeredwrite(T, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) { }
# 4529 "/usr/local/cuda-8.0/include/device_functions.h" 2
# 120 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-8.0/include/device_launch_parameters.h" 1
# 68 "/usr/local/cuda-8.0/include/device_launch_parameters.h"
extern "C" {


uint3 __attribute__((device_builtin)) extern const threadIdx;
uint3 __attribute__((device_builtin)) extern const blockIdx;
dim3 __attribute__((device_builtin)) extern const blockDim;
dim3 __attribute__((device_builtin)) extern const gridDim;
int __attribute__((device_builtin)) extern const warpSize;




}
# 121 "/usr/local/cuda-8.0/include/cuda_runtime.h" 2
# 183 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaLaunchKernel(
  const T *func,
  dim3 gridDim,
  dim3 blockDim,
  void **args,
  size_t sharedMem = 0,
  cudaStream_t stream = 0
)
{
    return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream);
}
# 221 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaSetupArgument(
  T arg,
  size_t offset
)
{
  return ::cudaSetupArgument((const void*)&arg, sizeof(T), offset);
}
# 260 "/usr/local/cuda-8.0/include/cuda_runtime.h"
static __inline__ __attribute__((host)) cudaError_t cudaEventCreate(
  cudaEvent_t *event,
  unsigned int flags
)
{
  return ::cudaEventCreateWithFlags(event, flags);
}
# 323 "/usr/local/cuda-8.0/include/cuda_runtime.h"
static __inline__ __attribute__((host)) cudaError_t cudaMallocHost(
  void **ptr,
  size_t size,
  unsigned int flags
)
{
  return ::cudaHostAlloc(ptr, size, flags);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaHostAlloc(
  T **ptr,
  size_t size,
  unsigned int flags
)
{
  return ::cudaHostAlloc((void**)(void*)ptr, size, flags);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaHostGetDevicePointer(
  T **pDevice,
  void *pHost,
  unsigned int flags
)
{
  return ::cudaHostGetDevicePointer((void**)(void*)pDevice, pHost, flags);
}
# 449 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMallocManaged(
  T **devPtr,
  size_t size,
  unsigned int flags = 0x01
)
{
  return ::cudaMallocManaged((void**)(void*)devPtr, size, flags);
}
# 528 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaStreamAttachMemAsync(
  cudaStream_t stream,
  T *devPtr,
  size_t length = 0,
  unsigned int flags = 0x04
)
{
  return ::cudaStreamAttachMemAsync(stream, (void*)devPtr, length, flags);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMalloc(
  T **devPtr,
  size_t size
)
{
  return ::cudaMalloc((void**)(void*)devPtr, size);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMallocHost(
  T **ptr,
  size_t size,
  unsigned int flags = 0
)
{
  return cudaMallocHost((void**)(void*)ptr, size, flags);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMallocPitch(
  T **devPtr,
  size_t *pitch,
  size_t width,
  size_t height
)
{
  return ::cudaMallocPitch((void**)(void*)devPtr, pitch, width, height);
}
# 604 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMemcpyToSymbol(
  const T &symbol,
  const void *src,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyHostToDevice
)
{
  return ::cudaMemcpyToSymbol((const void*)&symbol, src, count, offset, kind);
}
# 656 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMemcpyToSymbolAsync(
  const T &symbol,
  const void *src,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyHostToDevice,
        cudaStream_t stream = 0
)
{
  return ::cudaMemcpyToSymbolAsync((const void*)&symbol, src, count, offset, kind, stream);
}
# 702 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMemcpyFromSymbol(
        void *dst,
  const T &symbol,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost
)
{
  return ::cudaMemcpyFromSymbol(dst, (const void*)&symbol, count, offset, kind);
}
# 754 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMemcpyFromSymbolAsync(
        void *dst,
  const T &symbol,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost,
        cudaStream_t stream = 0
)
{
  return ::cudaMemcpyFromSymbolAsync(dst, (const void*)&symbol, count, offset, kind, stream);
}
# 787 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGetSymbolAddress(
        void **devPtr,
  const T &symbol
)
{
  return ::cudaGetSymbolAddress(devPtr, (const void*)&symbol);
}
# 816 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGetSymbolSize(
        size_t *size,
  const T &symbol
)
{
  return ::cudaGetSymbolSize(size, (const void*)&symbol);
}
# 859 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaBindTexture(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
  const struct cudaChannelFormatDesc &desc,
        size_t size = (2147483647 * 2U + 1U)
)
{
  return ::cudaBindTexture(offset, &tex, devPtr, &desc, size);
}
# 904 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaBindTexture(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
        size_t size = (2147483647 * 2U + 1U)
)
{
  return cudaBindTexture(offset, tex, devPtr, tex.channelDesc, size);
}
# 960 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaBindTexture2D(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
  const struct cudaChannelFormatDesc &desc,
  size_t width,
  size_t height,
  size_t pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch);
}
# 1018 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaBindTexture2D(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
  size_t width,
  size_t height,
  size_t pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &tex.channelDesc, width, height, pitch);
}
# 1060 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t array,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindTextureToArray(&tex, array, &desc);
}
# 1098 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindTextureToArray(tex, array, desc) : err;
}
# 1139 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t mipmappedArray,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc);
}
# 1177 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t mipmappedArray
)
{
  struct cudaChannelFormatDesc desc;
  cudaArray_t levelArray;
  cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0);

  if (err != cudaSuccess) {
      return err;
  }
  err = ::cudaGetChannelDesc(&desc, levelArray);

  return err == cudaSuccess ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err;
}
# 1216 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaUnbindTexture(
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaUnbindTexture(&tex);
}
# 1250 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __inline__ __attribute__((host)) cudaError_t cudaGetTextureAlignmentOffset(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaGetTextureAlignmentOffset(offset, &tex);
}
# 1302 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaFuncSetCacheConfig(
  T *func,
  enum cudaFuncCache cacheConfig
)
{
  return ::cudaFuncSetCacheConfig((const void*)func, cacheConfig);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaFuncSetSharedMemConfig(
  T *func,
  enum cudaSharedMemConfig config
)
{
  return ::cudaFuncSetSharedMemConfig((const void*)func, config);
}
# 1347 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(
    int *numBlocks,
    T func,
    int blockSize,
    size_t dynamicSMemSize)
{
    return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void*)func, blockSize, dynamicSMemSize, 0x00);
}
# 1398 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
    int *numBlocks,
    T func,
    int blockSize,
    size_t dynamicSMemSize,
    unsigned int flags)
{
    return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void*)func, blockSize, dynamicSMemSize, flags);
}




class __cudaOccupancyB2DHelper {
  size_t n;
public:
  inline __attribute__((host)) __attribute__((device)) __cudaOccupancyB2DHelper(size_t n_) : n(n_) {}
  inline __attribute__((host)) __attribute__((device)) size_t operator()(int)
  {
      return n;
  }
};
# 1467 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<typename UnaryFunction, class T>
static __inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(
    int *minGridSize,
    int *blockSize,
    T func,
    UnaryFunction blockSizeToDynamicSMemSize,
    int blockSizeLimit = 0,
    unsigned int flags = 0)
{
    cudaError_t status;


    int device;
    struct cudaFuncAttributes attr;


    int maxThreadsPerMultiProcessor;
    int warpSize;
    int devMaxThreadsPerBlock;
    int multiProcessorCount;
    int funcMaxThreadsPerBlock;
    int occupancyLimit;
    int granularity;


    int maxBlockSize = 0;
    int numBlocks = 0;
    int maxOccupancy = 0;


    int blockSizeToTryAligned;
    int blockSizeToTry;
    int blockSizeLimitAligned;
    int occupancyInBlocks;
    int occupancyInThreads;
    size_t dynamicSMemSize;





    if (!minGridSize || !blockSize || !func) {
        return cudaErrorInvalidValue;
    }





    status = ::cudaGetDevice(&device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &maxThreadsPerMultiProcessor,
        cudaDevAttrMaxThreadsPerMultiProcessor,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &warpSize,
        cudaDevAttrWarpSize,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &devMaxThreadsPerBlock,
        cudaDevAttrMaxThreadsPerBlock,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &multiProcessorCount,
        cudaDevAttrMultiProcessorCount,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaFuncGetAttributes(&attr, func);
    if (status != cudaSuccess) {
        return status;
    }

    funcMaxThreadsPerBlock = attr.maxThreadsPerBlock;





    occupancyLimit = maxThreadsPerMultiProcessor;
    granularity = warpSize;

    if (blockSizeLimit == 0) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (devMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (funcMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = funcMaxThreadsPerBlock;
    }

    blockSizeLimitAligned = ((blockSizeLimit + (granularity - 1)) / granularity) * granularity;

    for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) {



        if (blockSizeLimit < blockSizeToTryAligned) {
            blockSizeToTry = blockSizeLimit;
        } else {
            blockSizeToTry = blockSizeToTryAligned;
        }

        dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry);

        status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
            &occupancyInBlocks,
            func,
            blockSizeToTry,
            dynamicSMemSize,
            flags);

        if (status != cudaSuccess) {
            return status;
        }

        occupancyInThreads = blockSizeToTry * occupancyInBlocks;

        if (occupancyInThreads > maxOccupancy) {
            maxBlockSize = blockSizeToTry;
            numBlocks = occupancyInBlocks;
            maxOccupancy = occupancyInThreads;
        }



        if (occupancyLimit == maxOccupancy) {
            break;
        }
    }







    *minGridSize = numBlocks * multiProcessorCount;
    *blockSize = maxBlockSize;

    return status;
}
# 1662 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<typename UnaryFunction, class T>
static __inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSizeVariableSMem(
    int *minGridSize,
    int *blockSize,
    T func,
    UnaryFunction blockSizeToDynamicSMemSize,
    int blockSizeLimit = 0)
{
    return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0x00);
}
# 1707 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSize(
    int *minGridSize,
    int *blockSize,
    T func,
    size_t dynamicSMemSize = 0,
    int blockSizeLimit = 0)
{
  return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit, 0x00);
}
# 1766 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSizeWithFlags(
    int *minGridSize,
    int *blockSize,
    T func,
    size_t dynamicSMemSize = 0,
    int blockSizeLimit = 0,
    unsigned int flags = 0)
{
    return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit, flags);
}
# 1814 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaLaunch(
  T *func
)
{
  return ::cudaLaunch((const void*)func);
}
# 1851 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaFuncGetAttributes(
  struct cudaFuncAttributes *attr,
  T *entry
)
{
  return ::cudaFuncGetAttributes(attr, (const void*)entry);
}
# 1880 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim>
static __inline__ __attribute__((host)) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim> &surf,
  cudaArray_const_t array,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindSurfaceToArray(&surf, array, &desc);
}
# 1909 "/usr/local/cuda-8.0/include/cuda_runtime.h"
template<class T, int dim>
static __inline__ __attribute__((host)) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim> &surf,
  cudaArray_const_t array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindSurfaceToArray(surf, array, desc) : err;
}
# 1930 "/usr/local/cuda-8.0/include/cuda_runtime.h"
#pragma GCC diagnostic pop
# 1 "<command-line>" 2
# 1 "gpu_setup.cu"

# 1 "bench_gtc.h" 1



# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 33 "/usr/include/libio.h" 2 3 4
# 50 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 51 "/usr/include/libio.h" 2 3 4
# 145 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 155 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 178 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 246 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 294 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 303 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 339 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 435 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 465 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 527 "/usr/include/libio.h" 3 4
}
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 934 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio.h" 1 3 4
# 35 "/usr/include/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 935 "/usr/include/stdio.h" 2 3 4
# 943 "/usr/include/stdio.h" 3 4
}
# 5 "bench_gtc.h" 2






# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stdint.h" 2 3 4
# 12 "bench_gtc.h" 2
# 1 "bench_gtc_opt.h" 1
# 13 "bench_gtc.h" 2
# 1 "bench_gtc_port.h" 1
# 14 "bench_gtc.h" 2




typedef int16_t my_int;







typedef float my_real;





typedef double real;
typedef double wreal;
# 66 "bench_gtc.h"
extern real shift_t_comp;
extern real shift_t_comm1;
extern real shift_t_comm2;
extern real charge_t_comp;
extern real charge_t_comp_t1;
extern real charge_t_comm;
extern real charge_t_comm1;
extern real charge_t_comm2;
extern real charge_t_comm3;
extern real grid_t_comm1;
extern real grid_t_comm2;
extern real push_t_comp;

typedef struct {
    int mi;
    int mimax;
    int mgrid;
    int mpsi;
    int mthetamax;
    int mzeta;
    int mzetamax;
    int miinit;
    int holecount;

    int mpsi_loc;
    int m2pi;
    int mumax2;
    real delvperp;

    int istep;
    int ndiag;
    int ntracer;
    int msnap;
    int mstep;
    int mstepall;
    int mmomentsoutput;

    int tstdout;

    int mype;
    int numberpe;

    int mode00;
    int nbound;
    int irun;
    int iload;
    int irk;
    int idiag;
    int ncycle;
    int mtdiag;
    int idiag1;
    int idiag2;
    int mflux;

    int ntracer1;
    int nhybrid;
    int ihybrid;

    int nparam;
    int rng_control;

    int limit_vpara;
    int fixed_Tprofile;

    int mi_total;
    int micell;

    int hole_remove_freq;
    int radial_bin_freq;

    real nonlinear;
    real paranl;
    real a0;
    real a1;
    real a;
    real q0;
    real q1;
    real q2;

    real pi;
    real tstep;
    real kappati;
    real kappate;
    real kappan;

    real flow0;
    real flow1;
    real flow2;
    real ulength;
    real utime;
    real gyroradius;
    real deltar;
    real deltaz;

    real zetamax;
    real zetamin;
    real umax;
    real tite;
    real rc;
    real rw;
    real tauii;
    real qion;
    real qelectron;
    real aion;
    real aelectron;

    real r0;
    real b0;
    real temperature;
    real edensity0;
    real smu_inv;
    real delr;
    real delz;
    real pi2_inv;

} gtc_global_params_t;



typedef struct {
    real *z0;
    real *z1;
    real *z2;
    real *z3;
    real *z4;
    real *z5;

    real *z00;
    real *z01;
    real *z02;
    real *z03;
    real *z04;
    real *z05;



    real *ztmp;
    real *ztmp2;
    int *psi_count;
    int *psi_offsets;
} gtc_particle_data_t;

typedef struct {
  int *point_index;
  my_int *point_index_count;
  my_int *point_index_count_tid;
  my_real *point_vect;

} gtc_aux_particle_point_t;

typedef struct {
    int *kzion;
    int *jtion0;
    int *jtion1;
    real *wzion;
    real *wpion;
    real *wtion0;
    real *wtion1;
    int *kzi;
} gtc_aux_particle_data_t;

typedef struct {
    int mmpsi;
    int *itran;
    int *igrid;
    int *jtp1;
    int *jtp2;

    real *phi00;
    real *phip00;
    real *rtemi;
    real *rden;
    real *qtinv;
    real *pmarki;
    real *zonali;
    real *adum;
    real *adum2;
    real *gradt;
    real *difft;

    real *phi;

    wreal *densityi;
    wreal *densityi_local;

    real *dtemp;
    real *temp;
    wreal *dnitmp;

    real *hfluxpsi;
    real *pfluxpsi;
    real *vdrtmp;
    real *markeri;
    real *pgyro;
    real *tgyro;
    real *dtemper;
    real *heatflux;
    real *phit;

    real *evector;
    real *wtp1;
    real *wtp2;
    real *phisave;
    wreal *recvr;
    wreal *sendl;

    real *sendrsf;
    real *recvlsf;
    real *sendlf;
    real *recvlf;
    real *sendrf;
    real *recvrf;

    real *perr;
    real *ptilde;
    real *phitmp;
    real *phitmps;
    real *dentmp;
    real *den00;

    real *delt;
    int *mtheta;
    real *deltat;
    int *indexp;
    int *nindex;
    real *ring;

    real *drdpa;
    real *diffta;
    int *idx1a;
    int *idx2a;

    int *recvl_index;
    int *recvr_index;

} gtc_field_data_t;

typedef struct {
  int *nmode;
  int *mmode;
# 324 "bench_gtc.h"
  real *scalar_data;
  real *eflux;
  real *rmarker;
  real *dmark;
  real *dden;
  real *rdtemi;
  real *rdteme;

  real *flux_data;
  real *amp_mode;
  real *eigenmode;
  real ptracer[4];
  real eflux_average;
# 362 "bench_gtc.h"
} gtc_diagnosis_data_t;

typedef struct {
    int mype;
    int numberpe;
    int ntoroidal;
    int npartdom;
    int nproc_partd;
    int myrank_partd;
    int nproc_toroidal;
    int myrank_toroidal;
    int left_pe;
    int right_pe;
    int toroidal_domain_location;
    int particle_domain_location;
    int nthreads;

    real *recvbuf;
    int recvbuf_size;
    real *sendbuf;
    int sendbuf_size;
# 391 "bench_gtc.h"
} gtc_particle_decomp_t;

typedef struct {
  int ipsi_remap_in, ipsi_remap_out, igrid_remap_in, igrid_remap_out, nloc_remap;
  int mvpara, mvperp2;
  real deltavpara, deltavperp2;
  int remap_order;
  real *df_phase_space, *f_phase_space, *g_phase_space;
  real *sendl_phase_space, *sendr_phase_space, *recvl_phase_space, *recvr_phase_space;
  int remapping_freq;

  int *ghost_remap_comm_list;
  int *ghost_remap_start;
  int *ghost_remap_end;
  int ghost_remap_comm_num;
  real *ghost_remap_sendrecvbuf;
  int ghost_remap_bufsize;

  int *nghost_remap_comm_list;
  int *nghost_remap_start;
  int *nghost_remap_end;
  int nghost_remap_comm_num;
  real *nghost_remap_sendrecvbuf;
  int nghost_remap_bufsize;

  int *igrid_count;
  int *igrid_offsets;
} gtc_particle_remap_t;

typedef struct {
  int ipsi_nover_in;
  int ipsi_nover_out;
  int ipsi_in;
  int ipsi_out;
  int ipsi_valid_in;
  int ipsi_valid_out;
  int igrid_in;
  int igrid_out;
  int igrid_nover_in;
  int igrid_nover_out;
  int nloc_nover;
  int nloc_over;
  int ipsi_nover_in_radiald;
  int ipsi_nover_out_radiald;
  int igrid_nover_in_radiald;
  int igrid_nover_out_radiald;

  real a_nover_in;
  real a_nover_out;
  real a_valid_in;
  real a_valid_out;
  real rho_max;
  int *ri_pe;
  int *ri_pe2;

  int npe_radiald;
  int nradial_dom;
  int nproc_radiald;
  int myrank_radiald;
  int nproc_radial_partd;
  int myrank_radial_partd;
  int left_radial_pe;
  int right_radial_pe;
  int radial_domain_location;
  int radial_part_domain_location;





  int *ghost_comm_list;
  int *ghost_start;
  int *ghost_end;
  int ghost_comm_num;
  real *ghost_sendrecvbuf;
  int ghost_bufsize;
  int *nghost_comm_list;
  int *nghost_start;
  int *nghost_end;
  int nghost_comm_num;
  real *nghost_sendrecvbuf;
  int nghost_bufsize;
} gtc_radial_decomp_t;

typedef struct {
  int neop, neot, neoz;
  real *maxwell;
  real *tmp, *tmp_loc;
  real *dele, *delm, *marker, *ddum;
  real *dele_loc, *delm_loc, *marker_loc;
} gtc_particle_collision_t;

typedef struct {
    gtc_global_params_t global_params;
    gtc_field_data_t field_data;
    gtc_particle_data_t particle_data;
    gtc_aux_particle_data_t aux_particle_data;
    gtc_diagnosis_data_t diagnosis_data;
    gtc_particle_remap_t particle_remap;
    gtc_particle_collision_t particle_collision;
    gtc_aux_particle_point_t particle_point;
    gtc_radial_decomp_t radial_decomp;

    gtc_particle_decomp_t parallel_decomp;
} gtc_bench_data_t;






int setup(gtc_bench_data_t*);
int chargei(gtc_bench_data_t*);
int chargei_init(gtc_bench_data_t*);

int pushi(gtc_bench_data_t*);
int smooth(int, gtc_bench_data_t*);
int field(gtc_bench_data_t*);
int poisson(int, gtc_bench_data_t*);
int poisson_initial(gtc_bench_data_t *, int mring, int mindex, int *nindex,
        int *indexp, real *ring);





int radial_bin_particles(gtc_bench_data_t*);
int shifti_toroidal(gtc_bench_data_t*);
int shifti_radial(gtc_bench_data_t*);



int restart_read(gtc_bench_data_t*);
int gtc_mem_free(gtc_bench_data_t* gtc_input);
int collision(gtc_bench_data_t* gtc_input);

int restart_write(gtc_bench_data_t* gtc_input);
int sum_plane(gtc_bench_data_t* gtc_input);
int fix_radial_ghosts(gtc_bench_data_t *gtc_input, real *data, int mzeta, int dim);



int calc_moments(gtc_bench_data_t *);

int abs_min_int(int arg1, int arg2) __attribute__((always_inline));
real abs_min_real(real arg1, real arg2) __attribute__((always_inline));


void usage(const char *exec_name);
int read_input_file(char *filename, gtc_global_params_t *params,
      gtc_particle_decomp_t *, gtc_radial_decomp_t *);

int cd_comp_fun(const void *, const void *);

double timer();


# 1 "gtc_kernel_gpu.h" 1





# 1 "bench_gtc.h" 1
# 7 "gtc_kernel_gpu.h" 2

# 1 "/usr/local/cuda-8.0/include/driver_types.h" 1
# 9 "gtc_kernel_gpu.h" 2


 extern "C" {
# 92 "gtc_kernel_gpu.h"
   typedef struct {
     double memtransfer_charge_time;
     double memtransfer_push_time;
     double memtransfer_shift_time;
     double memreset_charge_time;
     double initialization_charge_time;
     double interpolation_charge_time;
     double interpolation_push_point_time;
     double interpolation_push_gyro_time;
     double device_charge_time;
     double device_particle_sort_time;
     double device_particle_bin_time;
     double device_push_time;
     double device_shift_time;
     cudaEvent_t start, stop;
   } gpu_timing_t;

   typedef struct {
     int *d_sort_key;
     int *d_value;
     real *d_aux_zion05;
   } gtc_sort_particle_t;

   typedef struct {
     struct cudaDeviceProp deviceProp;
     int nthreads;
     int d_mimax;
     int d_max_shift_mi;
     int d_extra_mimax;
     int d_nloc_over_cluster;
     int nblocks;
     int charge_mi_per_thread;
     int irk;
     int istep;
     int idiag;
     gpu_timing_t gpu_timing;

     gtc_particle_data_t d_zion;
     gtc_particle_data_t d_auxs_zion;
     gtc_aux_particle_data_t d_aux_zion;
     gtc_aux_particle_point_t d_aux_point;
     gtc_field_data_t d_grid;
     gtc_sort_particle_t d_sort;
     gtc_diagnosis_data_t d_diagnosis;

     gtc_particle_data_t *ptr_d_zion;
     gtc_particle_data_t *ptr_d_auxs_zion;
     gtc_aux_particle_data_t *ptr_d_aux_zion;
     gtc_aux_particle_point_t *ptr_d_aux_point;
     real *ptr_d_zion_shift;
     gtc_field_data_t *ptr_d_grid;
     gtc_diagnosis_data_t *ptr_d_diagnosis;
   } gpu_kernel_args_t;



   typedef struct {
     int key;
     real w1;
     real w2;
     real m1;
     real m2;
   } cd_update_t;

   void gpu_setup(gtc_bench_data_t* gtc_input, gpu_kernel_args_t* gpu_kernel_args);
   void cpy_gtc_data_to_device(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_args);
   void free_gtc_data_on_device(gpu_kernel_args_t* gpu_kernel_input);

   void gpu_charge_init(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input);
   int diagnosis(gtc_bench_data_t*);

   int gpu_chargei(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input);
   int gpu_shifti_toroidal(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input);
   int gpu_shifti_radial(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input);
   int gpu_pushi(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input);
   int gpu_bin_particles(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int shift_direction);

   void call_gpu_charge_kernel(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int idiag);
   void call_gpu_charge_4p_kernel(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int istep, int idiag);

   void call_gpu_push_kernel(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int idiag);
   void call_gpu_push_4p_kernel(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int idiag);
   void call_gpu_bin_particles_kernel(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int shift_direction);

   void call_gpu_shifti_extract_kernel (gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, unsigned int tops[2], real *sends[2], int shift_direction);
   void call_gpu_shifti_append_kernel (gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int mi_append, real *particle_data);

   void print_gpu_timing(gpu_kernel_args_t* gpu_kernel_args);


 }
# 549 "bench_gtc.h" 2
# 3 "gpu_setup.cu" 2
# 1 "./cutil.h" 1
# 37 "./cutil.h"
extern "C" {
# 60 "./cutil.h"
    enum CUTBoolean
    {
        CUTFalse = 0,
        CUTTrue = 1
    };





   
    void
   cutFree( void* ptr);
# 88 "./cutil.h"
   
    void
    cutCheckBankAccess( unsigned int tidx, unsigned int tidy, unsigned int tidz,
                        unsigned int bdimx, unsigned int bdimy,
                        unsigned int bdimz, const char* file, const int line,
                        const char* aname, const int index);







   
    char*
    cutFindFilePath(const char* filename, const char* executablePath);
# 116 "./cutil.h"
   
    CUTBoolean
    cutReadFilef( const char* filename, float** data, unsigned int* len,
                  bool verbose = false);
# 132 "./cutil.h"
   
    CUTBoolean
    cutReadFiled( const char* filename, double** data, unsigned int* len,
                  bool verbose = false);
# 148 "./cutil.h"
   
    CUTBoolean
    cutReadFilei( const char* filename, int** data, unsigned int* len, bool verbose = false);
# 163 "./cutil.h"
   
    CUTBoolean
    cutReadFileui( const char* filename, unsigned int** data,
                   unsigned int* len, bool verbose = false);
# 179 "./cutil.h"
   
    CUTBoolean
    cutReadFileb( const char* filename, char** data, unsigned int* len,
                  bool verbose = false);
# 195 "./cutil.h"
   
    CUTBoolean
    cutReadFileub( const char* filename, unsigned char** data,
                   unsigned int* len, bool verbose = false);
# 209 "./cutil.h"
   
    CUTBoolean
    cutWriteFilef( const char* filename, const float* data, unsigned int len,
                   const float epsilon, bool verbose = false);
# 223 "./cutil.h"
   
    CUTBoolean
    cutWriteFiled( const char* filename, const float* data, unsigned int len,
                   const double epsilon, bool verbose = false);
# 235 "./cutil.h"
   
    CUTBoolean
    cutWriteFilei( const char* filename, const int* data, unsigned int len,
                   bool verbose = false);
# 247 "./cutil.h"
   
    CUTBoolean
    cutWriteFileui( const char* filename,const unsigned int* data,
                    unsigned int len, bool verbose = false);
# 259 "./cutil.h"
   
    CUTBoolean
    cutWriteFileb( const char* filename, const char* data, unsigned int len,
                   bool verbose = false);
# 271 "./cutil.h"
   
    CUTBoolean
    cutWriteFileub( const char* filename,const unsigned char* data,
                    unsigned int len, bool verbose = false);
# 287 "./cutil.h"
   
    CUTBoolean
    cutLoadPGMub( const char* file, unsigned char** data,
                  unsigned int *w,unsigned int *h);
# 300 "./cutil.h"
   
    CUTBoolean
    cutLoadPPMub( const char* file, unsigned char** data,
                  unsigned int *w,unsigned int *h);
# 314 "./cutil.h"
   
    CUTBoolean
    cutLoadPPM4ub( const char* file, unsigned char** data,
                   unsigned int *w,unsigned int *h);
# 330 "./cutil.h"
   
    CUTBoolean
        cutLoadPGMi( const char* file, unsigned int** data,
                     unsigned int* w, unsigned int* h);
# 346 "./cutil.h"
   
    CUTBoolean
        cutLoadPGMs( const char* file, unsigned short** data,
                     unsigned int* w, unsigned int* h);
# 361 "./cutil.h"
   
    CUTBoolean
        cutLoadPGMf( const char* file, float** data,
                     unsigned int* w, unsigned int* h);
# 373 "./cutil.h"
   
    CUTBoolean
        cutSavePGMub( const char* file, unsigned char* data,
                      unsigned int w, unsigned int h);
# 385 "./cutil.h"
   
    CUTBoolean
    cutSavePPMub( const char* file, unsigned char *data,
                unsigned int w, unsigned int h);
# 398 "./cutil.h"
   
    CUTBoolean
    cutSavePPM4ub( const char* file, unsigned char *data,
                   unsigned int w, unsigned int h);
# 410 "./cutil.h"
   
    CUTBoolean
    cutSavePGMi( const char* file, unsigned int* data,
                 unsigned int w, unsigned int h);
# 422 "./cutil.h"
   
    CUTBoolean
    cutSavePGMs( const char* file, unsigned short* data,
                 unsigned int w, unsigned int h);
# 434 "./cutil.h"
   
    CUTBoolean
    cutSavePGMf( const char* file, float* data,
                 unsigned int w, unsigned int h);
# 455 "./cutil.h"
   
    CUTBoolean
    cutCheckCmdLineFlag( const int argc, const char** argv,
                         const char* flag_name);
# 469 "./cutil.h"
   
    CUTBoolean
    cutGetCmdLineArgumenti( const int argc, const char** argv,
                            const char* arg_name, int* val);
# 483 "./cutil.h"
   
    CUTBoolean
    cutGetCmdLineArgumentf( const int argc, const char** argv,
                            const char* arg_name, float* val);
# 497 "./cutil.h"
   
    CUTBoolean
    cutGetCmdLineArgumentstr( const int argc, const char** argv,
                              const char* arg_name, char** val);
# 512 "./cutil.h"
   
    CUTBoolean
    cutGetCmdLineArgumentListstr( const int argc, const char** argv,
                                  const char* arg_name, char** val,
                                  unsigned int* len);
# 526 "./cutil.h"
   
    CUTBoolean
    cutCheckCondition( int val, const char* file, const int line);
# 538 "./cutil.h"
   
    CUTBoolean
    cutComparef( const float* reference, const float* data,
                 const unsigned int len);
# 551 "./cutil.h"
   
    CUTBoolean
    cutComparei( const int* reference, const int* data,
                 const unsigned int len );
# 565 "./cutil.h"
   
    CUTBoolean
    cutCompareuit( const unsigned int* reference, const unsigned int* data,
                const unsigned int len, const float epsilon, const float threshold );
# 578 "./cutil.h"
   
    CUTBoolean
    cutCompareub( const unsigned char* reference, const unsigned char* data,
                  const unsigned int len );
# 593 "./cutil.h"
   
    CUTBoolean
    cutCompareubt( const unsigned char* reference, const unsigned char* data,
                 const unsigned int len, const float epsilon, const float threshold );
# 607 "./cutil.h"
   
    CUTBoolean
    cutCompareube( const unsigned char* reference, const unsigned char* data,
                 const unsigned int len, const float epsilon );
# 621 "./cutil.h"
   
    CUTBoolean
    cutComparefe( const float* reference, const float* data,
                  const unsigned int len, const float epsilon );
# 636 "./cutil.h"
   
    CUTBoolean
    cutComparefet( const float* reference, const float* data,
                 const unsigned int len, const float epsilon, const float threshold );
# 651 "./cutil.h"
   
    CUTBoolean
    cutCompareL2fe( const float* reference, const float* data,
                    const unsigned int len, const float epsilon );
# 666 "./cutil.h"
   
    CUTBoolean
 cutComparePPM( const char *src_file, const char *ref_file, const float epsilon, const float threshold, bool verboseErrors = false );
# 679 "./cutil.h"
   
    CUTBoolean
    cutCreateTimer( unsigned int* name);






   
    CUTBoolean
    cutDeleteTimer( unsigned int name);





   
    CUTBoolean
    cutStartTimer( const unsigned int name);





   
    CUTBoolean
    cutStopTimer( const unsigned int name);





   
    CUTBoolean
    cutResetTimer( const unsigned int name);






   
    float
    cutGetTimerValue( const unsigned int name);
# 732 "./cutil.h"
   
    float
    cutGetAverageTimerValue( const unsigned int name);
# 926 "./cutil.h"
}
# 4 "gpu_setup.cu" 2

__attribute__((device)) gtc_global_params_t params __attribute__((aligned(16)));
__attribute__((device)) __attribute__((constant)) real temp[721] __attribute__((aligned(16)));
__attribute__((device)) __attribute__((constant)) real dtemp[721] __attribute__((aligned(16)));
__attribute__((device)) __attribute__((constant)) real rtemi[721] __attribute__((aligned(16)));

__attribute__((device)) __attribute__((constant)) real qtinv[721] __attribute__((aligned(16)));
__attribute__((device)) __attribute__((constant)) real delt[721] __attribute__((aligned(16)));
__attribute__((device)) __attribute__((constant)) int igrid[721] __attribute__((aligned(16)));
__attribute__((device)) __attribute__((constant)) int mtheta[721] __attribute__((aligned(16)));
__attribute__((device)) __attribute__((constant)) int max_shift_mi __attribute__((aligned(16)));
__attribute__((device)) gtc_radial_decomp_t radial_decomp __attribute__((aligned(16)));


void gpu_timer_start(gpu_kernel_args_t* gpu_kernel_input)
{
  { cudaError err = cudaEventCreate(&gpu_kernel_input->gpu_timing.start); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 20, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaEventCreate(&gpu_kernel_input->gpu_timing.stop); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 21, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaEventRecord(gpu_kernel_input->gpu_timing.start,0); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 22, cudaGetErrorString( err) ); exit(1); } };;
}

float gpu_timer_measure(gpu_kernel_args_t* gpu_kernel_input)
{
  float elapsedTime;
  { cudaError err = cudaEventRecord( gpu_kernel_input->gpu_timing.stop, 0 ); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 28, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaEventSynchronize(gpu_kernel_input->gpu_timing.stop); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 29, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaEventElapsedTime( &elapsedTime,gpu_kernel_input->gpu_timing.start,gpu_kernel_input->gpu_timing.stop); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 30, cudaGetErrorString( err) ); exit(1); } };;

  cudaEvent_t temp = gpu_kernel_input->gpu_timing.start;
  gpu_kernel_input->gpu_timing.start = gpu_kernel_input->gpu_timing.stop;
  gpu_kernel_input->gpu_timing.stop = temp;
  return elapsedTime/1000;
}

float gpu_timer_measure_end(gpu_kernel_args_t* gpu_kernel_input)
{
  float elapsedTime;
  { cudaError err = cudaEventRecord( gpu_kernel_input->gpu_timing.stop, 0 ); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 41, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaEventSynchronize(gpu_kernel_input->gpu_timing.stop); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 42, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaEventElapsedTime( &elapsedTime,gpu_kernel_input->gpu_timing.start,gpu_kernel_input->gpu_timing.stop); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 43, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaEventDestroy(gpu_kernel_input->gpu_timing.start); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 44, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaEventDestroy(gpu_kernel_input->gpu_timing.stop); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 45, cudaGetErrorString( err) ); exit(1); } };;
  return elapsedTime/1000;
}
# 71 "gpu_setup.cu"
texture<int2, 1, cudaReadModeElementType> evectorTexRef;



static void allocate_device_data(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_args)
{
  gtc_global_params_t *h_params = &(gtc_input->global_params);
  gtc_radial_decomp_t *h_radial_decomp = &(gtc_input->radial_decomp);

  int d_mimax = gpu_kernel_args->d_mimax;

  int nloc_over = h_radial_decomp->nloc_over;
  int d_extra_mimax = gpu_kernel_args->d_extra_mimax;
  int nloc_over_cluster = gpu_kernel_args->d_nloc_over_cluster;

  int mzeta= h_params->mzeta;

  gtc_field_data_t *d_grid = &(gpu_kernel_args->d_grid);
  gtc_particle_data_t *d_zion = &(gpu_kernel_args->d_zion);
  gtc_diagnosis_data_t *d_diagnosis = &(gpu_kernel_args->d_diagnosis);
  gtc_field_data_t *h_grid = &(gtc_input->field_data);


  { cudaError err = cudaMalloc((void**)&(gpu_kernel_args->ptr_d_zion), sizeof(gtc_particle_data_t)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 94, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMalloc((void**)&(d_zion->z0), 12*d_mimax*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 95, cudaGetErrorString( err) ); exit(1); } };;
  d_zion->z1 = d_zion->z0 + d_mimax;
  d_zion->z2 = d_zion->z0 + 2*d_mimax;
  d_zion->z3 = d_zion->z0 + 3*d_mimax;
  d_zion->z4 = d_zion->z0 + 4*d_mimax;
  d_zion->z5 = d_zion->z0 + 5*d_mimax;
  d_zion->z00 = d_zion->z0 + 6*d_mimax;
  d_zion->z01 = d_zion->z0 + 7*d_mimax;
  d_zion->z02 = d_zion->z0 + 8*d_mimax;
  d_zion->z03 = d_zion->z0 + 9*d_mimax;
  d_zion->z04 = d_zion->z0 + 10*d_mimax;
  d_zion->z05 = d_zion->z0 + 11*d_mimax;



  gtc_particle_data_t *d_auxs_zion = &(gpu_kernel_args->d_auxs_zion);
  { cudaError err = cudaMalloc((void**)&(gpu_kernel_args->ptr_d_auxs_zion), sizeof(gtc_particle_data_t)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 111, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMalloc((void**)&(d_auxs_zion->z0), 12* (d_mimax)*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 112, cudaGetErrorString( err) ); exit(1); } };;
  d_auxs_zion->z1 = d_auxs_zion->z0 + d_mimax;
  d_auxs_zion->z2 = d_auxs_zion->z0 + 2*d_mimax;
  d_auxs_zion->z3 = d_auxs_zion->z0 + 3*d_mimax;
  d_auxs_zion->z4 = d_auxs_zion->z0 + 4*d_mimax;
  d_auxs_zion->z5 = d_auxs_zion->z0 + 5*d_mimax;
  d_auxs_zion->z00 = d_auxs_zion->z0 + 6*d_mimax;
  d_auxs_zion->z01 = d_auxs_zion->z0 + 7*d_mimax;
  d_auxs_zion->z02 = d_auxs_zion->z0 + 8*d_mimax;
  d_auxs_zion->z03 = d_auxs_zion->z0 + 9*d_mimax;
  d_auxs_zion->z04 = d_auxs_zion->z0 + 10*d_mimax;
  d_auxs_zion->z05 = d_auxs_zion->z0 + 11*d_mimax;
# 174 "gpu_setup.cu"
  gtc_sort_particle_t *d_sort = &(gpu_kernel_args->d_sort);
  { cudaError err = cudaMalloc((void**)&(d_sort->d_sort_key), 2*d_mimax*sizeof(int)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 175, cudaGetErrorString( err) ); exit(1); } };;
  d_sort->d_value = d_sort->d_sort_key + d_mimax;
  { cudaError err = cudaMalloc((void**)&(d_sort->d_aux_zion05), d_mimax*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 177, cudaGetErrorString( err) ); exit(1); } };;





  { cudaError err = cudaMalloc((void**)&(gpu_kernel_args->ptr_d_diagnosis), sizeof(gtc_diagnosis_data_t)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 183, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMalloc((void**)&(d_diagnosis->scalar_data), 16*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 184, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMalloc((void**)&(d_diagnosis->flux_data), 5*4*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 185, cudaGetErrorString( err) ); exit(1); } };;







  { cudaError err = cudaMalloc((void**)&(gpu_kernel_args->ptr_d_grid), sizeof(gtc_field_data_t)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 193, cudaGetErrorString( err) ); exit(1); } };;

  { cudaError err = cudaMalloc((void**)&(d_grid->pgyro), 2*4*nloc_over*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 195, cudaGetErrorString( err) ); exit(1); } };;
  d_grid->tgyro = d_grid->pgyro + 4*nloc_over;

  { cudaError err = cudaMalloc((void**)&(d_grid->evector), nloc_over*3*(mzeta+1)*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 198, cudaGetErrorString( err) ); exit(1); } };;


  d_grid->densityi = d_grid->evector;
  { cudaError err = cudaMalloc((void**)&(d_grid->pfluxpsi), 5*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 202, cudaGetErrorString( err) ); exit(1); } };;

}

extern "C"
void free_gtc_data_on_device(gpu_kernel_args_t* gpu_kernel_input)
{
  gtc_particle_data_t *d_zion = &(gpu_kernel_input->d_zion);
  gtc_field_data_t *d_grid = &(gpu_kernel_input->d_grid);
  gtc_diagnosis_data_t *d_diagnosis = &(gpu_kernel_input->d_diagnosis);

  { cudaError err = cudaFree(gpu_kernel_input->ptr_d_zion); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 213, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaFree(d_zion->z0); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 214, cudaGetErrorString( err) ); exit(1); } };;
# 231 "gpu_setup.cu"
  gtc_particle_data_t *d_auxs_zion = &(gpu_kernel_input->d_auxs_zion);
  { cudaError err = cudaFree(gpu_kernel_input->ptr_d_auxs_zion); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 232, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaFree(d_auxs_zion->z0); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 233, cudaGetErrorString( err) ); exit(1); } };;
# 247 "gpu_setup.cu"
  gtc_sort_particle_t *d_sort = &(gpu_kernel_input->d_sort);
  { cudaError err = cudaFree(d_sort->d_sort_key); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 248, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaFree(d_sort->d_aux_zion05); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 249, cudaGetErrorString( err) ); exit(1); } };;




  { cudaError err = cudaFree(gpu_kernel_input->ptr_d_diagnosis); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 254, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaFree(d_diagnosis->scalar_data); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 255, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaFree(d_diagnosis->flux_data); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 256, cudaGetErrorString( err) ); exit(1); } };;





  { cudaError err = cudaFree(gpu_kernel_input->ptr_d_grid); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 262, cudaGetErrorString( err) ); exit(1); } };;

  { cudaError err = cudaFree(d_grid->pgyro); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 264, cudaGetErrorString( err) ); exit(1); } };;


  { cudaError err = cudaFree(d_grid->evector); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 267, cudaGetErrorString( err) ); exit(1); } };;

  { cudaError err = cudaFree(d_grid->pfluxpsi); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 269, cudaGetErrorString( err) ); exit(1); } };;
}

# 1 "./ptx_custom.cu" 1
 __attribute__((device)) __inline__ __attribute__((always_inline)) int custom_popc(unsigned int x)
{
 int ret;
    asm volatile ("{\n\t"
   ".reg .u32 t1,t2;\n\t"
   "mov.u32 t1,%1;\n\t"
   "popc.b32 t2,t1;\n\t"
   "mov.u32 %0,t2;\n\t"
   "}"
   : "=r"(ret) : "r"(x));
    return ret;
}

 __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int select_gt_u32(unsigned int left, unsigned right)
{

 unsigned int ret;
    asm volatile ("{\n\t"
   ".reg .u32 a,b,c,d;\n\t"
   ".reg .u32 l,r;\n\t"
   ".reg .pred p;\n\t"
   "mov.u32 l,%1;\n\t"
   "mov.u32 r,%2;\n\t"
   "setp.u32.gt p,l,r;\n\t"
   "selp.u32 d,1,0,p;\n\t"
   "mov.u32 %0,d;\n\t"
   "}"
   : "=r"(ret) : "r"(left), "r"(right));
    return ret;
}

 __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int select_eq_u32(unsigned int left, unsigned int right)
{

 unsigned int ret;
    asm ("{\n\t"
   ".reg .u32 d;\n\t"
   ".reg .u32 l,r;\n\t"
   ".reg .pred p;\n\t"
   "mov.u32 l,%1;\n\t"
   "mov.u32 r,%2;\n\t"
   "setp.u32.eq p,l,r;\n\t"
   "selp.u32 d,1,0,p;\n\t"
   "mov.u32 %0,d;\n\t"
   "}"
   : "=r"(ret) : "r"(left), "r"(right));
    return ret;
}


 __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int select_gt_f64(real left, real right)
{

 unsigned int ret;
    asm ("{\n\t"
   ".reg .u32 d;\n\t"
   ".reg .f64 l,r;\n\t"
   ".reg .pred p;\n\t"
   "mov.f64 l,%1;\n\t"
   "mov.f64 r,%2;\n\t"
   "setp.f64.gt p,l,r;\n\t"
   "selp.u32 d,1,0,p;\n\t"
   "mov.u32 %0,d;\n\t"
   "}"
   : "=r"(ret) : "d"(left), "d"(right));
    return ret;
}

 __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int select_eq_f64(real left, real right)
{

 unsigned int ret;
    asm volatile ("{\n\t"
   ".reg .u32 a,b,c,d;\n\t"
   ".reg .f64 l,r;\n\t"
   ".reg .pred p;\n\t"
   "mov.f64 l,%1;\n\t"
   "mov.f64 r,%2;\n\t"
   "setp.f64.eq p,l,r;\n\t"
   "selp.u32 d,1,0,p;\n\t"
   "mov.u32 %0,d;\n\t"
   "}"
   : "=r"(ret) : "d"(left), "d"(right));
    return ret;
}


__attribute__((device)) __inline__ __attribute__((always_inline)) int sorting_ballot(int sel, unsigned int count[3], int tidx, int tidy,unsigned int mask)
{
 int keep = (sel==0);
 int left = (sel==1);
 int right = (sel==2);
# 104 "./ptx_custom.cu"
 __attribute__((shared)) unsigned int count_right_low, count_left_low,count_keep_low;
 unsigned int my_left_ballot = ballot(left);
 unsigned int my_right_ballot = ballot(right);
 unsigned int my_keep_ballot = ballot(keep);

 unsigned int my_count_right = custom_popc(my_right_ballot);
 unsigned int my_count_left = custom_popc(my_left_ballot);
 unsigned int my_count_keep = custom_popc(my_keep_ballot);
 int my_before_ballot = mask&(left*my_left_ballot+right*my_right_ballot+keep*my_keep_ballot);

 int order = custom_popc(my_before_ballot);
 if((tidx==0)&&(tidy==0)) {
  count_right_low = my_count_right;
  count_left_low = my_count_left;
  count_keep_low = my_count_keep;
 }
  __syncthreads();
  order += tidy*(count_right_low*right+count_left_low*left + count_keep_low*keep);

 if((tidx==31)&&(tidy==1)) {
  count[2] = my_count_right + count_right_low;
  count[1] = my_count_left + count_left_low;
  count[0] = my_count_keep + count_keep_low;
 }
 return order;
}
# 138 "./ptx_custom.cu"
enum CacheModifier {
 CG,
 CS,
 CA,
 LU,
 CV,
 WB,
 WT

};
# 160 "./ptx_custom.cu"
template <typename T, CacheModifier CACHE_MODIFIER> struct TunedTexLoad;
# 188 "./ptx_custom.cu"
template <> struct TunedTexLoad<double, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static double Ld(const double* d_ptr) { double val; asm("ld.global.cg.nc.""f64"" %0, [%1];" : "=""d"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<double, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static double Ld(const double* d_ptr) { double val; asm("ld.global.cs.nc.""f64"" %0, [%1];" : "=""d"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<double, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static double Ld(const double* d_ptr) { double val; asm("ld.global.ca.nc.""f64"" %0, [%1];" : "=""d"(val) : "l"(d_ptr)); return val; } };
template <> struct TunedTexLoad<float, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static float Ld(const float* d_ptr) { float val; asm("ld.global.cg.nc.""f32"" %0, [%1];" : "=""f"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<float, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static float Ld(const float* d_ptr) { float val; asm("ld.global.cs.nc.""f32"" %0, [%1];" : "=""f"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<float, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static float Ld(const float* d_ptr) { float val; asm("ld.global.ca.nc.""f32"" %0, [%1];" : "=""f"(val) : "l"(d_ptr)); return val; } };
template <> struct TunedTexLoad<short, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static short Ld(const short* d_ptr) { short val; asm("ld.global.cg.nc.""s16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<short, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static short Ld(const short* d_ptr) { short val; asm("ld.global.cs.nc.""s16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<short, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static short Ld(const short* d_ptr) { short val; asm("ld.global.ca.nc.""s16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); return val; } };
template <> struct TunedTexLoad<int, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static int Ld(const int* d_ptr) { int val; asm("ld.global.cg.nc.""s32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<int, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static int Ld(const int* d_ptr) { int val; asm("ld.global.cs.nc.""s32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<int, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static int Ld(const int* d_ptr) { int val; asm("ld.global.ca.nc.""s32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); return val; } };
template <> struct TunedTexLoad<long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static long Ld(const long* d_ptr) { long val; asm("ld.global.cg.nc.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static long Ld(const long* d_ptr) { long val; asm("ld.global.cs.nc.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<long, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static long Ld(const long* d_ptr) { long val; asm("ld.global.ca.nc.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); return val; } };
template <> struct TunedTexLoad<unsigned short, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static unsigned short Ld(const unsigned short* d_ptr) { unsigned short val; asm("ld.global.cg.nc.""u16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<unsigned short, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static unsigned short Ld(const unsigned short* d_ptr) { unsigned short val; asm("ld.global.cs.nc.""u16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<unsigned short, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static unsigned short Ld(const unsigned short* d_ptr) { unsigned short val; asm("ld.global.ca.nc.""u16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); return val; } };
template <> struct TunedTexLoad<unsigned int, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static unsigned int Ld(const unsigned int* d_ptr) { unsigned int val; asm("ld.global.cg.nc.""u32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<unsigned int, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static unsigned int Ld(const unsigned int* d_ptr) { unsigned int val; asm("ld.global.cs.nc.""u32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<unsigned int, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static unsigned int Ld(const unsigned int* d_ptr) { unsigned int val; asm("ld.global.ca.nc.""u32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); return val; } };
template <> struct TunedTexLoad<unsigned long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static unsigned long Ld(const unsigned long* d_ptr) { unsigned long val; asm("ld.global.cg.nc.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<unsigned long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static unsigned long Ld(const unsigned long* d_ptr) { unsigned long val; asm("ld.global.cs.nc.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); return val; } }; template <> struct TunedTexLoad<unsigned long, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static unsigned long Ld(const unsigned long* d_ptr) { unsigned long val; asm("ld.global.ca.nc.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); return val; } };
# 206 "./ptx_custom.cu"
template <typename T, CacheModifier CACHE_MODIFIER> struct TunedLoad;
# 266 "./ptx_custom.cu"
 template <> struct TunedLoad<short, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(short &val, const short* d_ptr) { asm("ld.global.cg.""s16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<short, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(short &val, const short* d_ptr) { asm("ld.global.cs.""s16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<short, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(short &val, const short* d_ptr) { asm("ld.global.lu.""s16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<short, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(short &val, const short* d_ptr) { asm("ld.global.cv.""s16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<short, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(short &val, const short* d_ptr) { asm("ld.global.ca.""s16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } };
 template <> struct TunedLoad<int, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(int &val, const int* d_ptr) { asm("ld.global.cg.""s32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<int, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(int &val, const int* d_ptr) { asm("ld.global.cs.""s32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<int, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(int &val, const int* d_ptr) { asm("ld.global.lu.""s32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<int, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(int &val, const int* d_ptr) { asm("ld.global.cv.""s32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<int, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(int &val, const int* d_ptr) { asm("ld.global.ca.""s32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } };
 template <> struct TunedLoad<long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long &val, const long* d_ptr) { asm("ld.global.cg.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long &val, const long* d_ptr) { asm("ld.global.cs.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<long, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long &val, const long* d_ptr) { asm("ld.global.lu.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<long, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long &val, const long* d_ptr) { asm("ld.global.cv.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<long, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long &val, const long* d_ptr) { asm("ld.global.ca.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } };
 template <> struct TunedLoad<long long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long long &val, const long long* d_ptr) { asm("ld.global.cg.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<long long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long long &val, const long long* d_ptr) { asm("ld.global.cs.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<long long, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long long &val, const long long* d_ptr) { asm("ld.global.lu.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<long long, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long long &val, const long long* d_ptr) { asm("ld.global.cv.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<long long, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(long long &val, const long long* d_ptr) { asm("ld.global.ca.""s64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } };

 template <> struct TunedLoad<unsigned short, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned short &val, const unsigned short* d_ptr) { asm("ld.global.cg.""u16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned short, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned short &val, const unsigned short* d_ptr) { asm("ld.global.cs.""u16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned short, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned short &val, const unsigned short* d_ptr) { asm("ld.global.lu.""u16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned short, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned short &val, const unsigned short* d_ptr) { asm("ld.global.cv.""u16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned short, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned short &val, const unsigned short* d_ptr) { asm("ld.global.ca.""u16"" %0, [%1];" : "=""h"(val) : "l"(d_ptr)); } };
 template <> struct TunedLoad<unsigned int, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned int &val, const unsigned int* d_ptr) { asm("ld.global.cg.""u32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned int, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned int &val, const unsigned int* d_ptr) { asm("ld.global.cs.""u32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned int, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned int &val, const unsigned int* d_ptr) { asm("ld.global.lu.""u32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned int, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned int &val, const unsigned int* d_ptr) { asm("ld.global.cv.""u32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned int, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned int &val, const unsigned int* d_ptr) { asm("ld.global.ca.""u32"" %0, [%1];" : "=""r"(val) : "l"(d_ptr)); } };
 template <> struct TunedLoad<unsigned long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long &val, const unsigned long* d_ptr) { asm("ld.global.cg.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long &val, const unsigned long* d_ptr) { asm("ld.global.cs.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned long, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long &val, const unsigned long* d_ptr) { asm("ld.global.lu.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned long, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long &val, const unsigned long* d_ptr) { asm("ld.global.cv.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned long, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long &val, const unsigned long* d_ptr) { asm("ld.global.ca.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } };
 template <> struct TunedLoad<unsigned long long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long long &val, const unsigned long long* d_ptr) { asm("ld.global.cg.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned long long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long long &val, const unsigned long long* d_ptr) { asm("ld.global.cs.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned long long, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long long &val, const unsigned long long* d_ptr) { asm("ld.global.lu.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned long long, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long long &val, const unsigned long long* d_ptr) { asm("ld.global.cv.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<unsigned long long, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(unsigned long long &val, const unsigned long long* d_ptr) { asm("ld.global.ca.""u64"" %0, [%1];" : "=""l"(val) : "l"(d_ptr)); } };
 template <> struct TunedLoad<float, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(float &val, const float* d_ptr) { asm("ld.global.cg.""f32"" %0, [%1];" : "=""f"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<float, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(float &val, const float* d_ptr) { asm("ld.global.cs.""f32"" %0, [%1];" : "=""f"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<float, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(float &val, const float* d_ptr) { asm("ld.global.lu.""f32"" %0, [%1];" : "=""f"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<float, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(float &val, const float* d_ptr) { asm("ld.global.cv.""f32"" %0, [%1];" : "=""f"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<float, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(float &val, const float* d_ptr) { asm("ld.global.ca.""f32"" %0, [%1];" : "=""f"(val) : "l"(d_ptr)); } };
 template <> struct TunedLoad<double, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(double &val, const double* d_ptr) { asm("ld.global.cg.""f64"" %0, [%1];" : "=""d"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<double, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(double &val, const double* d_ptr) { asm("ld.global.cs.""f64"" %0, [%1];" : "=""d"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<double, LU> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(double &val, const double* d_ptr) { asm("ld.global.lu.""f64"" %0, [%1];" : "=""d"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<double, CV> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(double &val, const double* d_ptr) { asm("ld.global.cv.""f64"" %0, [%1];" : "=""d"(val) : "l"(d_ptr)); } }; template <> struct TunedLoad<double, CA> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Ld(double &val, const double* d_ptr) { asm("ld.global.ca.""f64"" %0, [%1];" : "=""d"(val) : "l"(d_ptr)); } };


template <typename T, CacheModifier CACHE_MODIFIER> struct TunedStore;
# 327 "./ptx_custom.cu"
 template <> struct TunedStore<short, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const short &val, short* d_ptr) { asm("st.global.cg.""s16"" [%0], %1;" : : "l"(d_ptr), "h"(val)); } }; template <> struct TunedStore<short, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const short &val, short* d_ptr) { asm("st.global.cs.""s16"" [%0], %1;" : : "l"(d_ptr), "h"(val)); } }; template <> struct TunedStore<short, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const short &val, short* d_ptr) { asm("st.global.wt.""s16"" [%0], %1;" : : "l"(d_ptr), "h"(val)); } }; template <> struct TunedStore<short, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const short &val, short* d_ptr) { asm("st.global.wb.""s16"" [%0], %1;" : : "l"(d_ptr), "h"(val)); } };
 template <> struct TunedStore<int, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const int &val, int* d_ptr) { asm("st.global.cg.""s32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } }; template <> struct TunedStore<int, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const int &val, int* d_ptr) { asm("st.global.cs.""s32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } }; template <> struct TunedStore<int, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const int &val, int* d_ptr) { asm("st.global.wt.""s32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } }; template <> struct TunedStore<int, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const int &val, int* d_ptr) { asm("st.global.wb.""s32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } };
 template <> struct TunedStore<long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const long &val, long* d_ptr) { asm("st.global.cg.""s64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const long &val, long* d_ptr) { asm("st.global.cs.""s64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<long, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const long &val, long* d_ptr) { asm("st.global.wt.""s64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<long, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const long &val, long* d_ptr) { asm("st.global.wb.""s64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } };
 template <> struct TunedStore<long long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const long long &val, long long* d_ptr) { asm("st.global.cg.""s64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<long long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const long long &val, long long* d_ptr) { asm("st.global.cs.""s64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<long long, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const long long &val, long long* d_ptr) { asm("st.global.wt.""s64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<long long, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const long long &val, long long* d_ptr) { asm("st.global.wb.""s64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } };

 template <> struct TunedStore<unsigned short, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned short &val, unsigned short* d_ptr) { asm("st.global.cg.""u16"" [%0], %1;" : : "l"(d_ptr), "h"(val)); } }; template <> struct TunedStore<unsigned short, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned short &val, unsigned short* d_ptr) { asm("st.global.cs.""u16"" [%0], %1;" : : "l"(d_ptr), "h"(val)); } }; template <> struct TunedStore<unsigned short, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned short &val, unsigned short* d_ptr) { asm("st.global.wt.""u16"" [%0], %1;" : : "l"(d_ptr), "h"(val)); } }; template <> struct TunedStore<unsigned short, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned short &val, unsigned short* d_ptr) { asm("st.global.wb.""u16"" [%0], %1;" : : "l"(d_ptr), "h"(val)); } };
 template <> struct TunedStore<unsigned int, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned int &val, unsigned int* d_ptr) { asm("st.global.cg.""u32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } }; template <> struct TunedStore<unsigned int, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned int &val, unsigned int* d_ptr) { asm("st.global.cs.""u32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } }; template <> struct TunedStore<unsigned int, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned int &val, unsigned int* d_ptr) { asm("st.global.wt.""u32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } }; template <> struct TunedStore<unsigned int, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned int &val, unsigned int* d_ptr) { asm("st.global.wb.""u32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } };
 template <> struct TunedStore<unsigned long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned long &val, unsigned long* d_ptr) { asm("st.global.cg.""u64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<unsigned long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned long &val, unsigned long* d_ptr) { asm("st.global.cs.""u64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<unsigned long, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned long &val, unsigned long* d_ptr) { asm("st.global.wt.""u64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<unsigned long, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned long &val, unsigned long* d_ptr) { asm("st.global.wb.""u64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } };
 template <> struct TunedStore<unsigned long long, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned long long &val, unsigned long long* d_ptr) { asm("st.global.cg.""u64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<unsigned long long, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned long long &val, unsigned long long* d_ptr) { asm("st.global.cs.""u64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<unsigned long long, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned long long &val, unsigned long long* d_ptr) { asm("st.global.wt.""u64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } }; template <> struct TunedStore<unsigned long long, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const unsigned long long &val, unsigned long long* d_ptr) { asm("st.global.wb.""u64"" [%0], %1;" : : "l"(d_ptr), "l"(val)); } };
 template <> struct TunedStore<float, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const float &val, float* d_ptr) { asm("st.global.cg.""f32"" [%0], %1;" : : "l"(d_ptr), "f"(val)); } }; template <> struct TunedStore<float, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const float &val, float* d_ptr) { asm("st.global.cs.""f32"" [%0], %1;" : : "l"(d_ptr), "f"(val)); } }; template <> struct TunedStore<float, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const float &val, float* d_ptr) { asm("st.global.wt.""f32"" [%0], %1;" : : "l"(d_ptr), "f"(val)); } }; template <> struct TunedStore<float, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const float &val, float* d_ptr) { asm("st.global.wb.""f32"" [%0], %1;" : : "l"(d_ptr), "f"(val)); } };
 template <> struct TunedStore<double, CG> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const double &val, double* d_ptr) { asm("st.global.cg.""f64"" [%0], %1;" : : "l"(d_ptr), "d"(val)); } }; template <> struct TunedStore<double, CS> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const double &val, double* d_ptr) { asm("st.global.cs.""f64"" [%0], %1;" : : "l"(d_ptr), "d"(val)); } }; template <> struct TunedStore<double, WT> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const double &val, double* d_ptr) { asm("st.global.wt.""f64"" [%0], %1;" : : "l"(d_ptr), "d"(val)); } }; template <> struct TunedStore<double, WB> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void St(const double &val, double* d_ptr) { asm("st.global.wb.""f64"" [%0], %1;" : : "l"(d_ptr), "d"(val)); } };
# 346 "./ptx_custom.cu"
__attribute__((device)) __inline__ __attribute__((always_inline)) int popc_instr_b32(unsigned int x) { int ret; asm ("popc.""b32"" %0,%1;\n\t": "=r"(ret) : "r"(x)); return ret; }
__attribute__((device)) __inline__ __attribute__((always_inline)) int popc_instr_b64(unsigned long long x) { int ret; asm ("popc.""b64"" %0,%1;\n\t": "=r"(ret) : "l"(x)); return ret; }
# 357 "./ptx_custom.cu"
__attribute__((device)) __inline__ __attribute__((always_inline)) static void ExtractKeyBits(int bit_start, int num_bits, unsigned int &bits, const unsigned int &source) { asm("bfe.""u32""  %0, %1, %2, %3;" : "=""r"(bits) : "r"(source), "r"(bit_start), "r"(num_bits)); };
__attribute__((device)) __inline__ __attribute__((always_inline)) static void ExtractKeyBits(int bit_start, int num_bits, unsigned long long &bits, const unsigned long long &source) { asm("bfe.""u64""  %0, %1, %2, %3;" : "=""l"(bits) : "l"(source), "r"(bit_start), "r"(num_bits)); };
# 367 "./ptx_custom.cu"
__attribute__((device)) __inline__ __attribute__((always_inline)) void mirror_bitmap(unsigned int &reversed, unsigned int input) { asm("brev.""b32"" %0, %1;" : "=""r"(reversed): "r"(input)); };
__attribute__((device)) __inline__ __attribute__((always_inline)) void mirror_bitmap(unsigned long long &reversed, unsigned long long input) { asm("brev.""b64"" %0, %1;" : "=""l"(reversed): "l"(input)); };
# 381 "./ptx_custom.cu"
enum reductionOp {
 AND, OR, XOR,
 add,
 INC, DEC,
 MIN, MAX
};

template <typename T, reductionOp REDUCTION_OP> struct OptimizedReduction;
# 399 "./ptx_custom.cu"
template <> struct OptimizedReduction<unsigned int, AND> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Barrier(const unsigned int &val, unsigned int* d_ptr) { asm("red.""and"".""b32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } };;
template <> struct OptimizedReduction<unsigned int, OR> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Barrier(const unsigned int &val, unsigned int* d_ptr) { asm("red.""or"".""b32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } };;
template <> struct OptimizedReduction<unsigned int, XOR> { __attribute__((device)) __inline__ __attribute__((always_inline)) static void Barrier(const unsigned int &val, unsigned int* d_ptr) { asm("red.""xor"".""b32"" [%0], %1;" : : "l"(d_ptr), "r"(val)); } };;
# 273 "gpu_setup.cu" 2
# 1 "./gpu_charge_kernel.cu" 1
# 21 "./gpu_charge_kernel.cu"
__attribute__((noinline)) __attribute__((device)) int fixed_d(double d, int exponent)
{
  if (d == 0) return 0L;

  long long *p_d = (long long *)&d;
  long long exp_mask = 0x7FF0000000000000;
  long long significand_mask = 0x000FFFFFFFFFFFFF;
  long long positive_prefix = 0x0010000000000000;
  int r;

  int e = ((*p_d) & exp_mask ) >> 52;
  long long s;
  s = ((*p_d) & significand_mask) | positive_prefix;

  int shift_amt = exponent - e;
  if (shift_amt > 0) s = s >> shift_amt;
  else s = s << (-shift_amt);

  r = *(((int *)&s)+1);
  if ((*p_d) < 0) r = -r;


  return r;
}

__attribute__((noinline)) __attribute__((device)) double fp_d (int s, int e)
{
  int negative = 0;
  double r;
  long long sl;

  if (s == 0) return 0.0;
  else if (s <0) { negative = 1; s=-s;}

  sl = ((long long)s) << 32;
  long long one = 0x0010000000000000;


  if ( sl < one) {
    do {
      sl = sl << 1; e--;

    } while(sl < one);
  }
  else if (sl > one){
    do {
      sl = sl >> 1; e++;

    } while(sl >= one);
    sl = sl<<1; e--;
  }

  long long exp = (long long) e << 52;

  sl = (sl & (~one)) | exp;

  r = *((double *)&sl);
  if (negative) return -r;
  else return r;
}
# 94 "./gpu_charge_kernel.cu"
__attribute__((noinline)) __attribute__((device)) double atomicDPupdate(double *address, double val)
{
  double old = *address, assumed;
  do { assumed = old;
    old = __longlong_as_double( atomicCAS((unsigned long long int*)address,
       __double_as_longlong(assumed),
       __double_as_longlong(val + assumed)));
  } while (assumed != old);
  return old;
}

__attribute__((noinline)) __attribute__((device)) void atomicFPupdate(float *addr,float delta)
{
  float copied;
  float updated;
  int *c_ptr = (int *)&copied, *n_ptr = (int *)&updated;

  do {
    copied = *addr;
    updated = copied + delta;
  } while ( atomicCAS((int *)addr, *c_ptr, *n_ptr) != *c_ptr);

}

__attribute__((device)) inline int d_abs_min_int(int arg1, int arg2) {

  int minval, retval;
  minval = (arg1 < arg2) ? arg1 : arg2;
  retval = (minval > 0) ? minval : 0;
  return retval;
}

__attribute__((device)) inline real d_abs_min_real(real arg1, real arg2) {

  real minval, retval;
  minval = (arg1 < arg2) ? arg1 : arg2;
  retval = (minval > 0) ? minval : 0;
  return retval;
}

__attribute__((device)) inline void swap(int & a, int & b)
{
  int tmp = a;
  a = b;
  b = tmp;
}


__attribute__((global)) static void
__attribute__((launch_bounds(64 , 1)))
  gpu_charge_multi(gtc_field_data_t *grid, gtc_particle_data_t *zion, gtc_aux_particle_data_t *aux_zion, int mi_per_thread){

  const int tid = threadIdx.x;
  const int bid = blockIdx.x;
  const int nblocks = gridDim.x;
  const int nthreads = blockDim.x;
  const int gid = tid + bid*nthreads;
  const int np = nblocks * nthreads;

  const real* __restrict__ zion0; const real* __restrict__ zion1; const real* __restrict__ zion2;
  const real* __restrict__ zion4; const real* __restrict__ zion5;







  const real* __restrict__ pgyro; const real* __restrict__ tgyro;
  int ipjt, idx1;
# 175 "./gpu_charge_kernel.cu"
  real *densityi;






  int mi; real smu_inv; real a0;
  real a1; real delr; real delz; int mpsi;
  real pi2_inv; real zetamin; int mzeta;


  real psitmp, thetatmp, zetatmp, weight, rhoi, rhotmp, rho_max, r, wzt, wz1, wz0;
  int iptmp, ip, jttmp, jt, kk, ii, im, im2, larmor, idx;
  real rdum, wp1, wp0, tflr;
  int j01, j00, jtion0tmp, jtion1tmp, ij1, ij2, mpsi_max;
  real tdumtmp, tdum, tdumtmp2, tdum2, wt10, wt00, wt01, wt11, wtion0tmp, wtion1tmp;
  real r_diff, a_diff;

  int igrid_in, ipsi_in, ipsi_out, nloc_over, ipsi_valid_in, ipsi_valid_out;

  mpsi = params.mpsi;
  a0 = params.a0; a1=params.a1;
  delr = params.delr;
  delz = params.delz;
  smu_inv = params.smu_inv;
  zetamin = params.zetamin; mzeta = params.mzeta;
  pi2_inv = params.pi2_inv;
  mi = params.mi;

  igrid_in = radial_decomp.igrid_in;
  ipsi_in = radial_decomp.ipsi_in;
  ipsi_out = radial_decomp.ipsi_out;
  nloc_over = radial_decomp.nloc_over;
  ipsi_valid_in = radial_decomp.ipsi_valid_in;
  ipsi_valid_out = radial_decomp.ipsi_valid_out;
  rho_max = radial_decomp.rho_max;
# 225 "./gpu_charge_kernel.cu"
  densityi = grid->densityi;

  a_diff = a1-a0;
  mpsi_max = mpsi-1;
# 239 "./gpu_charge_kernel.cu"
  pgyro = grid->pgyro; tgyro = grid->tgyro;


  zion0 = zion->z0; zion1 = zion->z1; zion2 = zion->z2; zion4 = zion->z4;
  zion5 = zion->z5;

  for (int m=gid; m<mi; m+=np){

    psitmp = zion0[m];
    thetatmp = zion1[m];
    zetatmp = zion2[m];
    weight = zion4[m];
    rhoi = zion5[m]*smu_inv;


    r = psitmp;




    iptmp = (int) ((r-a0)*delr+0.5);
    ip = d_abs_min_int(mpsi, iptmp);






    jttmp = (int) (thetatmp*pi2_inv*delt[ip]+0.5);
    jt = d_abs_min_int(mtheta[ip], jttmp);

    wzt = (zetatmp-zetamin)*delz;
    kk = d_abs_min_int(mzeta-1, (int) wzt);
# 280 "./gpu_charge_kernel.cu"
    wz1 = weight * (wzt - (real) kk);
    wz0 = weight - wz1;
    r_diff = r-a0;
# 303 "./gpu_charge_kernel.cu"
    ipjt = igrid[ip]+jt;


    for (larmor = 0; larmor < 4; larmor++) {
# 323 "./gpu_charge_kernel.cu"
      idx1 = larmor + 4*(ipjt-igrid_in);
      rhotmp = rhoi*pgyro[idx1];
      if (fabs(rhotmp)>rho_max) {
 printf("warning: reducing rhoi to %e from %e\n", (rhotmp/fabs(rhotmp))*rho_max/pgyro[idx1
                ], rhotmp);
 rhotmp = (rhotmp/fabs(rhotmp))*rho_max;
 rhoi = rhotmp/pgyro[idx1];
      }
      rdum = delr * d_abs_min_real(a_diff,
     r_diff+rhotmp);
      tflr = thetatmp + rhoi*tgyro[idx1];


      ii = d_abs_min_int(mpsi_max, (int) rdum);




      wp1 = rdum - (real) ii;
      wp0 = 1.0 - wp1;


      im = ii;
      tdumtmp = pi2_inv * (tflr - zetatmp * qtinv[im]) + 10.0;
      tdum = (tdumtmp - (int) tdumtmp) * delt[im];
      j00 = d_abs_min_int(mtheta[im]-1, (int) tdum);
      jtion0tmp = igrid[im] + j00;
      wtion0tmp = tdum - (real) j00;


      im2 = ii + 1;
      tdumtmp2 = pi2_inv * (tflr - zetatmp * qtinv[im2]) + 10.0;
      tdum2 = (tdumtmp2 - (int) tdumtmp2) * delt[im2];
      j01 = d_abs_min_int(mtheta[im2]-1, (int) tdum2);
      jtion1tmp = igrid[im2] + j01;
      wtion1tmp = tdum2 - (real) j01;
# 377 "./gpu_charge_kernel.cu"
      wt10 = wp0 * wtion0tmp;
      wt00 = wp0 - wt10;

      wt11 = wp1 * wtion1tmp;
      wt01 = wp1 - wt11;

      ij1 = kk + (mzeta+1)*(jtion0tmp-igrid_in);

      atomicDPupdate(densityi+ij1, wz0*wt00);
      atomicDPupdate(densityi+ij1+1, wz1*wt00);
      atomicDPupdate(densityi+ij1+mzeta+1, wz0*wt10);
      atomicDPupdate(densityi+ij1+mzeta+2, wz1*wt10);

      ij2 = kk + (mzeta+1)*(jtion1tmp-igrid_in);
      atomicDPupdate(densityi+ij2, wz0*wt01);
      atomicDPupdate(densityi+ij2+1, wz1*wt01);
      atomicDPupdate(densityi+ij2+mzeta+1, wz0*wt11);
      atomicDPupdate(densityi+ij2+mzeta+2, wz1*wt11);

    }
    }
}




__attribute__((global)) static void
__attribute__((launch_bounds(64 , 1)))
  gpu_charge_cooperative (gtc_field_data_t *grid, gtc_particle_data_t *zion,gtc_aux_particle_data_t *aux_zion, int mi_per_thread){

    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nblocks = gridDim.x;
    const int nthreads = blockDim.x;
    const int gid = tid + bid*nthreads;
    const int np = nblocks * nthreads;


    __syncthreads();


    extern __attribute__((shared)) int shared_buffer[];
    int *update_idx = shared_buffer;
    real *update_val = (real *)&shared_buffer[nthreads*4];





    const real* __restrict__ zion0; const real* __restrict__ zion1; const real* __restrict__ zion2;
    const real* __restrict__ zion4; const real*__restrict__ zion5;







    const real* __restrict__ pgyro; const real* __restrict__ tgyro;
    int ipjt, idx1;
# 448 "./gpu_charge_kernel.cu"
    real * __restrict__ densityi;






    int mi; real smu_inv; real a0;
    real a1; real delr; real delz; int mpsi;
    real pi2_inv; real zetamin; int mzeta;


    real psitmp, thetatmp, zetatmp, weight, rhoi, rhotmp, rho_max, r, wzt, wz1, wz0;
    int iptmp, ip, jttmp, jt, kk, ii, im, larmor, idx;
    real rdum, wp1, wp0, tflr;
    int j01, j00, jtion0tmp, jtion1tmp, ij1, ij2, mpsi_max;
    real tdumtmp, tdum, wt10, wt00, wt01, wt11, wtion0tmp, wtion1tmp;
    real r_diff, a_diff;
    int stride;
    int last_gthreads, last_threads, last_block, total_iterations;

    int igrid_in,ipsi_in, ipsi_out;

    mpsi = params.mpsi;
    a0 = params.a0; a1=params.a1;
    delr = params.delr;
    delz = params.delz;
    smu_inv = params.smu_inv;
    zetamin = params.zetamin; mzeta = params.mzeta;
    pi2_inv = params.pi2_inv;
    mi = params.mi;

    igrid_in = radial_decomp.igrid_in;
    ipsi_in = radial_decomp.ipsi_in;
    ipsi_out = radial_decomp.ipsi_out;
    rho_max = radial_decomp.rho_max;
# 494 "./gpu_charge_kernel.cu"
    densityi = grid->densityi;







    a_diff = a1-a0;
    mpsi_max = mpsi-1;
# 514 "./gpu_charge_kernel.cu"
    pgyro = grid->pgyro; tgyro = grid->tgyro;


    zion0 = zion->z0; zion1 = zion->z1; zion2 = zion->z2; zion4 = zion->z4;
    zion5 = zion->z5;

    last_gthreads = mi % (nthreads * nblocks);
    last_threads = last_gthreads % nthreads;
    last_block = last_gthreads / nthreads;
    if (last_threads == 0) last_block--;

    total_iterations = (bid <= last_block) ? mi_per_thread : (mi_per_thread -1);
    stride = nthreads;
    for (int iter=0, m=gid; m<mi; iter++, m+=np) {

      TunedLoad<real,CS>::Ld(psitmp,zion0+m);
      TunedLoad<real,CS>::Ld(thetatmp,zion1+m);
      TunedLoad<real,CS>::Ld(zetatmp,zion2+m);
      TunedLoad<real,CS>::Ld(weight,zion4+m);
      TunedLoad<real,CS>::Ld(rhoi,zion5+m);
      rhoi *= smu_inv;
# 544 "./gpu_charge_kernel.cu"
      r = psitmp;




      iptmp = (int) ((r-a0)*delr+0.5);
      ip = d_abs_min_int(mpsi, iptmp);

      jttmp = (int) (thetatmp*pi2_inv*delt[ip]+0.5);
      jt = d_abs_min_int(mtheta[ip], jttmp);

      wzt = (zetatmp-zetamin)*delz;
      kk = d_abs_min_int(mzeta-1, (int) wzt);







      wz1 = weight * (wzt - (real) kk);
      wz0 = weight - wz1;
      r_diff = r-a0;
# 587 "./gpu_charge_kernel.cu"
      ipjt = igrid[ip]+jt;

      for (larmor = 0; larmor < 4; larmor++) {
# 604 "./gpu_charge_kernel.cu"
        idx1 = larmor + 4*(ipjt-igrid_in);
        rhotmp = rhoi*pgyro[idx1];
        if (fabs(rhotmp)>rho_max) {
          printf("warning: reducing rhoi to %e from %e\n", (rhotmp/fabs(rhotmp))*rho_max/pgyro[idx1], rhoi);
          rhotmp = (rhotmp/fabs(rhotmp))*rho_max;
          rhoi = rhotmp/pgyro[idx1];
        }
        rdum = delr * d_abs_min_real(a_diff,r_diff+rhotmp);
        tflr = thetatmp + rhoi*tgyro[idx1];


 ii = d_abs_min_int(mpsi_max, (int) rdum);






 wp1 = rdum - (real) ii;
 wp0 = 1.0 - wp1;


 im = ii;
 tdumtmp = pi2_inv * (tflr - zetatmp * qtinv[im]) + 10.0;
 tdum = (tdumtmp - (int) tdumtmp) * delt[im];
 j00 = d_abs_min_int(mtheta[im]-1, (int) tdum);
 jtion0tmp = igrid[im] + j00;
 wtion0tmp = tdum - (real) j00;


 im = ii + 1;
 tdumtmp = pi2_inv * (tflr - zetatmp * qtinv[im]) + 10.0;
 tdum = (tdumtmp - (int) tdumtmp) * delt[im];
 j01 = d_abs_min_int(mtheta[im]-1, (int) tdum);
 jtion1tmp = igrid[im] + j01;
 wtion1tmp = tdum - (real) j01;
# 659 "./gpu_charge_kernel.cu"
 wt10 = wp0 * wtion0tmp;
 wt00 = wp0 - wt10;

 wt11 = wp1 * wtion1tmp;
 wt01 = wp1 - wt11;

 ij1 = kk + (mzeta+1)*(jtion0tmp-igrid_in);
# 677 "./gpu_charge_kernel.cu"
 if ((iter == (total_iterations - 1)) && (bid == last_block) && last_threads){

   atomicDPupdate(densityi+ij1, wz0*wt00);
   atomicDPupdate(densityi+ij1+1, wz1*wt00);
   atomicDPupdate(densityi+ij1+mzeta+1, wz0*wt10);
   atomicDPupdate(densityi+ij1+mzeta+2, wz1*wt10);

   ij2 = kk + (mzeta+1)*(jtion1tmp-igrid_in);
   atomicDPupdate(densityi+ij2, wz0*wt01);
   atomicDPupdate(densityi+ij2+1, wz1*wt01);
   atomicDPupdate(densityi+ij2+mzeta+1, wz0*wt11);
   atomicDPupdate(densityi+ij2+mzeta+2, wz1*wt11);

 }
 else {
   update_idx[4*tid]=ij1;
   update_idx[4*tid+1]=ij1+1;
   update_idx[4*tid+2]=ij1+mzeta+1;
   update_idx[4*tid+3]=ij1+mzeta+2;
   update_val[4*tid]= wz0*wt00;
   update_val[4*tid+1]= wz1*wt00;
   update_val[4*tid+2]= wz0*wt10;
   update_val[4*tid+3]= wz1*wt10;
   __syncthreads();

   atomicDPupdate(densityi+update_idx[tid], update_val[tid]);
   atomicDPupdate(densityi+update_idx[stride+tid], update_val[stride+tid]);
   atomicDPupdate(densityi+update_idx[2*stride+tid], update_val[2*stride+tid]);
   atomicDPupdate(densityi+update_idx[3*stride+tid], update_val[3*stride+tid]);

   ij2 = kk + (mzeta+1)*(jtion1tmp-igrid_in);
   update_idx[4*tid]=ij2;
   update_idx[4*tid+1]=ij2+1;
   update_idx[4*tid+2]=ij2+mzeta+1;
   update_idx[4*tid+3]=ij2+mzeta+2;
   update_val[4*tid]= wz0*wt01;
   update_val[4*tid+1]= wz1*wt01;
   update_val[4*tid+2]= wz0*wt11;
   update_val[4*tid+3]= wz1*wt11;
   __syncthreads();

   atomicDPupdate(densityi+update_idx[tid], update_val[tid]);
   atomicDPupdate(densityi+update_idx[stride+tid], update_val[stride+tid]);
   atomicDPupdate(densityi+update_idx[2*stride+tid], update_val[2*stride+tid]);
   atomicDPupdate(densityi+update_idx[3*stride+tid], update_val[3*stride+tid]);
 }

      }
      __syncthreads();

    }
}


__attribute__((global)) static void memreset(real *array, int size) {
  const int tidx = threadIdx.x;
  const int tid = threadIdx.y *blockDim.x + tidx;
  const int bid = blockIdx.x +gridDim.x * blockIdx.y;
  const int nthreads = blockDim.x * blockDim.y;
  const int nblocks = gridDim.x * gridDim.y;
  int step = nthreads * nblocks;
  int i;
  for(i=bid*nthreads;i<size;i+=step)
    array[i+tid] = 0;
}

extern "C"
void call_gpu_charge_kernel (gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int idiag)
{
  int mi_per_thread = gpu_kernel_input->charge_mi_per_thread;
  int nthreads = gpu_kernel_input->nthreads;
  gtc_global_params_t *h_params = &(gtc_input->global_params);
  gtc_field_data_t *d_grid = &(gpu_kernel_input->d_grid);
  gtc_field_data_t *h_grid = &(gtc_input->field_data);
  gtc_radial_decomp_t *h_radial_decomp = &(gtc_input->radial_decomp);

  gpu_timer_start(gpu_kernel_input);
  int mzeta=h_params->mzeta; int nloc_over = h_radial_decomp->nloc_over;
  int mi = h_params->mi;
  int mype = gtc_input->parallel_decomp.mype;

  int mp = gpu_kernel_input->deviceProp.multiProcessorCount;
  int m = (mi + nthreads*mp -1) / (nthreads*mp);
  m = (m + mi_per_thread -1)/ mi_per_thread;
  int nblocks = mp * m;
  mi_per_thread = (mi + nblocks*nthreads -1)/(nblocks*nthreads);

  memreset<<< mp, 512>>>(d_grid->densityi, (mzeta+1)*nloc_over);
  gpu_kernel_input->gpu_timing.memtransfer_charge_time += gpu_timer_measure(gpu_kernel_input);
# 774 "./gpu_charge_kernel.cu"
  int shared_buffer_sz = nthreads*4*(sizeof(int)+sizeof(real));
  gpu_charge_cooperative<<< nblocks, nthreads,shared_buffer_sz>>>(gpu_kernel_input->ptr_d_grid, gpu_kernel_input->ptr_d_zion, gpu_kernel_input->ptr_d_aux_zion, mi_per_thread);





  if (idiag==0) diagnosis(gtc_input);

  cudaError_t lasterror = cudaGetLastError();
  if(lasterror != cudaSuccess)
    printf("Error in launching gpu_charge_ routine: %s\n", cudaGetErrorString(lasterror));
  gpu_kernel_input->gpu_timing.device_charge_time += gpu_timer_measure(gpu_kernel_input);

  { cudaError err = cudaMemcpy((void*)(h_grid->densityi), (d_grid->densityi), (mzeta+1)*nloc_over* sizeof(wreal), cudaMemcpyDeviceToHost); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_charge_kernel.cu", 788, cudaGetErrorString( err) ); exit(1); } };;
  gpu_kernel_input->gpu_timing.memtransfer_charge_time += gpu_timer_measure_end(gpu_kernel_input);
# 828 "./gpu_charge_kernel.cu"
}
# 274 "gpu_setup.cu" 2





# 1 "./gpu_bin_shift.cu" 1
# 1 "/usr/local/cuda-8.0/include/thrust/host_vector.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/host_vector.h"
       

# 1 "/usr/local/cuda-8.0/include/thrust/detail/config.h" 1
# 20 "/usr/local/cuda-8.0/include/thrust/detail/config.h"
       

# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/simple_defines.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/config/simple_defines.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/compiler.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/config/compiler.h"
       



# 1 "/usr/local/cuda-8.0/include/cuda.h" 1
# 59 "/usr/local/cuda-8.0/include/cuda.h"
typedef uint32_t cuuint32_t;
typedef uint64_t cuuint64_t;
# 211 "/usr/local/cuda-8.0/include/cuda.h"
extern "C" {
# 221 "/usr/local/cuda-8.0/include/cuda.h"
typedef unsigned long long CUdeviceptr;






typedef int CUdevice;
typedef struct CUctx_st *CUcontext;
typedef struct CUmod_st *CUmodule;
typedef struct CUfunc_st *CUfunction;
typedef struct CUarray_st *CUarray;
typedef struct CUmipmappedArray_st *CUmipmappedArray;
typedef struct CUtexref_st *CUtexref;
typedef struct CUsurfref_st *CUsurfref;
typedef struct CUevent_st *CUevent;
typedef struct CUstream_st *CUstream;
typedef struct CUgraphicsResource_st *CUgraphicsResource;
typedef unsigned long long CUtexObject;
typedef unsigned long long CUsurfObject;

typedef struct CUuuid_st {
    char bytes[16];
} CUuuid;
# 257 "/usr/local/cuda-8.0/include/cuda.h"
typedef struct CUipcEventHandle_st {
    char reserved[64];
} CUipcEventHandle;




typedef struct CUipcMemHandle_st {
    char reserved[64];
} CUipcMemHandle;




typedef enum CUipcMem_flags_enum {
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 0x1
} CUipcMem_flags;






typedef enum CUmemAttach_flags_enum {
    CU_MEM_ATTACH_GLOBAL = 0x1,
    CU_MEM_ATTACH_HOST = 0x2,
    CU_MEM_ATTACH_SINGLE = 0x4
} CUmemAttach_flags;




typedef enum CUctx_flags_enum {
    CU_CTX_SCHED_AUTO = 0x00,
    CU_CTX_SCHED_SPIN = 0x01,
    CU_CTX_SCHED_YIELD = 0x02,
    CU_CTX_SCHED_BLOCKING_SYNC = 0x04,
    CU_CTX_BLOCKING_SYNC = 0x04,


    CU_CTX_SCHED_MASK = 0x07,
    CU_CTX_MAP_HOST = 0x08,
    CU_CTX_LMEM_RESIZE_TO_MAX = 0x10,
    CU_CTX_FLAGS_MASK = 0x1f
} CUctx_flags;




typedef enum CUstream_flags_enum {
    CU_STREAM_DEFAULT = 0x0,
    CU_STREAM_NON_BLOCKING = 0x1
} CUstream_flags;
# 334 "/usr/local/cuda-8.0/include/cuda.h"
typedef enum CUevent_flags_enum {
    CU_EVENT_DEFAULT = 0x0,
    CU_EVENT_BLOCKING_SYNC = 0x1,
    CU_EVENT_DISABLE_TIMING = 0x2,
    CU_EVENT_INTERPROCESS = 0x4
} CUevent_flags;





typedef enum CUstreamWaitValue_flags_enum {
    CU_STREAM_WAIT_VALUE_GEQ = 0x0,

    CU_STREAM_WAIT_VALUE_EQ = 0x1,
    CU_STREAM_WAIT_VALUE_AND = 0x2,
    CU_STREAM_WAIT_VALUE_FLUSH = 1<<30






} CUstreamWaitValue_flags;




typedef enum CUstreamWriteValue_flags_enum {
    CU_STREAM_WRITE_VALUE_DEFAULT = 0x0,
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 0x1





} CUstreamWriteValue_flags;




typedef enum CUstreamBatchMemOpType_enum {
    CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1,
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = 2,
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3

} CUstreamBatchMemOpType;




typedef union CUstreamBatchMemOpParams_union {
    CUstreamBatchMemOpType operation;
    struct CUstreamMemOpWaitValueParams_st {
        CUstreamBatchMemOpType operation;
        CUdeviceptr address;
        union {
            cuuint32_t value;
            cuuint64_t pad;
        };
        unsigned int flags;
        CUdeviceptr alias;
    } waitValue;
    struct CUstreamMemOpWriteValueParams_st {
        CUstreamBatchMemOpType operation;
        CUdeviceptr address;
        union {
            cuuint32_t value;
            cuuint64_t pad;
        };
        unsigned int flags;
        CUdeviceptr alias;
    } writeValue;
    struct CUstreamMemOpFlushRemoteWritesParams_st {
        CUstreamBatchMemOpType operation;
        unsigned int flags;
    } flushRemoteWrites;
    cuuint64_t pad[6];
} CUstreamBatchMemOpParams;





typedef enum CUoccupancy_flags_enum {
    CU_OCCUPANCY_DEFAULT = 0x0,
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = 0x1
} CUoccupancy_flags;




typedef enum CUarray_format_enum {
    CU_AD_FORMAT_UNSIGNED_INT8 = 0x01,
    CU_AD_FORMAT_UNSIGNED_INT16 = 0x02,
    CU_AD_FORMAT_UNSIGNED_INT32 = 0x03,
    CU_AD_FORMAT_SIGNED_INT8 = 0x08,
    CU_AD_FORMAT_SIGNED_INT16 = 0x09,
    CU_AD_FORMAT_SIGNED_INT32 = 0x0a,
    CU_AD_FORMAT_HALF = 0x10,
    CU_AD_FORMAT_FLOAT = 0x20
} CUarray_format;




typedef enum CUaddress_mode_enum {
    CU_TR_ADDRESS_MODE_WRAP = 0,
    CU_TR_ADDRESS_MODE_CLAMP = 1,
    CU_TR_ADDRESS_MODE_MIRROR = 2,
    CU_TR_ADDRESS_MODE_BORDER = 3
} CUaddress_mode;




typedef enum CUfilter_mode_enum {
    CU_TR_FILTER_MODE_POINT = 0,
    CU_TR_FILTER_MODE_LINEAR = 1
} CUfilter_mode;




typedef enum CUdevice_attribute_enum {
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,
    CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8,
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,
    CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12,
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = 28,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = 29,
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49,
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77,
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86,
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87,
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89,
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90,
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91,
    CU_DEVICE_ATTRIBUTE_MAX
} CUdevice_attribute;




typedef struct CUdevprop_st {
    int maxThreadsPerBlock;
    int maxThreadsDim[3];
    int maxGridSize[3];
    int sharedMemPerBlock;
    int totalConstantMemory;
    int SIMDWidth;
    int memPitch;
    int regsPerBlock;
    int clockRate;
    int textureAlign;
} CUdevprop;




typedef enum CUpointer_attribute_enum {
    CU_POINTER_ATTRIBUTE_CONTEXT = 1,
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
    CU_POINTER_ATTRIBUTE_HOST_POINTER = 4,
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
    CU_POINTER_ATTRIBUTE_BUFFER_ID = 7,
    CU_POINTER_ATTRIBUTE_IS_MANAGED = 8
} CUpointer_attribute;




typedef enum CUfunction_attribute_enum {





    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,






    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,





    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,




    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,




    CU_FUNC_ATTRIBUTE_NUM_REGS = 4,
# 629 "/usr/local/cuda-8.0/include/cuda.h"
    CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,
# 638 "/usr/local/cuda-8.0/include/cuda.h"
    CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,





    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,

    CU_FUNC_ATTRIBUTE_MAX
} CUfunction_attribute;




typedef enum CUfunc_cache_enum {
    CU_FUNC_CACHE_PREFER_NONE = 0x00,
    CU_FUNC_CACHE_PREFER_SHARED = 0x01,
    CU_FUNC_CACHE_PREFER_L1 = 0x02,
    CU_FUNC_CACHE_PREFER_EQUAL = 0x03
} CUfunc_cache;




typedef enum CUsharedconfig_enum {
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = 0x00,
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = 0x01,
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 0x02
} CUsharedconfig;




typedef enum CUmemorytype_enum {
    CU_MEMORYTYPE_HOST = 0x01,
    CU_MEMORYTYPE_DEVICE = 0x02,
    CU_MEMORYTYPE_ARRAY = 0x03,
    CU_MEMORYTYPE_UNIFIED = 0x04
} CUmemorytype;




typedef enum CUcomputemode_enum {
    CU_COMPUTEMODE_DEFAULT = 0,
    CU_COMPUTEMODE_PROHIBITED = 2,
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3
} CUcomputemode;




typedef enum CUmem_advise_enum {
    CU_MEM_ADVISE_SET_READ_MOSTLY = 1,
    CU_MEM_ADVISE_UNSET_READ_MOSTLY = 2,
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION = 3,
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = 4,
    CU_MEM_ADVISE_SET_ACCESSED_BY = 5,
    CU_MEM_ADVISE_UNSET_ACCESSED_BY = 6
} CUmem_advise;

typedef enum CUmem_range_attribute_enum {
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1,
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION = 2,
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY = 3,
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = 4
} CUmem_range_attribute;




typedef enum CUjit_option_enum
{





    CU_JIT_MAX_REGISTERS = 0,
# 731 "/usr/local/cuda-8.0/include/cuda.h"
    CU_JIT_THREADS_PER_BLOCK,







    CU_JIT_WALL_TIME,
# 748 "/usr/local/cuda-8.0/include/cuda.h"
    CU_JIT_INFO_LOG_BUFFER,
# 757 "/usr/local/cuda-8.0/include/cuda.h"
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES,
# 766 "/usr/local/cuda-8.0/include/cuda.h"
    CU_JIT_ERROR_LOG_BUFFER,
# 775 "/usr/local/cuda-8.0/include/cuda.h"
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES,







    CU_JIT_OPTIMIZATION_LEVEL,







    CU_JIT_TARGET_FROM_CUCONTEXT,







    CU_JIT_TARGET,
# 808 "/usr/local/cuda-8.0/include/cuda.h"
    CU_JIT_FALLBACK_STRATEGY,







    CU_JIT_GENERATE_DEBUG_INFO,






    CU_JIT_LOG_VERBOSE,






    CU_JIT_GENERATE_LINE_INFO,







    CU_JIT_CACHE_MODE,




    CU_JIT_NEW_SM3X_OPT,
    CU_JIT_FAST_COMPILE,

    CU_JIT_NUM_OPTIONS

} CUjit_option;




typedef enum CUjit_target_enum
{
    CU_TARGET_COMPUTE_10 = 10,
    CU_TARGET_COMPUTE_11 = 11,
    CU_TARGET_COMPUTE_12 = 12,
    CU_TARGET_COMPUTE_13 = 13,
    CU_TARGET_COMPUTE_20 = 20,
    CU_TARGET_COMPUTE_21 = 21,
    CU_TARGET_COMPUTE_30 = 30,
    CU_TARGET_COMPUTE_32 = 32,
    CU_TARGET_COMPUTE_35 = 35,
    CU_TARGET_COMPUTE_37 = 37,
    CU_TARGET_COMPUTE_50 = 50,
    CU_TARGET_COMPUTE_52 = 52,
    CU_TARGET_COMPUTE_53 = 53,
    CU_TARGET_COMPUTE_60 = 60,
    CU_TARGET_COMPUTE_61 = 61,
    CU_TARGET_COMPUTE_62 = 62
} CUjit_target;




typedef enum CUjit_fallback_enum
{
    CU_PREFER_PTX = 0,

    CU_PREFER_BINARY

} CUjit_fallback;




typedef enum CUjit_cacheMode_enum
{
    CU_JIT_CACHE_OPTION_NONE = 0,
    CU_JIT_CACHE_OPTION_CG,
    CU_JIT_CACHE_OPTION_CA
} CUjit_cacheMode;




typedef enum CUjitInputType_enum
{




    CU_JIT_INPUT_CUBIN = 0,





    CU_JIT_INPUT_PTX,





    CU_JIT_INPUT_FATBINARY,





    CU_JIT_INPUT_OBJECT,





    CU_JIT_INPUT_LIBRARY,

    CU_JIT_NUM_INPUT_TYPES
} CUjitInputType;


typedef struct CUlinkState_st *CUlinkState;





typedef enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE = 0x00,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = 0x01,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 0x02,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 0x04,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 0x08
} CUgraphicsRegisterFlags;




typedef enum CUgraphicsMapResourceFlags_enum {
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = 0x00,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = 0x01,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 0x02
} CUgraphicsMapResourceFlags;




typedef enum CUarray_cubemap_face_enum {
    CU_CUBEMAP_FACE_POSITIVE_X = 0x00,
    CU_CUBEMAP_FACE_NEGATIVE_X = 0x01,
    CU_CUBEMAP_FACE_POSITIVE_Y = 0x02,
    CU_CUBEMAP_FACE_NEGATIVE_Y = 0x03,
    CU_CUBEMAP_FACE_POSITIVE_Z = 0x04,
    CU_CUBEMAP_FACE_NEGATIVE_Z = 0x05
} CUarray_cubemap_face;




typedef enum CUlimit_enum {
    CU_LIMIT_STACK_SIZE = 0x00,
    CU_LIMIT_PRINTF_FIFO_SIZE = 0x01,
    CU_LIMIT_MALLOC_HEAP_SIZE = 0x02,
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = 0x03,
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 0x04,
    CU_LIMIT_MAX
} CUlimit;




typedef enum CUresourcetype_enum {
    CU_RESOURCE_TYPE_ARRAY = 0x00,
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01,
    CU_RESOURCE_TYPE_LINEAR = 0x02,
    CU_RESOURCE_TYPE_PITCH2D = 0x03
} CUresourcetype;




typedef enum cudaError_enum {





    CUDA_SUCCESS = 0,





    CUDA_ERROR_INVALID_VALUE = 1,





    CUDA_ERROR_OUT_OF_MEMORY = 2,





    CUDA_ERROR_NOT_INITIALIZED = 3,




    CUDA_ERROR_DEINITIALIZED = 4,






    CUDA_ERROR_PROFILER_DISABLED = 5,







    CUDA_ERROR_PROFILER_NOT_INITIALIZED = 6,






    CUDA_ERROR_PROFILER_ALREADY_STARTED = 7,






    CUDA_ERROR_PROFILER_ALREADY_STOPPED = 8,





    CUDA_ERROR_NO_DEVICE = 100,





    CUDA_ERROR_INVALID_DEVICE = 101,






    CUDA_ERROR_INVALID_IMAGE = 200,
# 1080 "/usr/local/cuda-8.0/include/cuda.h"
    CUDA_ERROR_INVALID_CONTEXT = 201,
# 1089 "/usr/local/cuda-8.0/include/cuda.h"
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT = 202,




    CUDA_ERROR_MAP_FAILED = 205,




    CUDA_ERROR_UNMAP_FAILED = 206,





    CUDA_ERROR_ARRAY_IS_MAPPED = 207,




    CUDA_ERROR_ALREADY_MAPPED = 208,







    CUDA_ERROR_NO_BINARY_FOR_GPU = 209,




    CUDA_ERROR_ALREADY_ACQUIRED = 210,




    CUDA_ERROR_NOT_MAPPED = 211,





    CUDA_ERROR_NOT_MAPPED_AS_ARRAY = 212,





    CUDA_ERROR_NOT_MAPPED_AS_POINTER = 213,





    CUDA_ERROR_ECC_UNCORRECTABLE = 214,





    CUDA_ERROR_UNSUPPORTED_LIMIT = 215,






    CUDA_ERROR_CONTEXT_ALREADY_IN_USE = 216,





    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = 217,




    CUDA_ERROR_INVALID_PTX = 218,




    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = 219,





    CUDA_ERROR_NVLINK_UNCORRECTABLE = 220,




    CUDA_ERROR_INVALID_SOURCE = 300,




    CUDA_ERROR_FILE_NOT_FOUND = 301,




    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,




    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = 303,




    CUDA_ERROR_OPERATING_SYSTEM = 304,





    CUDA_ERROR_INVALID_HANDLE = 400,





    CUDA_ERROR_NOT_FOUND = 500,







    CUDA_ERROR_NOT_READY = 600,
# 1235 "/usr/local/cuda-8.0/include/cuda.h"
    CUDA_ERROR_ILLEGAL_ADDRESS = 700,
# 1246 "/usr/local/cuda-8.0/include/cuda.h"
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = 701,
# 1257 "/usr/local/cuda-8.0/include/cuda.h"
    CUDA_ERROR_LAUNCH_TIMEOUT = 702,





    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = 703,






    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = 704,






    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = 705,





    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708,






    CUDA_ERROR_CONTEXT_IS_DESTROYED = 709,







    CUDA_ERROR_ASSERT = 710,






    CUDA_ERROR_TOO_MANY_PEERS = 711,





    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,





    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = 713,
# 1326 "/usr/local/cuda-8.0/include/cuda.h"
    CUDA_ERROR_HARDWARE_STACK_ERROR = 714,







    CUDA_ERROR_ILLEGAL_INSTRUCTION = 715,
# 1343 "/usr/local/cuda-8.0/include/cuda.h"
    CUDA_ERROR_MISALIGNED_ADDRESS = 716,
# 1354 "/usr/local/cuda-8.0/include/cuda.h"
    CUDA_ERROR_INVALID_ADDRESS_SPACE = 717,







    CUDA_ERROR_INVALID_PC = 718,
# 1372 "/usr/local/cuda-8.0/include/cuda.h"
    CUDA_ERROR_LAUNCH_FAILED = 719,





    CUDA_ERROR_NOT_PERMITTED = 800,





    CUDA_ERROR_NOT_SUPPORTED = 801,




    CUDA_ERROR_UNKNOWN = 999
} CUresult;




typedef enum CUdevice_P2PAttribute_enum {
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 0x01,
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = 0x02,
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = 0x03
} CUdevice_P2PAttribute;
# 1413 "/usr/local/cuda-8.0/include/cuda.h"
typedef void ( *CUstreamCallback)(CUstream hStream, CUresult status, void *userData);







typedef size_t ( *CUoccupancyB2DSize)(int blockSize);
# 1476 "/usr/local/cuda-8.0/include/cuda.h"
typedef struct CUDA_MEMCPY2D_st {
    size_t srcXInBytes;
    size_t srcY;

    CUmemorytype srcMemoryType;
    const void *srcHost;
    CUdeviceptr srcDevice;
    CUarray srcArray;
    size_t srcPitch;

    size_t dstXInBytes;
    size_t dstY;

    CUmemorytype dstMemoryType;
    void *dstHost;
    CUdeviceptr dstDevice;
    CUarray dstArray;
    size_t dstPitch;

    size_t WidthInBytes;
    size_t Height;
} CUDA_MEMCPY2D;




typedef struct CUDA_MEMCPY3D_st {
    size_t srcXInBytes;
    size_t srcY;
    size_t srcZ;
    size_t srcLOD;
    CUmemorytype srcMemoryType;
    const void *srcHost;
    CUdeviceptr srcDevice;
    CUarray srcArray;
    void *reserved0;
    size_t srcPitch;
    size_t srcHeight;

    size_t dstXInBytes;
    size_t dstY;
    size_t dstZ;
    size_t dstLOD;
    CUmemorytype dstMemoryType;
    void *dstHost;
    CUdeviceptr dstDevice;
    CUarray dstArray;
    void *reserved1;
    size_t dstPitch;
    size_t dstHeight;

    size_t WidthInBytes;
    size_t Height;
    size_t Depth;
} CUDA_MEMCPY3D;




typedef struct CUDA_MEMCPY3D_PEER_st {
    size_t srcXInBytes;
    size_t srcY;
    size_t srcZ;
    size_t srcLOD;
    CUmemorytype srcMemoryType;
    const void *srcHost;
    CUdeviceptr srcDevice;
    CUarray srcArray;
    CUcontext srcContext;
    size_t srcPitch;
    size_t srcHeight;

    size_t dstXInBytes;
    size_t dstY;
    size_t dstZ;
    size_t dstLOD;
    CUmemorytype dstMemoryType;
    void *dstHost;
    CUdeviceptr dstDevice;
    CUarray dstArray;
    CUcontext dstContext;
    size_t dstPitch;
    size_t dstHeight;

    size_t WidthInBytes;
    size_t Height;
    size_t Depth;
} CUDA_MEMCPY3D_PEER;




typedef struct CUDA_ARRAY_DESCRIPTOR_st
{
    size_t Width;
    size_t Height;

    CUarray_format Format;
    unsigned int NumChannels;
} CUDA_ARRAY_DESCRIPTOR;




typedef struct CUDA_ARRAY3D_DESCRIPTOR_st
{
    size_t Width;
    size_t Height;
    size_t Depth;

    CUarray_format Format;
    unsigned int NumChannels;
    unsigned int Flags;
} CUDA_ARRAY3D_DESCRIPTOR;
# 1598 "/usr/local/cuda-8.0/include/cuda.h"
typedef struct CUDA_RESOURCE_DESC_st
{
    CUresourcetype resType;

    union {
        struct {
            CUarray hArray;
        } array;
        struct {
            CUmipmappedArray hMipmappedArray;
        } mipmap;
        struct {
            CUdeviceptr devPtr;
            CUarray_format format;
            unsigned int numChannels;
            size_t sizeInBytes;
        } linear;
        struct {
            CUdeviceptr devPtr;
            CUarray_format format;
            unsigned int numChannels;
            size_t width;
            size_t height;
            size_t pitchInBytes;
        } pitch2D;
        struct {
            int reserved[32];
        } reserved;
    } res;

    unsigned int flags;
} CUDA_RESOURCE_DESC;




typedef struct CUDA_TEXTURE_DESC_st {
    CUaddress_mode addressMode[3];
    CUfilter_mode filterMode;
    unsigned int flags;
    unsigned int maxAnisotropy;
    CUfilter_mode mipmapFilterMode;
    float mipmapLevelBias;
    float minMipmapLevelClamp;
    float maxMipmapLevelClamp;
    float borderColor[4];
    int reserved[12];
} CUDA_TEXTURE_DESC;




typedef enum CUresourceViewFormat_enum
{
    CU_RES_VIEW_FORMAT_NONE = 0x00,
    CU_RES_VIEW_FORMAT_UINT_1X8 = 0x01,
    CU_RES_VIEW_FORMAT_UINT_2X8 = 0x02,
    CU_RES_VIEW_FORMAT_UINT_4X8 = 0x03,
    CU_RES_VIEW_FORMAT_SINT_1X8 = 0x04,
    CU_RES_VIEW_FORMAT_SINT_2X8 = 0x05,
    CU_RES_VIEW_FORMAT_SINT_4X8 = 0x06,
    CU_RES_VIEW_FORMAT_UINT_1X16 = 0x07,
    CU_RES_VIEW_FORMAT_UINT_2X16 = 0x08,
    CU_RES_VIEW_FORMAT_UINT_4X16 = 0x09,
    CU_RES_VIEW_FORMAT_SINT_1X16 = 0x0a,
    CU_RES_VIEW_FORMAT_SINT_2X16 = 0x0b,
    CU_RES_VIEW_FORMAT_SINT_4X16 = 0x0c,
    CU_RES_VIEW_FORMAT_UINT_1X32 = 0x0d,
    CU_RES_VIEW_FORMAT_UINT_2X32 = 0x0e,
    CU_RES_VIEW_FORMAT_UINT_4X32 = 0x0f,
    CU_RES_VIEW_FORMAT_SINT_1X32 = 0x10,
    CU_RES_VIEW_FORMAT_SINT_2X32 = 0x11,
    CU_RES_VIEW_FORMAT_SINT_4X32 = 0x12,
    CU_RES_VIEW_FORMAT_FLOAT_1X16 = 0x13,
    CU_RES_VIEW_FORMAT_FLOAT_2X16 = 0x14,
    CU_RES_VIEW_FORMAT_FLOAT_4X16 = 0x15,
    CU_RES_VIEW_FORMAT_FLOAT_1X32 = 0x16,
    CU_RES_VIEW_FORMAT_FLOAT_2X32 = 0x17,
    CU_RES_VIEW_FORMAT_FLOAT_4X32 = 0x18,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = 0x19,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = 0x1a,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = 0x1b,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = 0x1c,
    CU_RES_VIEW_FORMAT_SIGNED_BC4 = 0x1d,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = 0x1e,
    CU_RES_VIEW_FORMAT_SIGNED_BC5 = 0x1f,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 0x20,
    CU_RES_VIEW_FORMAT_SIGNED_BC6H = 0x21,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = 0x22
} CUresourceViewFormat;




typedef struct CUDA_RESOURCE_VIEW_DESC_st
{
    CUresourceViewFormat format;
    size_t width;
    size_t height;
    size_t depth;
    unsigned int firstMipmapLevel;
    unsigned int lastMipmapLevel;
    unsigned int firstLayer;
    unsigned int lastLayer;
    unsigned int reserved[16];
} CUDA_RESOURCE_VIEW_DESC;




typedef struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    unsigned long long p2pToken;
    unsigned int vaSpaceToken;
} CUDA_POINTER_ATTRIBUTE_P2P_TOKENS;
# 1858 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuGetErrorString(CUresult error, const char **pStr);
# 1877 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuGetErrorName(CUresult error, const char **pStr);
# 1909 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuInit(unsigned int Flags);
# 1939 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDriverGetVersion(int *driverVersion);
# 1979 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceGet(CUdevice *device, int ordinal);
# 2004 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceGetCount(int *count);
# 2032 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceGetName(char *name, int len, CUdevice dev);
# 2059 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceTotalMem_v2(size_t *bytes, CUdevice dev);
# 2254 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceGetAttribute(int *pi, CUdevice_attribute attrib, CUdevice dev);
# 2331 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceGetProperties(CUdevprop *prop, CUdevice dev);
# 2364 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceComputeCapability(int *major, int *minor, CUdevice dev);
# 2432 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDevicePrimaryCtxRetain(CUcontext *pctx, CUdevice dev);
# 2466 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDevicePrimaryCtxRelease(CUdevice dev);
# 2529 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDevicePrimaryCtxSetFlags(CUdevice dev, unsigned int flags);
# 2553 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDevicePrimaryCtxGetState(CUdevice dev, unsigned int *flags, int *active);
# 2591 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDevicePrimaryCtxReset(CUdevice dev);
# 2697 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxCreate_v2(CUcontext *pctx, unsigned int flags, CUdevice dev);
# 2737 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxDestroy_v2(CUcontext ctx);
# 2773 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxPushCurrent_v2(CUcontext ctx);
# 2807 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxPopCurrent_v2(CUcontext *pctx);
# 2833 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxSetCurrent(CUcontext ctx);
# 2852 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxGetCurrent(CUcontext *pctx);
# 2882 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxGetDevice(CUdevice *device);
# 2910 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxGetFlags(unsigned int *flags);
# 2940 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxSynchronize(void);
# 3035 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxSetLimit(CUlimit limit, size_t value);
# 3074 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxGetLimit(size_t *pvalue, CUlimit limit);
# 3117 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxGetCacheConfig(CUfunc_cache *pconfig);
# 3167 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxSetCacheConfig(CUfunc_cache config);
# 3209 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxGetSharedMemConfig(CUsharedconfig *pConfig);
# 3261 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxSetSharedMemConfig(CUsharedconfig config);
# 3299 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxGetApiVersion(CUcontext ctx, unsigned int *version);
# 3338 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxGetStreamPriorityRange(int *leastPriority, int *greatestPriority);
# 3393 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxAttach(CUcontext *pctx, unsigned int flags);
# 3429 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxDetach(CUcontext ctx);
# 3483 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuModuleLoad(CUmodule *module, const char *fname);
# 3519 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuModuleLoadData(CUmodule *module, const void *image);
# 3561 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuModuleLoadDataEx(CUmodule *module, const void *image, unsigned int numOptions, CUjit_option *options, void **optionValues);
# 3602 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuModuleLoadFatBinary(CUmodule *module, const void *fatCubin);
# 3627 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuModuleUnload(CUmodule hmod);
# 3657 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuModuleGetFunction(CUfunction *hfunc, CUmodule hmod, const char *name);
# 3691 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuModuleGetGlobal_v2(CUdeviceptr *dptr, size_t *bytes, CUmodule hmod, const char *name);
# 3725 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuModuleGetTexRef(CUtexref *pTexRef, CUmodule hmod, const char *name);
# 3756 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuModuleGetSurfRef(CUsurfref *pSurfRef, CUmodule hmod, const char *name);
# 3797 "/usr/local/cuda-8.0/include/cuda.h"
CUresult
cuLinkCreate_v2(unsigned int numOptions, CUjit_option *options, void **optionValues, CUlinkState *stateOut);
# 3834 "/usr/local/cuda-8.0/include/cuda.h"
CUresult
cuLinkAddData_v2(CUlinkState state, CUjitInputType type, void *data, size_t size, const char *name,
    unsigned int numOptions, CUjit_option *options, void **optionValues);
# 3873 "/usr/local/cuda-8.0/include/cuda.h"
CUresult
cuLinkAddFile_v2(CUlinkState state, CUjitInputType type, const char *path,
    unsigned int numOptions, CUjit_option *options, void **optionValues);
# 3900 "/usr/local/cuda-8.0/include/cuda.h"
CUresult
cuLinkComplete(CUlinkState state, void **cubinOut, size_t *sizeOut);
# 3914 "/usr/local/cuda-8.0/include/cuda.h"
CUresult
cuLinkDestroy(CUlinkState state);
# 3963 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemGetInfo_v2(size_t *free, size_t *total);
# 3996 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemAlloc_v2(CUdeviceptr *dptr, size_t bytesize);
# 4057 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemAllocPitch_v2(CUdeviceptr *dptr, size_t *pPitch, size_t WidthInBytes, size_t Height, unsigned int ElementSizeBytes);
# 4086 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemFree_v2(CUdeviceptr dptr);
# 4119 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemGetAddressRange_v2(CUdeviceptr *pbase, size_t *psize, CUdeviceptr dptr);
# 4165 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemAllocHost_v2(void **pp, size_t bytesize);
# 4195 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemFreeHost(void *p);
# 4277 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemHostAlloc(void **pp, size_t bytesize, unsigned int Flags);
# 4330 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemHostGetDevicePointer_v2(CUdeviceptr *pdptr, void *p, unsigned int Flags);
# 4355 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemHostGetFlags(unsigned int *pFlags, void *p);
# 4465 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemAllocManaged(CUdeviceptr *dptr, size_t bytesize, unsigned int flags);
# 4494 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceGetByPCIBusId(CUdevice *dev, const char *pciBusId);
# 4522 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceGetPCIBusId(char *pciBusId, int len, CUdevice dev);
# 4564 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuIpcGetEventHandle(CUipcEventHandle *pHandle, CUevent event);
# 4601 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuIpcOpenEventHandle(CUevent *phEvent, CUipcEventHandle handle);
# 4638 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuIpcGetMemHandle(CUipcMemHandle *pHandle, CUdeviceptr dptr);
# 4689 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuIpcOpenMemHandle(CUdeviceptr *pdptr, CUipcMemHandle handle, unsigned int Flags);
# 4720 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuIpcCloseMemHandle(CUdeviceptr dptr);
# 4803 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemHostRegister_v2(void *p, size_t bytesize, unsigned int Flags);
# 4827 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemHostUnregister(void *p);
# 4863 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpy(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount);
# 4892 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyPeer(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount);
# 4928 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyHtoD_v2(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount);
# 4961 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyDtoH_v2(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount);
# 4994 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyDtoD_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount);
# 5029 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyDtoA_v2(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount);
# 5066 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyAtoD_v2(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount);
# 5101 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyHtoA_v2(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount);
# 5136 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyAtoH_v2(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount);
# 5175 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyAtoA_v2(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount);
# 5336 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpy2D_v2(const CUDA_MEMCPY2D *pCopy);
# 5495 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpy2DUnaligned_v2(const CUDA_MEMCPY2D *pCopy);
# 5663 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpy3D_v2(const CUDA_MEMCPY3D *pCopy);
# 5688 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpy3DPeer(const CUDA_MEMCPY3D_PEER *pCopy);
# 5728 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyAsync(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount, CUstream hStream);
# 5759 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyPeerAsync(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount, CUstream hStream);
# 5798 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyHtoDAsync_v2(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount, CUstream hStream);
# 5835 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyDtoHAsync_v2(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);
# 5872 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyDtoDAsync_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);
# 5911 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyHtoAAsync_v2(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount, CUstream hStream);
# 5950 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpyAtoHAsync_v2(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount, CUstream hStream);
# 6115 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpy2DAsync_v2(const CUDA_MEMCPY2D *pCopy, CUstream hStream);
# 6287 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpy3DAsync_v2(const CUDA_MEMCPY3D *pCopy, CUstream hStream);
# 6314 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemcpy3DPeerAsync(const CUDA_MEMCPY3D_PEER *pCopy, CUstream hStream);
# 6350 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD8_v2(CUdeviceptr dstDevice, unsigned char uc, size_t N);
# 6384 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD16_v2(CUdeviceptr dstDevice, unsigned short us, size_t N);
# 6418 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD32_v2(CUdeviceptr dstDevice, unsigned int ui, size_t N);
# 6457 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD2D8_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height);
# 6497 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD2D16_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height);
# 6537 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD2D32_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height);
# 6573 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD8Async(CUdeviceptr dstDevice, unsigned char uc, size_t N, CUstream hStream);
# 6609 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD16Async(CUdeviceptr dstDevice, unsigned short us, size_t N, CUstream hStream);
# 6644 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD32Async(CUdeviceptr dstDevice, unsigned int ui, size_t N, CUstream hStream);
# 6685 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD2D8Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, CUstream hStream);
# 6727 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD2D16Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, CUstream hStream);
# 6769 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemsetD2D32Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height, CUstream hStream);
# 6872 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuArrayCreate_v2(CUarray *pHandle, const CUDA_ARRAY_DESCRIPTOR *pAllocateArray);
# 6905 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
# 6936 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuArrayDestroy(CUarray hArray);
# 7116 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuArray3DCreate_v2(CUarray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pAllocateArray);
# 7152 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
# 7279 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMipmappedArrayCreate(CUmipmappedArray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pMipmappedArrayDesc, unsigned int numMipmapLevels);
# 7305 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMipmappedArrayGetLevel(CUarray *pLevelArray, CUmipmappedArray hMipmappedArray, unsigned int level);
# 7325 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMipmappedArrayDestroy(CUmipmappedArray hMipmappedArray);
# 7571 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuPointerGetAttribute(void *data, CUpointer_attribute attribute, CUdeviceptr ptr);
# 7640 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemPrefetchAsync(CUdeviceptr devPtr, size_t count, CUdevice dstDevice, CUstream hStream);
# 7726 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemAdvise(CUdeviceptr devPtr, size_t count, CUmem_advise advice, CUdevice device);
# 7783 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemRangeGetAttribute(void *data, size_t dataSize, CUmem_range_attribute attribute, CUdeviceptr devPtr, size_t count);
# 7822 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuMemRangeGetAttributes(void **data, size_t *dataSizes, CUmem_range_attribute *attributes, size_t numAttributes, CUdeviceptr devPtr, size_t count);
# 7866 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuPointerSetAttribute(const void *value, CUpointer_attribute attribute, CUdeviceptr ptr);
# 7908 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuPointerGetAttributes(unsigned int numAttributes, CUpointer_attribute *attributes, void **data, CUdeviceptr ptr);
# 7956 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamCreate(CUstream *phStream, unsigned int Flags);
# 8004 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamCreateWithPriority(CUstream *phStream, unsigned int flags, int priority);
# 8034 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamGetPriority(CUstream hStream, int *priority);
# 8061 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamGetFlags(CUstream hStream, unsigned int *flags);
# 8102 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamWaitEvent(CUstream hStream, CUevent hEvent, unsigned int Flags);
# 8173 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamAddCallback(CUstream hStream, CUstreamCallback callback, void *userData, unsigned int flags);
# 8252 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamAttachMemAsync(CUstream hStream, CUdeviceptr dptr, size_t length, unsigned int flags);
# 8283 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamQuery(CUstream hStream);
# 8310 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamSynchronize(CUstream hStream);
# 8339 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamDestroy_v2(CUstream hStream);
# 8394 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuEventCreate(CUevent *phEvent, unsigned int Flags);
# 8430 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuEventRecord(CUevent hEvent, CUstream hStream);
# 8464 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuEventQuery(CUevent hEvent);
# 8498 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuEventSynchronize(CUevent hEvent);
# 8527 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuEventDestroy_v2(CUevent hEvent);
# 8571 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuEventElapsedTime(float *pMilliseconds, CUevent hStart, CUevent hEnd);
# 8606 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamWaitValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);
# 8639 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamWriteValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);
# 8671 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuStreamBatchMemOp(CUstream stream, unsigned int count, CUstreamBatchMemOpParams *paramArray, unsigned int flags);
# 8739 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuFuncGetAttribute(int *pi, CUfunction_attribute attrib, CUfunction hfunc);
# 8782 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuFuncSetCacheConfig(CUfunction hfunc, CUfunc_cache config);
# 8834 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuFuncSetSharedMemConfig(CUfunction hfunc, CUsharedconfig config);
# 8948 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuLaunchKernel(CUfunction f,
                                unsigned int gridDimX,
                                unsigned int gridDimY,
                                unsigned int gridDimZ,
                                unsigned int blockDimX,
                                unsigned int blockDimY,
                                unsigned int blockDimZ,
                                unsigned int sharedMemBytes,
                                CUstream hStream,
                                void **kernelParams,
                                void **extra);
# 9009 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuFuncSetBlockShape(CUfunction hfunc, int x, int y, int z);
# 9043 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuFuncSetSharedSize(CUfunction hfunc, unsigned int bytes);
# 9075 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuParamSetSize(CUfunction hfunc, unsigned int numbytes);
# 9108 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuParamSeti(CUfunction hfunc, int offset, unsigned int value);
# 9141 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuParamSetf(CUfunction hfunc, int offset, float value);
# 9176 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuParamSetv(CUfunction hfunc, int offset, void *ptr, unsigned int numbytes);
# 9213 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuLaunch(CUfunction f);
# 9252 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuLaunchGrid(CUfunction f, int grid_width, int grid_height);
# 9299 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuLaunchGridAsync(CUfunction f, int grid_width, int grid_height, CUstream hStream);
# 9324 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuParamSetTexRef(CUfunction hfunc, int texunit, CUtexref hTexRef);
# 9362 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize);
# 9402 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize, unsigned int flags);
# 9452 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuOccupancyMaxPotentialBlockSize(int *minGridSize, int *blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit);
# 9496 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuOccupancyMaxPotentialBlockSizeWithFlags(int *minGridSize, int *blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned int flags);
# 9539 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetArray(CUtexref hTexRef, CUarray hArray, unsigned int Flags);
# 9566 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetMipmappedArray(CUtexref hTexRef, CUmipmappedArray hMipmappedArray, unsigned int Flags);
# 9610 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetAddress_v2(size_t *ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes);
# 9662 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetAddress2D_v3(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR *desc, CUdeviceptr dptr, size_t Pitch);
# 9691 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetFormat(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents);
# 9731 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetAddressMode(CUtexref hTexRef, int dim, CUaddress_mode am);
# 9764 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetFilterMode(CUtexref hTexRef, CUfilter_mode fm);
# 9797 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetMipmapFilterMode(CUtexref hTexRef, CUfilter_mode fm);
# 9823 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetMipmapLevelBias(CUtexref hTexRef, float bias);
# 9851 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetMipmapLevelClamp(CUtexref hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp);
# 9877 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetMaxAnisotropy(CUtexref hTexRef, unsigned int maxAniso);
# 9907 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetBorderColor(CUtexref hTexRef, float *pBorderColor);
# 9942 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefSetFlags(CUtexref hTexRef, unsigned int Flags);
# 9968 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetAddress_v2(CUdeviceptr *pdptr, CUtexref hTexRef);
# 9994 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetArray(CUarray *phArray, CUtexref hTexRef);
# 10019 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetMipmappedArray(CUmipmappedArray *phMipmappedArray, CUtexref hTexRef);
# 10045 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetAddressMode(CUaddress_mode *pam, CUtexref hTexRef, int dim);
# 10069 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetFilterMode(CUfilter_mode *pfm, CUtexref hTexRef);
# 10095 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetFormat(CUarray_format *pFormat, int *pNumChannels, CUtexref hTexRef);
# 10119 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetMipmapFilterMode(CUfilter_mode *pfm, CUtexref hTexRef);
# 10143 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetMipmapLevelBias(float *pbias, CUtexref hTexRef);
# 10168 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetMipmapLevelClamp(float *pminMipmapLevelClamp, float *pmaxMipmapLevelClamp, CUtexref hTexRef);
# 10192 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetMaxAnisotropy(int *pmaxAniso, CUtexref hTexRef);
# 10219 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetBorderColor(float *pBorderColor, CUtexref hTexRef);
# 10242 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefGetFlags(unsigned int *pFlags, CUtexref hTexRef);
# 10281 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefCreate(CUtexref *pTexRef);
# 10301 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexRefDestroy(CUtexref hTexRef);
# 10340 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuSurfRefSetArray(CUsurfref hSurfRef, CUarray hArray, unsigned int Flags);
# 10361 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuSurfRefGetArray(CUarray *phArray, CUsurfref hSurfRef);
# 10583 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexObjectCreate(CUtexObject *pTexObject, const CUDA_RESOURCE_DESC *pResDesc, const CUDA_TEXTURE_DESC *pTexDesc, const CUDA_RESOURCE_VIEW_DESC *pResViewDesc);
# 10601 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexObjectDestroy(CUtexObject texObject);
# 10620 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC *pResDesc, CUtexObject texObject);
# 10639 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC *pTexDesc, CUtexObject texObject);
# 10659 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC *pResViewDesc, CUtexObject texObject);
# 10700 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuSurfObjectCreate(CUsurfObject *pSurfObject, const CUDA_RESOURCE_DESC *pResDesc);
# 10718 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuSurfObjectDestroy(CUsurfObject surfObject);
# 10737 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC *pResDesc, CUsurfObject surfObject);
# 10779 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceCanAccessPeer(int *canAccessPeer, CUdevice dev, CUdevice peerDev);
# 10816 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuDeviceGetP2PAttribute(int* value, CUdevice_P2PAttribute attrib, CUdevice srcDevice, CUdevice dstDevice);
# 10865 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxEnablePeerAccess(CUcontext peerContext, unsigned int Flags);
# 10890 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuCtxDisablePeerAccess(CUcontext peerContext);
# 10934 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuGraphicsUnregisterResource(CUgraphicsResource resource);
# 10972 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuGraphicsSubResourceGetMappedArray(CUarray *pArray, CUgraphicsResource resource, unsigned int arrayIndex, unsigned int mipLevel);
# 11003 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray *pMipmappedArray, CUgraphicsResource resource);
# 11039 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr *pDevPtr, size_t *pSize, CUgraphicsResource resource);
# 11080 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuGraphicsResourceSetMapFlags_v2(CUgraphicsResource resource, unsigned int flags);
# 11119 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuGraphicsMapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);
# 11155 "/usr/local/cuda-8.0/include/cuda.h"
CUresult cuGraphicsUnmapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);



CUresult cuGetExportTable(const void **ppExportTable, const CUuuid *pExportTableId);
# 11478 "/usr/local/cuda-8.0/include/cuda.h"
}
# 26 "/usr/local/cuda-8.0/include/thrust/detail/config/compiler.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/host_system.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/config/host_system.h"
       
# 30 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/device_system.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/config/device_system.h"
       
# 31 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/host_device.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/config/host_device.h"
       
# 32 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/debug.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/config/debug.h"
       
# 33 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/compiler_fence.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/config/compiler_fence.h"
       
# 34 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/forceinline.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/config/forceinline.h"
       
# 35 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/exec_check_disable.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/config/exec_check_disable.h"
       
# 36 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/config/global_workarounds.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/config/global_workarounds.h"
       






#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
# 37 "/usr/local/cuda-8.0/include/thrust/detail/config/config.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/detail/config.h" 2
# 25 "/usr/local/cuda-8.0/include/thrust/host_vector.h" 2
# 1 "/usr/include/c++/4.8.2/memory" 1 3
# 46 "/usr/include/c++/4.8.2/memory" 3
       
# 47 "/usr/include/c++/4.8.2/memory" 3
# 62 "/usr/include/c++/4.8.2/memory" 3
# 1 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.8.2/bits/functexcept.h" 1 3
# 40 "/usr/include/c++/4.8.2/bits/functexcept.h" 3
# 1 "/usr/include/c++/4.8.2/bits/exception_defines.h" 1 3
# 41 "/usr/include/c++/4.8.2/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 2 3


# 1 "/usr/include/c++/4.8.2/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/4.8.2/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/4.8.2/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/4.8.2/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/4.8.2/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 106) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 31);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 308);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_pair.h" 1 3
# 59 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
# 1 "/usr/include/c++/4.8.2/bits/move.h" 1 3
# 34 "/usr/include/c++/4.8.2/bits/move.h" 3
# 1 "/usr/include/c++/4.8.2/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/4.8.2/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/4.8.2/bits/concept_check.h" 3
# 35 "/usr/include/c++/4.8.2/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}
# 149 "/usr/include/c++/4.8.2/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 164 "/usr/include/c++/4.8.2/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)




    {

     

      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])



    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/usr/include/c++/4.8.2/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 95 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }



      template<class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
# 209 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline
   
# 214 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
   
# 213 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
                              bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline
   
# 220 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
   
# 219 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
                              bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline
   
# 227 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
   
# 226 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
                              bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline
   
# 233 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
   
# 232 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
                              bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline
   
# 239 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
   
# 238 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
                              bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline
   
# 245 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
   
# 244 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
                              bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 284 "/usr/include/c++/4.8.2/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }





}
# 65 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/4.8.2/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/4.8.2/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "/usr/include/c++/4.8.2/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/include/c++/4.8.2/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 162 "/usr/include/c++/4.8.2/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };



  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };
# 232 "/usr/include/c++/4.8.2/bits/stl_iterator_base_types.h" 3

}
# 66 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/include/c++/4.8.2/debug/debug.h" 1 3
# 46 "/usr/include/c++/4.8.2/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 66 "/usr/include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 112 "/usr/include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 171 "/usr/include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
# 202 "/usr/include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 3

}
# 67 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 1 3
# 67 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 95 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 159 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 289 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline
   
# 291 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 290 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline
   
# 297 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 296 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline
   
# 303 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 302 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline
   
# 309 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 308 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline
   
# 315 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 314 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline
   
# 321 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 320 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline
   
# 341 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 340 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline
   
# 347 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 346 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline
   
# 353 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 352 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline
   
# 359 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 358 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline
   
# 365 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 364 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline
   
# 371 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 370 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
# 401 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 428 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 451 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 477 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 492 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 518 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 541 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 567 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 586 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 629 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 655 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 681 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 705 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 803 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline
   
# 805 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 804 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline
   
# 811 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 810 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline
   
# 817 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 816 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline
   
# 823 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 822 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline
   
# 830 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 829 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline
   
# 836 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 835 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline
   
# 842 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 841 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline
   
# 848 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 847 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline
   
# 854 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 853 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline
   
# 860 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 859 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline
   
# 866 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 865 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline
   
# 872 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
   
# 871 "/usr/include/c++/4.8.2/bits/stl_iterator.h" 3
           bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}
# 68 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{






  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 117 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     



      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);



    }
# 163 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 191 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 214 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 237 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 258 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 325 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 363 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 448 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 500 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 528 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 558 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 617 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 675 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 719 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 779 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static
       
# 794 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
       
# 793 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
               bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static
       
# 808 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
       
# 807 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
               bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline
   
# 817 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
   
# 816 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
           bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static
       
# 841 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
       
# 840 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
               bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static
       
# 862 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
       
# 861 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
               bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
     
     
# 876 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
     
# 875 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static
       
# 901 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
       
# 900 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
               bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline
   
# 914 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
   
# 913 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
           bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 941 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1019 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline
   
# 1021 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
   
# 1020 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
           bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1051 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline
   
# 1053 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
   
# 1052 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
           bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1082 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline
   
# 1084 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
   
# 1083 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
           bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1118 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
   
   
# 1120 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
   
# 1119 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1158 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1195 "/usr/include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
# 63 "/usr/include/c++/4.8.2/memory" 2 3
# 1 "/usr/include/c++/4.8.2/bits/allocator.h" 1 3
# 46 "/usr/include/c++/4.8.2/bits/allocator.h" 3
# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++allocator.h" 1 3
# 33 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.8.2/ext/new_allocator.h" 1 3
# 33 "/usr/include/c++/4.8.2/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.8.2/new" 1 3
# 37 "/usr/include/c++/4.8.2/new" 3
       
# 38 "/usr/include/c++/4.8.2/new" 3


# 1 "/usr/include/c++/4.8.2/exception" 1 3
# 33 "/usr/include/c++/4.8.2/exception" 3
       
# 34 "/usr/include/c++/4.8.2/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/4.8.2/bits/atomic_lockfree_defines.h" 1 3
# 33 "/usr/include/c++/4.8.2/bits/atomic_lockfree_defines.h" 3
       
# 34 "/usr/include/c++/4.8.2/bits/atomic_lockfree_defines.h" 3
# 39 "/usr/include/c++/4.8.2/exception" 2 3

extern "C++" {

namespace std
{
# 60 "/usr/include/c++/4.8.2/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 117 "/usr/include/c++/4.8.2/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 142 "/usr/include/c++/4.8.2/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
# 41 "/usr/include/c++/4.8.2/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 91 "/usr/include/c++/4.8.2/new" 3
void* operator new(std::size_t) throw(std::bad_alloc)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t) throw(std::bad_alloc)
  __attribute__((__externally_visible__));
void operator delete(void*) throw()
  __attribute__((__externally_visible__));
void operator delete[](void*) throw()
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) throw()
{ return __p; }
inline void* operator new[](std::size_t, void* __p) throw()
{ return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 34 "/usr/include/c++/4.8.2/ext/new_allocator.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/include/c++/4.8.2/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };







      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }
# 128 "/usr/include/c++/4.8.2/ext/new_allocator.h" 3
      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }

    };

  template<typename _Tp>
    inline
   
# 139 "/usr/include/c++/4.8.2/ext/new_allocator.h" 3
   
# 138 "/usr/include/c++/4.8.2/ext/new_allocator.h" 3
           bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline
   
# 144 "/usr/include/c++/4.8.2/ext/new_allocator.h" 3
   
# 143 "/usr/include/c++/4.8.2/ext/new_allocator.h" 3
           bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++allocator.h" 2 3
# 47 "/usr/include/c++/4.8.2/bits/allocator.h" 2 3
# 1 "/usr/include/c++/4.8.2/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/4.8.2/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/4.8.2/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/4.8.2/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 48 "/usr/include/c++/4.8.2/bits/allocator.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };






    };
# 91 "/usr/include/c++/4.8.2/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };







      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline
   
# 128 "/usr/include/c++/4.8.2/bits/allocator.h" 3
   
# 127 "/usr/include/c++/4.8.2/bits/allocator.h" 3
           bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline
   
# 133 "/usr/include/c++/4.8.2/bits/allocator.h" 3
   
# 132 "/usr/include/c++/4.8.2/bits/allocator.h" 3
           bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline
   
# 138 "/usr/include/c++/4.8.2/bits/allocator.h" 3
   
# 137 "/usr/include/c++/4.8.2/bits/allocator.h" 3
           bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline
   
# 143 "/usr/include/c++/4.8.2/bits/allocator.h" 3
   
# 142 "/usr/include/c++/4.8.2/bits/allocator.h" 3
           bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static
     
# 180 "/usr/include/c++/4.8.2/bits/allocator.h" 3
     
# 179 "/usr/include/c++/4.8.2/bits/allocator.h" 3
             bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static
     
# 188 "/usr/include/c++/4.8.2/bits/allocator.h" 3
     
# 187 "/usr/include/c++/4.8.2/bits/allocator.h" 3
             bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
# 218 "/usr/include/c++/4.8.2/bits/allocator.h" 3

}
# 64 "/usr/include/c++/4.8.2/memory" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_construct.h" 1 3
# 61 "/usr/include/c++/4.8.2/bits/stl_construct.h" 3
# 1 "/usr/include/c++/4.8.2/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/4.8.2/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/4.8.2/ext/alloc_traits.h" 3
# 41 "/usr/include/c++/4.8.2/ext/alloc_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 120 "/usr/include/c++/4.8.2/ext/alloc_traits.h" 3
template<typename _Alloc>
  struct __alloc_traits



  {
    typedef _Alloc allocator_type;
# 199 "/usr/include/c++/4.8.2/ext/alloc_traits.h" 3
    typedef typename _Alloc::pointer pointer;
    typedef typename _Alloc::const_pointer const_pointer;
    typedef typename _Alloc::value_type value_type;
    typedef typename _Alloc::reference reference;
    typedef typename _Alloc::const_reference const_reference;
    typedef typename _Alloc::size_type size_type;
    typedef typename _Alloc::difference_type difference_type;

    static pointer
    allocate(_Alloc& __a, size_type __n)
    { return __a.allocate(__n); }

    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
    { __a.deallocate(__p, __n); }

    template<typename _Tp>
      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
      { __a.construct(__p, __arg); }

    static void destroy(_Alloc& __a, pointer __p)
    { __a.destroy(__p); }

    static size_type max_size(const _Alloc& __a)
    { return __a.max_size(); }

    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    {


      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Alloc::template rebind<_Tp>::other other; };

  };


}
# 62 "/usr/include/c++/4.8.2/bits/stl_construct.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 77 "/usr/include/c++/4.8.2/bits/stl_construct.h" 3
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }





  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 65 "/usr/include/c++/4.8.2/memory" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_uninitialized.h" 1 3
# 59 "/usr/include/c++/4.8.2/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "/usr/include/c++/4.8.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
     && __is_trivial(_ValueType2))>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 162 "/usr/include/c++/4.8.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_trivial(_ValueType)>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 216 "/usr/include/c++/4.8.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 ((__first),
  (__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 346 "/usr/include/c++/4.8.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 653 "/usr/include/c++/4.8.2/bits/stl_uninitialized.h" 3

}
# 66 "/usr/include/c++/4.8.2/memory" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_tempbuf.h" 1 3
# 62 "/usr/include/c++/4.8.2/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 83 "/usr/include/c++/4.8.2/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/include/c++/4.8.2/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         (*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    (*__prev));
       *__seed = (*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "/usr/include/c++/4.8.2/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 67 "/usr/include/c++/4.8.2/memory" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_raw_storage_iter.h" 1 3
# 59 "/usr/include/c++/4.8.2/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };


}
# 68 "/usr/include/c++/4.8.2/memory" 2 3
# 87 "/usr/include/c++/4.8.2/memory" 3
# 1 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 1 3
# 36 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } ;
# 86 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 112 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 124 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 135 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 152 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 170 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 180 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 210 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 224 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 239 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 260 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } ;



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } ;
# 326 "/usr/include/c++/4.8.2/backward/auto_ptr.h" 3

}
# 88 "/usr/include/c++/4.8.2/memory" 2 3
# 26 "/usr/local/cuda-8.0/include/thrust/host_vector.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h" 1
# 23 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h"
       

# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/normal_iterator.h" 1
# 23 "/usr/local/cuda-8.0/include/thrust/iterator/detail/normal_iterator.h"
       

# 1 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_adaptor.h" 1
# 33 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_adaptor.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h" 1
# 33 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits.h" 1
# 23 "/usr/local/cuda-8.0/include/thrust/detail/type_traits.h"
       
# 45 "/usr/local/cuda-8.0/include/thrust/detail/type_traits.h"
namespace thrust
{


template<typename T> class device_reference;

namespace detail
{

 template<typename _Tp, _Tp __v>
   struct integral_constant
   {
     static const _Tp value = __v;
     typedef _Tp value_type;
     typedef integral_constant<_Tp, __v> type;
   };


 typedef integral_constant<bool, true> true_type;


 typedef integral_constant<bool, false> false_type;


template<typename T> struct is_integral : public false_type {};
template<> struct is_integral<bool> : public true_type {};
template<> struct is_integral<char> : public true_type {};
template<> struct is_integral<signed char> : public true_type {};
template<> struct is_integral<unsigned char> : public true_type {};
template<> struct is_integral<short> : public true_type {};
template<> struct is_integral<unsigned short> : public true_type {};
template<> struct is_integral<int> : public true_type {};
template<> struct is_integral<unsigned int> : public true_type {};
template<> struct is_integral<long> : public true_type {};
template<> struct is_integral<unsigned long> : public true_type {};
template<> struct is_integral<long long> : public true_type {};
template<> struct is_integral<unsigned long long> : public true_type {};
template<> struct is_integral<const bool> : public true_type {};
template<> struct is_integral<const char> : public true_type {};
template<> struct is_integral<const unsigned char> : public true_type {};
template<> struct is_integral<const short> : public true_type {};
template<> struct is_integral<const unsigned short> : public true_type {};
template<> struct is_integral<const int> : public true_type {};
template<> struct is_integral<const unsigned int> : public true_type {};
template<> struct is_integral<const long> : public true_type {};
template<> struct is_integral<const unsigned long> : public true_type {};
template<> struct is_integral<const long long> : public true_type {};
template<> struct is_integral<const unsigned long long> : public true_type {};

template<typename T> struct is_floating_point : public false_type {};
template<> struct is_floating_point<float> : public true_type {};
template<> struct is_floating_point<double> : public true_type {};
template<> struct is_floating_point<long double> : public true_type {};

template<typename T> struct is_arithmetic : public is_integral<T> {};
template<> struct is_arithmetic<float> : public true_type {};
template<> struct is_arithmetic<double> : public true_type {};
template<> struct is_arithmetic<const float> : public true_type {};
template<> struct is_arithmetic<const double> : public true_type {};

template<typename T> struct is_pointer : public false_type {};
template<typename T> struct is_pointer<T *> : public true_type {};

template<typename T> struct is_device_ptr : public false_type {};

template<typename T> struct is_void : public false_type {};
template<> struct is_void<void> : public true_type {};
template<> struct is_void<const void> : public true_type {};


namespace tt_detail
{


}

template<typename T> struct is_pod
   : public integral_constant<
       bool,
       is_void<T>::value || is_pointer<T>::value || is_arithmetic<T>::value






       || __is_pod(T)


     >
 {};


template<typename T> struct has_trivial_constructor
  : public integral_constant<
      bool,
      is_pod<T>::value





      || __has_trivial_constructor(T)


      >
{};

template<typename T> struct has_trivial_copy_constructor
  : public integral_constant<
      bool,
      is_pod<T>::value





      || __has_trivial_copy(T)


    >
{};

template<typename T> struct has_trivial_destructor : public is_pod<T> {};

template<typename T> struct is_const : public false_type {};
template<typename T> struct is_const<const T> : public true_type {};

template<typename T> struct is_volatile : public false_type {};
template<typename T> struct is_volatile<volatile T> : public true_type {};

template<typename T>
  struct add_const
{
  typedef T const type;
};

template<typename T>
  struct remove_const
{
  typedef T type;
};

template<typename T>
  struct remove_const<const T>
{
  typedef T type;
};

template<typename T>
  struct add_volatile
{
  typedef volatile T type;
};

template<typename T>
  struct remove_volatile
{
  typedef T type;
};

template<typename T>
  struct remove_volatile<volatile T>
{
  typedef T type;
};

template<typename T>
  struct add_cv
{
  typedef const volatile T type;
};

template<typename T>
  struct remove_cv
{
  typedef typename remove_const<typename remove_volatile<T>::type>::type type;
};


template<typename T> struct is_reference : public false_type {};
template<typename T> struct is_reference<T&> : public true_type {};

template<typename T> struct is_device_reference : public false_type {};
template<typename T> struct is_device_reference< thrust::device_reference<T> > : public true_type {};



template<typename _Tp, bool = (is_void<_Tp>::value || is_reference<_Tp>::value)>
  struct __add_reference_helper
  { typedef _Tp& type; };

template<typename _Tp>
  struct __add_reference_helper<_Tp, true>
  { typedef _Tp type; };

template<typename _Tp>
  struct add_reference
    : public __add_reference_helper<_Tp>{};

template<typename T>
  struct remove_reference
{
  typedef T type;
};

template<typename T>
  struct remove_reference<T&>
{
  typedef T type;
};

template<typename T1, typename T2>
  struct is_same
    : public false_type
{
};

template<typename T>
  struct is_same<T,T>
    : public true_type
{
};

template<typename T1, typename T2>
  struct lazy_is_same
    : is_same<typename T1::type, typename T2::type>
{
};

template<typename T1, typename T2>
  struct is_different
    : public true_type
{
};

template<typename T>
  struct is_different<T,T>
    : public false_type
{
};

template<typename T1, typename T2>
  struct lazy_is_different
    : is_different<typename T1::type, typename T2::type>
{
};

namespace tt_detail
{

template<typename T>
  struct is_int_or_cref
{
  typedef typename remove_reference<T>::type type_sans_ref;
  static const bool value = (is_integral<T>::value
                             || (is_integral<type_sans_ref>::value
                                 && is_const<type_sans_ref>::value
                                 && !is_volatile<type_sans_ref>::value));
};






template<typename From, typename To>
  struct is_convertible_sfinae
{
  private:
    typedef char yes;
    typedef struct { char two_chars[2]; } no;

    static inline yes test(To) { return yes(); }
    static inline no test(...) { return no(); }
    static inline typename remove_reference<From>::type& from() { typename remove_reference<From>::type* ptr = 0; return *ptr; }

  public:
    static const bool value = sizeof(test(from())) == sizeof(yes);
};






template<typename From, typename To>
  struct is_convertible_needs_simple_test
{
  static const bool from_is_void = is_void<From>::value;
  static const bool to_is_void = is_void<To>::value;
  static const bool from_is_float = is_floating_point<typename remove_reference<From>::type>::value;
  static const bool to_is_int_or_cref = is_int_or_cref<To>::value;

  static const bool value = (from_is_void || to_is_void || (from_is_float && to_is_int_or_cref));
};


template<typename From, typename To,
         bool = is_convertible_needs_simple_test<From,To>::value>
  struct is_convertible
{
  static const bool value = (is_void<To>::value
                             || (is_int_or_cref<To>::value
                                 && !is_void<From>::value));
};


template<typename From, typename To>
  struct is_convertible<From, To, false>
{
  static const bool value = (is_convertible_sfinae<typename
                             add_reference<From>::type, To>::value);
};


}

template<typename From, typename To>
  struct is_convertible
    : public integral_constant<bool, tt_detail::is_convertible<From, To>::value>
{
};


template<typename T1, typename T2>
  struct is_one_convertible_to_the_other
    : public integral_constant<
        bool,
        is_convertible<T1,T2>::value || is_convertible<T2,T1>::value
      >
{};




template <typename Condition1, typename Condition2, typename Condition3 = false_type,
          typename Condition4 = false_type, typename Condition5 = false_type, typename Condition6 = false_type,
          typename Condition7 = false_type, typename Condition8 = false_type, typename Condition9 = false_type,
          typename Condition10 = false_type>
  struct or_
    : public integral_constant<
        bool,
        Condition1::value || Condition2::value || Condition3::value || Condition4::value || Condition5::value || Condition6::value || Condition7::value || Condition8::value || Condition9::value || Condition10::value
      >
{
};

template <typename Condition1, typename Condition2, typename Condition3 = true_type>
  struct and_
    : public integral_constant<bool, Condition1::value && Condition2::value && Condition3::value>
{
};

template <typename Boolean>
  struct not_
    : public integral_constant<bool, !Boolean::value>
{
};

template <bool, typename Then, typename Else>
  struct eval_if
{
};

template<typename Then, typename Else>
  struct eval_if<true, Then, Else>
{
  typedef typename Then::type type;
};

template<typename Then, typename Else>
  struct eval_if<false, Then, Else>
{
  typedef typename Else::type type;
};

template<typename T>


  struct identity_
{
  typedef T type;
};

template<bool, typename T = void> struct enable_if {};
template<typename T> struct enable_if<true, T> {typedef T type;};

template<bool, typename T> struct lazy_enable_if {};
template<typename T> struct lazy_enable_if<true, T> {typedef typename T::type type;};

template<bool condition, typename T = void> struct disable_if : enable_if<!condition, T> {};
template<bool condition, typename T> struct lazy_disable_if : lazy_enable_if<!condition, T> {};


template<typename T1, typename T2, typename T = void>
  struct enable_if_convertible
    : enable_if< is_convertible<T1,T2>::value, T >
{};


template<typename T1, typename T2, typename T = void>
  struct disable_if_convertible
    : disable_if< is_convertible<T1,T2>::value, T >
{};


template<typename T1, typename T2, typename Result = void>
  struct enable_if_different
    : enable_if<is_different<T1,T2>::value, Result>
{};


template<typename T>
  struct is_numeric
    : and_<
        is_convertible<int,T>,
        is_convertible<T,int>
      >
{
};


template<typename> struct is_reference_to_const : false_type {};
template<typename T> struct is_reference_to_const<const T&> : true_type {};




namespace tt_detail
{

template<typename T> struct make_unsigned_simple;

template<> struct make_unsigned_simple<char> { typedef unsigned char type; };
template<> struct make_unsigned_simple<signed char> { typedef signed char type; };
template<> struct make_unsigned_simple<unsigned char> { typedef unsigned char type; };
template<> struct make_unsigned_simple<short> { typedef unsigned short type; };
template<> struct make_unsigned_simple<unsigned short> { typedef unsigned short type; };
template<> struct make_unsigned_simple<int> { typedef unsigned int type; };
template<> struct make_unsigned_simple<unsigned int> { typedef unsigned int type; };
template<> struct make_unsigned_simple<long int> { typedef unsigned long int type; };
template<> struct make_unsigned_simple<unsigned long int> { typedef unsigned long int type; };
template<> struct make_unsigned_simple<long long int> { typedef unsigned long long int type; };
template<> struct make_unsigned_simple<unsigned long long int> { typedef unsigned long long int type; };

template<typename T>
  struct make_unsigned_base
{

  typedef typename remove_cv<T>::type remove_cv_t;


  typedef typename make_unsigned_simple<remove_cv_t>::type unsigned_remove_cv_t;


  typedef typename eval_if<
    is_const<T>::value && is_volatile<T>::value,

    add_cv<unsigned_remove_cv_t>,

    eval_if<
      is_const<T>::value,

      add_const<unsigned_remove_cv_t>,
      eval_if<
        is_volatile<T>::value,

        add_volatile<unsigned_remove_cv_t>,

        identity_<unsigned_remove_cv_t>
      >
    >
  >::type type;
};

}

template<typename T>
  struct make_unsigned
    : tt_detail::make_unsigned_base<T>
{};

struct largest_available_float
{







  typedef double type;

};


template<typename T1, typename T2>
  struct larger_type
    : thrust::detail::eval_if<
        (sizeof(T2) > sizeof(T1)),
        thrust::detail::identity_<T2>,
        thrust::detail::identity_<T1>
      >
{};


namespace is_base_of_ns
{

typedef char yes;
typedef struct { char two_chars[2]; } no;

template<typename Base, typename Derived>
  struct host
{
  operator Base*() const;
  operator Derived*();
};

template<typename Base, typename Derived>
  struct impl
{
  template<typename T> static yes check(Derived *, T);
  static no check(Base*, int);

  static const bool value = sizeof(check(host<Base,Derived>(), int())) == sizeof(yes);
};

}


template<typename Base, typename Derived>
  struct is_base_of
    : integral_constant<
        bool,
        is_base_of_ns::impl<Base,Derived>::value
      >
{};

template<typename Base, typename Derived, typename Result = void>
  struct enable_if_base_of
    : enable_if<
        is_base_of<Base,Derived>::value,
        Result
      >
{};


namespace is_assignable_ns
{

template<typename T1, typename T2>
  class is_assignable
{
  typedef char yes_type;
  typedef struct { char array[2]; } no_type;

  template<typename T> static typename add_reference<T>::type declval();

  template<unsigned int> struct helper { typedef void * type; };

  template<typename U1, typename U2> static yes_type test(typename helper<sizeof(declval<U1>() = declval<U2>())>::type);

  template<typename,typename> static no_type test(...);

  public:
    static const bool value = sizeof(test<T1,T2>(0)) == 1;
};

}


template<typename T1, typename T2>
  struct is_assignable
    : integral_constant<
        bool,
        is_assignable_ns::is_assignable<T1,T2>::value
      >
{};


template<typename T>
  struct is_copy_assignable
    : is_assignable<
        typename add_reference<T>::type,
        typename add_reference<typename add_const<T>::type>::type
      >
{};


template<typename T1, typename T2, typename Enable = void> struct promoted_numerical_type;

template<typename T1, typename T2>
  struct promoted_numerical_type<T1,T2,typename enable_if<and_
  <typename is_floating_point<T1>::type,typename is_floating_point<T2>::type>
  ::value>::type>
  {
  typedef larger_type<T1,T2> type;
  };

template<typename T1, typename T2>
  struct promoted_numerical_type<T1,T2,typename enable_if<and_
  <typename is_integral<T1>::type,typename is_floating_point<T2>::type>
  ::value>::type>
  {
  typedef T2 type;
  };

template<typename T1, typename T2>
  struct promoted_numerical_type<T1,T2,typename enable_if<and_
  <typename is_floating_point<T1>::type, typename is_integral<T2>::type>
  ::value>::type>
  {
  typedef T1 type;
  };

}

}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/has_trivial_assign.h" 1
# 23 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/has_trivial_assign.h"
       




namespace thrust
{

namespace detail
{

template<typename T> struct has_trivial_assign
  : public integral_constant<
      bool,
      (is_pod<T>::value && !is_const<T>::value)





      || __has_trivial_assign(T)


    >
{};

}

}
# 667 "/usr/local/cuda-8.0/include/thrust/detail/type_traits.h" 2
# 37 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_facade_category.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_facade_category.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/host_system_tag.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/host_system_tag.h"
       





# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/execution_policy.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/execution_policy.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/execution_policy.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/execution_policy.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/execution_policy.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/execution_policy.h"
       



namespace thrust
{
namespace detail
{
# 41 "/usr/local/cuda-8.0/include/thrust/detail/execution_policy.h"
template<typename DerivedPolicy> struct execution_policy_base {};


template<typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
inline execution_policy_base<DerivedPolicy> &strip_const(const execution_policy_base<DerivedPolicy> &x)
{
  return const_cast<execution_policy_base<DerivedPolicy>&>(x);
}


template<typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
inline DerivedPolicy &derived_cast(execution_policy_base<DerivedPolicy> &x)
{
  return static_cast<DerivedPolicy&>(x);
}


template<typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
inline const DerivedPolicy &derived_cast(const execution_policy_base<DerivedPolicy> &x)
{
  return static_cast<const DerivedPolicy&>(x);
}


}


template<typename DerivedPolicy>
  struct execution_policy
    : thrust::detail::execution_policy_base<DerivedPolicy>
{};


}
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/execution_policy.h" 2

namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{
# 39 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/execution_policy.h"
struct tag;


template<typename> struct execution_policy;


template<>
  struct execution_policy<tag>
    : thrust::execution_policy<tag>
{};


struct tag : execution_policy<tag>
{
  __attribute__((host)) __attribute__((device)) tag() {}
};


template<typename Derived>
  struct execution_policy
    : thrust::execution_policy<Derived>
{

  inline operator tag () const
  {
    return tag();
  }
};





static const tag seq;



}
}
}
}
# 21 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/execution_policy.h" 2

namespace thrust
{
namespace system
{

namespace cpp
{
namespace detail
{
# 39 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/execution_policy.h"
struct tag;


template<typename> struct execution_policy;


template<>
  struct execution_policy<tag>
    : thrust::system::detail::sequential::execution_policy<tag>
{};



struct tag : execution_policy<tag> {};


template<typename Derived>
  struct execution_policy
    : thrust::system::detail::sequential::execution_policy<Derived>
{

  inline operator tag () const
  {
    return tag();
  }
};

}


using thrust::system::cpp::detail::execution_policy;
using thrust::system::cpp::detail::tag;

}
}


namespace cpp
{

using thrust::system::cpp::execution_policy;
using thrust::system::cpp::tag;

}
}
# 24 "/usr/local/cuda-8.0/include/thrust/iterator/detail/host_system_tag.h" 2


namespace thrust
{

typedef thrust::system::cpp::tag host_system_tag;

}


namespace thrust
{

typedef __attribute__ ((deprecated)) host_system_tag host_space_tag;

}
# 22 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_facade_category.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/device_system_tag.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/device_system_tag.h"
       





# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/execution_policy.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/execution_policy.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/any_system_tag.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/any_system_tag.h"
       




namespace thrust
{

struct any_system_tag
  : thrust::execution_policy<any_system_tag>
{


  template<typename T> operator T () const {return T();}
};


typedef __attribute__ ((deprecated)) any_system_tag any_space_tag;

}
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/execution_policy.h" 2

namespace thrust
{
namespace system
{
namespace cuda
{

namespace detail
{
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/execution_policy.h"
struct tag;


template<typename> struct execution_policy;


template<>
  struct execution_policy<tag>
    : thrust::execution_policy<tag>
{};



struct tag : execution_policy<tag> {};


template<typename Derived>
  struct execution_policy
    : thrust::execution_policy<Derived>
{

  inline operator tag () const
  {
    return tag();
  }
};


template<typename System1, typename System2>
  struct cross_system
    : thrust::execution_policy<cross_system<System1,System2> >
{
  inline __attribute__((host)) __attribute__((device))
  cross_system(thrust::execution_policy<System1> &system1,
               thrust::execution_policy<System2> &system2)
    : system1(system1), system2(system2)
  {}

  thrust::execution_policy<System1> &system1;
  thrust::execution_policy<System2> &system2;

  inline __attribute__((host)) __attribute__((device))
  cross_system<System2,System1> rotate() const
  {
    return cross_system<System2,System1>(system2,system1);
  }
};





template<typename System1, typename System2>
inline __attribute__((host)) __attribute__((device))
cross_system<System1,System2> select_system(const execution_policy<System1> &system1, const thrust::cpp::execution_policy<System2> &system2)
{
  thrust::execution_policy<System1> &non_const_system1 = const_cast<execution_policy<System1>&>(system1);
  thrust::cpp::execution_policy<System2> &non_const_system2 = const_cast<thrust::cpp::execution_policy<System2>&>(system2);
  return cross_system<System1,System2>(non_const_system1,non_const_system2);
}


template<typename System1, typename System2>
inline __attribute__((host)) __attribute__((device))
cross_system<System1,System2> select_system(const thrust::cpp::execution_policy<System1> &system1, execution_policy<System2> &system2)
{
  thrust::cpp::execution_policy<System1> &non_const_system1 = const_cast<thrust::cpp::execution_policy<System1>&>(system1);
  thrust::execution_policy<System2> &non_const_system2 = const_cast<execution_policy<System2>&>(system2);
  return cross_system<System1,System2>(non_const_system1,non_const_system2);
}


}


using thrust::system::cuda::detail::execution_policy;
using thrust::system::cuda::detail::tag;

}
}


namespace cuda
{

using thrust::system::cuda::execution_policy;
using thrust::system::cuda::tag;

}
}
# 24 "/usr/local/cuda-8.0/include/thrust/iterator/detail/device_system_tag.h" 2


namespace thrust
{

typedef thrust::system::cuda::tag device_system_tag;

}


namespace thrust
{

typedef __attribute__ ((deprecated)) device_system_tag device_space_tag;

}
# 23 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_facade_category.h" 2

# 1 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h" 1
# 32 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_category_with_system_and_traversal.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_category_with_system_and_traversal.h"
       



namespace thrust
{
namespace detail
{


template<typename Category, typename System, typename Traversal>
  struct iterator_category_with_system_and_traversal
    : Category
{
};



template<typename Category> struct iterator_category_to_system;

template<typename Category, typename System, typename Traversal>
  struct iterator_category_to_system<iterator_category_with_system_and_traversal<Category,System,Traversal> >
{
  typedef System type;
};



template<typename Category> struct iterator_category_to_traversal;

template<typename Category, typename System, typename Traversal>
  struct iterator_category_to_traversal<iterator_category_with_system_and_traversal<Category,System,Traversal> >
{
  typedef Traversal type;
};



}
}
# 36 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_traversal_tags.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_traversal_tags.h"
       

namespace thrust
{


struct no_traversal_tag {};

struct incrementable_traversal_tag
  : no_traversal_tag {};

struct single_pass_traversal_tag
  : incrementable_traversal_tag {};

struct forward_traversal_tag
  : single_pass_traversal_tag {};

struct bidirectional_traversal_tag
  : forward_traversal_tag {};

struct random_access_traversal_tag
  : bidirectional_traversal_tag {};

}
# 37 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h" 2



# 1 "/usr/include/c++/4.8.2/iterator" 1 3
# 58 "/usr/include/c++/4.8.2/iterator" 3
       
# 59 "/usr/include/c++/4.8.2/iterator" 3





# 1 "/usr/include/c++/4.8.2/ostream" 1 3
# 36 "/usr/include/c++/4.8.2/ostream" 3
       
# 37 "/usr/include/c++/4.8.2/ostream" 3

# 1 "/usr/include/c++/4.8.2/ios" 1 3
# 36 "/usr/include/c++/4.8.2/ios" 3
       
# 37 "/usr/include/c++/4.8.2/ios" 3

# 1 "/usr/include/c++/4.8.2/iosfwd" 1 3
# 36 "/usr/include/c++/4.8.2/iosfwd" 3
       
# 37 "/usr/include/c++/4.8.2/iosfwd" 3


# 1 "/usr/include/c++/4.8.2/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/4.8.2/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/4.8.2/bits/stringfwd.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;


  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;


  typedef basic_string<wchar_t> wstring;
# 86 "/usr/include/c++/4.8.2/bits/stringfwd.h" 3

}
# 40 "/usr/include/c++/4.8.2/iosfwd" 2 3
# 1 "/usr/include/c++/4.8.2/bits/postypes.h" 1 3
# 38 "/usr/include/c++/4.8.2/bits/postypes.h" 3
       
# 39 "/usr/include/c++/4.8.2/bits/postypes.h" 3

# 1 "/usr/include/c++/4.8.2/cwchar" 1 3
# 39 "/usr/include/c++/4.8.2/cwchar" 3
       
# 40 "/usr/include/c++/4.8.2/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 39 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stdarg.h" 1 3 4
# 40 "/usr/include/wchar.h" 2 3 4
# 51 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 353 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 52 "/usr/include/wchar.h" 2 3 4
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;






# 132 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 306 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();








extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
__attribute__ ((__leaf__)) btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__leaf__)) mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 530 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 680 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 736 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 801 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 827 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 837 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 891 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/include/c++/4.8.2/cwchar" 2 3
# 62 "/usr/include/c++/4.8.2/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/4.8.2/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 232 "/usr/include/c++/4.8.2/cwchar" 3

}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/usr/include/c++/4.8.2/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 41 "/usr/include/c++/4.8.2/bits/postypes.h" 2 3
# 68 "/usr/include/c++/4.8.2/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/include/c++/4.8.2/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/include/c++/4.8.2/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/4.8.2/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/4.8.2/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline
   
# 216 "/usr/include/c++/4.8.2/bits/postypes.h" 3
   
# 215 "/usr/include/c++/4.8.2/bits/postypes.h" 3
           bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline
   
# 221 "/usr/include/c++/4.8.2/bits/postypes.h" 3
   
# 220 "/usr/include/c++/4.8.2/bits/postypes.h" 3
           bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 239 "/usr/include/c++/4.8.2/bits/postypes.h" 3

}
# 41 "/usr/include/c++/4.8.2/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/4.8.2/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/usr/include/c++/4.8.2/ios" 2 3

# 1 "/usr/include/c++/4.8.2/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/4.8.2/bits/char_traits.h" 3



# 1 "/usr/include/c++/4.8.2/cwchar" 1 3
# 39 "/usr/include/c++/4.8.2/cwchar" 3
       
# 40 "/usr/include/c++/4.8.2/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/include/c++/4.8.2/cwchar" 2 3
# 42 "/usr/include/c++/4.8.2/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static
     
# 96 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
     
# 95 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
                                bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static
     
# 100 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
     
# 99 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
                                bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static
     
# 130 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
     
# 129 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
                                bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 226 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static
     
# 246 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
     
# 245 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
                                bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static
     
# 250 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
     
# 249 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
                                bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static
     
# 288 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
     
# 287 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
                                bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static
     
# 317 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
     
# 316 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
                                bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static
     
# 321 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
     
# 320 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
                                bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static
     
# 357 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
     
# 356 "/usr/include/c++/4.8.2/bits/char_traits.h" 3
                                bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}
# 41 "/usr/include/c++/4.8.2/ios" 2 3
# 1 "/usr/include/c++/4.8.2/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/4.8.2/bits/localefwd.h" 3


# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++locale.h" 1 3
# 39 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++locale.h" 3
       
# 40 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++locale.h" 3

# 1 "/usr/include/c++/4.8.2/clocale" 1 3
# 39 "/usr/include/c++/4.8.2/clocale" 3
       
# 40 "/usr/include/c++/4.8.2/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 43 "/usr/include/c++/4.8.2/clocale" 2 3
# 51 "/usr/include/c++/4.8.2/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/include/c++/4.8.2/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/4.8.2/cctype" 1 3
# 39 "/usr/include/c++/4.8.2/cctype" 3
       
# 40 "/usr/include/c++/4.8.2/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 29 "/usr/include/ctype.h" 3 4
extern "C" {
# 47 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 80 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 105 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 272 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 348 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/include/c++/4.8.2/cctype" 2 3
# 62 "/usr/include/c++/4.8.2/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
# 43 "/usr/include/c++/4.8.2/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
   
   
# 59 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 58 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
   
   
# 68 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 67 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
   
   
# 72 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 71 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
   
   
# 76 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 75 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
   
   
# 80 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 79 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
   
   
# 84 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 83 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
   
   
# 88 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 87 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
   
   
# 92 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 91 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
   
   
# 96 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 95 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
   
   
# 100 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 99 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
   
   
# 104 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 103 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
   
   
# 108 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
   
# 107 "/usr/include/c++/4.8.2/bits/localefwd.h" 3
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;


namespace __gnu_cxx_ldbl128 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
}
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __gnu_cxx_ldbl128 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
# 42 "/usr/include/c++/4.8.2/ios" 2 3
# 1 "/usr/include/c++/4.8.2/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/4.8.2/bits/ios_base.h" 3

# 1 "/usr/include/c++/4.8.2/ext/atomicity.h" 1 3
# 32 "/usr/include/c++/4.8.2/ext/atomicity.h" 3
       
# 33 "/usr/include/c++/4.8.2/ext/atomicity.h" 3


# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr.h" 1 3
# 30 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr.h" 3
# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 1 3
# 35 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 42 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 73 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 119 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 202 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 43 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 117 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 32 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 33 "/usr/include/bits/setjmp.h" 2 3 4
# 43 "/usr/include/bits/setjmp.h" 3 4
typedef long int __jmp_buf[64] __attribute__ ((__aligned__ (16)));
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 113 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 154 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 189 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 227 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 485 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 497 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 531 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 733 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 797 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 879 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 991 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1035 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1102 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1136 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 36 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 2 3
# 47 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/include/c++/4.8.2/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/atomic_word.h" 1 3
# 28 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/include/c++/4.8.2/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/include/c++/4.8.2/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/include/c++/4.8.2/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/4.8.2/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3


# 1 "/usr/include/c++/4.8.2/string" 1 3
# 36 "/usr/include/c++/4.8.2/string" 3
       
# 37 "/usr/include/c++/4.8.2/string" 3







# 1 "/usr/include/c++/4.8.2/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/4.8.2/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/4.8.2/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/4.8.2/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/4.8.2/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/4.8.2/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/4.8.2/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/include/c++/4.8.2/string" 2 3



# 1 "/usr/include/c++/4.8.2/bits/stl_function.h" 1 3
# 59 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 100 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 139 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 203 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
     
     
# 207 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 206 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
     
     
# 216 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 215 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
     
     
# 225 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 224 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
     
     
# 234 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 233 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
     
     
# 243 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 242 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
     
     
# 252 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 251 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 267 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
     
     
# 271 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 270 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
     
     
# 280 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 279 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
     
     
# 289 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 288 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 350 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

     
     
# 362 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 361 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

     
     
# 386 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
     
# 385 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 421 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
# 508 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 541 "/usr/include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/4.8.2/backward/binders.h" 1 3
# 59 "/usr/include/c++/4.8.2/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 103 "/usr/include/c++/4.8.2/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
# 732 "/usr/include/c++/4.8.2/bits/stl_function.h" 2 3
# 49 "/usr/include/c++/4.8.2/string" 2 3


# 1 "/usr/include/c++/4.8.2/bits/range_access.h" 1 3
# 33 "/usr/include/c++/4.8.2/bits/range_access.h" 3
       
# 34 "/usr/include/c++/4.8.2/bits/range_access.h" 3
# 52 "/usr/include/c++/4.8.2/string" 2 3
# 1 "/usr/include/c++/4.8.2/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/4.8.2/bits/basic_string.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 111 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 148 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 173 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

       

# 191 "/usr/include/c++/4.8.2/bits/basic_string.h" 3

# 190 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

       

# 195 "/usr/include/c++/4.8.2/bits/basic_string.h" 3

# 194 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


     
     
# 345 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
     
# 344 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 483 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 531 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 564 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 604 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
# 710 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 739 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 752 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
# 775 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 796 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





     
     
# 811 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
     
# 810 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      bool
      empty() const
      { return this->size() == 0; }
# 825 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 842 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 863 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 882 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }
# 931 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
# 972 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
# 988 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 1020 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 1042 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1099 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1115 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1127 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1143 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1155 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 1184 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1200 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1232 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1254 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1277 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1295 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1318 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1336 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1361 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1377 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1397 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1428 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1450 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1475 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1495 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1519 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1537 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1556 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1577 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1598 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1621 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1697 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1779 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1789 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1799 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1832 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1845 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const

      { return this->find(__str.data(), __pos, __str.size()); }
# 1860 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1877 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const ;
# 1890 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const

      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1907 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1920 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1937 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const ;
# 1951 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const

      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1968 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1981 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2000 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 2015 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const

      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2032 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2045 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2064 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 2078 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const

      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2095 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2109 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2126 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 ;
# 2141 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const

      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2158 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2172 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2189 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 ;
# 2205 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2224 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2256 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2282 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2300 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2324 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2351 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2363 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2484 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2486 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2485 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2507 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2506 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2519 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2518 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2530 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2532 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2531 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2544 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2543 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2556 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2555 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2567 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2569 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2568 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2581 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2580 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2593 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2592 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2604 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2606 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2605 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2618 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2617 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2630 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2629 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2641 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2643 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2642 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2655 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2654 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2667 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2666 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2678 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2680 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2679 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2692 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2691 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline
   
# 2704 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
   
# 2703 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
           bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2715 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2733 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2751 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2774 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2791 "/usr/include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}
# 53 "/usr/include/c++/4.8.2/string" 2 3
# 1 "/usr/include/c++/4.8.2/bits/basic_string.tcc" 1 3
# 40 "/usr/include/c++/4.8.2/bits/basic_string.tcc" 3
       
# 41 "/usr/include/c++/4.8.2/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
# 240 "/usr/include/c++/4.8.2/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
      
                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 577 "/usr/include/c++/4.8.2/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/usr/include/c++/4.8.2/string" 2 3
# 41 "/usr/include/c++/4.8.2/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend
     
# 79 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
     
# 78 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
             bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 164 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 177 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 191 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 206 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 225 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
   
   
# 226 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
   
# 225 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







   
   
# 235 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
   
# 234 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 253 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
     
     
# 255 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
     
# 254 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 269 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 304 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 338 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 369 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 436 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend
     
# 448 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
     
# 447 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
             bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend
     
# 484 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
     
# 483 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
             bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

   
   
# 539 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
   
# 538 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 583 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 610 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 624 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 641 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 660 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 674 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 703 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 717 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 730 "/usr/include/c++/4.8.2/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
   
   
# 80 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
   
# 79 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
  template<typename _Facet>
   
   
# 104 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
   
# 103 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
   
   
# 279 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
   
# 278 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
   
   
# 291 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
   
# 290 "/usr/include/c++/4.8.2/bits/locale_classes.tcc" 3
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 788 "/usr/include/c++/4.8.2/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/4.8.2/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 199 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 255 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 330 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 361 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 393 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 419 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 436 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 448 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 561 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 577 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 594 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 620 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 671 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    static
   
# 672 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
   
# 671 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
           bool
    sync_with_stdio(bool __sync = true);
# 683 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 694 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 705 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 724 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 740 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 761 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 778 "/usr/include/c++/4.8.2/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


}
# 43 "/usr/include/c++/4.8.2/ios" 2 3
# 1 "/usr/include/c++/4.8.2/streambuf" 1 3
# 36 "/usr/include/c++/4.8.2/streambuf" 3
       
# 37 "/usr/include/c++/4.8.2/streambuf" 3
# 45 "/usr/include/c++/4.8.2/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "/usr/include/c++/4.8.2/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/include/c++/4.8.2/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/include/c++/4.8.2/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/include/c++/4.8.2/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "/usr/include/c++/4.8.2/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "/usr/include/c++/4.8.2/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "/usr/include/c++/4.8.2/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "/usr/include/c++/4.8.2/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "/usr/include/c++/4.8.2/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "/usr/include/c++/4.8.2/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "/usr/include/c++/4.8.2/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "/usr/include/c++/4.8.2/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "/usr/include/c++/4.8.2/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "/usr/include/c++/4.8.2/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "/usr/include/c++/4.8.2/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "/usr/include/c++/4.8.2/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "/usr/include/c++/4.8.2/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "/usr/include/c++/4.8.2/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "/usr/include/c++/4.8.2/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "/usr/include/c++/4.8.2/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "/usr/include/c++/4.8.2/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "/usr/include/c++/4.8.2/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "/usr/include/c++/4.8.2/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "/usr/include/c++/4.8.2/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "/usr/include/c++/4.8.2/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "/usr/include/c++/4.8.2/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "/usr/include/c++/4.8.2/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "/usr/include/c++/4.8.2/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "/usr/include/c++/4.8.2/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "/usr/include/c++/4.8.2/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "/usr/include/c++/4.8.2/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "/usr/include/c++/4.8.2/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "/usr/include/c++/4.8.2/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "/usr/include/c++/4.8.2/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "/usr/include/c++/4.8.2/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:


      basic_streambuf(const basic_streambuf& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_end),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      basic_streambuf&
      operator=(const basic_streambuf& __sb)
      {
 _M_in_beg = __sb._M_in_beg;
 _M_in_cur = __sb._M_in_cur;
 _M_in_end = __sb._M_in_end;
 _M_out_beg = __sb._M_out_beg;
 _M_out_cur = __sb._M_out_cur;
 _M_out_end = __sb._M_out_end;
 _M_buf_locale = __sb._M_buf_locale;
 return *this;
      };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

# 1 "/usr/include/c++/4.8.2/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/4.8.2/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/4.8.2/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 839 "/usr/include/c++/4.8.2/streambuf" 2 3
# 44 "/usr/include/c++/4.8.2/ios" 2 3
# 1 "/usr/include/c++/4.8.2/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3



# 1 "/usr/include/c++/4.8.2/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3

# 1 "/usr/include/c++/4.8.2/cwctype" 1 3
# 39 "/usr/include/c++/4.8.2/cwctype" 3
       
# 40 "/usr/include/c++/4.8.2/cwctype" 3
# 50 "/usr/include/c++/4.8.2/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 33 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 34 "/usr/include/wctype.h" 2 3 4
# 49 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 71 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 171 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 213 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 51 "/usr/include/c++/4.8.2/cwctype" 2 3
# 80 "/usr/include/c++/4.8.2/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/4.8.2/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.8.2/cctype" 1 3
# 39 "/usr/include/c++/4.8.2/cctype" 3
       
# 40 "/usr/include/c++/4.8.2/cctype" 3
# 41 "/usr/include/c++/4.8.2/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/ctype_base.h" 1 3
# 36 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };


}
# 42 "/usr/include/c++/4.8.2/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,




        _CharT&>

    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }
# 112 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





     
     
# 172 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
     
# 171 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

     
     
# 195 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
     
# 194 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline
   
# 204 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
   
# 203 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
           bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline
   
# 210 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
   
# 209 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
           bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


     
     
# 275 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
     
# 274 "/usr/include/c++/4.8.2/bits/streambuf_iterator.h" 3
      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "/usr/include/c++/4.8.2/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 142 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 161 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
     
     
# 162 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
     
# 161 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 178 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 194 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 210 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 224 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 239 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 253 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 268 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 285 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 304 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 323 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 345 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 370 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual
     
# 371 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
     
# 370 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
              bool
      do_is(mask __m, char_type __c) const = 0;
# 389 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 408 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 427 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 445 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 462 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 478 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 495 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 514 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 535 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 556 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 581 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 604 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual
     
# 623 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
     
# 622 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
              bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 673 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 710 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 723 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 736 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      inline
     
# 737 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
     
# 736 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
             bool
      is(mask __m, char __c) const;
# 751 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 765 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 779 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 794 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 811 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 827 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 844 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 864 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 891 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 922 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 955 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1004 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1021 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1037 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1054 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1074 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1097 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1123 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }
# 1149 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1174 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1207 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1218 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1242 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual
     
# 1243 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
     
# 1242 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
              bool
      do_is(mask __m, char_type __c) const;
# 1261 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1279 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1297 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1314 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1331 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1347 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1364 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1384 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1406 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1429 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1455 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


 
 
# 42 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/ctype_inline.h" 3
 
# 41 "/usr/include/c++/4.8.2/ppc64le-redhat-linux/bits/ctype_inline.h" 3
  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1512 "/usr/include/c++/4.8.2/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1640 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1678 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1692 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1706 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1719 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1750 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1763 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1776 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1793 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1805 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1818 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1831 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1844 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };

namespace __gnu_cxx_ldbl128 {
# 1914 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1935 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1961 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1998 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2058 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2101 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2172 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;



      virtual iter_type
      __do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
        double&) const;






      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;



      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2253 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2274 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2292 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2334 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2397 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2422 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2470 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;



      virtual iter_type
      __do_put(iter_type, ios_base&, char_type, double) const;





      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;



      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;

}







  template<typename _CharT>
    inline
   
# 2530 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2529 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline
   
# 2536 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2535 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline
   
# 2542 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2541 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline
   
# 2548 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2547 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline
   
# 2554 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2553 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline
   
# 2560 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2559 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline
   
# 2566 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2565 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline
   
# 2572 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2571 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline
   
# 2578 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2577 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline
   
# 2584 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2583 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline
   
# 2590 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
   
# 2589 "/usr/include/c++/4.8.2/bits/locale_facets.h" 3
           bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 136 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__))
 
# 137 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
 
# 136 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
                bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();

namespace __gnu_cxx_ldbl128 {

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    __do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }

}

  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }

namespace __gnu_cxx_ldbl128 {

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 966 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1027 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    __do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }

}
# 1189 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class __gnu_cxx_ldbl128:: num_get<char>;
  extern template class __gnu_cxx_ldbl128:: num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
   
   
# 1302 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
   
# 1301 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
   
   
# 1306 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
   
# 1305 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
   
   
# 1310 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
   
# 1309 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
   
   
# 1314 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
   
# 1313 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class __gnu_cxx_ldbl128:: num_get<wchar_t>;
  extern template class __gnu_cxx_ldbl128:: num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
   
   
# 1341 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
   
# 1340 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
   
   
# 1345 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
   
# 1344 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
   
   
# 1349 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
   
# 1348 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
   
   
# 1353 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
   
# 1352 "/usr/include/c++/4.8.2/bits/locale_facets.tcc" 3
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2609 "/usr/include/c++/4.8.2/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/4.8.2/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 65 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

     
     
# 119 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
     
# 118 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      bool
      operator!() const
      { return this->fail(); }
# 130 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 141 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







     
     
# 174 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
     
# 173 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      bool
      good() const
      { return this->rdstate() == 0; }







     
     
# 184 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
     
# 183 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 194 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
     
     
# 195 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
     
# 194 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







     
     
# 205 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
     
# 204 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 215 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 250 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 288 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 300 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 340 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 354 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 383 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 403 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 423 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 442 "/usr/include/c++/4.8.2/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/4.8.2/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/4.8.2/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/4.8.2/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/4.8.2/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 476 "/usr/include/c++/4.8.2/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/4.8.2/ios" 2 3
# 39 "/usr/include/c++/4.8.2/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/include/c++/4.8.2/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/usr/include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/usr/include/c++/4.8.2/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/usr/include/c++/4.8.2/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/usr/include/c++/4.8.2/ostream" 3
      __ostream_type&
      flush();
# 357 "/usr/include/c++/4.8.2/ostream" 3
      pos_type
      tellp();
# 368 "/usr/include/c++/4.8.2/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/usr/include/c++/4.8.2/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 399 "/usr/include/c++/4.8.2/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 418 "/usr/include/c++/4.8.2/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 428 "/usr/include/c++/4.8.2/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 449 "/usr/include/c++/4.8.2/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 469 "/usr/include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 511 "/usr/include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 562 "/usr/include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 574 "/usr/include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 609 "/usr/include/c++/4.8.2/ostream" 3

}

# 1 "/usr/include/c++/4.8.2/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/4.8.2/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/4.8.2/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 613 "/usr/include/c++/4.8.2/ostream" 2 3
# 65 "/usr/include/c++/4.8.2/iterator" 2 3
# 1 "/usr/include/c++/4.8.2/istream" 1 3
# 36 "/usr/include/c++/4.8.2/istream" 3
       
# 37 "/usr/include/c++/4.8.2/istream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/include/c++/4.8.2/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/include/c++/4.8.2/istream" 3
      int_type
      get();
# 315 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/include/c++/4.8.2/istream" 3
      int_type
      peek();
# 485 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/include/c++/4.8.2/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      unget();
# 555 "/usr/include/c++/4.8.2/istream" 3
      int
      sync();
# 570 "/usr/include/c++/4.8.2/istream" 3
      pos_type
      tellg();
# 585 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/include/c++/4.8.2/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 656 "/usr/include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 692 "/usr/include/c++/4.8.2/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 705 "/usr/include/c++/4.8.2/istream" 3
      operator bool() const
      { return _M_ok; }
    };
# 721 "/usr/include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 763 "/usr/include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 794 "/usr/include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 854 "/usr/include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 879 "/usr/include/c++/4.8.2/istream" 3

}

# 1 "/usr/include/c++/4.8.2/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/4.8.2/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/4.8.2/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 513 "/usr/include/c++/4.8.2/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 883 "/usr/include/c++/4.8.2/istream" 2 3
# 66 "/usr/include/c++/4.8.2/iterator" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 1 3
# 33 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3
       
# 34 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

     
     
# 111 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3
     
# 110 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3
      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline
   
# 130 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3
   
# 129 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3
           bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline
   
# 137 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3
   
# 136 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3
           bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 152 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 183 "/usr/include/c++/4.8.2/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };




}
# 67 "/usr/include/c++/4.8.2/iterator" 2 3
# 41 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h" 2

namespace thrust
{
# 64 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
struct input_device_iterator_tag
  : thrust::detail::iterator_category_with_system_and_traversal<
      std::input_iterator_tag,
      thrust::device_system_tag,
      thrust::single_pass_traversal_tag
    >
{};
# 83 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
struct output_device_iterator_tag
  : thrust::detail::iterator_category_with_system_and_traversal<
      std::output_iterator_tag,
      thrust::device_system_tag,
      thrust::single_pass_traversal_tag
    >
{};
# 102 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
struct forward_device_iterator_tag
  : thrust::detail::iterator_category_with_system_and_traversal<
      std::forward_iterator_tag,
      thrust::device_system_tag,
      thrust::forward_traversal_tag
    >
{};
# 121 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
struct bidirectional_device_iterator_tag
  : thrust::detail::iterator_category_with_system_and_traversal<
      std::bidirectional_iterator_tag,
      thrust::device_system_tag,
      thrust::bidirectional_traversal_tag
    >
{};
# 140 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
struct random_access_device_iterator_tag
  : thrust::detail::iterator_category_with_system_and_traversal<
      std::random_access_iterator_tag,
      thrust::device_system_tag,
      thrust::random_access_traversal_tag
    >
{};
# 160 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
typedef std::input_iterator_tag input_host_iterator_tag;
# 174 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
typedef std::output_iterator_tag output_host_iterator_tag;
# 188 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
typedef std::forward_iterator_tag forward_host_iterator_tag;
# 202 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
typedef std::bidirectional_iterator_tag bidirectional_host_iterator_tag;
# 216 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h"
typedef std::random_access_iterator_tag random_access_host_iterator_tag;




}

# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/universal_categories.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/universal_categories.h"
       






namespace thrust
{



struct input_universal_iterator_tag
{
  operator input_host_iterator_tag () {return input_host_iterator_tag();}

  operator input_device_iterator_tag () {return input_device_iterator_tag();}
};

struct output_universal_iterator_tag
{
  operator output_host_iterator_tag () {return output_host_iterator_tag();}

  operator output_device_iterator_tag () {return output_device_iterator_tag();}
};

struct forward_universal_iterator_tag
  : input_universal_iterator_tag
{
  operator forward_host_iterator_tag () {return forward_host_iterator_tag();};

  operator forward_device_iterator_tag () {return forward_device_iterator_tag();};
};

struct bidirectional_universal_iterator_tag
  : forward_universal_iterator_tag
{
  operator bidirectional_host_iterator_tag () {return bidirectional_host_iterator_tag();};

  operator bidirectional_device_iterator_tag () {return bidirectional_device_iterator_tag();};
};


namespace detail
{


template<typename T>
struct one_degree_of_separation
  : T
{
};

}


struct random_access_universal_iterator_tag
{

  operator random_access_host_iterator_tag () {return random_access_host_iterator_tag();};

  operator random_access_device_iterator_tag () {return random_access_device_iterator_tag();};


  operator detail::one_degree_of_separation<bidirectional_universal_iterator_tag> () {return detail::one_degree_of_separation<bidirectional_universal_iterator_tag>();}

};


}
# 224 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_categories.h" 2
# 25 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_facade_category.h" 2

# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/is_iterator_category.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/is_iterator_category.h"
       





namespace thrust
{

namespace detail
{

template <typename T>
  struct is_host_iterator_category
    : thrust::detail::or_<
        thrust::detail::is_convertible<T, thrust::input_host_iterator_tag>,
        thrust::detail::is_convertible<T, thrust::output_host_iterator_tag>
      >
{
};

template <typename T>
  struct is_device_iterator_category
    : thrust::detail::or_<
        thrust::detail::is_convertible<T, thrust::input_device_iterator_tag>,
        thrust::detail::is_convertible<T, thrust::output_device_iterator_tag>
      >
{
};


template <typename T>
  struct is_iterator_category
    : thrust::detail::or_<
        is_host_iterator_category<T>,
        is_device_iterator_category<T>
      >
{
};

}

}
# 27 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_facade_category.h" 2

# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_category_to_traversal.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_category_to_traversal.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_category_to_system.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_category_to_system.h"
       
# 27 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_category_to_system.h"
namespace thrust
{

namespace detail
{


template <typename> struct is_iterator_system;

template <typename> struct device_iterator_category_to_backend_system;



template<typename Category>
  struct iterator_category_to_system

    : eval_if<
        or_<
          is_convertible<Category, thrust::input_host_iterator_tag>,
          is_convertible<Category, thrust::output_host_iterator_tag>
        >::value,

        detail::identity_<thrust::host_system_tag>,


        eval_if<
          or_<
            is_convertible<Category, thrust::input_device_iterator_tag>,
            is_convertible<Category, thrust::output_device_iterator_tag>
          >::value,

          detail::identity_<thrust::device_system_tag>,


          detail::identity_<void>
        >
      >
{
};


template<typename CategoryOrTraversal>
  struct iterator_category_or_traversal_to_system
    : eval_if<
        is_iterator_system<CategoryOrTraversal>::value,
        detail::identity_<CategoryOrTraversal>,
        iterator_category_to_system<CategoryOrTraversal>
      >
{
};

}
}
# 23 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_category_to_traversal.h" 2


namespace thrust
{

namespace detail
{


template <typename> struct is_iterator_system;
template <typename> struct is_iterator_traversal;


using namespace thrust::detail;

template <typename Category>
  struct host_system_category_to_traversal
    : eval_if<
        is_convertible<Category, random_access_host_iterator_tag>::value,
        detail::identity_<random_access_traversal_tag>,
        eval_if<
          is_convertible<Category, bidirectional_host_iterator_tag>::value,
          detail::identity_<bidirectional_traversal_tag>,
          eval_if<
            is_convertible<Category, forward_host_iterator_tag>::value,
            detail::identity_<forward_traversal_tag>,
            eval_if<
              is_convertible<Category, input_host_iterator_tag>::value,
              detail::identity_<single_pass_traversal_tag>,
              eval_if<
                is_convertible<Category, output_host_iterator_tag>::value,
                detail::identity_<incrementable_traversal_tag>,
                void
              >
            >
          >
        >
      >
{
};



template <typename Category>
  struct device_system_category_to_traversal
    : eval_if<
        is_convertible<Category, random_access_device_iterator_tag>::value,
        detail::identity_<random_access_traversal_tag>,
        eval_if<
          is_convertible<Category, bidirectional_device_iterator_tag>::value,
          detail::identity_<bidirectional_traversal_tag>,
          eval_if<
            is_convertible<Category, forward_device_iterator_tag>::value,
            detail::identity_<forward_traversal_tag>,
            eval_if<
              is_convertible<Category, input_device_iterator_tag>::value,
              detail::identity_<single_pass_traversal_tag>,
              eval_if<
                is_convertible<Category, output_device_iterator_tag>::value,
                detail::identity_<incrementable_traversal_tag>,
                void
              >
            >
          >
        >
      >
{
};


template<typename Category>
  struct category_to_traversal

    : eval_if<
        or_<
          is_convertible<Category, thrust::input_host_iterator_tag>,
          is_convertible<Category, thrust::output_host_iterator_tag>
        >::value,

        host_system_category_to_traversal<Category>,


        eval_if<
          or_<
            is_convertible<Category, thrust::input_device_iterator_tag>,
            is_convertible<Category, thrust::output_device_iterator_tag>
          >::value,

          device_system_category_to_traversal<Category>,


          void
        >
      >
{};


template <typename CategoryOrTraversal>
  struct iterator_category_to_traversal
    : eval_if<
        is_iterator_traversal<CategoryOrTraversal>::value,
        detail::identity_<CategoryOrTraversal>,
        category_to_traversal<CategoryOrTraversal>
      >
{
};


}

}
# 29 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_facade_category.h" 2

namespace thrust
{

namespace detail
{
# 81 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_facade_category.h"
template<typename System, typename Traversal, typename ValueParam, typename Reference>
  struct iterator_facade_default_category;
# 95 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_facade_category.h"
template<typename Traversal, typename ValueParam, typename Reference>
  struct iterator_facade_default_category_std :
    thrust::detail::eval_if<
      thrust::detail::is_convertible<Traversal, thrust::forward_traversal_tag>::value,
      thrust::detail::eval_if<
        thrust::detail::is_convertible<Traversal, thrust::random_access_traversal_tag>::value,
        thrust::detail::identity_<std::random_access_iterator_tag>,
        thrust::detail::eval_if<
          thrust::detail::is_convertible<Traversal, thrust::bidirectional_traversal_tag>::value,
          thrust::detail::identity_<std::bidirectional_iterator_tag>,
          thrust::detail::identity_<std::forward_iterator_tag>
        >
      >,
      thrust::detail::eval_if<
        thrust::detail::is_convertible<Traversal, thrust::single_pass_traversal_tag>::value,
        thrust::detail::identity_<std::input_iterator_tag>,
        thrust::detail::identity_<Traversal>
      >
    >
{
};



template<typename Traversal, typename ValueParam, typename Reference>
  struct iterator_facade_default_category_host :
    thrust::detail::eval_if<
      thrust::detail::is_convertible<Traversal, thrust::forward_traversal_tag>::value,
      thrust::detail::eval_if<
        thrust::detail::is_convertible<Traversal, thrust::random_access_traversal_tag>::value,
        thrust::detail::identity_<thrust::random_access_host_iterator_tag>,
        thrust::detail::eval_if<
          thrust::detail::is_convertible<Traversal, thrust::bidirectional_traversal_tag>::value,
          thrust::detail::identity_<thrust::bidirectional_host_iterator_tag>,
          thrust::detail::identity_<thrust::forward_host_iterator_tag>
        >
      >,
      thrust::detail::eval_if<
        thrust::detail::is_convertible<Traversal, thrust::single_pass_traversal_tag>::value,
        thrust::detail::identity_<thrust::input_host_iterator_tag>,
        thrust::detail::identity_<Traversal>
      >
    >
{
};



template<typename Traversal, typename ValueParam, typename Reference>
  struct iterator_facade_default_category_device :
    thrust::detail::eval_if<
      thrust::detail::is_convertible<Traversal, thrust::forward_traversal_tag>::value,
      thrust::detail::eval_if<
        thrust::detail::is_convertible<Traversal, thrust::random_access_traversal_tag>::value,
        thrust::detail::identity_<thrust::random_access_device_iterator_tag>,
        thrust::detail::eval_if<
          thrust::detail::is_convertible<Traversal, thrust::bidirectional_traversal_tag>::value,
          thrust::detail::identity_<thrust::bidirectional_device_iterator_tag>,
          thrust::detail::identity_<thrust::forward_device_iterator_tag>
        >
      >,
      thrust::detail::eval_if<
        thrust::detail::is_convertible<Traversal, thrust::single_pass_traversal_tag>::value,
        thrust::detail::identity_<thrust::input_device_iterator_tag>,
        thrust::detail::identity_<Traversal>
      >
    >
{
};



template<typename Traversal, typename ValueParam, typename Reference>
  struct iterator_facade_default_category_any
{
  typedef thrust::detail::iterator_category_with_system_and_traversal<
    typename iterator_facade_default_category_std<Traversal, ValueParam, Reference>::type,
    thrust::any_system_tag,
    Traversal
  > type;
};


template<typename System, typename Traversal, typename ValueParam, typename Reference>
  struct iterator_facade_default_category

    : thrust::detail::eval_if<
        thrust::detail::is_convertible<System, thrust::any_system_tag>::value,
        iterator_facade_default_category_any<Traversal, ValueParam, Reference>,


        thrust::detail::eval_if<
          thrust::detail::is_convertible<System, thrust::host_system_tag>::value,
          iterator_facade_default_category_host<Traversal, ValueParam, Reference>,


          thrust::detail::eval_if<
            thrust::detail::is_convertible<System, thrust::device_system_tag>::value,
            iterator_facade_default_category_device<Traversal, ValueParam, Reference>,



            thrust::detail::identity_<
              thrust::detail::iterator_category_with_system_and_traversal<
                typename iterator_facade_default_category_std<Traversal, ValueParam, Reference>::type,
                System,
                Traversal
              >
            >
          >
        >
      >
{};


template<typename System, typename Traversal, typename ValueParam, typename Reference>
  struct iterator_facade_category_impl
{
  typedef typename iterator_facade_default_category<
    System,Traversal,ValueParam,Reference
  >::type category;



  typedef typename thrust::detail::eval_if<
    thrust::detail::and_<
      thrust::detail::is_same<
        Traversal,
        typename thrust::detail::iterator_category_to_traversal<category>::type
      >,
      thrust::detail::is_same<
        System,
        typename thrust::detail::iterator_category_to_system<category>::type
      >
    >::value,
    thrust::detail::identity_<category>,
    thrust::detail::identity_<thrust::detail::iterator_category_with_system_and_traversal<category,System,Traversal> >
  >::type type;
};


template<typename CategoryOrSystem,
         typename CategoryOrTraversal,
         typename ValueParam,
         typename Reference>
  struct iterator_facade_category
{
  typedef typename
  thrust::detail::eval_if<
    thrust::detail::is_iterator_category<CategoryOrTraversal>::value,
    thrust::detail::identity_<CategoryOrTraversal>,
    iterator_facade_category_impl<CategoryOrSystem, CategoryOrTraversal, ValueParam, Reference>
  >::type type;
};


}
}
# 38 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/distance_from_result.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/distance_from_result.h"
       




namespace thrust
{

namespace detail
{



template<typename IteratorFacade1, typename IteratorFacade2>
  struct distance_from_result
    : eval_if<
        is_convertible<IteratorFacade2,IteratorFacade1>::value,
        identity_<typename IteratorFacade1::difference_type>,
        identity_<typename IteratorFacade2::difference_type>
      >
{};

}

}
# 39 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h" 2

namespace thrust
{
# 55 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
template<typename Derived, typename Value, typename System, typename Traversal, typename Reference, typename Difference> class iterator_facade;





class iterator_core_access
{




    template<typename Derived, typename Value, typename System, typename Traversal, typename Reference, typename Difference> friend class iterator_facade;


    template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
              typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
    inline __attribute__((host)) __attribute__((device))
    friend
   
# 74 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
   
# 73 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
           bool
    operator ==(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
                iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs);

    template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
              typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
    inline __attribute__((host)) __attribute__((device))
    friend
   
# 81 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
   
# 80 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
           bool
    operator !=(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
                iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs);

    template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
              typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
    inline __attribute__((host)) __attribute__((device))
    friend
   
# 88 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
   
# 87 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
           bool
    operator <(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
               iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs);

    template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
              typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
    inline __attribute__((host)) __attribute__((device))
    friend
   
# 95 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
   
# 94 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
           bool
    operator >(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
               iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs);

    template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
              typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
    inline __attribute__((host)) __attribute__((device))
    friend
   
# 102 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
   
# 101 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
           bool
    operator <=(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
                iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs);

    template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
              typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
    inline __attribute__((host)) __attribute__((device))
    friend
   
# 109 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
   
# 108 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
           bool
    operator >=(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
                iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs);


    template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
              typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
    inline __attribute__((host)) __attribute__((device))
    friend
      typename thrust::detail::distance_from_result<
        iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1>,
        iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2>
      >::type
    operator-(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
              iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs);

    template<typename Facade>
    __attribute__((host)) __attribute__((device))
    static typename Facade::reference dereference(Facade const& f)
    {
      return f.dereference();
    }

    template<typename Facade>
    __attribute__((host)) __attribute__((device))
    static void increment(Facade& f)
    {
      f.increment();
    }

    template<typename Facade>
    __attribute__((host)) __attribute__((device))
    static void decrement(Facade& f)
    {
      f.decrement();
    }

    template <class Facade1, class Facade2>
    __attribute__((host)) __attribute__((device))
    static bool equal(Facade1 const& f1, Facade2 const& f2)
    {
      return f1.equal(f2);
    }
# 167 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
    template <class Facade>
    __attribute__((host)) __attribute__((device))
    static void advance(Facade& f, typename Facade::difference_type n)
    {
      f.advance(n);
    }



    template <class Facade1, class Facade2>
    __attribute__((host)) __attribute__((device))
    static typename Facade1::difference_type
      distance_from(Facade1 const& f1, Facade2 const& f2, thrust::detail::true_type)
    {
      return -f1.distance_to(f2);
    }



    template <class Facade1, class Facade2>
    __attribute__((host)) __attribute__((device))
    static typename Facade2::difference_type
      distance_from(Facade1 const& f1, Facade2 const& f2, thrust::detail::false_type)
    {
      return f2.distance_to(f1);
    }

    template <class Facade1, class Facade2>
    __attribute__((host)) __attribute__((device))
    static typename thrust::detail::distance_from_result<Facade1,Facade2>::type
      distance_from(Facade1 const& f1, Facade2 const& f2)
    {


      return distance_from(f1, f2,
        typename thrust::detail::is_convertible<Facade2,Facade1>::type());
    }




    template <typename Derived, typename Value, typename System, typename Traversal, typename Reference, typename Difference>
    __attribute__((host)) __attribute__((device))
    static Derived& derived(iterator_facade<Derived,Value,System,Traversal,Reference,Difference>& facade)
    {
      return *static_cast<Derived*>(&facade);
    }

    template <typename Derived, typename Value, typename System, typename Traversal, typename Reference, typename Difference>
    __attribute__((host)) __attribute__((device))
    static Derived const& derived(iterator_facade<Derived,Value,System,Traversal,Reference,Difference> const& facade)
    {
      return *static_cast<Derived const*>(&facade);
    }



};
# 246 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
template<typename Derived,
         typename Value,
         typename System,
         typename Traversal,
         typename Reference,
         typename Difference = std::ptrdiff_t>
  class iterator_facade
{
  private:






    __attribute__((host)) __attribute__((device))
    Derived& derived()
    {
      return *static_cast<Derived*>(this);
    }

    __attribute__((host)) __attribute__((device))
    Derived const& derived() const
    {
      return *static_cast<Derived const*>(this);
    }



  public:


    typedef typename thrust::detail::remove_const<Value>::type value_type;



    typedef Reference reference;
# 291 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
    typedef void pointer;




    typedef Difference difference_type;



    typedef typename thrust::detail::iterator_facade_category<
      System, Traversal, Value, Reference
    >::type iterator_category;




    __attribute__((host)) __attribute__((device))
    reference operator*() const
    {
      return iterator_core_access::dereference(this->derived());
    }
# 325 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
    __attribute__((host)) __attribute__((device))
    reference operator[](difference_type n) const
    {
      return *(this->derived() + n);
    }




    __attribute__((host)) __attribute__((device))
    Derived& operator++()
    {
      iterator_core_access::increment(this->derived());
      return this->derived();
    }




    __attribute__((host)) __attribute__((device))
    Derived operator++(int)
    {
      Derived tmp(this->derived());
      ++*this;
      return tmp;
    }




    __attribute__((host)) __attribute__((device))
    Derived& operator--()
    {
      iterator_core_access::decrement(this->derived());
      return this->derived();
    }




    __attribute__((host)) __attribute__((device))
    Derived operator--(int)
    {
      Derived tmp(this->derived());
      --*this;
      return tmp;
    }





    __attribute__((host)) __attribute__((device))
    Derived& operator+=(difference_type n)
    {
      iterator_core_access::advance(this->derived(), n);
      return this->derived();
    }





    __attribute__((host)) __attribute__((device))
    Derived& operator-=(difference_type n)
    {
      iterator_core_access::advance(this->derived(), -n);
      return this->derived();
    }





    __attribute__((host)) __attribute__((device))
    Derived operator-(difference_type n) const
    {
      Derived result(this->derived());
      return result -= n;
    }
};





template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
          typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
inline __attribute__((host)) __attribute__((device))




# 416 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
 bool
operator ==(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
            iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs)
{
  return iterator_core_access
    ::equal(*static_cast<Derived1 const*>(&lhs),
            *static_cast<Derived2 const*>(&rhs));
}

template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
          typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
inline __attribute__((host)) __attribute__((device))




# 430 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
 bool
operator !=(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
            iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs)
{
  return !iterator_core_access
    ::equal(*static_cast<Derived1 const*>(&lhs),
            *static_cast<Derived2 const*>(&rhs));
}

template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
          typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
inline __attribute__((host)) __attribute__((device))




# 444 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
 bool
operator <(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
           iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs)
{
  return 0 > iterator_core_access
    ::distance_from(*static_cast<Derived1 const*>(&lhs),
                    *static_cast<Derived2 const*>(&rhs));
}

template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
          typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
inline __attribute__((host)) __attribute__((device))




# 458 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
 bool
operator >(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
           iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs)
{
  return 0 < iterator_core_access
    ::distance_from(*static_cast<Derived1 const*>(&lhs),
                    *static_cast<Derived2 const*>(&rhs));
}

template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
          typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
inline __attribute__((host)) __attribute__((device))




# 472 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
 bool
operator <=(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
            iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs)
{
  return 0 >= iterator_core_access
    ::distance_from(*static_cast<Derived1 const*>(&lhs),
                    *static_cast<Derived2 const*>(&rhs));
}

template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
          typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
inline __attribute__((host)) __attribute__((device))




# 486 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
 bool
operator >=(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
            iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs)
{
  return 0 <= iterator_core_access
    ::distance_from(*static_cast<Derived1 const*>(&lhs),
                    *static_cast<Derived2 const*>(&rhs));
}


template <typename Derived1, typename Value1, typename System1, typename Traversal1, typename Reference1, typename Difference1,
          typename Derived2, typename Value2, typename System2, typename Traversal2, typename Reference2, typename Difference2>
inline __attribute__((host)) __attribute__((device))


typename thrust::detail::distance_from_result<
  iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1>,
  iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2>
>::type

operator-(iterator_facade<Derived1,Value1,System1,Traversal1,Reference1,Difference1> const& lhs,
          iterator_facade<Derived2,Value2,System2,Traversal2,Reference2,Difference2> const& rhs)
{
  return iterator_core_access
    ::distance_from(*static_cast<Derived1 const*>(&lhs),
                    *static_cast<Derived2 const*>(&rhs));
}


template <typename Derived, typename Value, typename System, typename Traversal, typename Reference, typename Difference>
inline __attribute__((host)) __attribute__((device))
Derived operator+ (iterator_facade<Derived,Value,System,Traversal,Reference,Difference> const& i,
                   typename Derived::difference_type n)
{
  Derived tmp(static_cast<Derived const&>(i));
  return tmp += n;
}

template <typename Derived, typename Value, typename System, typename Traversal, typename Reference, typename Difference>
inline __attribute__((host)) __attribute__((device))
Derived operator+ (typename Derived::difference_type n,
                   iterator_facade<Derived,Value,System,Traversal,Reference,Difference> const& i)
{
  Derived tmp(static_cast<Derived const&>(i));
  return tmp += n;
}
# 542 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_facade.h"
}
# 37 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_adaptor.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/use_default.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/use_default.h"
       



namespace thrust
{

struct use_default {};

}
# 38 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_adaptor.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_adaptor_base.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_adaptor_base.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_traits.h" 1
# 31 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_traits.h"
       




namespace thrust
{




template<typename T>
  struct iterator_traits
{
  typedef typename T::difference_type difference_type;
  typedef typename T::value_type value_type;
  typedef typename T::pointer pointer;
  typedef typename T::reference reference;
  typedef typename T::iterator_category iterator_category;
};


template<typename T>
  struct iterator_traits<T*>
{
  typedef std::ptrdiff_t difference_type;
  typedef T value_type;
  typedef T* pointer;
  typedef T& reference;
  typedef std::random_access_iterator_tag iterator_category;
};

template<typename T>
  struct iterator_traits<const T*>
{
  typedef std::ptrdiff_t difference_type;
  typedef T value_type;
  typedef const T* pointer;
  typedef const T& reference;
  typedef std::random_access_iterator_tag iterator_category;
};

template<typename Iterator> struct iterator_value;

template<typename Iterator> struct iterator_pointer;

template<typename Iterator> struct iterator_reference;

template<typename Iterator> struct iterator_difference;

template<typename Iterator> struct iterator_traversal;

template<typename Iterator> struct iterator_system;


template<typename Iterator>
  struct __attribute__ ((deprecated)) iterator_space
{
  typedef __attribute__ ((deprecated)) typename iterator_system<Iterator>::type type;
};


}





# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_traits.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_traits.inl"
namespace thrust
{

template<typename Iterator>
  struct iterator_value
{
  typedef typename thrust::iterator_traits<Iterator>::value_type type;
};


template<typename Iterator>
  struct iterator_pointer
{
  typedef typename thrust::iterator_traits<Iterator>::pointer type;
};


template<typename Iterator>
  struct iterator_reference
{
  typedef typename iterator_traits<Iterator>::reference type;
};


template<typename Iterator>
  struct iterator_difference
{
  typedef typename thrust::iterator_traits<Iterator>::difference_type type;
};


template<typename Iterator>
  struct iterator_system
    : detail::iterator_category_to_system<
        typename thrust::iterator_traits<Iterator>::iterator_category
      >
{
};


template<>
  struct iterator_system<void *>
{
  typedef thrust::iterator_system<int*>::type type;
};

template<>
  struct iterator_system<const void *>
{
  typedef thrust::iterator_system<const int*>::type type;
};


template <typename Iterator>
  struct iterator_traversal
    : detail::iterator_category_to_traversal<
        typename thrust::iterator_traits<Iterator>::iterator_category
      >
{
};

namespace detail
{

template <typename T>
  struct is_iterator_traversal
    : thrust::detail::is_convertible<T, incrementable_traversal_tag>
{
};


template<typename T>
  struct is_iterator_system
    : detail::or_<
        detail::is_convertible<T, any_system_tag>,
        detail::or_<
          detail::is_convertible<T, host_system_tag>,
          detail::is_convertible<T, device_system_tag>
        >
      >
{
};


}
}
# 100 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_traits.h" 2
# 21 "/usr/local/cuda-8.0/include/thrust/iterator/detail/iterator_adaptor_base.h" 2



namespace thrust
{



template<typename Derived,
         typename Base,
         typename Value,
         typename System,
         typename Traversal,
         typename Reference,
         typename Difference
>
class iterator_adaptor;


namespace detail
{




template <class T, class DefaultNullaryFn>
struct ia_dflt_help
  : thrust::detail::eval_if<
        thrust::detail::is_same<T, thrust::use_default>::value
      , DefaultNullaryFn
      , thrust::detail::identity_<T>
    >
{
};




template<typename Derived,
         typename Base,
         typename Value,
         typename System,
         typename Traversal,
         typename Reference,
         typename Difference
>
  struct iterator_adaptor_base
{
  typedef typename ia_dflt_help<
    Value,
    iterator_value<Base>
  >::type value;

  typedef typename ia_dflt_help<
    System,
    thrust::iterator_system<Base>
  >::type system;

  typedef typename ia_dflt_help<
    Traversal,
    thrust::iterator_traversal<Base>
  >::type traversal;

  typedef typename ia_dflt_help<
    Reference,
    thrust::detail::eval_if<
      thrust::detail::is_same<Value,use_default>::value,
      thrust::iterator_reference<Base>,
      thrust::detail::add_reference<Value>
    >
  >::type reference;

  typedef typename ia_dflt_help<
    Difference,
    iterator_difference<Base>
  >::type difference;

  typedef thrust::iterator_facade<
    Derived,
    value,
    system,
    traversal,
    reference,
    difference
  > type;
};


}
}
# 39 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_adaptor.h" 2

namespace thrust
{
# 114 "/usr/local/cuda-8.0/include/thrust/iterator/iterator_adaptor.h"
template<typename Derived,
         typename Base,
         typename Value = use_default,
         typename System = use_default,
         typename Traversal = use_default,
         typename Reference = use_default,
         typename Difference = use_default>
  class iterator_adaptor:
    public detail::iterator_adaptor_base<
      Derived, Base, Value, System, Traversal, Reference, Difference
    >::type
{



    friend class thrust::iterator_core_access;

  protected:
    typedef typename detail::iterator_adaptor_base<
        Derived, Base, Value, System, Traversal, Reference, Difference
    >::type super_t;




  public:


    __attribute__((host)) __attribute__((device))
    iterator_adaptor(){}



    __attribute__((host)) __attribute__((device))
    explicit iterator_adaptor(Base const& iter)
      : m_iterator(iter)
    {}



    typedef Base base_type;



    typedef typename super_t::reference reference;

    typedef typename super_t::difference_type difference_type;





    __attribute__((host)) __attribute__((device))
    Base const& base() const
    { return m_iterator; }

  protected:


    __attribute__((host)) __attribute__((device))
    Base const& base_reference() const
    { return m_iterator; }



    __attribute__((host)) __attribute__((device))
    Base& base_reference()
    { return m_iterator; }



  private:

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    typename iterator_adaptor::reference dereference() const
    { return *m_iterator; }

    #pragma nv_exec_check_disable
    template<typename OtherDerived, typename OtherIterator, typename V, typename S, typename T, typename R, typename D>
    __attribute__((host)) __attribute__((device))
    bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, S, T, R, D> const& x) const
    { return m_iterator == x.base(); }

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    void advance(typename iterator_adaptor::difference_type n)
    {

      m_iterator += n;
    }

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    void increment()
    { ++m_iterator; }

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    void decrement()
    {

      --m_iterator;
    }

    #pragma nv_exec_check_disable
    template<typename OtherDerived, typename OtherIterator, typename V, typename S, typename T, typename R, typename D>
    __attribute__((host)) __attribute__((device))
    typename iterator_adaptor::difference_type distance_to(iterator_adaptor<OtherDerived, OtherIterator, V, S, T, R, D> const& y) const
    { return y.base() - m_iterator; }

  private:
    Base m_iterator;



};







}
# 26 "/usr/local/cuda-8.0/include/thrust/iterator/detail/normal_iterator.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/is_trivial_iterator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/is_trivial_iterator.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/pointer_traits.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/pointer_traits.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/is_metafunction_defined.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/is_metafunction_defined.h"
       

# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/has_nested_type.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/has_nested_type.h"
       
# 20 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/is_metafunction_defined.h" 2


namespace thrust
{

namespace detail
{

template<typename T> struct is_metafunction_defined { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::type *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};

template<typename Metafunction>
  struct enable_if_defined
    : thrust::detail::lazy_enable_if<
        is_metafunction_defined<Metafunction>::value,
        Metafunction
      >
{};

}

}
# 22 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/pointer_traits.h" 2


# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 25 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/pointer_traits.h" 2

namespace thrust
{
namespace detail
{

template<typename Ptr> struct pointer_element;

template<template<typename> class Ptr, typename Arg>
  struct pointer_element<Ptr<Arg> >
{
  typedef Arg type;
};

template<template<typename,typename> class Ptr, typename Arg1, typename Arg2>
  struct pointer_element<Ptr<Arg1,Arg2> >
{
  typedef Arg1 type;
};

template<template<typename,typename,typename> class Ptr, typename Arg1, typename Arg2, typename Arg3>
  struct pointer_element<Ptr<Arg1,Arg2,Arg3> >
{
  typedef Arg1 type;
};

template<template<typename,typename,typename,typename> class Ptr, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
  struct pointer_element<Ptr<Arg1,Arg2,Arg3,Arg4> >
{
  typedef Arg1 type;
};

template<template<typename,typename,typename,typename,typename> class Ptr, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
  struct pointer_element<Ptr<Arg1,Arg2,Arg3,Arg4,Arg5> >
{
  typedef Arg1 type;
};

template<typename T>
  struct pointer_element<T*>
{
  typedef T type;
};

template<typename Ptr>
  struct pointer_difference
{
  typedef typename Ptr::difference_type type;
};

template<typename T>
  struct pointer_difference<T*>
{
  typedef std::ptrdiff_t type;
};

template<typename Ptr, typename T> struct rebind_pointer;

template<typename T, typename U>
  struct rebind_pointer<T*,U>
{
  typedef U* type;
};

template<template<typename> class Ptr, typename Arg, typename T>
  struct rebind_pointer<Ptr<Arg>,T>
{
  typedef Ptr<T> type;
};

template<template<typename, typename> class Ptr, typename Arg1, typename Arg2, typename T>
  struct rebind_pointer<Ptr<Arg1,Arg2>,T>
{
  typedef Ptr<T,Arg2> type;
};

template<template<typename, typename, typename> class Ptr, typename Arg1, typename Arg2, typename Arg3, typename T>
  struct rebind_pointer<Ptr<Arg1,Arg2,Arg3>,T>
{
  typedef Ptr<T,Arg2,Arg3> type;
};

template<template<typename, typename, typename, typename> class Ptr, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename T>
  struct rebind_pointer<Ptr<Arg1,Arg2,Arg3,Arg4>,T>
{
  typedef Ptr<T,Arg2,Arg3,Arg4> type;
};


template<typename T> struct has_raw_pointer { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::raw_pointer *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};

namespace pointer_traits_detail
{

template<typename Ptr, typename Enable = void> struct pointer_raw_pointer_impl {};

template<typename T>
  struct pointer_raw_pointer_impl<T*>
{
  typedef T* type;
};

template<typename Ptr>
  struct pointer_raw_pointer_impl<Ptr, typename enable_if<has_raw_pointer<Ptr>::value>::type>
{
  typedef typename Ptr::raw_pointer type;
};

}

template<typename T>
  struct pointer_raw_pointer
    : pointer_traits_detail::pointer_raw_pointer_impl<T>
{};

namespace pointer_traits_detail
{

template<typename Void>
  struct capture_address
{
  template<typename T>
  __attribute__((host)) __attribute__((device))
  capture_address(T &r)
    : m_addr(&r)
  {}

  inline __attribute__((host)) __attribute__((device))
  Void *operator&() const
  {
    return m_addr;
  }

  Void *m_addr;
};


template<typename T>
  struct pointer_to_param
    : thrust::detail::eval_if<
        thrust::detail::is_void<T>::value,
        thrust::detail::identity_<capture_address<T> >,
        thrust::detail::add_reference<T>
      >
{};

}

template<typename Ptr>
  struct pointer_traits
{
  typedef Ptr pointer;
  typedef typename pointer_element<Ptr>::type element_type;
  typedef typename pointer_difference<Ptr>::type difference_type;

  template<typename U>
    struct rebind
  {
    typedef typename rebind_pointer<Ptr,U>::type other;
  };

  __attribute__((host)) __attribute__((device))
  inline static pointer pointer_to(typename pointer_traits_detail::pointer_to_param<element_type>::type r)
  {



    return pointer(&r);
  }


  typedef typename pointer_raw_pointer<Ptr>::type raw_pointer;

  __attribute__((host)) __attribute__((device))
  inline static raw_pointer get(pointer ptr)
  {
    return ptr.get();
  }
};

template<typename T>
  struct pointer_traits<T*>
{
  typedef T* pointer;
  typedef T element_type;
  typedef typename pointer_difference<T*>::type difference_type;

  template<typename U>
    struct rebind
  {
    typedef U* other;
  };

  __attribute__((host)) __attribute__((device))
  inline static pointer pointer_to(typename pointer_traits_detail::pointer_to_param<element_type>::type r)
  {
    return &r;
  }


  typedef typename pointer_raw_pointer<T*>::type raw_pointer;

  __attribute__((host)) __attribute__((device))
  inline static raw_pointer get(pointer ptr)
  {
    return ptr;
  }
};

template<typename FromPtr, typename ToPtr>
  struct is_pointer_convertible
    : thrust::detail::and_<
        thrust::detail::is_convertible<
          typename pointer_element<FromPtr>::type *,
          typename pointer_element<ToPtr>::type *
        >,
        thrust::detail::is_convertible<
          typename iterator_system<FromPtr>::type,
          typename iterator_system<ToPtr>::type
        >
      >
{};



template<typename T>
  struct is_thrust_pointer
    : is_metafunction_defined<pointer_raw_pointer<T> >
{};


template<typename FromPtr, typename ToPtr>
  struct lazy_is_pointer_convertible
    : thrust::detail::eval_if<
        is_thrust_pointer<FromPtr>::value && is_thrust_pointer<ToPtr>::value,
        is_pointer_convertible<FromPtr,ToPtr>,
        thrust::detail::identity_<thrust::detail::false_type>
      >
{};

template<typename FromPtr, typename ToPtr, typename T = void>
  struct enable_if_pointer_is_convertible
    : thrust::detail::enable_if<
        lazy_is_pointer_convertible<FromPtr,ToPtr>::type::value,
        T
      >
{};


}
}
# 21 "/usr/local/cuda-8.0/include/thrust/iterator/detail/is_trivial_iterator.h" 2



namespace __gnu_cxx
{

template<typename Iterator, typename Container> class __normal_iterator;

}
# 42 "/usr/local/cuda-8.0/include/thrust/iterator/detail/is_trivial_iterator.h"
namespace thrust
{
namespace detail
{


template<typename T>
  struct is_gnu_normal_iterator
    : false_type
{};



template<typename Iterator, typename Container>
  struct is_gnu_normal_iterator< __gnu_cxx::__normal_iterator<Iterator, Container> >
    : true_type
{};
# 79 "/usr/local/cuda-8.0/include/thrust/iterator/detail/is_trivial_iterator.h"
template<typename T>
  struct is_trivial_iterator :
    integral_constant<
      bool,
        is_pointer<T>::value
      | thrust::detail::is_thrust_pointer<T>::value

      | is_gnu_normal_iterator<T>::value




    >
{};

}
}
# 27 "/usr/local/cuda-8.0/include/thrust/iterator/detail/normal_iterator.h" 2


namespace thrust
{
namespace detail
{


template<typename Pointer>
  class normal_iterator
    : public iterator_adaptor<
        normal_iterator<Pointer>,
        Pointer
      >
{
  typedef iterator_adaptor<normal_iterator<Pointer>, Pointer> super_t;

  public:
    __attribute__((host)) __attribute__((device))
    normal_iterator() {}

    __attribute__((host)) __attribute__((device))
    normal_iterator(Pointer p)
      : super_t(p) {}

    template<typename OtherPointer>
    __attribute__((host)) __attribute__((device))
    normal_iterator(const normal_iterator<OtherPointer> &other,
                    typename thrust::detail::enable_if_convertible<
                      OtherPointer,
                      Pointer
                    >::type * = 0)
      : super_t(other.base()) {}

};


template<typename Pointer>
  inline __attribute__((host)) __attribute__((device)) normal_iterator<Pointer> make_normal_iterator(Pointer ptr)
{
  return normal_iterator<Pointer>(ptr);
}


template<typename T> struct is_trivial_iterator< normal_iterator<T> > : public true_type {};


}
}
# 26 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/reverse_iterator.h" 1
# 33 "/usr/local/cuda-8.0/include/thrust/iterator/reverse_iterator.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/reverse_iterator_base.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/reverse_iterator_base.h"
       




namespace thrust
{

template <typename> class reverse_iterator;

namespace detail
{

template<typename BidirectionalIterator>
  struct reverse_iterator_base
{
  typedef thrust::iterator_adaptor<
    thrust::reverse_iterator<BidirectionalIterator>,
    BidirectionalIterator
  > type;
};

}

}
# 38 "/usr/local/cuda-8.0/include/thrust/iterator/reverse_iterator.h" 2


namespace thrust
{
# 144 "/usr/local/cuda-8.0/include/thrust/iterator/reverse_iterator.h"
template<typename BidirectionalIterator>
  class reverse_iterator
    : public detail::reverse_iterator_base<BidirectionalIterator>::type
{


  private:
    typedef typename thrust::detail::reverse_iterator_base<
      BidirectionalIterator
    >::type super_t;

    friend class thrust::iterator_core_access;



  public:


    __attribute__((host)) __attribute__((device))
    reverse_iterator(void) {}






    __attribute__((host)) __attribute__((device))
    explicit reverse_iterator(BidirectionalIterator x);






    template<typename OtherBidirectionalIterator>
    __attribute__((host)) __attribute__((device))
    reverse_iterator(reverse_iterator<OtherBidirectionalIterator> const &r



                     , typename thrust::detail::enable_if<
                         thrust::detail::is_convertible<
                           OtherBidirectionalIterator,
                           BidirectionalIterator
                         >::value
                       >::type * = 0

                     );



  private:
    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    typename super_t::reference dereference(void) const;

    __attribute__((host)) __attribute__((device))
    void increment(void);

    __attribute__((host)) __attribute__((device))
    void decrement(void);

    __attribute__((host)) __attribute__((device))
    void advance(typename super_t::difference_type n);

    template<typename OtherBidirectionalIterator>
    __attribute__((host)) __attribute__((device))
    typename super_t::difference_type
    distance_to(reverse_iterator<OtherBidirectionalIterator> const &y) const;


};
# 224 "/usr/local/cuda-8.0/include/thrust/iterator/reverse_iterator.h"
template<typename BidirectionalIterator>
__attribute__((host)) __attribute__((device))
reverse_iterator<BidirectionalIterator> make_reverse_iterator(BidirectionalIterator x);
# 235 "/usr/local/cuda-8.0/include/thrust/iterator/reverse_iterator.h"
}

# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/reverse_iterator.inl" 1
# 20 "/usr/local/cuda-8.0/include/thrust/iterator/detail/reverse_iterator.inl"
namespace thrust
{

namespace detail
{

 #pragma nv_exec_check_disable
template<typename Iterator>
__attribute__((host)) __attribute__((device))
  Iterator prior(Iterator x)
{
  return --x;
}

}

template<typename BidirectionalIterator>
  reverse_iterator<BidirectionalIterator>
    ::reverse_iterator(BidirectionalIterator x)
      :super_t(x)
{
}

template<typename BidirectionalIterator>
  template<typename OtherBidirectionalIterator>
    reverse_iterator<BidirectionalIterator>
      ::reverse_iterator(reverse_iterator<OtherBidirectionalIterator> const &r


                     , typename thrust::detail::enable_if<
                         thrust::detail::is_convertible<
                           OtherBidirectionalIterator,
                           BidirectionalIterator
                         >::value
                       >::type *

                     )
        :super_t(r.base())
{
}

template<typename BidirectionalIterator>
  typename reverse_iterator<BidirectionalIterator>::super_t::reference
    reverse_iterator<BidirectionalIterator>
      ::dereference(void) const
{
  return *thrust::detail::prior(this->base());
}

template<typename BidirectionalIterator>
  void reverse_iterator<BidirectionalIterator>
    ::increment(void)
{
  --this->base_reference();
}

template<typename BidirectionalIterator>
  void reverse_iterator<BidirectionalIterator>
    ::decrement(void)
{
  ++this->base_reference();
}

template<typename BidirectionalIterator>
  void reverse_iterator<BidirectionalIterator>
    ::advance(typename super_t::difference_type n)
{
  this->base_reference() += -n;
}

template<typename BidirectionalIterator>
  template<typename OtherBidirectionalIterator>
    typename reverse_iterator<BidirectionalIterator>::super_t::difference_type
      reverse_iterator<BidirectionalIterator>
        ::distance_to(reverse_iterator<OtherBidirectionalIterator> const &y) const
{
  return this->base_reference() - y.base();
}

template<typename BidirectionalIterator>
__attribute__((host)) __attribute__((device))
reverse_iterator<BidirectionalIterator> make_reverse_iterator(BidirectionalIterator x)
{
  return reverse_iterator<BidirectionalIterator>(x);
}


}
# 238 "/usr/local/cuda-8.0/include/thrust/iterator/reverse_iterator.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/allocator_traits.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/allocator/allocator_traits.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/has_member_function.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/has_member_function.h"
       
# 23 "/usr/local/cuda-8.0/include/thrust/detail/allocator/allocator_traits.h" 2


namespace thrust
{
namespace detail
{



template<typename Alloc> struct allocator_system;


namespace allocator_traits_detail
{

template<typename T> struct has_value_type { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::value_type *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_pointer { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::pointer *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_const_pointer { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::const_pointer *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_reference { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::reference *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_const_reference { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::const_reference *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_void_pointer { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::void_pointer *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_const_void_pointer { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::const_void_pointer *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_difference_type { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::difference_type *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_size_type { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::size_type *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_propagate_on_container_copy_assignment { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::propagate_on_container_copy_assignment *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_propagate_on_container_move_assignment { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::propagate_on_container_move_assignment *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_propagate_on_container_swap { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::propagate_on_container_swap *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T> struct has_system_type { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::system_type *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};
template<typename T, typename Signature> class has_member_system_impl; template<typename T, typename Result> class has_member_system_impl<T, Result(void)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(), &U::system>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg> class has_member_system_impl<T, Result(Arg)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(Arg); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg), &U::system>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2> class has_member_system_impl<T, Result(Arg1,Arg2)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(Arg1,Arg2); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2), &U::system>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3> class has_member_system_impl<T, Result(Arg1,Arg2,Arg3)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(Arg1,Arg2,Arg3); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3), &U::system>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> class has_member_system_impl<T, Result(Arg1,Arg2,Arg3,Arg4)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(Arg1,Arg2,Arg3,Arg4); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3,Arg4), &U::system>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; };


template<typename T>
  struct nested_pointer
{
  typedef typename T::pointer type;
};

template<typename T>
  struct nested_const_pointer
{
  typedef typename T::const_pointer type;
};

template<typename T>
  struct nested_reference
{
  typedef typename T::reference type;
};

template<typename T>
  struct nested_const_reference
{
  typedef typename T::const_reference type;
};

template<typename T>
  struct nested_void_pointer
{
  typedef typename T::void_pointer type;
};

template<typename T>
  struct nested_const_void_pointer
{
  typedef typename T::const_void_pointer type;
};

template<typename T>
  struct nested_difference_type
{
  typedef typename T::difference_type type;
};

template<typename T>
  struct nested_size_type
{
  typedef typename T::size_type type;
};

template<typename T>
  struct nested_propagate_on_container_copy_assignment
{
  typedef typename T::propagate_on_container_copy_assignment type;
};

template<typename T>
  struct nested_propagate_on_container_move_assignment
{
  typedef typename T::propagate_on_container_move_assignment type;
};

template<typename T>
  struct nested_propagate_on_container_swap
{
  typedef typename T::propagate_on_container_swap type;
};

template<typename T>
  struct nested_system_type
{
  typedef typename T::system_type type;
};

template<typename Alloc>
  class has_member_system
{
  typedef typename allocator_system<Alloc>::type system_type;

  public:
    typedef typename has_member_system_impl<Alloc, system_type&(void)>::type type;
    static const bool value = type::value;
};


}


template<typename Alloc>
  struct allocator_traits
{
  typedef Alloc allocator_type;

  typedef typename allocator_type::value_type value_type;

  typedef typename eval_if<
    allocator_traits_detail::has_pointer<allocator_type>::value,
    allocator_traits_detail::nested_pointer<allocator_type>,
    identity_<value_type*>
  >::type pointer;

  private:
    template<typename T>
      struct rebind_pointer
    {
      typedef typename pointer_traits<pointer>::template rebind<T>::other type;
    };

  public:

  typedef typename eval_if<
    allocator_traits_detail::has_const_pointer<allocator_type>::value,
    allocator_traits_detail::nested_const_pointer<allocator_type>,
    rebind_pointer<const value_type>
  >::type const_pointer;

  typedef typename eval_if<
    allocator_traits_detail::has_void_pointer<allocator_type>::value,
    allocator_traits_detail::nested_void_pointer<allocator_type>,
    rebind_pointer<void>
  >::type void_pointer;

  typedef typename eval_if<
    allocator_traits_detail::has_const_void_pointer<allocator_type>::value,
    allocator_traits_detail::nested_const_void_pointer<allocator_type>,
    rebind_pointer<const void>
  >::type const_void_pointer;

  typedef typename eval_if<
    allocator_traits_detail::has_difference_type<allocator_type>::value,
    allocator_traits_detail::nested_difference_type<allocator_type>,
    pointer_difference<pointer>
  >::type difference_type;

  typedef typename eval_if<
    allocator_traits_detail::has_size_type<allocator_type>::value,
    allocator_traits_detail::nested_size_type<allocator_type>,
    make_unsigned<difference_type>
  >::type size_type;

  typedef typename eval_if<
    allocator_traits_detail::has_propagate_on_container_copy_assignment<allocator_type>::value,
    allocator_traits_detail::nested_propagate_on_container_copy_assignment<allocator_type>,
    identity_<false_type>
  >::type propagate_on_container_copy_assignment;

  typedef typename eval_if<
    allocator_traits_detail::has_propagate_on_container_move_assignment<allocator_type>::value,
    allocator_traits_detail::nested_propagate_on_container_move_assignment<allocator_type>,
    identity_<false_type>
  >::type propagate_on_container_move_assignment;

  typedef typename eval_if<
    allocator_traits_detail::has_propagate_on_container_swap<allocator_type>::value,
    allocator_traits_detail::nested_propagate_on_container_swap<allocator_type>,
    identity_<false_type>
  >::type propagate_on_container_swap;

  typedef typename eval_if<
    allocator_traits_detail::has_system_type<allocator_type>::value,
    allocator_traits_detail::nested_system_type<allocator_type>,
    thrust::iterator_system<pointer>
  >::type system_type;




  inline __attribute__((host)) __attribute__((device))
  static pointer allocate(allocator_type &a, size_type n);

  inline __attribute__((host)) __attribute__((device))
  static pointer allocate(allocator_type &a, size_type n, const_void_pointer hint);

  inline __attribute__((host)) __attribute__((device))
  static void deallocate(allocator_type &a, pointer p, size_type n);



  template<typename T>
  inline __attribute__((host)) __attribute__((device)) static void construct(allocator_type &a, T *p);

  template<typename T, typename Arg1>
  inline __attribute__((host)) __attribute__((device)) static void construct(allocator_type &a, T *p, const Arg1 &arg1);

  template<typename T>
  inline __attribute__((host)) __attribute__((device)) static void destroy(allocator_type &a, T *p);

  inline __attribute__((host)) __attribute__((device))
  static size_type max_size(const allocator_type &a);
};





template<typename T>
  struct is_allocator
    : allocator_traits_detail::has_value_type<T>
{};



template<typename Alloc>
  struct allocator_system
{

  typedef typename eval_if<
    allocator_traits_detail::has_system_type<Alloc>::value,
    allocator_traits_detail::nested_system_type<Alloc>,
    thrust::iterator_system<
      typename allocator_traits<Alloc>::pointer
    >
  >::type type;


  typedef typename eval_if<
    allocator_traits_detail::has_member_system<Alloc>::value,
    add_reference<type>,
    identity_<type>
  >::type get_result_type;

  __attribute__((host)) __attribute__((device))
  inline static get_result_type get(Alloc &a);
};


}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/allocator_traits.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/detail/allocator/allocator_traits.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/is_call_possible.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/is_call_possible.h"
       







namespace thrust
{
namespace detail
{
namespace is_call_possible_detail
{

template<typename T> class void_exp_result {};

template<typename T, typename U>
U const& operator,(U const&, void_exp_result<T>);

template<typename T, typename U>
U& operator,(U&, void_exp_result<T>);

template<typename src_type, typename dest_type>
struct clone_constness
{
  typedef dest_type type;
};

template<typename src_type, typename dest_type>
struct clone_constness<const src_type, dest_type>
{
  typedef const dest_type type;
};

}
}
}
# 20 "/usr/local/cuda-8.0/include/thrust/detail/allocator/allocator_traits.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/integer_traits.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/integer_traits.h"
       


# 1 "/usr/include/c++/4.8.2/limits" 1 3
# 40 "/usr/include/c++/4.8.2/limits" 3
       
# 41 "/usr/include/c++/4.8.2/limits" 3
# 147 "/usr/include/c++/4.8.2/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "/usr/include/c++/4.8.2/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;


    static const int digits10 = 0;
# 212 "/usr/include/c++/4.8.2/limits" 3
    static const bool is_signed = false;


    static const bool is_integer = false;




    static const bool is_exact = false;



    static const int radix = 0;



    static const int min_exponent = 0;



    static const int min_exponent10 = 0;




    static const int max_exponent = 0;



    static const int max_exponent10 = 0;


    static const bool has_infinity = false;



    static const bool has_quiet_NaN = false;



    static const bool has_signaling_NaN = false;


    static const float_denorm_style has_denorm = denorm_absent;



    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;




    static const bool is_bounded = false;
# 277 "/usr/include/c++/4.8.2/limits" 3
    static const bool is_modulo = false;


    static const bool traps = false;


    static const bool tinyness_before = false;




    static const float_round_style round_style =
          round_toward_zero;
  };
# 303 "/usr/include/c++/4.8.2/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp
      min() throw() { return _Tp(); }


      static _Tp
      max() throw() { return _Tp(); }
# 324 "/usr/include/c++/4.8.2/limits" 3
      static _Tp
      epsilon() throw() { return _Tp(); }


      static _Tp
      round_error() throw() { return _Tp(); }


      static _Tp
      infinity() throw() { return _Tp(); }



      static _Tp
      quiet_NaN() throw() { return _Tp(); }



      static _Tp
      signaling_NaN() throw() { return _Tp(); }




      static _Tp
      denorm_min() throw() { return _Tp(); }
    };
# 370 "/usr/include/c++/4.8.2/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static
     
# 376 "/usr/include/c++/4.8.2/limits" 3
     
# 375 "/usr/include/c++/4.8.2/limits" 3
                                bool
      min() throw() { return false; }

      static
     
# 379 "/usr/include/c++/4.8.2/limits" 3
     
# 378 "/usr/include/c++/4.8.2/limits" 3
                                bool
      max() throw() { return true; }





      static const int digits = 1;
      static const int digits10 = 0;



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static
     
# 396 "/usr/include/c++/4.8.2/limits" 3
     
# 395 "/usr/include/c++/4.8.2/limits" 3
                                bool
      epsilon() throw() { return false; }

      static
     
# 399 "/usr/include/c++/4.8.2/limits" 3
     
# 398 "/usr/include/c++/4.8.2/limits" 3
                                bool
      round_error() throw() { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static
     
# 414 "/usr/include/c++/4.8.2/limits" 3
     
# 413 "/usr/include/c++/4.8.2/limits" 3
                                bool
      infinity() throw() { return false; }

      static
     
# 417 "/usr/include/c++/4.8.2/limits" 3
     
# 416 "/usr/include/c++/4.8.2/limits" 3
                                bool
      quiet_NaN() throw() { return false; }

      static
     
# 420 "/usr/include/c++/4.8.2/limits" 3
     
# 419 "/usr/include/c++/4.8.2/limits" 3
                                bool
      signaling_NaN() throw() { return false; }

      static
     
# 423 "/usr/include/c++/4.8.2/limits" 3
     
# 422 "/usr/include/c++/4.8.2/limits" 3
                                bool
      denorm_min() throw() { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char
      min() throw() { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static char
      max() throw() { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }






      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static char
      epsilon() throw() { return 0; }

      static char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static
      char infinity() throw() { return char(); }

      static char
      quiet_NaN() throw() { return char(); }

      static char
      signaling_NaN() throw() { return char(); }

      static char
      denorm_min() throw() { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = !is_signed;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char
      min() throw() { return -127 - 1; }

      static signed char
      max() throw() { return 127; }






      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static signed char
      epsilon() throw() { return 0; }

      static signed char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char
      infinity() throw() { return static_cast<signed char>(0); }

      static signed char
      quiet_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      signaling_NaN() throw()
      { return static_cast<signed char>(0); }

      static signed char
      denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char
      min() throw() { return 0; }

      static unsigned char
      max() throw() { return 127 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned char
      epsilon() throw() { return 0; }

      static unsigned char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char
      infinity() throw()
      { return static_cast<unsigned char>(0); }

      static unsigned char
      quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }

      static unsigned char
      signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }

      static unsigned char
      denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t
      min() throw() { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static wchar_t
      max() throw() { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }






      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static wchar_t
      epsilon() throw() { return 0; }

      static wchar_t
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t
      infinity() throw() { return wchar_t(); }

      static wchar_t
      quiet_NaN() throw() { return wchar_t(); }

      static wchar_t
      signaling_NaN() throw() { return wchar_t(); }

      static wchar_t
      denorm_min() throw() { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = !is_signed;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
# 841 "/usr/include/c++/4.8.2/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short
      min() throw() { return -32767 - 1; }

      static short
      max() throw() { return 32767; }






      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static short
      epsilon() throw() { return 0; }

      static short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static short
      infinity() throw() { return short(); }

      static short
      quiet_NaN() throw() { return short(); }

      static short
      signaling_NaN() throw() { return short(); }

      static short
      denorm_min() throw() { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short
      min() throw() { return 0; }

      static unsigned short
      max() throw() { return 32767 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned short
      epsilon() throw() { return 0; }

      static unsigned short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short
      infinity() throw()
      { return static_cast<unsigned short>(0); }

      static unsigned short
      quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }

      static unsigned short
      signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }

      static unsigned short
      denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int
      min() throw() { return -2147483647 - 1; }

      static int
      max() throw() { return 2147483647; }






      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static int
      epsilon() throw() { return 0; }

      static int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static int
      infinity() throw() { return static_cast<int>(0); }

      static int
      quiet_NaN() throw() { return static_cast<int>(0); }

      static int
      signaling_NaN() throw() { return static_cast<int>(0); }

      static int
      denorm_min() throw() { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int
      min() throw() { return 0; }

      static unsigned int
      max() throw() { return 2147483647 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned int
      epsilon() throw() { return 0; }

      static unsigned int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int
      infinity() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }

      static unsigned int
      signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }

      static unsigned int
      denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long
      min() throw() { return -9223372036854775807L - 1; }

      static long
      max() throw() { return 9223372036854775807L; }






      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long
      epsilon() throw() { return 0; }

      static long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long
      infinity() throw() { return static_cast<long>(0); }

      static long
      quiet_NaN() throw() { return static_cast<long>(0); }

      static long
      signaling_NaN() throw() { return static_cast<long>(0); }

      static long
      denorm_min() throw() { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long
      min() throw() { return 0; }

      static unsigned long
      max() throw() { return 9223372036854775807L * 2UL + 1; }






      static const int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long
      epsilon() throw() { return 0; }

      static unsigned long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long
      infinity() throw()
      { return static_cast<unsigned long>(0); }

      static unsigned long
      quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }

      static unsigned long
      signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }

      static unsigned long
      denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long
      min() throw() { return -9223372036854775807LL - 1; }

      static long long
      max() throw() { return 9223372036854775807LL; }






      static const int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long long
      epsilon() throw() { return 0; }

      static long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long
      infinity() throw() { return static_cast<long long>(0); }

      static long long
      quiet_NaN() throw() { return static_cast<long long>(0); }

      static long long
      signaling_NaN() throw()
      { return static_cast<long long>(0); }

      static long long
      denorm_min() throw() { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long
      min() throw() { return 0; }

      static unsigned long long
      max() throw() { return 9223372036854775807LL * 2ULL + 1; }






      static const int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long long
      epsilon() throw() { return 0; }

      static unsigned long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long
      infinity() throw()
      { return static_cast<unsigned long long>(0); }

      static unsigned long long
      quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }

      static unsigned long long
      signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }

      static unsigned long long
      denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<__int128>
    {
      static const bool is_specialized = true;

      static __int128
      min() throw() { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); }

      static __int128
      max() throw() { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); }






      static const int digits
       = (sizeof(__int128) * 8 - ((__int128)(-1) < 0));
      static const int digits10
       = ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static __int128
      epsilon() throw() { return 0; }

      static __int128
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static __int128
      infinity() throw()
      { return static_cast<__int128>(0); }

      static __int128
      quiet_NaN() throw()
      { return static_cast<__int128>(0); }

      static __int128
      signaling_NaN() throw()
      { return static_cast<__int128>(0); }

      static __int128
      denorm_min() throw()
      { return static_cast<__int128>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps
       = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned __int128>
    {
      static const bool is_specialized = true;

      static unsigned __int128
      min() throw() { return 0; }

      static unsigned __int128
      max() throw() { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); }






      static const int digits
       = (sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned __int128
      epsilon() throw() { return 0; }

      static unsigned __int128
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned __int128
      infinity() throw()
      { return static_cast<unsigned __int128>(0); }

      static unsigned __int128
      quiet_NaN() throw()
      { return static_cast<unsigned __int128>(0); }

      static unsigned __int128
      signaling_NaN() throw()
      { return static_cast<unsigned __int128>(0); }

      static unsigned __int128
      denorm_min() throw()
      { return static_cast<unsigned __int128>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float
      min() throw() { return 1.17549435082228750796873653722225e-38F; }

      static float
      max() throw() { return 3.40282346638528859811704183484517e+38F; }






      static const int digits = 24;
      static const int digits10 = 6;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static float
      epsilon() throw() { return 1.19209289550781250000000000000000e-7F; }

      static float
      round_error() throw() { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
       = false;

      static float
      infinity() throw() { return __builtin_huge_valf(); }

      static float
      quiet_NaN() throw() { return __builtin_nanf(""); }

      static float
      signaling_NaN() throw() { return __builtin_nansf(""); }

      static float
      denorm_min() throw() { return 1.40129846432481707092372958328992e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double
      min() throw() { return double(2.22507385850720138309023271733240e-308L); }

      static double
      max() throw() { return double(1.79769313486231570814527423731704e+308L); }






      static const int digits = 53;
      static const int digits10 = 15;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static double
      epsilon() throw() { return double(2.22044604925031308084726333618164e-16L); }

      static double
      round_error() throw() { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;

      static double
      infinity() throw() { return __builtin_huge_val(); }

      static double
      quiet_NaN() throw() { return __builtin_nan(""); }

      static double
      signaling_NaN() throw() { return __builtin_nans(""); }

      static double
      denorm_min() throw() { return double(4.94065645841246544176568792868221e-324L); }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double
      min() throw() { return 2.00416836000897277799610805135016e-292L; }

      static long double
      max() throw() { return 1.79769313486231580793728971405301e+308L; }






      static const int digits = 106;
      static const int digits10 = 31;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static long double
      epsilon() throw() { return 4.94065645841246544176568792868221e-324L; }

      static long double
      round_error() throw() { return 0.5L; }

      static const int min_exponent = (-968);
      static const int min_exponent10 = (-291);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double
      infinity() throw() { return __builtin_huge_vall(); }

      static long double
      quiet_NaN() throw() { return __builtin_nanl(""); }

      static long double
      signaling_NaN() throw() { return __builtin_nansl(""); }

      static long double
      denorm_min() throw() { return 4.94065645841246544176568792868221e-324L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before =
      false;
      static const float_round_style round_style =
            round_to_nearest;
    };






}
# 21 "/usr/local/cuda-8.0/include/thrust/detail/integer_traits.h" 2
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/limits.h" 1 3 4
# 22 "/usr/local/cuda-8.0/include/thrust/detail/integer_traits.h" 2

namespace thrust
{

namespace detail
{

template<typename T>
  class integer_traits
{
  public:
    static const bool is_integral = false;
};

template<typename T, T min_val, T max_val>
  class integer_traits_base
{
  public:
    static const bool is_integral = true;
    static const T const_min = min_val;
    static const T const_max = max_val;
};


template<>
  class integer_traits<bool>
    : public std::numeric_limits<bool>,
      public integer_traits_base<bool, false, true>
{};


template<>
  class integer_traits<char>
    : public std::numeric_limits<char>,
      public integer_traits_base<char, 0, (127 * 2 + 1)>
{};


template<>
  class integer_traits<signed char>
    : public std::numeric_limits<signed char>,
      public integer_traits_base<signed char, (-127 - 1), 127>
{};


template<>
  class integer_traits<unsigned char>
    : public std::numeric_limits<unsigned char>,
      public integer_traits_base<unsigned char, 0, (127 * 2 + 1)>
{};


template<>
  class integer_traits<short>
    : public std::numeric_limits<short>,
      public integer_traits_base<short, (-32767 - 1), 32767>
{};


template<>
  class integer_traits<unsigned short>
    : public std::numeric_limits<unsigned short>,
      public integer_traits_base<unsigned short, 0, (32767 * 2 + 1)>
{};


template<>
  class integer_traits<int>
    : public std::numeric_limits<int>,
      public integer_traits_base<int, (-2147483647 - 1), 2147483647>
{};


template<>
  class integer_traits<unsigned int>
    : public std::numeric_limits<unsigned int>,
      public integer_traits_base<unsigned int, 0, (2147483647 * 2U + 1U)>
{};


template<>
  class integer_traits<long>
    : public std::numeric_limits<long>,
      public integer_traits_base<long, (-9223372036854775807L - 1L), 9223372036854775807L>
{};


template<>
  class integer_traits<unsigned long>
    : public std::numeric_limits<unsigned long>,
      public integer_traits_base<unsigned long, 0, (9223372036854775807L * 2UL + 1UL)>
{};


template<>
  class integer_traits<long long>
    : public std::numeric_limits<long long>,
      public integer_traits_base<long long, (-9223372036854775807LL -1), 9223372036854775807LL>
{};


template<>
  class integer_traits<unsigned long long>
    : public std::numeric_limits<unsigned long long>,
      public integer_traits_base<unsigned long long, 0, (9223372036854775807LL * 2ULL + 1)>
{};

}

}
# 21 "/usr/local/cuda-8.0/include/thrust/detail/allocator/allocator_traits.inl" 2


namespace thrust
{
namespace detail
{
namespace allocator_traits_detail
{

template<typename T, typename Signature> class has_member_allocate_with_hint_impl_has_member; template<typename T, typename Result> class has_member_allocate_with_hint_impl_has_member<T, Result(void)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(), &U::allocate>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg> class has_member_allocate_with_hint_impl_has_member<T, Result(Arg)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(Arg); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg), &U::allocate>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2> class has_member_allocate_with_hint_impl_has_member<T, Result(Arg1,Arg2)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(Arg1,Arg2); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2), &U::allocate>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3> class has_member_allocate_with_hint_impl_has_member<T, Result(Arg1,Arg2,Arg3)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(Arg1,Arg2,Arg3); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3), &U::allocate>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> class has_member_allocate_with_hint_impl_has_member<T, Result(Arg1,Arg2,Arg3,Arg4)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(Arg1,Arg2,Arg3,Arg4); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3,Arg4), &U::allocate>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template <typename T, typename Signature> struct has_member_allocate_with_hint_impl { private: struct yes {}; struct no { yes m[2]; }; struct derived : public T { using T::allocate; no allocate(...) const; }; typedef typename thrust::detail::is_call_possible_detail::clone_constness<T, derived>::type derived_type; template<typename U, typename Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(thrust::detail::is_call_possible_detail::void_exp_result<T>); }; template<typename U> struct return_value_check<U, void> { static yes deduce(...); static no deduce(no); }; template<bool has_the_member_of_interest, typename F> struct impl { static const bool value = false; }; template<typename Result, typename Arg> struct impl<true, Result(Arg)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg>::type arg; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.allocate(arg), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2> struct impl<true, Result(Arg1,Arg2)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.allocate(arg1,arg2), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3> struct impl<true, Result(Arg1,Arg2,Arg3)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.allocate(arg1,arg2,arg3), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> struct impl<true, Result(Arg1,Arg2,Arg3,Arg4)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static typename add_reference<Arg4>::type arg4; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.allocate(arg1,arg2,arg3,arg4), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; public: static const bool value = impl<has_member_allocate_with_hint_impl_has_member<T,Signature>::value, Signature>::value; typedef thrust::detail::integral_constant<bool,value> type; };

template<typename Alloc>
  class has_member_allocate_with_hint
{
  typedef typename allocator_traits<Alloc>::pointer pointer;
  typedef typename allocator_traits<Alloc>::size_type size_type;
  typedef typename allocator_traits<Alloc>::const_void_pointer const_void_pointer;

  public:
    typedef typename has_member_allocate_with_hint_impl<Alloc, pointer(size_type,const_void_pointer)>::type type;
    static const bool value = type::value;
};

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename enable_if<
    has_member_allocate_with_hint<Alloc>::value,
    typename allocator_traits<Alloc>::pointer
  >::type
    allocate(Alloc &a, typename allocator_traits<Alloc>::size_type n, typename allocator_traits<Alloc>::const_void_pointer hint)
{
  return a.allocate(n,hint);
}

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename disable_if<
    has_member_allocate_with_hint<Alloc>::value,
    typename allocator_traits<Alloc>::pointer
  >::type
    allocate(Alloc &a, typename allocator_traits<Alloc>::size_type n, typename allocator_traits<Alloc>::const_void_pointer)
{
  return a.allocate(n);
}


template<typename T, typename Signature> class has_member_construct1_impl_has_member; template<typename T, typename Result> class has_member_construct1_impl_has_member<T, Result(void)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg> class has_member_construct1_impl_has_member<T, Result(Arg)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2> class has_member_construct1_impl_has_member<T, Result(Arg1,Arg2)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1,Arg2); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3> class has_member_construct1_impl_has_member<T, Result(Arg1,Arg2,Arg3)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1,Arg2,Arg3); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> class has_member_construct1_impl_has_member<T, Result(Arg1,Arg2,Arg3,Arg4)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1,Arg2,Arg3,Arg4); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3,Arg4), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template <typename T, typename Signature> struct has_member_construct1_impl { private: struct yes {}; struct no { yes m[2]; }; struct derived : public T { using T::construct; no construct(...) const; }; typedef typename thrust::detail::is_call_possible_detail::clone_constness<T, derived>::type derived_type; template<typename U, typename Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(thrust::detail::is_call_possible_detail::void_exp_result<T>); }; template<typename U> struct return_value_check<U, void> { static yes deduce(...); static no deduce(no); }; template<bool has_the_member_of_interest, typename F> struct impl { static const bool value = false; }; template<typename Result, typename Arg> struct impl<true, Result(Arg)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg>::type arg; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.construct(arg), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2> struct impl<true, Result(Arg1,Arg2)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.construct(arg1,arg2), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3> struct impl<true, Result(Arg1,Arg2,Arg3)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.construct(arg1,arg2,arg3), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> struct impl<true, Result(Arg1,Arg2,Arg3,Arg4)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static typename add_reference<Arg4>::type arg4; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.construct(arg1,arg2,arg3,arg4), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; public: static const bool value = impl<has_member_construct1_impl_has_member<T,Signature>::value, Signature>::value; typedef thrust::detail::integral_constant<bool,value> type; };

template<typename Alloc, typename T>
  struct has_member_construct1
    : has_member_construct1_impl<Alloc, void(T*)>
{};

 #pragma nv_exec_check_disable
template<typename Alloc, typename T>
  inline __attribute__((host)) __attribute__((device))
    typename enable_if<
      has_member_construct1<Alloc,T>::value
    >::type
      construct(Alloc &a, T *p)
{
  a.construct(p);
}

template<typename Alloc, typename T>
  inline __attribute__((host)) __attribute__((device))
    typename disable_if<
      has_member_construct1<Alloc,T>::value
    >::type
      construct(Alloc &a, T *p)
{
  ::new(static_cast<void*>(p)) T();
}


template<typename T, typename Signature> class has_member_construct2_impl_has_member; template<typename T, typename Result> class has_member_construct2_impl_has_member<T, Result(void)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg> class has_member_construct2_impl_has_member<T, Result(Arg)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2> class has_member_construct2_impl_has_member<T, Result(Arg1,Arg2)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1,Arg2); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3> class has_member_construct2_impl_has_member<T, Result(Arg1,Arg2,Arg3)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1,Arg2,Arg3); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> class has_member_construct2_impl_has_member<T, Result(Arg1,Arg2,Arg3,Arg4)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1,Arg2,Arg3,Arg4); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3,Arg4), &U::construct>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template <typename T, typename Signature> struct has_member_construct2_impl { private: struct yes {}; struct no { yes m[2]; }; struct derived : public T { using T::construct; no construct(...) const; }; typedef typename thrust::detail::is_call_possible_detail::clone_constness<T, derived>::type derived_type; template<typename U, typename Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(thrust::detail::is_call_possible_detail::void_exp_result<T>); }; template<typename U> struct return_value_check<U, void> { static yes deduce(...); static no deduce(no); }; template<bool has_the_member_of_interest, typename F> struct impl { static const bool value = false; }; template<typename Result, typename Arg> struct impl<true, Result(Arg)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg>::type arg; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.construct(arg), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2> struct impl<true, Result(Arg1,Arg2)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.construct(arg1,arg2), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3> struct impl<true, Result(Arg1,Arg2,Arg3)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.construct(arg1,arg2,arg3), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> struct impl<true, Result(Arg1,Arg2,Arg3,Arg4)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static typename add_reference<Arg4>::type arg4; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.construct(arg1,arg2,arg3,arg4), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; public: static const bool value = impl<has_member_construct2_impl_has_member<T,Signature>::value, Signature>::value; typedef thrust::detail::integral_constant<bool,value> type; };

template<typename Alloc, typename T, typename Arg1>
  struct has_member_construct2
    : has_member_construct2_impl<Alloc, void(T*,const Arg1 &)>
{};

template<typename Alloc, typename T, typename Arg1>
  inline __attribute__((host)) __attribute__((device))
    typename enable_if<
      has_member_construct2<Alloc,T,Arg1>::value
    >::type
      construct(Alloc &a, T *p, const Arg1 &arg1)
{
  a.construct(p,arg1);
}

template<typename Alloc, typename T, typename Arg1>
  inline __attribute__((host)) __attribute__((device))
    typename disable_if<
      has_member_construct2<Alloc,T,Arg1>::value
    >::type
      construct(Alloc &, T *p, const Arg1 &arg1)
{
  ::new(static_cast<void*>(p)) T(arg1);
}


template<typename T, typename Signature> class has_member_destroy_impl_has_member; template<typename T, typename Result> class has_member_destroy_impl_has_member<T, Result(void)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(), &U::destroy>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg> class has_member_destroy_impl_has_member<T, Result(Arg)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(Arg); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg), &U::destroy>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2> class has_member_destroy_impl_has_member<T, Result(Arg1,Arg2)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(Arg1,Arg2); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2), &U::destroy>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3> class has_member_destroy_impl_has_member<T, Result(Arg1,Arg2,Arg3)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(Arg1,Arg2,Arg3); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3), &U::destroy>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> class has_member_destroy_impl_has_member<T, Result(Arg1,Arg2,Arg3,Arg4)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(Arg1,Arg2,Arg3,Arg4); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3,Arg4), &U::destroy>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template <typename T, typename Signature> struct has_member_destroy_impl { private: struct yes {}; struct no { yes m[2]; }; struct derived : public T { using T::destroy; no destroy(...) const; }; typedef typename thrust::detail::is_call_possible_detail::clone_constness<T, derived>::type derived_type; template<typename U, typename Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(thrust::detail::is_call_possible_detail::void_exp_result<T>); }; template<typename U> struct return_value_check<U, void> { static yes deduce(...); static no deduce(no); }; template<bool has_the_member_of_interest, typename F> struct impl { static const bool value = false; }; template<typename Result, typename Arg> struct impl<true, Result(Arg)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg>::type arg; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.destroy(arg), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2> struct impl<true, Result(Arg1,Arg2)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.destroy(arg1,arg2), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3> struct impl<true, Result(Arg1,Arg2,Arg3)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.destroy(arg1,arg2,arg3), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> struct impl<true, Result(Arg1,Arg2,Arg3,Arg4)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static typename add_reference<Arg4>::type arg4; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.destroy(arg1,arg2,arg3,arg4), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; public: static const bool value = impl<has_member_destroy_impl_has_member<T,Signature>::value, Signature>::value; typedef thrust::detail::integral_constant<bool,value> type; };

template<typename Alloc, typename T>
  struct has_member_destroy
    : has_member_destroy_impl<Alloc, void(T*)>
{};

template<typename Alloc, typename T>
  inline __attribute__((host)) __attribute__((device))
    typename enable_if<
      has_member_destroy<Alloc,T>::value
    >::type
      destroy(Alloc &a, T *p)
{
  a.destroy(p);
}

template<typename Alloc, typename T>
  inline __attribute__((host)) __attribute__((device))
    typename disable_if<
      has_member_destroy<Alloc,T>::value
    >::type
      destroy(Alloc &, T *p)
{
  p->~T();
}


template<typename T, typename Signature> class has_member_max_size_impl_has_member; template<typename T, typename Result> class has_member_max_size_impl_has_member<T, Result(void)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(), &U::max_size>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg> class has_member_max_size_impl_has_member<T, Result(Arg)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(Arg); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg), &U::max_size>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2> class has_member_max_size_impl_has_member<T, Result(Arg1,Arg2)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(Arg1,Arg2); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2), &U::max_size>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3> class has_member_max_size_impl_has_member<T, Result(Arg1,Arg2,Arg3)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(Arg1,Arg2,Arg3); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3), &U::max_size>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template<typename T, typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> class has_member_max_size_impl_has_member<T, Result(Arg1,Arg2,Arg3,Arg4)> { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(Arg1,Arg2,Arg3,Arg4); }; struct base : public T, public base_mixin {}; template <typename U, U t> class helper{}; template <typename U> static no deduce(U*, helper<Result (base_mixin::*)(Arg1,Arg2,Arg3,Arg4), &U::max_size>* = 0); static yes deduce(...); public: static const bool value = sizeof(yes) == sizeof(deduce(static_cast<base*>(0))); typedef thrust::detail::integral_constant<bool,value> type; }; template <typename T, typename Signature> struct has_member_max_size_impl { private: struct yes {}; struct no { yes m[2]; }; struct derived : public T { using T::max_size; no max_size(...) const; }; typedef typename thrust::detail::is_call_possible_detail::clone_constness<T, derived>::type derived_type; template<typename U, typename Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(thrust::detail::is_call_possible_detail::void_exp_result<T>); }; template<typename U> struct return_value_check<U, void> { static yes deduce(...); static no deduce(no); }; template<bool has_the_member_of_interest, typename F> struct impl { static const bool value = false; }; template<typename Result, typename Arg> struct impl<true, Result(Arg)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg>::type arg; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.max_size(arg), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2> struct impl<true, Result(Arg1,Arg2)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.max_size(arg1,arg2), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3> struct impl<true, Result(Arg1,Arg2,Arg3)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.max_size(arg1,arg2,arg3), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; template<typename Result, typename Arg1, typename Arg2, typename Arg3, typename Arg4> struct impl<true, Result(Arg1,Arg2,Arg3,Arg4)> { static typename add_reference<derived_type>::type test_me; static typename add_reference<Arg1>::type arg1; static typename add_reference<Arg2>::type arg2; static typename add_reference<Arg3>::type arg3; static typename add_reference<Arg4>::type arg4; static const bool value = sizeof( return_value_check<T, Result>::deduce( (test_me.max_size(arg1,arg2,arg3,arg4), thrust::detail::is_call_possible_detail::void_exp_result<T>()) ) ) == sizeof(yes); }; public: static const bool value = impl<has_member_max_size_impl_has_member<T,Signature>::value, Signature>::value; typedef thrust::detail::integral_constant<bool,value> type; };

template<typename Alloc>
  class has_member_max_size
{
  typedef typename allocator_traits<Alloc>::size_type size_type;

  public:
    typedef typename has_member_max_size_impl<Alloc, size_type(void)>::type type;
    static const bool value = type::value;
};

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename enable_if<
    has_member_max_size<Alloc>::value,
    typename allocator_traits<Alloc>::size_type
  >::type
    max_size(const Alloc &a)
{
  return a.max_size();
}

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename disable_if<
    has_member_max_size<Alloc>::value,
    typename allocator_traits<Alloc>::size_type
  >::type
    max_size(const Alloc &)
{
  typedef typename allocator_traits<Alloc>::size_type size_type;
  return thrust::detail::integer_traits<size_type>::const_max;
}

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename enable_if<
    has_member_system<Alloc>::value,
    typename allocator_system<Alloc>::type &
  >::type
    system(Alloc &a)
{

  return a.system();
}

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename disable_if<
    has_member_system<Alloc>::value,
    typename allocator_system<Alloc>::type
  >::type
    system(Alloc &)
{

  typename allocator_system<Alloc>::type result;
  return result;
}


}


template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename allocator_traits<Alloc>::pointer
    allocator_traits<Alloc>
      ::allocate(Alloc &a, typename allocator_traits<Alloc>::size_type n)
{
  struct workaround_warnings
  {
    #pragma nv_exec_check_disable
    static __attribute__((host)) __attribute__((device))
    typename allocator_traits<Alloc>::pointer
      allocate(Alloc &a, typename allocator_traits<Alloc>::size_type n)
    {
      return a.allocate(n);
    }
  };

  return workaround_warnings::allocate(a, n);
}

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename allocator_traits<Alloc>::pointer
    allocator_traits<Alloc>
      ::allocate(Alloc &a, typename allocator_traits<Alloc>::size_type n, typename allocator_traits<Alloc>::const_void_pointer hint)
{
  return allocator_traits_detail::allocate(a, n, hint);
}

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  void allocator_traits<Alloc>
    ::deallocate(Alloc &a, typename allocator_traits<Alloc>::pointer p, typename allocator_traits<Alloc>::size_type n)
{
  struct workaround_warnings
  {
    #pragma nv_exec_check_disable
    static __attribute__((host)) __attribute__((device))
    void deallocate(Alloc &a, typename allocator_traits<Alloc>::pointer p, typename allocator_traits<Alloc>::size_type n)
    {
      return a.deallocate(p,n);
    }
  };

  return workaround_warnings::deallocate(a,p,n);
}

template<typename Alloc>
  template<typename T>
  __attribute__((host)) __attribute__((device))
    void allocator_traits<Alloc>
      ::construct(allocator_type &a, T *p)
{
  return allocator_traits_detail::construct(a,p);
}

template<typename Alloc>
  template<typename T, typename Arg1>
  __attribute__((host)) __attribute__((device))
    void allocator_traits<Alloc>
      ::construct(allocator_type &a, T *p, const Arg1 &arg1)
{
  return allocator_traits_detail::construct(a,p,arg1);
}

template<typename Alloc>
  template<typename T>
  __attribute__((host)) __attribute__((device))
    void allocator_traits<Alloc>
      ::destroy(allocator_type &a, T *p)
{
  return allocator_traits_detail::destroy(a,p);
}

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename allocator_traits<Alloc>::size_type
    allocator_traits<Alloc>
      ::max_size(const allocator_type &a)
{
  return allocator_traits_detail::max_size(a);
}

template<typename Alloc>
__attribute__((host)) __attribute__((device))
  typename allocator_system<Alloc>::get_result_type
    allocator_system<Alloc>
      ::get(Alloc &a)
{
  return allocator_traits_detail::system(a);
}


}
}
# 282 "/usr/local/cuda-8.0/include/thrust/detail/allocator/allocator_traits.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.h" 2

namespace thrust
{

namespace detail
{


template<typename T, typename Alloc>
  class contiguous_storage
{
  private:
    typedef thrust::detail::allocator_traits<Alloc> alloc_traits;

  public:
    typedef Alloc allocator_type;
    typedef T value_type;
    typedef typename alloc_traits::pointer pointer;
    typedef typename alloc_traits::const_pointer const_pointer;
    typedef typename alloc_traits::size_type size_type;
    typedef typename alloc_traits::difference_type difference_type;






    typedef typename Alloc::reference reference;
    typedef typename Alloc::const_reference const_reference;

    typedef thrust::detail::normal_iterator<pointer> iterator;
    typedef thrust::detail::normal_iterator<const_pointer> const_iterator;

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    explicit contiguous_storage(const allocator_type &alloc = allocator_type());

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    explicit contiguous_storage(size_type n, const allocator_type &alloc = allocator_type());

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    ~contiguous_storage(void);

    __attribute__((host)) __attribute__((device))
    size_type size(void) const;

    __attribute__((host)) __attribute__((device))
    size_type max_size(void) const;

    __attribute__((host)) __attribute__((device))
    iterator begin(void);

    __attribute__((host)) __attribute__((device))
    const_iterator begin(void) const;

    __attribute__((host)) __attribute__((device))
    iterator end(void);

    __attribute__((host)) __attribute__((device))
    const_iterator end(void) const;

    __attribute__((host)) __attribute__((device))
    reference operator[](size_type n);

    __attribute__((host)) __attribute__((device))
    const_reference operator[](size_type n) const;

    __attribute__((host)) __attribute__((device))
    allocator_type get_allocator(void) const;


    __attribute__((host)) __attribute__((device))
    void allocate(size_type n);

    __attribute__((host)) __attribute__((device))
    void deallocate(void);

    __attribute__((host)) __attribute__((device))
    void swap(contiguous_storage &x);

    __attribute__((host)) __attribute__((device))
    void default_construct_n(iterator first, size_type n);

    __attribute__((host)) __attribute__((device))
    void uninitialized_fill_n(iterator first, size_type n, const value_type &value);

    template<typename InputIterator>
    __attribute__((host)) __attribute__((device))
    iterator uninitialized_copy(InputIterator first, InputIterator last, iterator result);

    template<typename System, typename InputIterator>
    __attribute__((host)) __attribute__((device))
    iterator uninitialized_copy(thrust::execution_policy<System> &from_system,
                                InputIterator first,
                                InputIterator last,
                                iterator result);

    template<typename InputIterator, typename Size>
    __attribute__((host)) __attribute__((device))
    iterator uninitialized_copy_n(InputIterator first, Size n, iterator result);

    template<typename System, typename InputIterator, typename Size>
    __attribute__((host)) __attribute__((device))
    iterator uninitialized_copy_n(thrust::execution_policy<System> &from_system,
                                  InputIterator first,
                                  Size n,
                                  iterator result);

    __attribute__((host)) __attribute__((device))
    void destroy(iterator first, iterator last);

  private:

    allocator_type m_allocator;

    iterator m_begin;

    size_type m_size;


    contiguous_storage &operator=(const contiguous_storage &x);
};

}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
void swap(detail::contiguous_storage<T,Alloc> &lhs, detail::contiguous_storage<T,Alloc> &rhs);

}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.inl"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/swap.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/detail/swap.h"
       



namespace thrust
{

 #pragma nv_exec_check_disable
template<typename Assignable1, typename Assignable2>
__attribute__((host)) __attribute__((device))
inline void swap(Assignable1 &a, Assignable2 &b)
{
  Assignable1 temp = a;
  a = b;
  b = temp;
}

}
# 21 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.inl" 2

# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/copy_construct_range.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/allocator/copy_construct_range.h"
       




namespace thrust
{
namespace detail
{

template<typename System, typename Allocator, typename InputIterator, typename Pointer>
__attribute__((host)) __attribute__((device))
  Pointer copy_construct_range(thrust::execution_policy<System> &from_system,
                               Allocator &a,
                               InputIterator first,
                               InputIterator last,
                               Pointer result);

template<typename System, typename Allocator, typename InputIterator, typename Size, typename Pointer>
__attribute__((host)) __attribute__((device))
  Pointer copy_construct_range_n(thrust::execution_policy<System> &from_system,
                                 Allocator &a,
                                 InputIterator first,
                                 Size n,
                                 Pointer result);

}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/copy_construct_range.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/allocator/copy_construct_range.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/detail/copy.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/copy.h"
       




namespace thrust
{

template<typename System,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy(const thrust::detail::execution_policy_base<System> &system,
                      InputIterator first,
                      InputIterator last,
                      OutputIterator result);

template<typename System,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_n(const thrust::detail::execution_policy_base<System> &system,
                        InputIterator first,
                        Size n,
                        OutputIterator result);

template<typename InputIterator,
         typename OutputIterator>
  OutputIterator copy(InputIterator first,
                      InputIterator last,
                      OutputIterator result);

template<typename InputIterator,
         typename Size,
         typename OutputIterator>
  OutputIterator copy_n(InputIterator first,
                        Size n,
                        OutputIterator result);


namespace detail
{


template<typename FromSystem,
         typename ToSystem,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator two_system_copy(const thrust::execution_policy<FromSystem> &from_system,
                                 const thrust::execution_policy<ToSystem> &two_system,
                                 InputIterator first,
                                 InputIterator last,
                                 OutputIterator result);


template<typename FromSystem,
         typename ToSystem,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator two_system_copy_n(const thrust::execution_policy<FromSystem> &from_system,
                                   const thrust::execution_policy<ToSystem> &two_system,
                                   InputIterator first,
                                   Size n,
                                   OutputIterator result);


}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/copy.inl" 1
# 20 "/usr/local/cuda-8.0/include/thrust/detail/copy.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/select_system.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/select_system.h"
       





# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/minimum_system.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/minimum_system.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/minimum_type.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/minimum_type.h"
       



namespace thrust
{

namespace detail
{

namespace minimum_type_detail
{





template <typename T1, typename T2, bool GreaterEqual, bool LessEqual> struct minimum_type_impl {};

template <typename T1, typename T2>
struct minimum_type_impl<T1,T2,true,false>
{
  typedef T2 type;
};

template <typename T1, typename T2>
struct minimum_type_impl<T1,T2,false,true>
{
  typedef T1 type;
};

template <typename T1, typename T2>
struct minimum_type_impl<T1,T2,true,true>
{
  typedef T1 type;
};

template <typename T1, typename T2>
struct primitive_minimum_type
  : minimum_type_detail::minimum_type_impl<
      T1,
      T2,
      ::thrust::detail::is_convertible<T1,T2>::value,
      ::thrust::detail::is_convertible<T2,T1>::value
    >
{
};



template <typename T>
struct primitive_minimum_type<T,T>
{
  typedef T type;
};


struct any_conversion
{
  template<typename T> operator T (void);
};

}

template<typename T1,
         typename T2 = minimum_type_detail::any_conversion,
         typename T3 = minimum_type_detail::any_conversion,
         typename T4 = minimum_type_detail::any_conversion,
         typename T5 = minimum_type_detail::any_conversion,
         typename T6 = minimum_type_detail::any_conversion,
         typename T7 = minimum_type_detail::any_conversion,
         typename T8 = minimum_type_detail::any_conversion,
         typename T9 = minimum_type_detail::any_conversion,
         typename T10 = minimum_type_detail::any_conversion,
         typename T11 = minimum_type_detail::any_conversion,
         typename T12 = minimum_type_detail::any_conversion,
         typename T13 = minimum_type_detail::any_conversion,
         typename T14 = minimum_type_detail::any_conversion,
         typename T15 = minimum_type_detail::any_conversion,
         typename T16 = minimum_type_detail::any_conversion>
  struct minimum_type;


template<typename T1, typename T2>
  struct minimum_type<T1,T2>
    : minimum_type_detail::primitive_minimum_type<T1,T2>
{};

template<typename T1, typename T2>
  struct lazy_minimum_type
    : minimum_type<
        typename T1::type,
        typename T2::type
      >
{};


template<typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8,
         typename T9, typename T10, typename T11, typename T12,
         typename T13, typename T14, typename T15, typename T16>
  struct minimum_type
    : lazy_minimum_type<
        lazy_minimum_type<
          lazy_minimum_type<
            minimum_type<
              T1,T2
            >,
            minimum_type<
              T3,T4
            >
          >,
          lazy_minimum_type<
            minimum_type<
              T5,T6
            >,
            minimum_type<
              T7,T8
            >
          >
        >,
        lazy_minimum_type<
          lazy_minimum_type<
            minimum_type<
              T9,T10
            >,
            minimum_type<
              T11,T12
            >
          >,
          lazy_minimum_type<
            minimum_type<
              T13,T14
            >,
            minimum_type<
              T15,T16
            >
          >
        >
      >
{};

}

}
# 23 "/usr/local/cuda-8.0/include/thrust/iterator/detail/minimum_system.h" 2

namespace thrust
{
namespace detail
{


template<typename T1,
         typename T2 = void,
         typename T3 = void,
         typename T4 = void,
         typename T5 = void,
         typename T6 = void,
         typename T7 = void,
         typename T8 = void,
         typename T9 = void,
         typename T10 = void,
         typename T11 = void,
         typename T12 = void,
         typename T13 = void,
         typename T14 = void,
         typename T15 = void,
         typename T16 = void>
  struct unrelated_systems {};




template<typename T1,
         typename T2 = minimum_type_detail::any_conversion,
         typename T3 = minimum_type_detail::any_conversion,
         typename T4 = minimum_type_detail::any_conversion,
         typename T5 = minimum_type_detail::any_conversion,
         typename T6 = minimum_type_detail::any_conversion,
         typename T7 = minimum_type_detail::any_conversion,
         typename T8 = minimum_type_detail::any_conversion,
         typename T9 = minimum_type_detail::any_conversion,
         typename T10 = minimum_type_detail::any_conversion,
         typename T11 = minimum_type_detail::any_conversion,
         typename T12 = minimum_type_detail::any_conversion,
         typename T13 = minimum_type_detail::any_conversion,
         typename T14 = minimum_type_detail::any_conversion,
         typename T15 = minimum_type_detail::any_conversion,
         typename T16 = minimum_type_detail::any_conversion>
  struct minimum_system
    : thrust::detail::eval_if<
        is_metafunction_defined<
          minimum_type<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16>
        >::value,
        minimum_type<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16>,
        thrust::detail::identity_<
          unrelated_systems<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16>
        >
      >
{};


}
}
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/select_system.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/type_traits.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/type_traits.h"
       



namespace thrust
{


struct any_system_tag;

namespace system
{
namespace detail
{


namespace generic_type_traits_ns
{

typedef char yes;
typedef char (&no)[2];

struct any_conversion
{
  template<typename T> any_conversion(const T &);


  any_conversion(const any_system_tag &);
};

namespace select_system_exists_ns
{
  no select_system(const any_conversion &);
  no select_system(const any_conversion &, const any_conversion &);
  no select_system(const any_conversion &, const any_conversion &, const any_conversion &);
  no select_system(const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &);
  no select_system(const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &);
  no select_system(const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &);

  template<typename T> yes check(const T &);

  no check(no);

  template<typename Tag>
    struct select_system1_exists
  {
    static Tag &tag;

    static const bool value = sizeof(check(select_system(tag))) == sizeof(yes);
  };

  template<typename Tag1, typename Tag2>
    struct select_system2_exists
  {
    static Tag1 &tag1;
    static Tag2 &tag2;

    static const bool value = sizeof(check(select_system(tag1,tag2))) == sizeof(yes);
  };

  template<typename Tag1, typename Tag2, typename Tag3>
    struct select_system3_exists
  {
    static Tag1 &tag1;
    static Tag2 &tag2;
    static Tag3 &tag3;

    static const bool value = sizeof(check(select_system(tag1,tag2,tag3))) == sizeof(yes);
  };

  template<typename Tag1, typename Tag2, typename Tag3, typename Tag4>
    struct select_system4_exists
  {
    static Tag1 &tag1;
    static Tag2 &tag2;
    static Tag3 &tag3;
    static Tag4 &tag4;

    static const bool value = sizeof(check(select_system(tag1,tag2,tag3,tag4))) == sizeof(yes);
  };

  template<typename Tag1, typename Tag2, typename Tag3, typename Tag4, typename Tag5>
    struct select_system5_exists
  {
    static Tag1 &tag1;
    static Tag2 &tag2;
    static Tag3 &tag3;
    static Tag4 &tag4;
    static Tag5 &tag5;

    static const bool value = sizeof(check(select_system(tag1,tag2,tag3,tag4,tag5))) == sizeof(yes);
  };

  template<typename Tag1, typename Tag2, typename Tag3, typename Tag4, typename Tag5, typename Tag6>
    struct select_system6_exists
  {
    static Tag1 &tag1;
    static Tag2 &tag2;
    static Tag3 &tag3;
    static Tag4 &tag4;
    static Tag5 &tag5;
    static Tag6 &tag6;

    static const bool value = sizeof(check(select_system(tag1,tag2,tag3,tag4,tag5,tag6))) == sizeof(yes);
  };
}

}

namespace generic
{

template<typename Tag>
  struct select_system1_exists
    : generic_type_traits_ns::select_system_exists_ns::select_system1_exists<Tag>
{};

template<typename Tag1, typename Tag2>
  struct select_system2_exists
    : generic_type_traits_ns::select_system_exists_ns::select_system2_exists<Tag1,Tag2>
{};

template<typename Tag1, typename Tag2, typename Tag3>
  struct select_system3_exists
    : generic_type_traits_ns::select_system_exists_ns::select_system3_exists<Tag1,Tag2,Tag3>
{};

template<typename Tag1, typename Tag2, typename Tag3, typename Tag4>
  struct select_system4_exists
    : generic_type_traits_ns::select_system_exists_ns::select_system4_exists<Tag1,Tag2,Tag3,Tag4>
{};

template<typename Tag1, typename Tag2, typename Tag3, typename Tag4, typename Tag5>
  struct select_system5_exists
    : generic_type_traits_ns::select_system_exists_ns::select_system5_exists<Tag1,Tag2,Tag3,Tag4,Tag5>
{};

template<typename Tag1, typename Tag2, typename Tag3, typename Tag4, typename Tag5, typename Tag6>
  struct select_system6_exists
    : generic_type_traits_ns::select_system_exists_ns::select_system6_exists<Tag1,Tag2,Tag3,Tag4,Tag5,Tag6>
{};

}
}
}
}
# 25 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/select_system.h" 2


namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace select_system_detail
{



template<typename System>
__attribute__((host)) __attribute__((device))
System &min_system(thrust::execution_policy<System> &system1,
                   thrust::execution_policy<System> &)
{
  return thrust::detail::derived_cast(system1);
}



template<typename System1, typename System2>
__attribute__((host)) __attribute__((device))
  typename thrust::detail::enable_if<
    thrust::detail::is_same<
      System1,
      typename thrust::detail::minimum_system<System1,System2>::type
    >::value,
    System1 &
  >::type
    min_system(thrust::execution_policy<System1> &system1, thrust::execution_policy<System2> &)
{
  return thrust::detail::derived_cast(system1);
}



template<typename System1, typename System2>
__attribute__((host)) __attribute__((device))
  typename thrust::detail::enable_if<
    thrust::detail::is_same<
      System2,
      typename thrust::detail::minimum_system<System1,System2>::type
    >::value,
    System2 &
  >::type
    min_system(thrust::execution_policy<System1> &, thrust::execution_policy<System2> &system2)
{
  return thrust::detail::derived_cast(system2);
}


}


template<typename System>
__attribute__((host)) __attribute__((device))
  typename thrust::detail::disable_if<
    select_system1_exists<System>::value,
    System &
  >::type
    select_system(thrust::execution_policy<System> &system)
{
  return thrust::detail::derived_cast(system);
}


template<typename System1, typename System2>
__attribute__((host)) __attribute__((device))
  typename thrust::detail::enable_if_defined<
    thrust::detail::minimum_system<System1,System2>
  >::type
    &select_system(thrust::execution_policy<System1> &system1,
                   thrust::execution_policy<System2> &system2)
{
  return select_system_detail::min_system(system1,system2);
}


template<typename System1, typename System2, typename System3>
__attribute__((host)) __attribute__((device))
  typename thrust::detail::lazy_disable_if<
    select_system3_exists<System1,System2,System3>::value,
    thrust::detail::minimum_system<System1,System2,System3>
  >::type
    &select_system(thrust::execution_policy<System1> &system1,
                   thrust::execution_policy<System2> &system2,
                   thrust::execution_policy<System3> &system3)
{
  return select_system(select_system(system1,system2), system3);
}


template<typename System1, typename System2, typename System3, typename System4>
__attribute__((host)) __attribute__((device))
  typename thrust::detail::lazy_disable_if<
    select_system4_exists<System1,System2,System3,System4>::value,
    thrust::detail::minimum_system<System1,System2,System3,System4>
  >::type
    &select_system(thrust::execution_policy<System1> &system1,
                   thrust::execution_policy<System2> &system2,
                   thrust::execution_policy<System3> &system3,
                   thrust::execution_policy<System4> &system4)
{
  return select_system(select_system(system1,system2,system3), system4);
}


template<typename System1, typename System2, typename System3, typename System4, typename System5>
__attribute__((host)) __attribute__((device))
  typename thrust::detail::lazy_disable_if<
    select_system5_exists<System1,System2,System3,System4,System5>::value,
    thrust::detail::minimum_system<System1,System2,System3,System4,System5>
  >::type
    &select_system(thrust::execution_policy<System1> &system1,
                   thrust::execution_policy<System2> &system2,
                   thrust::execution_policy<System3> &system3,
                   thrust::execution_policy<System4> &system4,
                   thrust::execution_policy<System5> &system5)
{
  return select_system(select_system(system1,system2,system3,system4), system5);
}


template<typename System1, typename System2, typename System3, typename System4, typename System5, typename System6>
__attribute__((host)) __attribute__((device))
  typename thrust::detail::lazy_disable_if<
    select_system6_exists<System1,System2,System3,System4,System5,System6>::value,
    thrust::detail::minimum_system<System1,System2,System3,System4,System5,System6>
  >::type
    &select_system(thrust::execution_policy<System1> &system1,
                   thrust::execution_policy<System2> &system2,
                   thrust::execution_policy<System3> &system3,
                   thrust::execution_policy<System4> &system4,
                   thrust::execution_policy<System5> &system5,
                   thrust::execution_policy<System6> &system6)
{
  return select_system(select_system(system1,system2,system3,system4,system5), system6);
}



inline __attribute__((host)) __attribute__((device))
thrust::device_system_tag select_system(thrust::any_system_tag)
{
  return thrust::device_system_tag();
}


}
}
}
}
# 21 "/usr/local/cuda-8.0/include/thrust/detail/copy.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/tag.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/tag.h"
       



namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{



struct tag
{
  template<typename T>
  __attribute__((host)) __attribute__((device)) inline
  tag(const T &) {}
};

}
}
}
}
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy.h" 2

namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy(thrust::execution_policy<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      OutputIterator result);


template<typename DerivedPolicy,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_n(thrust::execution_policy<DerivedPolicy> &exec,
                        InputIterator first,
                        Size n,
                        OutputIterator result);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy.inl"
       



# 1 "/usr/local/cuda-8.0/include/thrust/functional.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/functional.h"
       


# 1 "/usr/include/c++/4.8.2/functional" 1 3
# 46 "/usr/include/c++/4.8.2/functional" 3
       
# 47 "/usr/include/c++/4.8.2/functional" 3
# 26 "/usr/local/cuda-8.0/include/thrust/functional.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/placeholder.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/functional/placeholder.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.h" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/tuple.h" 1
# 31 "/usr/local/cuda-8.0/include/thrust/tuple.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/tuple.inl" 1
# 20 "/usr/local/cuda-8.0/include/thrust/detail/tuple.inl"
namespace thrust
{


struct null_type {};


__attribute__((host)) __attribute__((device)) inline
bool operator==(const null_type&, const null_type&) { return true; }

__attribute__((host)) __attribute__((device)) inline
bool operator>=(const null_type&, const null_type&) { return true; }

__attribute__((host)) __attribute__((device)) inline
bool operator<=(const null_type&, const null_type&) { return true; }

__attribute__((host)) __attribute__((device)) inline
bool operator!=(const null_type&, const null_type&) { return false; }

__attribute__((host)) __attribute__((device)) inline
bool operator<(const null_type&, const null_type&) { return false; }

__attribute__((host)) __attribute__((device)) inline
bool operator>(const null_type&, const null_type&) { return false; }


template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type>
class tuple;


template<int i, typename T> struct tuple_element;


template<class T>
  struct tuple_element<0,T>
{
  typedef typename T::head_type type;
};

template<int N, class T>
  struct tuple_element<N, const T>
{
  private:
    typedef typename T::tail_type Next;
    typedef typename tuple_element<N-1, Next>::type unqualified_type;

  public:
    typedef typename thrust::detail::add_const<unqualified_type>::type type;
};

template<class T>
  struct tuple_element<0,const T>
{
  typedef typename thrust::detail::add_const<typename T::head_type>::type type;
};




template<class T> struct tuple_size;


template<>
  struct tuple_size< tuple<> >
{
  static const int value = 0;
};

template<>
  struct tuple_size<null_type>
{
  static const int value = 0;
};




namespace detail
{

template <class HT, class TT> struct cons;

}



template <class T> struct access_traits
{
  typedef const T& const_type;
  typedef T& non_const_type;

  typedef const typename thrust::detail::remove_cv<T>::type& parameter_type;






};

template <class T> struct access_traits<T&>
{
  typedef T& const_type;
  typedef T& non_const_type;

  typedef T& parameter_type;
};


template<int N, class HT, class TT>
__attribute__((host)) __attribute__((device))
inline typename access_traits<
                  typename tuple_element<N, detail::cons<HT, TT> >::type
                >::non_const_type


get(detail::cons<HT, TT>& c);

template<int N, class HT, class TT>
__attribute__((host)) __attribute__((device))
inline typename access_traits<
                  typename tuple_element<N, detail::cons<HT, TT> >::type
                >::const_type


get(const detail::cons<HT, TT>& c);

namespace detail
{



template<class T>
class generate_error;




template< int N >
struct get_class
{
  template<class RET, class HT, class TT >
  __attribute__((host)) __attribute__((device))
  inline static RET get(const cons<HT, TT>& t)
  {


    return get_class<N-1>::template get<RET>(t.tail);



  }

  template<class RET, class HT, class TT >
  __attribute__((host)) __attribute__((device))
  inline static RET get(cons<HT, TT>& t)
  {


    return get_class<N-1>::template get<RET>(t.tail);



  }
};

template<>
struct get_class<0>
{
  template<class RET, class HT, class TT>
  __attribute__((host)) __attribute__((device))
  inline static RET get(const cons<HT, TT>& t)
  {
    return t.head;
  }

  template<class RET, class HT, class TT>
  __attribute__((host)) __attribute__((device))
  inline static RET get(cons<HT, TT>& t)
  {
    return t.head;
  }
};


template <bool If, class Then, class Else> struct IF
{
  typedef Then RET;
};

template <class Then, class Else> struct IF<false, Then, Else>
{
  typedef Else RET;
};







template <class T> class non_storeable_type
{
  __attribute__((host)) __attribute__((device))
  non_storeable_type();
};

template <class T> struct wrap_non_storeable_type
{





  typedef T type;
};

template <> struct wrap_non_storeable_type<void>
{
  typedef non_storeable_type<void> type;
};


template <class HT, class TT>
  struct cons
{
  typedef HT head_type;
  typedef TT tail_type;

  typedef typename
    wrap_non_storeable_type<head_type>::type stored_head_type;

  stored_head_type head;
  tail_type tail;

  inline __attribute__((host)) __attribute__((device))
  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }

  inline __attribute__((host)) __attribute__((device))
  typename access_traits<tail_type>::non_const_type
  get_tail() { return tail; }

  inline __attribute__((host)) __attribute__((device))
  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  inline __attribute__((host)) __attribute__((device))
  typename access_traits<tail_type>::const_type
  get_tail() const { return tail; }

  inline __attribute__((host)) __attribute__((device))
  cons(void) : head(), tail() {}







  inline __attribute__((host)) __attribute__((device))
  cons(typename access_traits<stored_head_type>::parameter_type h,
       const tail_type& t)
    : head (h), tail(t) {}

  template <class T1, class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  inline __attribute__((host)) __attribute__((device))
  cons( T1& t1, T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (t1),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, static_cast<const null_type&>(null_type()))
      {}

  template <class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  inline __attribute__((host)) __attribute__((device))
  cons( const null_type& , T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, static_cast<const null_type&>(null_type()))
      {}


  template <class HT2, class TT2>
  inline __attribute__((host)) __attribute__((device))
  cons( const cons<HT2, TT2>& u ) : head(u.head), tail(u.tail) {}

  template <class HT2, class TT2>
  inline __attribute__((host)) __attribute__((device))
  cons& operator=( const cons<HT2, TT2>& u ) {
    head=u.head; tail=u.tail; return *this;
  }



  inline __attribute__((host)) __attribute__((device))
  cons& operator=(const cons& u) {
    head = u.head; tail = u.tail; return *this;
  }
# 334 "/usr/local/cuda-8.0/include/thrust/detail/tuple.inl"
  template <int N>
  __attribute__((host)) __attribute__((device))
  typename access_traits<
             typename tuple_element<N, cons<HT, TT> >::type
           >::non_const_type
  get() {
    return thrust::get<N>(*this);
  }

  template <int N>
  __attribute__((host)) __attribute__((device))
  typename access_traits<
             typename tuple_element<N, cons<HT, TT> >::type
           >::const_type
  get() const {
    return thrust::get<N>(*this);
  }

  inline __attribute__((host)) __attribute__((device))
  void swap(cons &c)
  {
    using thrust::swap;

    swap(head, c.head);
    tail.swap(c.tail);
  }
};

template <class HT>
  struct cons<HT, null_type>
{
  typedef HT head_type;
  typedef null_type tail_type;
  typedef cons<HT, null_type> self_type;

  typedef typename
    wrap_non_storeable_type<head_type>::type stored_head_type;
  stored_head_type head;

  typename access_traits<stored_head_type>::non_const_type
  inline __attribute__((host)) __attribute__((device))
  get_head() { return head; }

  inline __attribute__((host)) __attribute__((device))
  null_type get_tail() { return null_type(); }

  inline __attribute__((host)) __attribute__((device))
  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  inline __attribute__((host)) __attribute__((device))
  null_type get_tail() const { return null_type(); }

  inline __attribute__((host)) __attribute__((device))
  cons() : head() {}

  inline __attribute__((host)) __attribute__((device))
  cons(typename access_traits<stored_head_type>::parameter_type h,
       const null_type& = null_type())
    : head (h) {}

  template<class T1>
  inline __attribute__((host)) __attribute__((device))
  cons(T1& t1, const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head (t1) {}

  inline __attribute__((host)) __attribute__((device))
  cons(const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head () {}

  template <class HT2>
  inline __attribute__((host)) __attribute__((device))
  cons( const cons<HT2, null_type>& u ) : head(u.head) {}

  template <class HT2>
  inline __attribute__((host)) __attribute__((device))
  cons& operator=(const cons<HT2, null_type>& u )
  {
    head = u.head;
    return *this;
  }



  inline __attribute__((host)) __attribute__((device))
  cons& operator=(const cons& u) { head = u.head; return *this; }

  template <int N>
  inline __attribute__((host)) __attribute__((device))
  typename access_traits<
             typename tuple_element<N, self_type>::type
            >::non_const_type


  get(void)
  {
    return thrust::get<N>(*this);
  }

  template <int N>
  inline __attribute__((host)) __attribute__((device))
  typename access_traits<
             typename tuple_element<N, self_type>::type
           >::const_type


  get(void) const
  {
    return thrust::get<N>(*this);
  }

  inline __attribute__((host)) __attribute__((device))
  void swap(cons &c)
  {
    using thrust::swap;

    swap(head, c.head);
  }
};

template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
  struct map_tuple_to_cons
{
  typedef cons<T0,
               typename map_tuple_to_cons<T1, T2, T3, T4, T5,
                                          T6, T7, T8, T9, null_type>::type
              > type;
};


template <>
  struct map_tuple_to_cons<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>
{
  typedef null_type type;
};
# 492 "/usr/local/cuda-8.0/include/thrust/detail/tuple.inl"
template<class T>
struct make_tuple_traits {
  typedef T type;







};
# 516 "/usr/local/cuda-8.0/include/thrust/detail/tuple.inl"
template<class T>
struct make_tuple_traits<T&> {
  typedef typename
     detail::generate_error<T&>::
       do_not_use_with_reference_type error;
};





template<class T, int n> struct make_tuple_traits <T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n> struct make_tuple_traits<volatile T[n]> {
  typedef const volatile T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const volatile T[n]> {
  typedef const volatile T (&type)[n];
};
# 559 "/usr/local/cuda-8.0/include/thrust/detail/tuple.inl"
template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type
>
struct make_tuple_mapper {
  typedef
    tuple<typename make_tuple_traits<T0>::type,
          typename make_tuple_traits<T1>::type,
          typename make_tuple_traits<T2>::type,
          typename make_tuple_traits<T3>::type,
          typename make_tuple_traits<T4>::type,
          typename make_tuple_traits<T5>::type,
          typename make_tuple_traits<T6>::type,
          typename make_tuple_traits<T7>::type,
          typename make_tuple_traits<T8>::type,
          typename make_tuple_traits<T9>::type> type;
};

}


template<int N, class HT, class TT>
__attribute__((host)) __attribute__((device))
inline typename access_traits<
                  typename tuple_element<N, detail::cons<HT, TT> >::type
                >::non_const_type
get(detail::cons<HT, TT>& c)
{





  return detail::get_class<N>::template
         get<
           typename access_traits<
             typename tuple_element<N, detail::cons<HT, TT> >::type
           >::non_const_type,
           HT,TT
         >(c);
}





template<int N, class HT, class TT>
__attribute__((host)) __attribute__((device))
inline typename access_traits<
                  typename tuple_element<N, detail::cons<HT, TT> >::type
                >::const_type
get(const detail::cons<HT, TT>& c)
{





  return detail::get_class<N>::template
         get<
           typename access_traits<
             typename tuple_element<N, detail::cons<HT, TT> >::type
           >::const_type,
           HT,TT
         >(c);
}


template<class T0>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0>::type
    make_tuple(const T0& t0)
{
  typedef typename detail::make_tuple_mapper<T0>::type t;
  return t(t0);
}

template<class T0, class T1>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1>::type
    make_tuple(const T0& t0, const T1& t1)
{
  typedef typename detail::make_tuple_mapper<T0,T1>::type t;
  return t(t0,t1);
}

template<class T0, class T1, class T2>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2)
{
  typedef typename detail::make_tuple_mapper<T0,T1,T2>::type t;
  return t(t0,t1,t2);
}

template<class T0, class T1, class T2, class T3>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3)
{
  typedef typename detail::make_tuple_mapper<T0,T1,T2,T3>::type t;
  return t(t0,t1,t2,t3);
}

template<class T0, class T1, class T2, class T3, class T4>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4)
{
  typedef typename detail::make_tuple_mapper<T0,T1,T2,T3,T4>::type t;
  return t(t0,t1,t2,t3,t4);
}

template<class T0, class T1, class T2, class T3, class T4, class T5>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5)
{
  typedef typename detail::make_tuple_mapper<T0,T1,T2,T3,T4,T5>::type t;
  return t(t0,t1,t2,t3,t4,t5);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6)
{
  typedef typename detail::make_tuple_mapper<T0,T1,T2,T3,T4,T5,T6>::type t;
  return t(t0,t1,t2,t3,t4,t5,t6);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6, const T7& t7)
{
  typedef typename detail::make_tuple_mapper<T0,T1,T2,T3,T4,T5,T6,T7>::type t;
  return t(t0,t1,t2,t3,t4,t5,t6,t7);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6, const T7& t7, const T8& t8)
{
  typedef typename detail::make_tuple_mapper<T0,T1,T2,T3,T4,T5,T6,T7,T8>::type t;
  return t(t0,t1,t2,t3,t4,t5,t6,t7,t8);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6, const T7& t7, const T8& t8, const T9& t9)
{
  typedef typename detail::make_tuple_mapper<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>::type t;
  return t(t0,t1,t2,t3,t4,t5,t6,t7,t8,t9);
}


template<typename T0>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&> tie(T0 &t0)
{
  return tuple<T0&>(t0);
}

template<typename T0,typename T1>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&> tie(T0 &t0, T1 &t1)
{
  return tuple<T0&,T1&>(t0,t1);
}

template<typename T0,typename T1, typename T2>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&> tie(T0 &t0, T1 &t1, T2 &t2)
{
  return tuple<T0&,T1&,T2&>(t0,t1,t2);
}

template<typename T0,typename T1, typename T2, typename T3>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3)
{
  return tuple<T0&,T1&,T2&,T3&>(t0,t1,t2,t3);
}

template<typename T0,typename T1, typename T2, typename T3, typename T4>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4)
{
  return tuple<T0&,T1&,T2&,T3&,T4&>(t0,t1,t2,t3,t4);
}

template<typename T0,typename T1, typename T2, typename T3, typename T4, typename T5>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5)
{
  return tuple<T0&,T1&,T2&,T3&,T4&,T5&>(t0,t1,t2,t3,t4,t5);
}

template<typename T0,typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6)
{
  return tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&>(t0,t1,t2,t3,t4,t5,t6);
}

template<typename T0,typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6, T7 &t7)
{
  return tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&>(t0,t1,t2,t3,t4,t5,t6,t7);
}

template<typename T0,typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6, T7 &t7, T8 &t8)
{
  return tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&>(t0,t1,t2,t3,t4,t5,t6,t7,t8);
}

template<typename T0,typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&,T9&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6, T7 &t7, T8 &t8, T9 &t9)
{
  return tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&,T9&>(t0,t1,t2,t3,t4,t5,t6,t7,t8,t9);
}

template<
  typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9,
  typename U0, typename U1, typename U2, typename U3, typename U4, typename U5, typename U6, typename U7, typename U8, typename U9
>
__attribute__((host)) __attribute__((device)) inline
void swap(thrust::tuple<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9> &x,
          thrust::tuple<U0,U1,U2,U3,U4,U5,U6,U7,U8,U9> &y)
{
  return x.swap(y);
}



namespace detail
{

template<class T1, class T2>
__attribute__((host)) __attribute__((device))
inline bool eq(const T1& lhs, const T2& rhs) {
  return lhs.get_head() == rhs.get_head() &&
         eq(lhs.get_tail(), rhs.get_tail());
}
template<>
inline bool eq<null_type,null_type>(const null_type&, const null_type&) { return true; }

template<class T1, class T2>
__attribute__((host)) __attribute__((device))
inline bool neq(const T1& lhs, const T2& rhs) {
  return lhs.get_head() != rhs.get_head() ||
         neq(lhs.get_tail(), rhs.get_tail());
}
template<>
__attribute__((host)) __attribute__((device))
inline bool neq<null_type,null_type>(const null_type&, const null_type&) { return false; }

template<class T1, class T2>
__attribute__((host)) __attribute__((device))
inline bool lt(const T1& lhs, const T2& rhs) {
  return (lhs.get_head() < rhs.get_head()) ||
            (!(rhs.get_head() < lhs.get_head()) &&
             lt(lhs.get_tail(), rhs.get_tail()));
}
template<>
__attribute__((host)) __attribute__((device))
inline bool lt<null_type,null_type>(const null_type&, const null_type&) { return false; }

template<class T1, class T2>
__attribute__((host)) __attribute__((device))
inline bool gt(const T1& lhs, const T2& rhs) {
  return (lhs.get_head() > rhs.get_head()) ||
            (!(rhs.get_head() > lhs.get_head()) &&
             gt(lhs.get_tail(), rhs.get_tail()));
}
template<>
__attribute__((host)) __attribute__((device))
inline bool gt<null_type,null_type>(const null_type&, const null_type&) { return false; }

template<class T1, class T2>
__attribute__((host)) __attribute__((device))
inline bool lte(const T1& lhs, const T2& rhs) {
  return lhs.get_head() <= rhs.get_head() &&
          ( !(rhs.get_head() <= lhs.get_head()) ||
            lte(lhs.get_tail(), rhs.get_tail()));
}
template<>
__attribute__((host)) __attribute__((device))
inline bool lte<null_type,null_type>(const null_type&, const null_type&) { return true; }

template<class T1, class T2>
__attribute__((host)) __attribute__((device))
inline bool gte(const T1& lhs, const T2& rhs) {
  return lhs.get_head() >= rhs.get_head() &&
          ( !(rhs.get_head() >= lhs.get_head()) ||
            gte(lhs.get_tail(), rhs.get_tail()));
}
template<>
__attribute__((host)) __attribute__((device))
inline bool gte<null_type,null_type>(const null_type&, const null_type&) { return true; }

}





template<class T1, class T2, class S1, class S2>
__attribute__((host)) __attribute__((device))
inline bool operator==(const detail::cons<T1, T2>& lhs, const detail::cons<S1, S2>& rhs)
{




  return detail::eq(lhs, rhs);
}



template<class T1, class T2, class S1, class S2>
__attribute__((host)) __attribute__((device))
inline bool operator!=(const detail::cons<T1, T2>& lhs, const detail::cons<S1, S2>& rhs)
{




  return detail::neq(lhs, rhs);
}


template<class T1, class T2, class S1, class S2>
__attribute__((host)) __attribute__((device))
inline bool operator<(const detail::cons<T1, T2>& lhs, const detail::cons<S1, S2>& rhs)
{




  return detail::lt(lhs, rhs);
}


template<class T1, class T2, class S1, class S2>
__attribute__((host)) __attribute__((device))
inline bool operator>(const detail::cons<T1, T2>& lhs, const detail::cons<S1, S2>& rhs)
{




  return detail::gt(lhs, rhs);
}


template<class T1, class T2, class S1, class S2>
__attribute__((host)) __attribute__((device))
inline bool operator<=(const detail::cons<T1, T2>& lhs, const detail::cons<S1, S2>& rhs)
{




  return detail::lte(lhs, rhs);
}


template<class T1, class T2, class S1, class S2>
__attribute__((host)) __attribute__((device))
inline bool operator>=(const detail::cons<T1, T2>& lhs, const detail::cons<S1, S2>& rhs)
{




  return detail::gte(lhs, rhs);
}

}
# 35 "/usr/local/cuda-8.0/include/thrust/tuple.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/pair.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/pair.h"
       


# 1 "/usr/include/c++/4.8.2/utility" 1 3
# 58 "/usr/include/c++/4.8.2/utility" 3
       
# 59 "/usr/include/c++/4.8.2/utility" 3
# 69 "/usr/include/c++/4.8.2/utility" 3
# 1 "/usr/include/c++/4.8.2/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
 
# 85 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline
     
# 87 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
     
# 86 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
             bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline
     
# 100 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
     
# 99 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
             bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline
     
# 113 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
     
# 112 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
             bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline
     
# 126 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
     
# 125 "/usr/include/c++/4.8.2/bits/stl_relops.h" 3
             bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 70 "/usr/include/c++/4.8.2/utility" 2 3
# 25 "/usr/local/cuda-8.0/include/thrust/pair.h" 2

namespace thrust
{
# 48 "/usr/local/cuda-8.0/include/thrust/pair.h"
template <typename T1, typename T2>
  struct pair
{


  typedef T1 first_type;



  typedef T2 second_type;



  first_type first;



  second_type second;





  __attribute__((host)) __attribute__((device)) pair(void);






  inline __attribute__((host)) __attribute__((device))
  pair(const T1 &x, const T2 &y);
# 90 "/usr/local/cuda-8.0/include/thrust/pair.h"
  template <typename U1, typename U2>
  inline __attribute__((host)) __attribute__((device))
  pair(const pair<U1,U2> &p);
# 103 "/usr/local/cuda-8.0/include/thrust/pair.h"
  template <typename U1, typename U2>
  inline __attribute__((host)) __attribute__((device))
  pair(const std::pair<U1,U2> &p);





  inline __attribute__((host)) __attribute__((device))
  void swap(pair &p);
};
# 125 "/usr/local/cuda-8.0/include/thrust/pair.h"
template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator==(const pair<T1,T2> &x, const pair<T1,T2> &y);
# 139 "/usr/local/cuda-8.0/include/thrust/pair.h"
template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator<(const pair<T1,T2> &x, const pair<T1,T2> &y);
# 153 "/usr/local/cuda-8.0/include/thrust/pair.h"
template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator!=(const pair<T1,T2> &x, const pair<T1,T2> &y);
# 167 "/usr/local/cuda-8.0/include/thrust/pair.h"
template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator>(const pair<T1,T2> &x, const pair<T1,T2> &y);
# 181 "/usr/local/cuda-8.0/include/thrust/pair.h"
template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator<=(const pair<T1,T2> &x, const pair<T1,T2> &y);
# 195 "/usr/local/cuda-8.0/include/thrust/pair.h"
template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator>=(const pair<T1,T2> &x, const pair<T1,T2> &y);







template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    void swap(pair<T1,T2> &x, pair<T1,T2> &y);
# 219 "/usr/local/cuda-8.0/include/thrust/pair.h"
template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    pair<T1,T2> make_pair(T1 x, T2 y);
# 231 "/usr/local/cuda-8.0/include/thrust/pair.h"
template<int N, typename T> struct tuple_element;
# 240 "/usr/local/cuda-8.0/include/thrust/pair.h"
template<typename Pair> struct tuple_size;
# 280 "/usr/local/cuda-8.0/include/thrust/pair.h"
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/pair.inl" 1
# 20 "/usr/local/cuda-8.0/include/thrust/detail/pair.inl"
namespace thrust
{

template <typename T1, typename T2>
  pair<T1,T2>
    ::pair(void)
      :first(),second()
{
  ;
}


template <typename T1, typename T2>
  pair<T1,T2>
    ::pair(const T1 &x, const T2 &y)
      :first(x),second(y)
{
  ;
}


template <typename T1, typename T2>
  template <typename U1, typename U2>
    pair<T1,T2>
      ::pair(const pair<U1,U2> &p)
        :first(p.first),second(p.second)
{
  ;
}


template <typename T1, typename T2>
  template <typename U1, typename U2>
    pair<T1,T2>
      ::pair(const std::pair<U1,U2> &p)
        :first(p.first),second(p.second)
{
  ;
}


template<typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    void pair<T1,T2>
      ::swap(thrust::pair<T1,T2> &p)
{
  using thrust::swap;

  swap(first, p.first);
  swap(second, p.second);
}


template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator==(const pair<T1,T2> &x, const pair<T1,T2> &y)
{
  return x.first == y.first && x.second == y.second;
}


template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator<(const pair<T1,T2> &x, const pair<T1,T2> &y)
{
  return x.first < y.first || (!(y.first < x.first) && x.second < y.second);
}


template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator!=(const pair<T1,T2> &x, const pair<T1,T2> &y)
{
  return !(x == y);
}


template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator>(const pair<T1,T2> &x, const pair<T1,T2> &y)
{
  return y < x;
}


template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator<=(const pair<T1,T2> &x, const pair<T1,T2> &y)
{
  return !(y < x);
}


template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    bool operator>=(const pair<T1,T2> &x, const pair<T1,T2> &y)
{
  return !(x < y);
}


template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    void swap(pair<T1,T2> &x, pair<T1,T2> &y)
{
  return x.swap(y);
}


template <typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    pair<T1,T2> make_pair(T1 x, T2 y)
{
  return pair<T1,T2>(x,y);
}



template<typename T1, typename T2>
  struct tuple_element<0, pair<T1,T2> >
{
  typedef T1 type;
};

template<typename T1, typename T2>
  struct tuple_element<1, pair<T1,T2> >
{
  typedef T2 type;
};



template<typename T1, typename T2>
  struct tuple_size< pair<T1,T2 > >
{
  static const unsigned int value = 2;
};



namespace detail
{


template<int N, typename Pair> struct pair_get {};

template<typename Pair>
  struct pair_get<0, Pair>
{
  inline __attribute__((host)) __attribute__((device))
    const typename tuple_element<0, Pair>::type &
      operator()(const Pair &p) const
  {
    return p.first;
  }

  inline __attribute__((host)) __attribute__((device))
    typename tuple_element<0, Pair>::type &
      operator()(Pair &p) const
  {
    return p.first;
  }
};


template<typename Pair>
  struct pair_get<1, Pair>
{
  inline __attribute__((host)) __attribute__((device))
    const typename tuple_element<1, Pair>::type &
      operator()(const Pair &p) const
  {
    return p.second;
  }

  inline __attribute__((host)) __attribute__((device))
    typename tuple_element<1, Pair>::type &
      operator()(Pair &p) const
  {
    return p.second;
  }
};

}



template<unsigned int N, typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    typename tuple_element<N, pair<T1,T2> >::type &
      get(pair<T1,T2> &p)
{
  return detail::pair_get<N, pair<T1,T2> >()(p);
}

template<unsigned int N, typename T1, typename T2>
  inline __attribute__((host)) __attribute__((device))
    const typename tuple_element<N, pair<T1,T2> >::type &
      get(const pair<T1,T2> &p)
{
  return detail::pair_get<N, pair<T1,T2> >()(p);
}


}
# 283 "/usr/local/cuda-8.0/include/thrust/pair.h" 2
# 36 "/usr/local/cuda-8.0/include/thrust/tuple.h" 2

namespace thrust
{
# 51 "/usr/local/cuda-8.0/include/thrust/tuple.h"
struct null_type;
# 65 "/usr/local/cuda-8.0/include/thrust/tuple.h"
template<int N, class T>
  struct tuple_element
{
  private:
    typedef typename T::tail_type Next;

  public:


    typedef typename tuple_element<N-1, Next>::type type;
};
# 85 "/usr/local/cuda-8.0/include/thrust/tuple.h"
template<class T>
  struct tuple_size
{


  static const int value = 1 + tuple_size<typename T::tail_type>::value;
};
# 118 "/usr/local/cuda-8.0/include/thrust/tuple.h"
template<int N, class HT, class TT>
__attribute__((host)) __attribute__((device))
inline typename access_traits<
                  typename tuple_element<N, detail::cons<HT, TT> >::type
                >::non_const_type
get(detail::cons<HT, TT>& t);
# 149 "/usr/local/cuda-8.0/include/thrust/tuple.h"
template<int N, class HT, class TT>
__attribute__((host)) __attribute__((device))
inline typename access_traits<
                  typename tuple_element<N, detail::cons<HT, TT> >::type
                >::const_type
get(const detail::cons<HT, TT>& t);
# 195 "/usr/local/cuda-8.0/include/thrust/tuple.h"
template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
  class tuple :
    public detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
{



  private:
  typedef typename detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type inherited;




  public:


  inline __attribute__((host)) __attribute__((device))
  tuple(void) {}





  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0)
    : inherited(t0,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type())) {}







  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1)
    : inherited(t0, t1,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type())) {}




  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2)
    : inherited(t0, t1, t2,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type())) {}

  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3)
    : inherited(t0, t1, t2, t3,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type())) {}

  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4)
    : inherited(t0, t1, t2, t3, t4,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type())) {}

  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5)
    : inherited(t0, t1, t2, t3, t4, t5,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type())) {}

  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6)
    : inherited(t0, t1, t2, t3, t4, t5, t6,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type())) {}

  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type())) {}

  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8,
                static_cast<const null_type&>(null_type())) {}

  inline __attribute__((host)) __attribute__((device))
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8,
        typename access_traits<T9>::parameter_type t9)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}


  template<class U1, class U2>
  inline __attribute__((host)) __attribute__((device))
  tuple(const detail::cons<U1, U2>& p) : inherited(p) {}

  template <class U1, class U2>
  inline __attribute__((host)) __attribute__((device))
  tuple& operator=(const detail::cons<U1, U2>& k)
  {
    inherited::operator=(k);
    return *this;
  }







  template <class U1, class U2>
  __attribute__((host)) __attribute__((device)) inline
  tuple& operator=(const thrust::pair<U1, U2>& k) {

    this->head = k.first;
    this->tail.head = k.second;
    return *this;
  }





  inline __attribute__((host)) __attribute__((device))
  void swap(tuple &t)
  {
    inherited::swap(t);
  }
};




template <>
class tuple<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> :
  public null_type
{
public:
  typedef null_type inherited;
};
# 418 "/usr/local/cuda-8.0/include/thrust/tuple.h"
template<class T0>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0>::type
    make_tuple(const T0& t0);
# 434 "/usr/local/cuda-8.0/include/thrust/tuple.h"
template<class T0, class T1>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1>::type
    make_tuple(const T0& t0, const T1& t1);







template<typename T0>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&> tie(T0& t0);
# 460 "/usr/local/cuda-8.0/include/thrust/tuple.h"
template<typename T0, typename T1>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&> tie(T0& t0, T1& t1);






template<
  typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9,
  typename U0, typename U1, typename U2, typename U3, typename U4, typename U5, typename U6, typename U7, typename U8, typename U9
>
inline __attribute__((host)) __attribute__((device))
void swap(tuple<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9> &x,
          tuple<U0,U1,U2,U3,U4,U5,U6,U7,U8,U9> &y);






template<class T0, class T1, class T2>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2);

template<class T0, class T1, class T2, class T3>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3);

template<class T0, class T1, class T2, class T3, class T4>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4);

template<class T0, class T1, class T2, class T3, class T4, class T5>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5);

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6);

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6, const T7& t7);

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6, const T7& t7, const T8& t8);

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
__attribute__((host)) __attribute__((device)) inline
  typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
    make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6, const T7& t7, const T8& t8, const T9& t9);

template<typename T0, typename T1, typename T2>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&> tie(T0 &t0, T1 &t1, T2 &t2);

template<typename T0, typename T1, typename T2, typename T3>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3);

template<typename T0, typename T1, typename T2, typename T3, typename T4>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4);

template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5);

template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6);

template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6, T7 &t7);

template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6, T7 &t7, T8 &t8);

template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
__attribute__((host)) __attribute__((device)) inline
tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&,T9&> tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6, T7 &t7, T8 &t8, T9 &t9);


__attribute__((host)) __attribute__((device)) inline
bool operator==(const null_type&, const null_type&);

__attribute__((host)) __attribute__((device)) inline
bool operator>=(const null_type&, const null_type&);

__attribute__((host)) __attribute__((device)) inline
bool operator<=(const null_type&, const null_type&);

__attribute__((host)) __attribute__((device)) inline
bool operator!=(const null_type&, const null_type&);

__attribute__((host)) __attribute__((device)) inline
bool operator<(const null_type&, const null_type&);

__attribute__((host)) __attribute__((device)) inline
bool operator>(const null_type&, const null_type&);
# 582 "/usr/local/cuda-8.0/include/thrust/tuple.h"
}
# 30 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/value.h" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/functional/value.h"
       




namespace thrust
{
namespace detail
{
namespace functional
{


template<typename Eval> struct actor;


template<typename T>
  class value
{
  public:

    template<typename Env>
      struct result
    {
      typedef T type;
    };

    __attribute__((host)) __attribute__((device))
    value(const T &arg)
      : m_val(arg)
    {}

    template<typename Env>
    __attribute__((host)) __attribute__((device))
      T eval(const Env &) const
    {
      return m_val;
    }

  private:
    T m_val;
};

template<typename T>
__attribute__((host)) __attribute__((device))
actor<value<T> > val(const T &x)
{
  return value<T>(x);
}


}
}
}
# 31 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/composite.h" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/functional/composite.h"
       




namespace thrust
{
namespace detail
{
namespace functional
{


template<typename Eval0,
         typename Eval1 = thrust::null_type,
         typename Eval2 = thrust::null_type,
         typename Eval3 = thrust::null_type,
         typename Eval4 = thrust::null_type,
         typename Eval5 = thrust::null_type,
         typename Eval6 = thrust::null_type,
         typename Eval7 = thrust::null_type,
         typename Eval8 = thrust::null_type,
         typename Eval9 = thrust::null_type,
         typename Eval10 = thrust::null_type>
  class composite;

template<typename Eval0, typename Eval1>
  class composite<
    Eval0,
    Eval1,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type
  >
{
  public:
    template<typename Env>
      struct result
    {
      typedef typename Eval0::template result<
        thrust::tuple<
          typename Eval1::template result<Env>::type
        >
      >::type type;
    };

    __attribute__((host)) __attribute__((device))
    composite(const Eval0 &e0, const Eval1 &e1)
      : m_eval0(e0),
        m_eval1(e1)
    {}

    template<typename Env>
    __attribute__((host)) __attribute__((device))
    typename result<Env>::type
    eval(const Env &x) const
    {
      typename Eval1::template result<Env>::type result1 = m_eval1.eval(x);
      return m_eval0.eval(thrust::tie(result1));
    }

  private:
    Eval0 m_eval0;
    Eval1 m_eval1;
};

template<typename Eval0, typename Eval1, typename Eval2>
  class composite<
    Eval0,
    Eval1,
    Eval2,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type,
    thrust::null_type
  >
{
  public:
    template<typename Env>
      struct result
    {
      typedef typename Eval0::template result<
        thrust::tuple<
          typename Eval1::template result<Env>::type,
          typename Eval2::template result<Env>::type
        >
      >::type type;
    };

    __attribute__((host)) __attribute__((device))
    composite(const Eval0 &e0, const Eval1 &e1, const Eval2 &e2)
      : m_eval0(e0),
        m_eval1(e1),
        m_eval2(e2)
    {}

    template<typename Env>
    __attribute__((host)) __attribute__((device))
    typename result<Env>::type
    eval(const Env &x) const
    {
      typename Eval1::template result<Env>::type result1 = m_eval1.eval(x);
      typename Eval2::template result<Env>::type result2 = m_eval2.eval(x);
      return m_eval0.eval(thrust::tie(result1,result2));
    }

  private:
    Eval0 m_eval0;
    Eval1 m_eval1;
    Eval2 m_eval2;
};

template<typename Eval0, typename Eval1>
__attribute__((host)) __attribute__((device))
  actor<composite<Eval0,Eval1> > compose(const Eval0 &e0, const Eval1 &e1)
{
  return actor<composite<Eval0,Eval1> >(composite<Eval0,Eval1>(e0,e1));
}

template<typename Eval0, typename Eval1, typename Eval2>
__attribute__((host)) __attribute__((device))
  actor<composite<Eval0,Eval1,Eval2> > compose(const Eval0 &e0, const Eval1 &e1, const Eval2 &e2)
{
  return actor<composite<Eval0,Eval1,Eval2> >(composite<Eval0,Eval1,Eval2>(e0,e1,e2));
}

}
}
}
# 32 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/assignment_operator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/assignment_operator.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/operator_adaptors.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/operator_adaptors.h"
       





namespace thrust
{
namespace detail
{
namespace functional
{



template<template<typename> class UnaryOperator>
  struct unary_operator
{
  template<typename Env>
    struct argument
      : thrust::detail::eval_if<
          (thrust::tuple_size<Env>::value == 0),
          thrust::detail::identity_<thrust::null_type>,
          thrust::tuple_element<0,Env>
        >
  {
  };

  template<typename Env>
    struct operator_type
  {
    typedef UnaryOperator<
      typename thrust::detail::remove_reference<
        typename argument<Env>::type
      >::type
    > type;
  };

  template<typename Env>
    struct result
  {
    typedef typename operator_type<Env>::type op_type;
    typedef typename op_type::result_type type;
  };

  template<typename Env>
  __attribute__((host)) __attribute__((device))
  typename result<Env>::type eval(const Env &e) const
  {
    typename operator_type<Env>::type op;
    return op(thrust::get<0>(e));
  }
};



template<template<typename> class BinaryOperator>
  struct binary_operator
{
  template<typename Env>
    struct first_argument
      : thrust::detail::eval_if<
          (thrust::tuple_size<Env>::value == 0),
          thrust::detail::identity_<thrust::null_type>,
          thrust::tuple_element<0,Env>
        >
  {
  };

  template<typename Env>
    struct operator_type
  {
    typedef BinaryOperator<
      typename thrust::detail::remove_reference<
        typename first_argument<Env>::type
      >::type
    > type;
  };

  template<typename Env>
    struct result
  {
    typedef typename operator_type<Env>::type op_type;
    typedef typename op_type::result_type type;
  };

  template<typename Env>
  __attribute__((host)) __attribute__((device))
  typename result<Env>::type eval(const Env &e) const
  {
    typename operator_type<Env>::type op;
    return op(thrust::get<0>(e), thrust::get<1>(e));
  }
};

}
}
}
# 23 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/assignment_operator.h" 2


namespace thrust
{


template<typename,typename,typename> struct binary_function;

namespace detail
{
namespace functional
{


template<typename> struct as_actor;


template<typename T>
  struct assign
    : thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T &rhs) const { return lhs = rhs; }
};

template<typename Eval, typename T>
  struct assign_result
{
  typedef actor<
    composite<
      binary_operator<assign>,
      actor<Eval>,
      typename as_actor<T>::type
    >
  > type;
};

template<typename Eval, typename T>
  __attribute__((host)) __attribute__((device))
    typename assign_result<Eval,T>::type
      do_assign(const actor<Eval> &_1, const T &_2)
{
  return compose(binary_operator<assign>(),
                 _1,
                 as_actor<T>::convert(_2));
}

}
}
}
# 33 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/result_of_adaptable_function.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/result_of_adaptable_function.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/function_traits.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/function_traits.h"
       




namespace thrust
{


template <typename T> struct plus;
template <typename T> struct multiplies;
template <typename T> struct minimum;
template <typename T> struct maximum;
template <typename T> struct logical_or;
template <typename T> struct logical_and;
template <typename T> struct bit_or;
template <typename T> struct bit_and;
template <typename T> struct bit_xor;

namespace detail
{




template<typename T> struct has_result_type { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::result_type *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};

template<typename T> struct has_argument_type { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::argument_type *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};

template<typename T> struct has_first_argument_type { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::first_argument_type *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};

template<typename T> struct has_second_argument_type { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::second_argument_type *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};


template<typename AdaptableBinaryFunction>
  struct result_type
{
  typedef typename AdaptableBinaryFunction::result_type type;
};


template<typename T>
  struct is_adaptable_unary_function
    : thrust::detail::and_<
        has_result_type<T>,
        has_argument_type<T>
      >
{};


template<typename T>
  struct is_adaptable_binary_function
    : thrust::detail::and_<
        has_result_type<T>,
        thrust::detail::and_<
          has_first_argument_type<T>,
          has_second_argument_type<T>
        >
      >
{};


template<typename BinaryFunction>
  struct is_commutative
    : public thrust::detail::false_type
{};

template<typename T> struct is_commutative< typename thrust::plus<T> > : public thrust::detail::is_arithmetic<T> {};
template<typename T> struct is_commutative< typename thrust::multiplies<T> > : public thrust::detail::is_arithmetic<T> {};
template<typename T> struct is_commutative< typename thrust::minimum<T> > : public thrust::detail::is_arithmetic<T> {};
template<typename T> struct is_commutative< typename thrust::maximum<T> > : public thrust::detail::is_arithmetic<T> {};
template<typename T> struct is_commutative< typename thrust::logical_or<T> > : public thrust::detail::is_arithmetic<T> {};
template<typename T> struct is_commutative< typename thrust::logical_and<T> > : public thrust::detail::is_arithmetic<T> {};
template<typename T> struct is_commutative< typename thrust::bit_or<T> > : public thrust::detail::is_arithmetic<T> {};
template<typename T> struct is_commutative< typename thrust::bit_and<T> > : public thrust::detail::is_arithmetic<T> {};
template<typename T> struct is_commutative< typename thrust::bit_xor<T> > : public thrust::detail::is_arithmetic<T> {};

}
}
# 22 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/result_of_adaptable_function.h" 2

namespace thrust
{
namespace detail
{






template<typename Signature, typename Enable = void>
struct result_of_adaptable_function;



template<typename Functor, typename Arg1>
  struct result_of_adaptable_function<
    Functor(Arg1),
    typename thrust::detail::enable_if<thrust::detail::has_result_type<Functor>::value>::type
  >
{
  typedef typename Functor::result_type type;
};


template<typename Functor, typename Arg1, typename Arg2>
  struct result_of_adaptable_function<
    Functor(Arg1,Arg2),
    typename thrust::detail::enable_if<thrust::detail::has_result_type<Functor>::value>::type
  >
{
  typedef typename Functor::result_type type;
};


}
}
# 34 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.h" 2

namespace thrust
{
namespace detail
{
namespace functional
{

template<typename Action, typename Env>
  struct apply_actor
{
  typedef typename Action::template result<Env>::type type;
};

template<typename Eval>
  struct actor
    : Eval
{
  typedef Eval eval_type;

  __attribute__((host)) __attribute__((device))
  actor(void);

  __attribute__((host)) __attribute__((device))
  actor(const Eval &base);

  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::null_type >::type
  operator()(void) const;

  template<typename T0>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&> >::type
  operator()(T0 &_0) const;

  template<typename T0, typename T1>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&,T1&> >::type
  operator()(T0 &_0, T1 &_1) const;

  template<typename T0, typename T1, typename T2>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&,T1&,T2&> >::type
  operator()(T0 &_0, T1 &_1, T2 &_2) const;

  template<typename T0, typename T1, typename T2, typename T3>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&,T1&,T2&,T3&> >::type
  operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3) const;

  template<typename T0, typename T1, typename T2, typename T3, typename T4>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&,T1&,T2&,T3&,T4&> >::type
  operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4) const;

  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&> >::type
  operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5) const;

  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&> >::type
  operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6) const;

  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&> >::type
  operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6, T7 &_7) const;

  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&> >::type
  operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6, T7 &_7, T8 &_8) const;

  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
  __attribute__((host)) __attribute__((device))
  typename apply_actor<eval_type, thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&,T9&> >::type
  operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6, T7 &_7, T8 &_8, T9 &_9) const;

  template<typename T>
  __attribute__((host)) __attribute__((device))
  typename assign_result<Eval,T>::type
  operator=(const T &_1) const;
};


template<typename T>
  struct as_actor
{
  typedef value<T> type;

  static inline __attribute__((host)) __attribute__((device)) type convert(const T &x)
  {
    return val(x);
  }
};


template<typename Eval>
  struct as_actor<actor<Eval> >
{
  typedef actor<Eval> type;

  static inline __attribute__((host)) __attribute__((device)) const type &convert(const actor<Eval> &x)
  {
    return x;
  }
};

template<typename T>
  typename as_actor<T>::type
  __attribute__((host)) __attribute__((device))
    make_actor(const T &x)
{
  return as_actor<T>::convert(x);
}

}


template<typename Eval>
  struct result_of_adaptable_function<
    thrust::detail::functional::actor<Eval>()
  >
{
  typedef typename thrust::detail::functional::apply_actor<
    thrust::detail::functional::actor<Eval>,
    thrust::null_type
  >::type type;
};

template<typename Eval, typename Arg1>
  struct result_of_adaptable_function<
    thrust::detail::functional::actor<Eval>(Arg1)
  >
{
  typedef typename thrust::detail::functional::apply_actor<
    thrust::detail::functional::actor<Eval>,
    thrust::tuple<Arg1>
  >::type type;
};

template<typename Eval, typename Arg1, typename Arg2>
  struct result_of_adaptable_function<
    thrust::detail::functional::actor<Eval>(Arg1,Arg2)
  >
{
  typedef typename thrust::detail::functional::apply_actor<
    thrust::detail::functional::actor<Eval>,
    thrust::tuple<Arg1,Arg2>
  >::type type;
};

}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.inl" 1
# 31 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.inl"
namespace thrust
{

namespace detail
{
namespace functional
{

template<typename Eval>
  actor<Eval>
    ::actor(void)
      : eval_type()
{}

template<typename Eval>
  actor<Eval>
    ::actor(const Eval &base)
      : eval_type(base)
{}

template<typename Eval>
  typename apply_actor<
    typename actor<Eval>::eval_type,
    typename thrust::null_type
  >::type
    actor<Eval>
      ::operator()(void) const
{
  return eval_type::eval(thrust::null_type());
}

template<typename Eval>
  template<typename T0>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0) const
{
  return eval_type::eval(thrust::tie(_0));
}

template<typename Eval>
  template<typename T0, typename T1>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&,T1&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0, T1 &_1) const
{
  return eval_type::eval(thrust::tie(_0,_1));
}

template<typename Eval>
  template<typename T0, typename T1, typename T2>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&,T1&,T2&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0, T1 &_1, T2 &_2) const
{
  return eval_type::eval(thrust::tie(_0,_1,_2));
}

template<typename Eval>
  template<typename T0, typename T1, typename T2, typename T3>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&,T1&,T2&,T3&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3) const
{
  return eval_type::eval(thrust::tie(_0,_1,_2,_3));
}

template<typename Eval>
  template<typename T0, typename T1, typename T2, typename T3, typename T4>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&,T1&,T2&,T3&,T4&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4) const
{
  return eval_type::eval(thrust::tie(_0,_1,_2,_3,_4));
}

template<typename Eval>
  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5) const
{
  return eval_type::eval(thrust::tie(_0,_1,_2,_3,_4,_5));
}

template<typename Eval>
  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6) const
{
  return eval_type::eval(thrust::tie(_0,_1,_2,_3,_4,_5,_6));
}

template<typename Eval>
  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6, T7 &_7) const
{
  return eval_type::eval(thrust::tie(_0,_1,_2,_3,_4,_5,_6,_7));
}

template<typename Eval>
  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6, T7 &_7, T8 &_8) const
{
  return eval_type::eval(thrust::tie(_0,_1,_2,_3,_4,_5,_6,_7,_8));
}

template<typename Eval>
  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
    typename apply_actor<
      typename actor<Eval>::eval_type,
      typename thrust::tuple<T0&,T1&,T2&,T3&,T4&,T5&,T6&,T7&,T8&,T9&>
    >::type
      actor<Eval>
        ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6, T7 &_7, T8 &_8, T9 &_9) const
{
  return eval_type::eval(thrust::tie(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9));
}

template<typename Eval>
  template<typename T>
    typename assign_result<Eval,T>::type
      actor<Eval>
        ::operator=(const T& _1) const
{
  return do_assign(*this,_1);
}

}
}
}
# 192 "/usr/local/cuda-8.0/include/thrust/detail/functional/actor.h" 2
# 21 "/usr/local/cuda-8.0/include/thrust/detail/functional/placeholder.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/argument.h" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/functional/argument.h"
       




namespace thrust
{
namespace detail
{
namespace functional
{

template<unsigned int i, typename Env>
  struct argument_helper
{
  typedef typename thrust::tuple_element<i,Env>::type type;
};

template<unsigned int i>
  struct argument_helper<i,thrust::null_type>
{
  typedef thrust::null_type type;
};


template<unsigned int i>
  class argument
{
  public:
    template<typename Env>
      struct result
        : argument_helper<i,Env>
    {
    };

    __attribute__((host)) __attribute__((device))
    argument(void){}

    template<typename Env>
    __attribute__((host)) __attribute__((device))
    typename result<Env>::type eval(const Env &e) const
    {
      return thrust::get<i>(e);
    }
};

}
}
}
# 22 "/usr/local/cuda-8.0/include/thrust/detail/functional/placeholder.h" 2

namespace thrust
{
namespace detail
{
namespace functional
{

template<unsigned int i>
  struct placeholder
{
  typedef actor<argument<i> > type;
};

}
}
}
# 27 "/usr/local/cuda-8.0/include/thrust/functional.h" 2

namespace thrust
{




template<typename Operation> struct unary_traits;

template<typename Operation> struct binary_traits;
# 68 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename Argument,
         typename Result>
struct unary_function
{



  typedef Argument argument_type;




  typedef Result result_type;
};
# 108 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename Argument1,
         typename Argument2,
         typename Result>
struct binary_function
{



  typedef Argument1 first_argument_type;




  typedef Argument2 second_argument_type;




  typedef Result result_type;
};
# 175 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct plus
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs + rhs;}
};
# 231 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct minus
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs - rhs;}
};
# 287 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct multiplies
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs * rhs;}
};
# 343 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct divides
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs / rhs;}
};
# 399 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct modulus
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs % rhs;}
};
# 452 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct negate
{



  typedef T argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &x) const {return -x;}
};
# 489 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct equal_to
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef bool result_type;



  __attribute__((host)) __attribute__((device)) bool operator()(const T &lhs, const T &rhs) const {return lhs == rhs;}
};
# 523 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct not_equal_to
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef bool result_type;



  __attribute__((host)) __attribute__((device)) bool operator()(const T &lhs, const T &rhs) const {return lhs != rhs;}
};
# 557 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct greater
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef bool result_type;



  __attribute__((host)) __attribute__((device)) bool operator()(const T &lhs, const T &rhs) const {return lhs > rhs;}
};
# 591 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct less
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef bool result_type;



  __attribute__((host)) __attribute__((device)) bool operator()(const T &lhs, const T &rhs) const {return lhs < rhs;}
};
# 625 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct greater_equal
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef bool result_type;



  __attribute__((host)) __attribute__((device)) bool operator()(const T &lhs, const T &rhs) const {return lhs >= rhs;}
};
# 659 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct less_equal
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef bool result_type;



  __attribute__((host)) __attribute__((device)) bool operator()(const T &lhs, const T &rhs) const {return lhs <= rhs;}
};
# 702 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct logical_and
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef bool result_type;



  __attribute__((host)) __attribute__((device)) bool operator()(const T &lhs, const T &rhs) const {return lhs && rhs;}
};
# 736 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct logical_or
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef bool result_type;



  __attribute__((host)) __attribute__((device)) bool operator()(const T &lhs, const T &rhs) const {return lhs || rhs;}
};
# 784 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct logical_not
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef bool result_type;



  __attribute__((host)) __attribute__((device)) bool operator()(const T &x) const {return !x;}
};
# 847 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct bit_and
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs & rhs;}
};
# 902 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct bit_or
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs | rhs;}
};
# 957 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct bit_xor
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs ^ rhs;}
};
# 1008 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct identity
{



  typedef T argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) const T &operator()(const T &x) const {return x;}
};
# 1050 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct maximum
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs < rhs ? rhs : lhs;}
};
# 1097 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T>
struct minimum
{



  typedef T first_argument_type;




  typedef T second_argument_type;




  typedef T result_type;



  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs < rhs ? lhs : rhs;}
};
# 1138 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T1, typename T2>
struct project1st
{



  typedef T1 first_argument_type;




  typedef T2 second_argument_type;




  typedef T1 result_type;



  __attribute__((host)) __attribute__((device)) const T1 &operator()(const T1 &lhs, const T2 &rhs) const {return lhs;}
};
# 1179 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename T1, typename T2>
struct project2nd
{



  typedef T1 first_argument_type;




  typedef T2 second_argument_type;




  typedef T2 result_type;



  __attribute__((host)) __attribute__((device)) const T2 &operator()(const T1 &lhs, const T2 &rhs) const {return rhs;}
};
# 1223 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename Predicate>
struct unary_negate
    : public thrust::unary_function<typename Predicate::argument_type, bool>
{



  __attribute__((host)) __attribute__((device))
  explicit unary_negate(Predicate p) : pred(p){}



  __attribute__((host)) __attribute__((device))
  bool operator()(const typename Predicate::argument_type& x) { return !pred(x); }



  Predicate pred;


};
# 1261 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename Predicate>
  __attribute__((host)) __attribute__((device))
  unary_negate<Predicate> not1(const Predicate &pred);
# 1275 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename Predicate>
struct binary_negate
    : public thrust::binary_function<typename Predicate::first_argument_type,
                                     typename Predicate::second_argument_type,
                                     bool>
{



  __attribute__((host)) __attribute__((device))
  explicit binary_negate(Predicate p) : pred(p){}



  __attribute__((host)) __attribute__((device))
  bool operator()(const typename Predicate::first_argument_type& x, const typename Predicate::second_argument_type& y)
  {
      return !pred(x,y);
  }



  Predicate pred;


};
# 1318 "/usr/local/cuda-8.0/include/thrust/functional.h"
template<typename BinaryPredicate>
  __attribute__((host)) __attribute__((device))
  binary_negate<BinaryPredicate> not2(const BinaryPredicate &pred);
# 1374 "/usr/local/cuda-8.0/include/thrust/functional.h"
namespace placeholders
{







static const thrust::detail::functional::placeholder<0>::type _1;
# 1392 "/usr/local/cuda-8.0/include/thrust/functional.h"
static const thrust::detail::functional::placeholder<1>::type _2;
# 1401 "/usr/local/cuda-8.0/include/thrust/functional.h"
static const thrust::detail::functional::placeholder<2>::type _3;
# 1410 "/usr/local/cuda-8.0/include/thrust/functional.h"
static const thrust::detail::functional::placeholder<3>::type _4;
# 1419 "/usr/local/cuda-8.0/include/thrust/functional.h"
static const thrust::detail::functional::placeholder<4>::type _5;
# 1428 "/usr/local/cuda-8.0/include/thrust/functional.h"
static const thrust::detail::functional::placeholder<5>::type _6;
# 1437 "/usr/local/cuda-8.0/include/thrust/functional.h"
static const thrust::detail::functional::placeholder<6>::type _7;
# 1446 "/usr/local/cuda-8.0/include/thrust/functional.h"
static const thrust::detail::functional::placeholder<7>::type _8;
# 1455 "/usr/local/cuda-8.0/include/thrust/functional.h"
static const thrust::detail::functional::placeholder<8>::type _9;
# 1464 "/usr/local/cuda-8.0/include/thrust/functional.h"
static const thrust::detail::functional::placeholder<9>::type _10;



}






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/detail/functional.inl"
namespace thrust
{

namespace detail
{

template<typename Operation>
  struct unary_traits_imp;

template<typename Operation>
  struct unary_traits_imp<Operation*>
{
  typedef Operation function_type;
  typedef const function_type & param_type;
  typedef typename Operation::result_type result_type;
  typedef typename Operation::argument_type argument_type;
};

template<typename Result, typename Argument>
  struct unary_traits_imp<Result(*)(Argument)>
{
  typedef Result (*function_type)(Argument);
  typedef Result (*param_type)(Argument);
  typedef Result result_type;
  typedef Argument argument_type;
};

template<typename Operation>
  struct binary_traits_imp;

template<typename Operation>
  struct binary_traits_imp<Operation*>
{
  typedef Operation function_type;
  typedef const function_type & param_type;
  typedef typename Operation::result_type result_type;
  typedef typename Operation::first_argument_type first_argument_type;
  typedef typename Operation::second_argument_type second_argument_type;
};

template<typename Result, typename Argument1, typename Argument2>
  struct binary_traits_imp<Result(*)(Argument1, Argument2)>
{
  typedef Result (*function_type)(Argument1, Argument2);
  typedef Result (*param_type)(Argument1, Argument2);
  typedef Result result_type;
  typedef Argument1 first_argument_type;
  typedef Argument2 second_argument_type;
};

}

template<typename Operation>
  struct unary_traits
{
  typedef typename detail::unary_traits_imp<Operation*>::function_type function_type;
  typedef typename detail::unary_traits_imp<Operation*>::param_type param_type;
  typedef typename detail::unary_traits_imp<Operation*>::result_type result_type;
  typedef typename detail::unary_traits_imp<Operation*>::argument_type argument_type;
};

template<typename Result, typename Argument>
  struct unary_traits<Result(*)(Argument)>
{
  typedef Result (*function_type)(Argument);
  typedef Result (*param_type)(Argument);
  typedef Result result_type;
  typedef Argument argument_type;
};

template<typename Operation>
  struct binary_traits
{
  typedef typename detail::binary_traits_imp<Operation*>::function_type function_type;
  typedef typename detail::binary_traits_imp<Operation*>::param_type param_type;
  typedef typename detail::binary_traits_imp<Operation*>::result_type result_type;
  typedef typename detail::binary_traits_imp<Operation*>::first_argument_type first_argument_type;
  typedef typename detail::binary_traits_imp<Operation*>::second_argument_type second_argument_type;
};

template<typename Result, typename Argument1, typename Argument2>
  struct binary_traits<Result(*)(Argument1, Argument2)>
{
  typedef Result (*function_type)(Argument1, Argument2);
  typedef Result (*param_type)(Argument1, Argument2);
  typedef Result result_type;
  typedef Argument1 first_argument_type;
  typedef Argument2 second_argument_type;
};

template<typename Predicate>
  unary_negate<Predicate> not1(const Predicate &pred)
{
  return unary_negate<Predicate>(pred);
}

template<typename BinaryPredicate>
  binary_negate<BinaryPredicate> not2(const BinaryPredicate &pred)
{
  return binary_negate<BinaryPredicate>(pred);
}

}
# 1478 "/usr/local/cuda-8.0/include/thrust/functional.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/arithmetic_operators.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/arithmetic_operators.h"
       







namespace thrust
{
namespace detail
{
namespace functional
{

template<typename Eval>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    unary_operator<thrust::negate>,
    actor<Eval>
  >
>
__attribute__((host)) __attribute__((device))
operator-(const actor<Eval> &_1)
{
  return compose(unary_operator<thrust::negate>(), _1);
}


template<typename T>
  struct unary_plus
    : public thrust::unary_function<T,T>
{
  __attribute__((host)) __attribute__((device)) T operator()(const T &x) const {return +x;}
};

template<typename Eval>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    unary_operator<unary_plus>,
    actor<Eval>
  >
>
operator+(const actor<Eval> &_1)
{
  return compose(unary_operator<unary_plus>(), _1);
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::plus>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator+(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::plus>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::plus>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator+(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::plus>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::plus>,
    actor<T1>,
    actor<T2>
  >
>
operator+(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::plus>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::minus>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator-(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::minus>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::minus>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator-(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::minus>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::minus>,
    actor<T1>,
    actor<T2>
  >
>
operator-(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::minus>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::multiplies>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator*(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::multiplies>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::multiplies>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator*(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::multiplies>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::multiplies>,
    actor<T1>,
    actor<T2>
  >
>
operator*(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::multiplies>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::divides>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator/(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::divides>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::divides>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator/(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::divides>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::divides>,
    actor<T1>,
    actor<T2>
  >
>
operator/(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::divides>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::modulus>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator%(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::modulus>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::modulus>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator%(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::modulus>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::modulus>,
    actor<T1>,
    actor<T2>
  >
>
operator%(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::modulus>(),
                 make_actor(_1),
                 make_actor(_2));
}


template<typename T>
  struct prefix_increment
    : public thrust::unary_function<T&,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &x) const { return ++x; }
};

template<typename Eval>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    unary_operator<prefix_increment>,
    actor<Eval>
  >
>
operator++(const actor<Eval> &_1)
{
  return compose(unary_operator<prefix_increment>(), _1);
}


template<typename T>
  struct suffix_increment
    : public thrust::unary_function<T&,T>
{
  __attribute__((host)) __attribute__((device)) T operator()(T &x) const { return x++; }
};

template<typename Eval>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    unary_operator<suffix_increment>,
    actor<Eval>
  >
>
operator++(const actor<Eval> &_1, int)
{
  return compose(unary_operator<suffix_increment>(), _1);
}


template<typename T>
  struct prefix_decrement
    : public thrust::unary_function<T&,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &x) const { return --x; }
};

template<typename Eval>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    unary_operator<prefix_decrement>,
    actor<Eval>
  >
>
operator--(const actor<Eval> &_1)
{
  return compose(unary_operator<prefix_decrement>(), _1);
}


template<typename T>
  struct suffix_decrement
    : public thrust::unary_function<T&,T>
{
  __attribute__((host)) __attribute__((device)) T operator()(T &x) const { return x--; }
};

template<typename Eval>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    unary_operator<suffix_decrement>,
    actor<Eval>
  >
>
operator--(const actor<Eval> &_1, int)
{
  return compose(unary_operator<suffix_decrement>(), _1);
}

}
}
}
# 21 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/relational_operators.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/relational_operators.h"
       







namespace thrust
{
namespace detail
{
namespace functional
{

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::equal_to>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator==(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::equal_to>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::equal_to>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator==(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::equal_to>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::equal_to>,
    actor<T1>,
    actor<T2>
  >
>
operator==(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::equal_to>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::not_equal_to>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator!=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::not_equal_to>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::not_equal_to>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator!=(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::not_equal_to>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::not_equal_to>,
    actor<T1>,
    actor<T2>
  >
>
operator!=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::not_equal_to>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::greater>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator>(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::greater>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::greater>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator>(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::greater>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::greater>,
    actor<T1>,
    actor<T2>
  >
>
operator>(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::greater>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::less>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator<(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::less>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::less>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator<(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::less>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::less>,
    actor<T1>,
    actor<T2>
  >
>
operator<(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::less>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::greater_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator>=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::greater_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::greater_equal>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator>=(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::greater_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::greater_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator>=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::greater_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::less_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator<=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::less_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::less_equal>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator<=(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::less_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::less_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator<=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::less_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

}
}
}
# 22 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/logical_operators.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/logical_operators.h"
       







namespace thrust
{
namespace detail
{
namespace functional
{

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::logical_and>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator&&(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::logical_and>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::logical_and>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator&&(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::logical_and>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::logical_and>,
    actor<T1>,
    actor<T2>
  >
>
operator&&(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::logical_and>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::logical_or>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator||(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::logical_or>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::logical_or>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator||(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::logical_or>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::logical_or>,
    actor<T1>,
    actor<T2>
  >
>
operator||(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::logical_or>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename Eval>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    unary_operator<thrust::logical_not>,
    actor<Eval>
  >
>
operator!(const actor<Eval> &_1)
{
  return compose(unary_operator<thrust::logical_not>(), _1);
}

}
}
}
# 23 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/bitwise_operators.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/bitwise_operators.h"
       







namespace thrust
{
namespace detail
{
namespace functional
{

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::bit_and>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator&(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::bit_and>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::bit_and>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator&(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::bit_and>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::bit_and>,
    actor<T1>,
    actor<T2>
  >
>
operator&(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::bit_and>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::bit_or>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator|(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::bit_or>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::bit_or>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator|(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::bit_or>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::bit_or>,
    actor<T1>,
    actor<T2>
  >
>
operator|(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::bit_or>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::bit_xor>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator^(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<thrust::bit_xor>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::bit_xor>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator^(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::bit_xor>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<thrust::bit_xor>,
    actor<T1>,
    actor<T2>
  >
>
operator^(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<thrust::bit_xor>(),
                 make_actor(_1),
                 make_actor(_2));
}


template<typename T>
  struct bit_not
    : public thrust::unary_function<T,T>
{
  __attribute__((host)) __attribute__((device)) T operator()(const T &x) const {return ~x;}
};

template<typename Eval>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    unary_operator<bit_not>,
    actor<Eval>
  >
>
__attribute__((host)) __attribute__((device))
operator~(const actor<Eval> &_1)
{
  return compose(unary_operator<bit_not>(), _1);
}


template<typename T>
  struct bit_lshift
    : public thrust::binary_function<T,T,T>
{
  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs << rhs;}
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_lshift>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator<<(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<bit_lshift>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_lshift>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator<<(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<bit_lshift>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_lshift>,
    actor<T1>,
    actor<T2>
  >
>
operator<<(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<bit_lshift>(),
                 make_actor(_1),
                 make_actor(_2));
}


template<typename T>
  struct bit_rshift
    : public thrust::binary_function<T,T,T>
{
  __attribute__((host)) __attribute__((device)) T operator()(const T &lhs, const T &rhs) const {return lhs >> rhs;}
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_rshift>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator>>(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<bit_rshift>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_rshift>,
    typename as_actor<T1>::type,
    actor<T2>
  >
>
operator>>(const T1 &_1, const actor<T2> &_2)
{
  return compose(binary_operator<bit_rshift>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_rshift>,
    actor<T1>,
    actor<T2>
  >
>
operator>>(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<bit_rshift>(),
                 make_actor(_1),
                 make_actor(_2));
}

}
}
}
# 24 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/compound_assignment_operators.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators/compound_assignment_operators.h"
       






namespace thrust
{
namespace detail
{
namespace functional
{

template<typename T>
  struct plus_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T &rhs) const { return lhs += rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<plus_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator+=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<plus_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<plus_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator+=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<plus_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T>
  struct minus_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T &rhs) const { return lhs -= rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<minus_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator-=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<minus_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<minus_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator-=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<minus_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T>
  struct multiplies_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T&rhs) const { return lhs *= rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<multiplies_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator*=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<multiplies_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<multiplies_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator*=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<multiplies_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T>
  struct divides_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T&rhs) const { return lhs /= rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<divides_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator/=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<divides_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<divides_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator/=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<divides_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T>
  struct modulus_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T&rhs) const { return lhs %= rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<modulus_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator%=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<modulus_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<modulus_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator%=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<modulus_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T>
  struct bit_and_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T&rhs) const { return lhs &= rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_and_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator&=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<bit_and_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_and_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator&=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<bit_and_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T>
  struct bit_or_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T&rhs) const { return lhs |= rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_or_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator|=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<bit_or_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_or_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator|=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<bit_or_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T>
  struct bit_xor_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T&rhs) const { return lhs ^= rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_xor_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator^=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<bit_xor_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_xor_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator^=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<bit_xor_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T>
  struct bit_lshift_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T&rhs) const { return lhs <<= rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_lshift_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator<<=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<bit_lshift_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_lshift_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator<<=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<bit_lshift_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T>
  struct bit_rshift_equal
    : public thrust::binary_function<T&,T,T&>
{
  __attribute__((host)) __attribute__((device)) T& operator()(T &lhs, const T&rhs) const { return lhs >>= rhs; }
};

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_rshift_equal>,
    actor<T1>,
    typename as_actor<T2>::type
  >
>
operator>>=(const actor<T1> &_1, const T2 &_2)
{
  return compose(binary_operator<bit_rshift_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

template<typename T1, typename T2>
__attribute__((host)) __attribute__((device))
actor<
  composite<
    binary_operator<bit_rshift_equal>,
    actor<T1>,
    actor<T2>
  >
>
operator>>=(const actor<T1> &_1, const actor<T2> &_2)
{
  return compose(binary_operator<bit_rshift_equal>(),
                 make_actor(_1),
                 make_actor(_2));
}

}
}
}
# 25 "/usr/local/cuda-8.0/include/thrust/detail/functional/operators.h" 2
# 1479 "/usr/local/cuda-8.0/include/thrust/functional.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/internal_functional.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/detail/internal_functional.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/tuple_of_iterator_references.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/tuple_of_iterator_references.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/detail/reference_forward_declaration.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/reference_forward_declaration.h"
       




namespace thrust
{

template<typename Element, typename Pointer, typename Derived = use_default> class reference;

}
# 23 "/usr/local/cuda-8.0/include/thrust/iterator/detail/tuple_of_iterator_references.h" 2

namespace thrust
{
namespace detail
{


template<
  typename T0, typename T1, typename T2,
  typename T3, typename T4, typename T5,
  typename T6, typename T7, typename T8,
  typename T9
>
  class tuple_of_iterator_references
    : public thrust::tuple<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
{
  private:
    typedef thrust::tuple<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9> super_t;

  public:

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(const super_t &other)
      : super_t(other)
    {}



    template<typename U1, typename U2>
    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references &operator=(const detail::cons<U1,U2> &other)
    {
      super_t::operator=(other);
      return *this;
    }



    template<typename U1, typename U2>
    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references &operator=(const thrust::pair<U1,U2> &other)
    {
      super_t::operator=(other);
      return *this;
    }




    template<typename U0, typename U1, typename U2,
             typename U3, typename U4, typename U5,
             typename U6, typename U7, typename U8,
             typename U9,
             typename Pointer, typename Derived>
    inline __attribute__((host)) __attribute__((device))
# 86 "/usr/local/cuda-8.0/include/thrust/iterator/detail/tuple_of_iterator_references.h"
    tuple_of_iterator_references &
    operator=(const thrust::reference<thrust::tuple<U0,U1,U2,U3,U4,U5,U6,U7,U8,U9>, Pointer, Derived> &other)
    {
      typedef thrust::tuple<U0,U1,U2,U3,U4,U5,U6,U7,U8,U9> tuple_type;


      tuple_type other_tuple = other;
      super_t::operator=(other_tuple);
      return *this;
    }



    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references() {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0)
      : super_t(t0,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()))
    {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0,
                                 typename access_traits<T1>::parameter_type t1)
      : super_t(t0, t1,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()))
    {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0,
                                 typename access_traits<T1>::parameter_type t1,
                                 typename access_traits<T2>::parameter_type t2)
      : super_t(t0, t1, t2,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()))
    {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0,
                                 typename access_traits<T1>::parameter_type t1,
                                 typename access_traits<T2>::parameter_type t2,
                                 typename access_traits<T3>::parameter_type t3)
      : super_t(t0, t1, t2, t3,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()))
    {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0,
                                 typename access_traits<T1>::parameter_type t1,
                                 typename access_traits<T2>::parameter_type t2,
                                 typename access_traits<T3>::parameter_type t3,
                                 typename access_traits<T4>::parameter_type t4)
      : super_t(t0, t1, t2, t3, t4,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()))
    {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0,
                                 typename access_traits<T1>::parameter_type t1,
                                 typename access_traits<T2>::parameter_type t2,
                                 typename access_traits<T3>::parameter_type t3,
                                 typename access_traits<T4>::parameter_type t4,
                                 typename access_traits<T5>::parameter_type t5)
      : super_t(t0, t1, t2, t3, t4, t5,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()))
    {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0,
                                 typename access_traits<T1>::parameter_type t1,
                                 typename access_traits<T2>::parameter_type t2,
                                 typename access_traits<T3>::parameter_type t3,
                                 typename access_traits<T4>::parameter_type t4,
                                 typename access_traits<T5>::parameter_type t5,
                                 typename access_traits<T6>::parameter_type t6)
      : super_t(t0, t1, t2, t3, t4, t5, t6,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()))
    {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0,
                                 typename access_traits<T1>::parameter_type t1,
                                 typename access_traits<T2>::parameter_type t2,
                                 typename access_traits<T3>::parameter_type t3,
                                 typename access_traits<T4>::parameter_type t4,
                                 typename access_traits<T5>::parameter_type t5,
                                 typename access_traits<T6>::parameter_type t6,
                                 typename access_traits<T7>::parameter_type t7)
      : super_t(t0, t1, t2, t3, t4, t5, t6, t7,
                static_cast<const null_type&>(null_type()),
                static_cast<const null_type&>(null_type()))
    {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0,
                                 typename access_traits<T1>::parameter_type t1,
                                 typename access_traits<T2>::parameter_type t2,
                                 typename access_traits<T3>::parameter_type t3,
                                 typename access_traits<T4>::parameter_type t4,
                                 typename access_traits<T5>::parameter_type t5,
                                 typename access_traits<T6>::parameter_type t6,
                                 typename access_traits<T7>::parameter_type t7,
                                 typename access_traits<T8>::parameter_type t8)
      : super_t(t0, t1, t2, t3, t4, t5, t6, t7, t8,
                static_cast<const null_type&>(null_type()))
    {}

    inline __attribute__((host)) __attribute__((device))
    tuple_of_iterator_references(typename access_traits<T0>::parameter_type t0,
                                 typename access_traits<T1>::parameter_type t1,
                                 typename access_traits<T2>::parameter_type t2,
                                 typename access_traits<T3>::parameter_type t3,
                                 typename access_traits<T4>::parameter_type t4,
                                 typename access_traits<T5>::parameter_type t5,
                                 typename access_traits<T6>::parameter_type t6,
                                 typename access_traits<T7>::parameter_type t7,
                                 typename access_traits<T8>::parameter_type t8,
                                 typename access_traits<T9>::parameter_type t9)
      : super_t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9)
    {}
};


}
}
# 28 "/usr/local/cuda-8.0/include/thrust/detail/internal_functional.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/raw_reference_cast.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/raw_reference_cast.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/raw_pointer_cast.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/raw_pointer_cast.h"
       




namespace thrust
{

template<typename Pointer>
  inline __attribute__((host)) __attribute__((device)) typename thrust::detail::pointer_traits<Pointer>::raw_pointer
    raw_pointer_cast(const Pointer &ptr)
{
  return thrust::detail::pointer_traits<Pointer>::get(ptr);
}

}
# 21 "/usr/local/cuda-8.0/include/thrust/detail/raw_reference_cast.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/detail/tuple_transform.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/tuple_transform.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/tuple_meta_transform.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/tuple_meta_transform.h"
       



namespace thrust
{

namespace detail
{

template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         unsigned int sz = thrust::tuple_size<Tuple>::value>
  struct tuple_meta_transform;

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,0>
{
  typedef null_type type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,1>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,2>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,3>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,4>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,5>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,6>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,7>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<6,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,8>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<6,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<7,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,9>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<6,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<7,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<8,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,10>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<6,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<7,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<8,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<9,Tuple>::type>::type
  > type;
};

}

}
# 21 "/usr/local/cuda-8.0/include/thrust/detail/tuple_transform.h" 2

namespace thrust
{

namespace detail
{

template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction,
         unsigned int sz = thrust::tuple_size<Tuple>::value>
  struct tuple_transform_functor;


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,0>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    return thrust::null_type();
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    return thrust::null_type();
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,1>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,2>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,3>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,4>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,5>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,6>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,7>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,8>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,9>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)),
                     f(thrust::get<8>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)),
                     f(thrust::get<8>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,10>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)),
                     f(thrust::get<8>(t)),
                     f(thrust::get<9>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)),
                     f(thrust::get<8>(t)),
                     f(thrust::get<9>(t)));
  }
};


template<template<typename> class UnaryMetaFunction,
         typename Tuple,
         typename UnaryFunction>
typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
tuple_host_transform(const Tuple &t, UnaryFunction f)
{
  return tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction>::do_it_on_the_host(t,f);
}

template<template<typename> class UnaryMetaFunction,
         typename Tuple,
         typename UnaryFunction>
typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
__attribute__((host)) __attribute__((device))
tuple_host_device_transform(const Tuple &t, UnaryFunction f)
{
  return tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction>::do_it_on_the_host_or_device(t,f);
}

}

}
# 24 "/usr/local/cuda-8.0/include/thrust/detail/raw_reference_cast.h" 2
# 32 "/usr/local/cuda-8.0/include/thrust/detail/raw_reference_cast.h"
namespace thrust
{
namespace detail
{


template<typename T> struct is_wrapped_reference { typedef char yes_type; typedef int no_type; template<typename S> static yes_type test(typename S::wrapped_reference_hint *); template<typename S> static no_type test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes_type); typedef thrust::detail::integral_constant<bool, value> type;};




template<typename T>
  struct is_unwrappable
    : is_wrapped_reference<T>
{};




template<
  typename T0, typename T1, typename T2,
  typename T3, typename T4, typename T5,
  typename T6, typename T7, typename T8,
  typename T9
>
  struct is_unwrappable<
    thrust::tuple<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
  >
    : or_<
        is_unwrappable<T0>,
        is_unwrappable<T1>,
        is_unwrappable<T2>,
        is_unwrappable<T3>,
        is_unwrappable<T4>,
        is_unwrappable<T5>,
        is_unwrappable<T6>,
        is_unwrappable<T7>,
        is_unwrappable<T8>,
        is_unwrappable<T9>
      >
{};




template<
  typename T0, typename T1, typename T2,
  typename T3, typename T4, typename T5,
  typename T6, typename T7, typename T8,
  typename T9
>
  struct is_unwrappable<
    thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
  >
    : or_<
        is_unwrappable<T0>,
        is_unwrappable<T1>,
        is_unwrappable<T2>,
        is_unwrappable<T3>,
        is_unwrappable<T4>,
        is_unwrappable<T5>,
        is_unwrappable<T6>,
        is_unwrappable<T7>,
        is_unwrappable<T8>,
        is_unwrappable<T9>
      >
{};


template<typename T, typename Result = void>
  struct enable_if_unwrappable
    : enable_if<
        is_unwrappable<T>::value,
        Result
      >
{};


namespace raw_reference_detail
{


template<typename T, typename Enable = void>
  struct raw_reference_impl
    : add_reference<T>
{};


template<typename T>
  struct raw_reference_impl<
    T,
    typename thrust::detail::enable_if<
      is_wrapped_reference<
        typename remove_cv<T>::type
      >::value
    >::type
  >
{
  typedef typename add_reference<
    typename pointer_element<typename T::pointer>::type
  >::type type;
};


}


template<typename T>
  struct raw_reference :
    raw_reference_detail::raw_reference_impl<T>
{};


namespace raw_reference_detail
{
# 162 "/usr/local/cuda-8.0/include/thrust/detail/raw_reference_cast.h"
template<typename T>
  struct raw_reference_tuple_helper
    : eval_if<
        is_unwrappable<
          typename remove_cv<T>::type
        >::value,
        raw_reference<T>,
        identity_<T>
      >
{};



template <
  typename T0, typename T1, typename T2,
  typename T3, typename T4, typename T5,
  typename T6, typename T7, typename T8,
  typename T9
>
  struct raw_reference_tuple_helper<
    thrust::tuple<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
  >
{
  typedef thrust::tuple<
    typename raw_reference_tuple_helper<T0>::type,
    typename raw_reference_tuple_helper<T1>::type,
    typename raw_reference_tuple_helper<T2>::type,
    typename raw_reference_tuple_helper<T3>::type,
    typename raw_reference_tuple_helper<T4>::type,
    typename raw_reference_tuple_helper<T5>::type,
    typename raw_reference_tuple_helper<T6>::type,
    typename raw_reference_tuple_helper<T7>::type,
    typename raw_reference_tuple_helper<T8>::type,
    typename raw_reference_tuple_helper<T9>::type
  > type;
};


template <
  typename T0, typename T1, typename T2,
  typename T3, typename T4, typename T5,
  typename T6, typename T7, typename T8,
  typename T9
>
  struct raw_reference_tuple_helper<
    thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
  >
{
  typedef thrust::detail::tuple_of_iterator_references<
    typename raw_reference_tuple_helper<T0>::type,
    typename raw_reference_tuple_helper<T1>::type,
    typename raw_reference_tuple_helper<T2>::type,
    typename raw_reference_tuple_helper<T3>::type,
    typename raw_reference_tuple_helper<T4>::type,
    typename raw_reference_tuple_helper<T5>::type,
    typename raw_reference_tuple_helper<T6>::type,
    typename raw_reference_tuple_helper<T7>::type,
    typename raw_reference_tuple_helper<T8>::type,
    typename raw_reference_tuple_helper<T9>::type
  > type;
};


}
# 234 "/usr/local/cuda-8.0/include/thrust/detail/raw_reference_cast.h"
template <
  typename T0, typename T1, typename T2,
  typename T3, typename T4, typename T5,
  typename T6, typename T7, typename T8,
  typename T9
>
  struct raw_reference<
    thrust::tuple<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
  >
{
  private:
    typedef thrust::tuple<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9> tuple_type;

  public:
    typedef typename eval_if<
      is_unwrappable<tuple_type>::value,
      raw_reference_detail::raw_reference_tuple_helper<tuple_type>,
      add_reference<tuple_type>
    >::type type;
};


template <
  typename T0, typename T1, typename T2,
  typename T3, typename T4, typename T5,
  typename T6, typename T7, typename T8,
  typename T9
>
  struct raw_reference<
    thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
  >
{
  private:
    typedef detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9> tuple_type;

  public:
    typedef typename raw_reference_detail::raw_reference_tuple_helper<tuple_type>::type type;







};


}



template<typename T>
inline __attribute__((host)) __attribute__((device))
typename detail::raw_reference<T>::type
  raw_reference_cast(T &ref);


template<typename T>
inline __attribute__((host)) __attribute__((device))
typename detail::raw_reference<const T>::type
  raw_reference_cast(const T &ref);


template<
  typename T0, typename T1, typename T2,
  typename T3, typename T4, typename T5,
  typename T6, typename T7, typename T8,
  typename T9
>
__attribute__((host)) __attribute__((device))
typename detail::enable_if_unwrappable<
  thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>,
  typename detail::raw_reference<
    thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
  >::type
>::type
raw_reference_cast(thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9> t);


namespace detail
{


struct raw_reference_caster
{
  template<typename T>
  __attribute__((host)) __attribute__((device))
  typename detail::raw_reference<T>::type operator()(T &ref)
  {
    return thrust::raw_reference_cast(ref);
  }

  template<typename T>
  __attribute__((host)) __attribute__((device))
  typename detail::raw_reference<const T>::type operator()(const T &ref)
  {
    return thrust::raw_reference_cast(ref);
  }

  template<
    typename T0, typename T1, typename T2,
    typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8,
    typename T9
  >
  __attribute__((host)) __attribute__((device))
  typename detail::raw_reference<
    thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
  >::type
  operator()(thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9> t,
             typename enable_if<
               is_unwrappable<thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9> >::value
             >::type * = 0)
  {
    return thrust::raw_reference_cast(t);
  }
};


}


template<typename T>
inline __attribute__((host)) __attribute__((device))
typename detail::raw_reference<T>::type
  raw_reference_cast(T &ref)
{
  return *thrust::raw_pointer_cast(&ref);
}


template<typename T>
inline __attribute__((host)) __attribute__((device))
typename detail::raw_reference<const T>::type
  raw_reference_cast(const T &ref)
{
  return *thrust::raw_pointer_cast(&ref);
}


template<
  typename T0, typename T1, typename T2,
  typename T3, typename T4, typename T5,
  typename T6, typename T7, typename T8,
  typename T9
>
__attribute__((host)) __attribute__((device))
typename detail::enable_if_unwrappable<
  thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>,
  typename detail::raw_reference<
    thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>
  >::type
>::type
raw_reference_cast(thrust::detail::tuple_of_iterator_references<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9> t)
{
  thrust::detail::raw_reference_caster f;



  return thrust::detail::tuple_host_device_transform<detail::raw_reference_detail::raw_reference_tuple_helper>(t, f);
}


}
# 29 "/usr/local/cuda-8.0/include/thrust/detail/internal_functional.h" 2


namespace thrust
{
namespace detail
{


template<typename Predicate>
struct unary_negate
{
  typedef bool result_type;

  Predicate pred;

  __attribute__((host)) __attribute__((device))
  explicit unary_negate(const Predicate& pred) : pred(pred) {}

  template <typename T>
  __attribute__((host)) __attribute__((device))
  bool operator()(const T& x)
  {
    return !bool(pred(x));
  }
};


template<typename Predicate>
struct binary_negate
{
  typedef bool result_type;

  Predicate pred;

  __attribute__((host)) __attribute__((device))
  explicit binary_negate(const Predicate& pred) : pred(pred) {}

  template <typename T1, typename T2>
  __attribute__((host)) __attribute__((device))
  bool operator()(const T1& x, const T2& y)
  {
    return !bool(pred(x,y));
  }
};

template<typename Predicate>
__attribute__((host)) __attribute__((device))
thrust::detail::unary_negate<Predicate> not1(const Predicate &pred)
{
  return thrust::detail::unary_negate<Predicate>(pred);
}

template<typename Predicate>
__attribute__((host)) __attribute__((device))
thrust::detail::binary_negate<Predicate> not2(const Predicate &pred)
{
  return thrust::detail::binary_negate<Predicate>(pred);
}



template<typename Predicate, typename IntegralType>
struct predicate_to_integral
{
  Predicate pred;

  __attribute__((host)) __attribute__((device))
  explicit predicate_to_integral(const Predicate& pred) : pred(pred) {}

  template <typename T>
  __attribute__((host)) __attribute__((device))
  bool operator()(const T& x)
  {
    return pred(x) ? IntegralType(1) : IntegralType(0);
  }
};



template<typename T1>
struct equal_to
{
  typedef bool result_type;

  template <typename T2>
  __attribute__((host)) __attribute__((device))
  bool operator()(const T1& lhs, const T2& rhs) const
  {
    return lhs == rhs;
  }
};


template<typename T2>
struct equal_to_value
{
  T2 rhs;

  __attribute__((host)) __attribute__((device))
  equal_to_value(const T2& rhs) : rhs(rhs) {}

  template <typename T1>
  __attribute__((host)) __attribute__((device))
  bool operator()(const T1& lhs) const
  {
    return lhs == rhs;
  }
};

template<typename Predicate>
struct tuple_binary_predicate
{
  typedef bool result_type;

  __attribute__((host)) __attribute__((device))
  tuple_binary_predicate(const Predicate& p) : pred(p) {}

  template<typename Tuple>
  __attribute__((host)) __attribute__((device))
  bool operator()(const Tuple& t) const
  {
    return pred(thrust::get<0>(t), thrust::get<1>(t));
  }

  mutable Predicate pred;
};

template<typename Predicate>
struct tuple_not_binary_predicate
{
  typedef bool result_type;

  __attribute__((host)) __attribute__((device))
  tuple_not_binary_predicate(const Predicate& p) : pred(p) {}

  template<typename Tuple>
  __attribute__((host)) __attribute__((device))
  bool operator()(const Tuple& t) const
  {
    return !pred(thrust::get<0>(t), thrust::get<1>(t));
  }

  mutable Predicate pred;
};

template<typename Generator>
  struct host_generate_functor
{
  typedef void result_type;

  __attribute__((host)) __attribute__((device))
  host_generate_functor(Generator g)
    : gen(g) {}
# 193 "/usr/local/cuda-8.0/include/thrust/detail/internal_functional.h"
  template<typename T>
  __attribute__((host))
  void operator()(const T &x)
  {

    T &lvalue = const_cast<T&>(x);


    lvalue = gen();
  }

  Generator gen;
};

template<typename Generator>
  struct device_generate_functor
{
  typedef void result_type;

  __attribute__((host)) __attribute__((device))
  device_generate_functor(Generator g)
    : gen(g) {}
# 226 "/usr/local/cuda-8.0/include/thrust/detail/internal_functional.h"
  template<typename T>
  __attribute__((host)) __attribute__((device))
  void operator()(const T &x)
  {

    T &lvalue = const_cast<T&>(x);


    lvalue = gen();
  }

  Generator gen;
};

template<typename System, typename Generator>
  struct generate_functor
    : thrust::detail::eval_if<
        thrust::detail::is_convertible<System, thrust::host_system_tag>::value,
        thrust::detail::identity_<host_generate_functor<Generator> >,
        thrust::detail::identity_<device_generate_functor<Generator> >
      >
{};


template<typename ResultType, typename BinaryFunction>
  struct zipped_binary_op
{
  typedef ResultType result_type;

  __attribute__((host)) __attribute__((device))
  zipped_binary_op(BinaryFunction binary_op)
    : m_binary_op(binary_op) {}

  template<typename Tuple>
  __attribute__((host)) __attribute__((device))
  inline result_type operator()(Tuple t)
  {
    return m_binary_op(thrust::get<0>(t), thrust::get<1>(t));
  }

  BinaryFunction m_binary_op;
};


template<typename T>
  struct is_non_const_reference
    : thrust::detail::and_<
        thrust::detail::not_<thrust::detail::is_const<T> >,
        thrust::detail::is_reference<T>
      >
{};

template<typename T> struct is_tuple_of_iterator_references : thrust::detail::false_type {};

template<typename T1, typename T2, typename T3,
         typename T4, typename T5, typename T6,
         typename T7, typename T8, typename T9,
         typename T10>
  struct is_tuple_of_iterator_references<
    thrust::detail::tuple_of_iterator_references<
      T1,T2,T3,T4,T5,T6,T7,T8,T9,T10
    >
  >
    : thrust::detail::true_type
{};



template<typename T>
  struct enable_if_non_const_reference_or_tuple_of_iterator_references
    : thrust::detail::enable_if<
        is_non_const_reference<T>::value || is_tuple_of_iterator_references<T>::value
      >
{};


template<typename UnaryFunction>
  struct unary_transform_functor
{
  typedef void result_type;

  UnaryFunction f;

  __attribute__((host)) __attribute__((device))
  unary_transform_functor(UnaryFunction f)
    : f(f)
  {}

  #pragma nv_exec_check_disable
  template<typename Tuple>
  inline __attribute__((host)) __attribute__((device))
  typename enable_if_non_const_reference_or_tuple_of_iterator_references<
    typename thrust::tuple_element<1,Tuple>::type
  >::type
    operator()(Tuple t)
  {
    thrust::get<1>(t) = f(thrust::get<0>(t));
  }
};


template<typename BinaryFunction>
  struct binary_transform_functor
{
  BinaryFunction f;

  __attribute__((host)) __attribute__((device))
  binary_transform_functor(BinaryFunction f)
    : f(f)
  {}

  #pragma nv_exec_check_disable
  template<typename Tuple>
  inline __attribute__((host)) __attribute__((device))
  typename enable_if_non_const_reference_or_tuple_of_iterator_references<
    typename thrust::tuple_element<2,Tuple>::type
  >::type
    operator()(Tuple t)
  {
    thrust::get<2>(t) = f(thrust::get<0>(t), thrust::get<1>(t));
  }
};


template<typename UnaryFunction, typename Predicate>
struct unary_transform_if_functor
{
  UnaryFunction unary_op;
  Predicate pred;

  __attribute__((host)) __attribute__((device))
  unary_transform_if_functor(UnaryFunction unary_op, Predicate pred)
    : unary_op(unary_op), pred(pred)
  {}

  #pragma nv_exec_check_disable
  template<typename Tuple>
  inline __attribute__((host)) __attribute__((device))
  typename enable_if_non_const_reference_or_tuple_of_iterator_references<
    typename thrust::tuple_element<1,Tuple>::type
  >::type
    operator()(Tuple t)
  {
    if(pred(thrust::get<0>(t)))
    {
      thrust::get<1>(t) = unary_op(thrust::get<0>(t));
    }
  }
};


template<typename UnaryFunction, typename Predicate>
struct unary_transform_if_with_stencil_functor
{
  UnaryFunction unary_op;
  Predicate pred;

  __attribute__((host)) __attribute__((device))
  unary_transform_if_with_stencil_functor(UnaryFunction unary_op, Predicate pred)
    : unary_op(unary_op), pred(pred)
  {}

  #pragma nv_exec_check_disable
  template<typename Tuple>
  inline __attribute__((host)) __attribute__((device))
  typename enable_if_non_const_reference_or_tuple_of_iterator_references<
    typename thrust::tuple_element<2,Tuple>::type
  >::type
    operator()(Tuple t)
  {
    if(pred(thrust::get<1>(t)))
      thrust::get<2>(t) = unary_op(thrust::get<0>(t));
  }
};


template<typename BinaryFunction, typename Predicate>
struct binary_transform_if_functor
{
  BinaryFunction binary_op;
  Predicate pred;

  __attribute__((host)) __attribute__((device))
  binary_transform_if_functor(BinaryFunction binary_op, Predicate pred)
    : binary_op(binary_op), pred(pred) {}

  #pragma nv_exec_check_disable
  template<typename Tuple>
  inline __attribute__((host)) __attribute__((device))
  typename enable_if_non_const_reference_or_tuple_of_iterator_references<
    typename thrust::tuple_element<3,Tuple>::type
  >::type
    operator()(Tuple t)
  {
    if(pred(thrust::get<2>(t)))
      thrust::get<3>(t) = binary_op(thrust::get<0>(t), thrust::get<1>(t));
  }
};


template<typename T>
  struct host_destroy_functor
{
  __attribute__((host))
  void operator()(T &x) const
  {
    x.~T();
  }
};


template<typename T>
  struct device_destroy_functor
{

  __attribute__((host)) __attribute__((device))
  void operator()(T &x) const
  {
    x.~T();
  }
};


template<typename System, typename T>
  struct destroy_functor
    : thrust::detail::eval_if<
        thrust::detail::is_convertible<System, thrust::host_system_tag>::value,
        thrust::detail::identity_<host_destroy_functor<T> >,
        thrust::detail::identity_<device_destroy_functor<T> >
      >
{};


template <typename T>
struct fill_functor
{
  T exemplar;

  __attribute__((host)) __attribute__((device))
  fill_functor(const T& _exemplar)
    : exemplar(_exemplar) {}

  __attribute__((host)) __attribute__((device))
  T operator()(void) const
  {
    return exemplar;
  }
};


template<typename T>
  struct uninitialized_fill_functor
{
  T exemplar;

  __attribute__((host)) __attribute__((device))
  uninitialized_fill_functor(T x):exemplar(x){}

  __attribute__((host)) __attribute__((device))
  void operator()(T &x)
  {
    ::new(static_cast<void*>(&x)) T(exemplar);
  }
};






template<typename Compare>
  struct compare_first_less_second
{
  compare_first_less_second(Compare c)
    : comp(c) {}

  template<typename T1, typename T2>
  __attribute__((host)) __attribute__((device))
  bool operator()(T1 lhs, T2 rhs)
  {
    return comp(thrust::get<0>(lhs), thrust::get<0>(rhs)) || (!comp(thrust::get<0>(rhs), thrust::get<0>(lhs)) && thrust::get<1>(lhs) < thrust::get<1>(rhs));
  }

  Compare comp;
};


template<typename Compare>
  struct compare_first
{
  Compare comp;

  __attribute__((host)) __attribute__((device))
  compare_first(Compare comp)
    : comp(comp)
  {}

  template<typename Tuple1, typename Tuple2>
  __attribute__((host)) __attribute__((device))
  bool operator()(const Tuple1 &x, const Tuple2 &y)
  {
    return comp(thrust::raw_reference_cast(thrust::get<0>(x)), thrust::raw_reference_cast(thrust::get<0>(y)));
  }
};


}
}
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/transform.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/transform.h"
       




namespace thrust
{
# 87 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator transform(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                           InputIterator first, InputIterator last,
                           OutputIterator result,
                           UnaryFunction op);
# 138 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename InputIterator,
         typename OutputIterator,
         typename UnaryFunction>
  OutputIterator transform(InputIterator first, InputIterator last,
                           OutputIterator result,
                           UnaryFunction op);
# 201 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator transform(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                           InputIterator1 first1, InputIterator1 last1,
                           InputIterator2 first2,
                           OutputIterator result,
                           BinaryFunction op);
# 262 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryFunction>
  OutputIterator transform(InputIterator1 first1, InputIterator1 last1,
                           InputIterator2 first2,
                           OutputIterator result,
                           BinaryFunction op);
# 338 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                               InputIterator first, InputIterator last,
                               ForwardIterator result,
                               UnaryFunction op,
                               Predicate pred);
# 410 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename InputIterator,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
  ForwardIterator transform_if(InputIterator first, InputIterator last,
                               ForwardIterator result,
                               UnaryFunction op,
                               Predicate pred);
# 481 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                               InputIterator1 first, InputIterator1 last,
                               InputIterator2 stencil,
                               ForwardIterator result,
                               UnaryFunction op,
                               Predicate pred);
# 550 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
  ForwardIterator transform_if(InputIterator1 first, InputIterator1 last,
                               InputIterator2 stencil,
                               ForwardIterator result,
                               UnaryFunction op,
                               Predicate pred);
# 628 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename ForwardIterator,
         typename BinaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                               InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2,
                               InputIterator3 stencil,
                               ForwardIterator result,
                               BinaryFunction binary_op,
                               Predicate pred);
# 704 "/usr/local/cuda-8.0/include/thrust/transform.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename ForwardIterator,
         typename BinaryFunction,
         typename Predicate>
  ForwardIterator transform_if(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2,
                               InputIterator3 stencil,
                               ForwardIterator result,
                               BinaryFunction binary_op,
                               Predicate pred);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/transform.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/transform.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{

template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator transform(thrust::execution_policy<DerivedPolicy> &exec,
                           InputIterator first,
                           InputIterator last,
                           OutputIterator result,
                           UnaryFunction op);

template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator transform(thrust::execution_policy<DerivedPolicy> &exec,
                           InputIterator1 first1,
                           InputIterator1 last1,
                           InputIterator2 first2,
                           OutputIterator result,
                           BinaryFunction op);

template<typename DerivedPolicy,
         typename InputIterator,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(thrust::execution_policy<DerivedPolicy> &exec,
                               InputIterator first,
                               InputIterator last,
                               ForwardIterator result,
                               UnaryFunction unary_op,
                               Predicate pred);

template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(thrust::execution_policy<DerivedPolicy> &exec,
                               InputIterator1 first,
                               InputIterator1 last,
                               InputIterator2 stencil,
                               ForwardIterator result,
                               UnaryFunction unary_op,
                               Predicate pred);

template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename ForwardIterator,
         typename BinaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(thrust::execution_policy<DerivedPolicy> &exec,
                               InputIterator1 first1,
                               InputIterator1 last1,
                               InputIterator2 first2,
                               InputIterator3 stencil,
                               ForwardIterator result,
                               BinaryFunction binary_op,
                               Predicate pred);

}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/for_each.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/for_each.h"
       





namespace thrust
{
# 91 "/usr/local/cuda-8.0/include/thrust/for_each.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
InputIterator for_each(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                       InputIterator first,
                       InputIterator last,
                       UnaryFunction f);
# 154 "/usr/local/cuda-8.0/include/thrust/for_each.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename Size,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
InputIterator for_each_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         InputIterator first,
                         Size n,
                         UnaryFunction f);
# 212 "/usr/local/cuda-8.0/include/thrust/for_each.h"
template<typename InputIterator,
         typename UnaryFunction>
InputIterator for_each(InputIterator first,
                       InputIterator last,
                       UnaryFunction f);
# 267 "/usr/local/cuda-8.0/include/thrust/for_each.h"
template<typename InputIterator,
         typename Size,
         typename UnaryFunction>
InputIterator for_each_n(InputIterator first,
                         Size n,
                         UnaryFunction f);




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/for_each.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/for_each.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/for_each.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/for_each.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/detail/static_assert.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/static_assert.h"
       
# 43 "/usr/local/cuda-8.0/include/thrust/detail/static_assert.h"
namespace thrust
{

namespace detail
{


template <bool x> struct STATIC_ASSERTION_FAILURE;

template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };


template<int x> struct static_assert_test{};

template<typename, bool x>
  struct depend_on_instantiation
{
  static const bool value = x;
};

}

}
# 28 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/for_each.h" 2

namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
InputIterator for_each(thrust::execution_policy<DerivedPolicy> &exec,
                       InputIterator first,
                       InputIterator last,
                       UnaryFunction f)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator, false>::value) ) >)> thrust_static_assert_typedef_49 __attribute__((unused));
  return first;
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename Size,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
InputIterator for_each_n(thrust::execution_policy<DerivedPolicy> &exec,
                         InputIterator first,
                         Size n,
                         UnaryFunction f)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator, false>::value) ) >)> thrust_static_assert_typedef_65 __attribute__((unused));
  return first;
}


}
}
}
}
# 27 "/usr/local/cuda-8.0/include/thrust/detail/for_each.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/for_each.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/for_each.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/for_each.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/for_each.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/function.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/function.h"
       




namespace thrust
{
namespace detail
{


template<typename Function, typename Result>
  struct wrapped_function
{

  mutable Function m_f;

  inline __attribute__((host)) __attribute__((device))
  wrapped_function()
    : m_f()
  {}

  inline __attribute__((host)) __attribute__((device))
  wrapped_function(const Function &f)
    : m_f(f)
  {}

  #pragma nv_exec_check_disable
  template<typename Argument>
  inline __attribute__((host)) __attribute__((device))
    Result operator()(Argument &x) const
  {


    return static_cast<Result>(m_f(thrust::raw_reference_cast(x)));
  }

  #pragma nv_exec_check_disable
  template<typename Argument>
    inline __attribute__((host)) __attribute__((device)) Result operator()(const Argument &x) const
  {


    return static_cast<Result>(m_f(thrust::raw_reference_cast(x)));
  }

  #pragma nv_exec_check_disable
  template<typename Argument1, typename Argument2>
    inline __attribute__((host)) __attribute__((device)) Result operator()(Argument1 &x, Argument2 &y) const
  {


    return static_cast<Result>(m_f(thrust::raw_reference_cast(x), thrust::raw_reference_cast(y)));
  }

  #pragma nv_exec_check_disable
  template<typename Argument1, typename Argument2>
    inline __attribute__((host)) __attribute__((device)) Result operator()(const Argument1 &x, Argument2 &y) const
  {


    return static_cast<Result>(m_f(thrust::raw_reference_cast(x), thrust::raw_reference_cast(y)));
  }

  #pragma nv_exec_check_disable
  template<typename Argument1, typename Argument2>
    inline __attribute__((host)) __attribute__((device)) Result operator()(const Argument1 &x, const Argument2 &y) const
  {


    return static_cast<Result>(m_f(thrust::raw_reference_cast(x), thrust::raw_reference_cast(y)));
  }

  #pragma nv_exec_check_disable
  template<typename Argument1, typename Argument2>
    inline __attribute__((host)) __attribute__((device)) Result operator()(Argument1 &x, const Argument2 &y) const
  {


    return static_cast<Result>(m_f(thrust::raw_reference_cast(x), thrust::raw_reference_cast(y)));
  }
};


}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/for_each.h" 2


namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
InputIterator for_each(sequential::execution_policy<DerivedPolicy> &,
                       InputIterator first,
                       InputIterator last,
                       UnaryFunction f)
{

  thrust::detail::wrapped_function<
    UnaryFunction,
    void
  > wrapped_f(f);

  for(; first != last; ++first)
  {
    wrapped_f(*first);
  }

  return first;
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename Size,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
InputIterator for_each_n(sequential::execution_policy<DerivedPolicy> &,
                         InputIterator first,
                         Size n,
                         UnaryFunction f)
{

  thrust::detail::wrapped_function<
    UnaryFunction,
    void
  > wrapped_f(f);

  for(Size i = 0; i != n; i++)
  {


    wrapped_f(*first);
    ++first;
  }

  return first;
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/for_each.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/for_each.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/for_each.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/for_each.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/for_each.h" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/for_each.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
RandomAccessIterator for_each(execution_policy<DerivedPolicy> &s,
                              RandomAccessIterator first,
                              RandomAccessIterator last,
                              UnaryFunction f);


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename Size,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
RandomAccessIterator for_each_n(execution_policy<DerivedPolicy> &s,
                                RandomAccessIterator first,
                                Size n,
                                UnaryFunction f);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/for_each.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/for_each.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/distance.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/distance.h"
       




namespace thrust
{
# 66 "/usr/local/cuda-8.0/include/thrust/distance.h"
template<typename InputIterator>
inline __attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last);




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/distance.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/detail/distance.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/advance.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/advance.h"
       



namespace thrust
{
# 64 "/usr/local/cuda-8.0/include/thrust/advance.h"
template <typename InputIterator, typename Distance>
__attribute__((host)) __attribute__((device))
void advance(InputIterator& i, Distance n);




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/advance.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/detail/advance.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/advance.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/advance.h"
       



namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{

template<typename InputIterator, typename Distance>
__attribute__((host)) __attribute__((device))
void advance(InputIterator& i, Distance n);

}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/advance.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/advance.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace detail
{

 #pragma nv_exec_check_disable
template<typename InputIterator, typename Distance>
__attribute__((host)) __attribute__((device))
void advance(InputIterator& i, Distance n, thrust::incrementable_traversal_tag)
{
  while(n)
  {
    ++i;
    --n;
  }
}

 #pragma nv_exec_check_disable
template<typename InputIterator, typename Distance>
__attribute__((host)) __attribute__((device))
void advance(InputIterator& i, Distance n, thrust::random_access_traversal_tag)
{
  i += n;
}

}

template<typename InputIterator, typename Distance>
__attribute__((host)) __attribute__((device))
void advance(InputIterator& i, Distance n)
{

  thrust::system::detail::generic::detail::advance(i, n,
    typename thrust::iterator_traversal<InputIterator>::type());
}

}
}
}
}
# 41 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/advance.h" 2
# 25 "/usr/local/cuda-8.0/include/thrust/detail/advance.inl" 2

namespace thrust
{


template <typename InputIterator, typename Distance>
__attribute__((host)) __attribute__((device))
void advance(InputIterator& i, Distance n)
{
  thrust::system::detail::generic::advance(i, n);
}


}
# 74 "/usr/local/cuda-8.0/include/thrust/advance.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/detail/distance.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/distance.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/distance.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{

template<typename InputIterator>
inline __attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last);

}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/distance.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/distance.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace detail
{


 #pragma nv_exec_check_disable
template<typename InputIterator>
inline __attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last, thrust::incrementable_traversal_tag)
{
  typename thrust::iterator_traits<InputIterator>::difference_type result(0);

  while(first != last)
  {
    ++first;
    ++result;
  }

  return result;
}


 #pragma nv_exec_check_disable
template<typename InputIterator>
inline __attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last, thrust::random_access_traversal_tag)
{
  return last - first;
}


}


template<typename InputIterator>
inline __attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last)
{

  return thrust::system::detail::generic::detail::distance(first, last,
    typename thrust::iterator_traversal<InputIterator>::type());
}


}
}
}
}
# 43 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/distance.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/detail/distance.inl" 2


namespace thrust
{


template<typename InputIterator>
inline __attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last)
{
  return thrust::system::detail::generic::distance(first, last);
}


}
# 77 "/usr/local/cuda-8.0/include/thrust/distance.h" 2
# 25 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/for_each.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk.h"
       
# 47 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk.h"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/bulk.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/bulk.hpp"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/config.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/config.hpp"
       
# 39 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/config.hpp"
# 1 "/usr/local/cuda-8.0/include/thrust/version.h" 1
# 29 "/usr/local/cuda-8.0/include/thrust/version.h"
       
# 83 "/usr/local/cuda-8.0/include/thrust/version.h"
namespace thrust
{

}
# 40 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/config.hpp" 2
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/bulk.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/execution_policy.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/execution_policy.hpp"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/future.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/future.hpp"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/guarded_cuda_runtime_api.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/guarded_cuda_runtime_api.hpp"
       
# 50 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/guarded_cuda_runtime_api.hpp"
# 1 "/usr/local/cuda-8.0/include/cuda_runtime_api.h" 1
# 51 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/guarded_cuda_runtime_api.hpp" 2
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/future.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/terminate.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/terminate.hpp"
       


# 1 "/usr/include/c++/4.8.2/cstdio" 1 3
# 39 "/usr/include/c++/4.8.2/cstdio" 3
       
# 40 "/usr/include/c++/4.8.2/cstdio" 3
# 94 "/usr/include/c++/4.8.2/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 150 "/usr/include/c++/4.8.2/cstdio" 3
namespace __gnu_cxx
{
# 168 "/usr/include/c++/4.8.2/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/terminate.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


__attribute__((host)) __attribute__((device))
inline void terminate()
{



  std::terminate();

}


__attribute__((host)) __attribute__((device))
inline void terminate_with_message(const char* message)
{

  std::printf("%s\n", message);


  bulk_::detail::terminate();
}


__attribute__((host)) __attribute__((device))
inline void terminate_on_error(cudaError_t e, const char* message)
{
  if(e)
  {

    printf("Error after: %s: %s\n", message, cudaGetErrorString(e));



    bulk_::detail::terminate();
  }
}


}
}
} } } }
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system_error.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system_error.h"
       



namespace thrust
{
# 40 "/usr/local/cuda-8.0/include/thrust/system_error.h"
namespace system
{
}




}

# 1 "/usr/local/cuda-8.0/include/thrust/system/error_code.h" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/error_code.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/errno.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/errno.h"
       
# 27 "/usr/local/cuda-8.0/include/thrust/system/detail/errno.h"
namespace thrust
{

namespace system
{

namespace detail
{

static const int eafnosupport = 9901;
static const int eaddrinuse = 9902;
static const int eaddrnotavail = 9903;
static const int eisconn = 9904;
static const int ebadmsg = 9905;
static const int econnaborted = 9906;
static const int ealready = 9907;
static const int econnrefused = 9908;
static const int econnreset = 9909;
static const int edestaddrreq = 9910;
static const int ehostunreach = 9911;
static const int eidrm = 9912;
static const int emsgsize = 9913;
static const int enetdown = 9914;
static const int enetreset = 9915;
static const int enetunreach = 9916;
static const int enobufs = 9917;
static const int enolink = 9918;
static const int enodata = 9919;
static const int enomsg = 9920;
static const int enoprotoopt = 9921;
static const int enosr = 9922;
static const int enotsock = 9923;
static const int enostr = 9924;
static const int enotconn = 9925;
static const int enotsup = 9926;
static const int ecanceled = 9927;
static const int einprogress = 9928;
static const int eopnotsupp = 9929;
static const int ewouldblock = 9930;
static const int eownerdead = 9931;
static const int eproto = 9932;
static const int eprotonosupport = 9933;
static const int enotrecoverable = 9934;
static const int etime = 9935;
static const int etxtbsy = 9936;
static const int etimedout = 9938;
static const int eloop = 9939;
static const int eoverflow = 9940;
static const int eprototype = 9941;
static const int enosys = 9942;
static const int einval = 9943;
static const int erange = 9944;
static const int eilseq = 9945;
static const int e2big = 9946;
static const int edom = 9947;
static const int efault = 9948;
static const int ebadf = 9949;
static const int epipe = 9950;
static const int exdev = 9951;
static const int ebusy = 9952;
static const int enotempty = 9953;
static const int enoexec = 9954;
static const int eexist = 9955;
static const int efbig = 9956;
static const int enametoolong = 9957;
static const int enotty = 9958;
static const int eintr = 9959;
static const int espipe = 9960;
static const int eio = 9961;
static const int eisdir = 9962;
static const int echild = 9963;
static const int enolck = 9964;
static const int enospc = 9965;
static const int enxio = 9966;
static const int enodev = 9967;
static const int enoent = 9968;
static const int esrch = 9969;
static const int enotdir = 9970;
static const int enomem = 9971;
static const int eperm = 9972;
static const int eacces = 9973;
static const int erofs = 9974;
static const int edeadlk = 9975;
static const int eagain = 9976;
static const int enfile = 9977;
static const int emfile = 9978;
static const int emlink = 9979;

}

}

}
# 28 "/usr/local/cuda-8.0/include/thrust/system/error_code.h" 2
# 1 "/usr/include/c++/4.8.2/iostream" 1 3
# 36 "/usr/include/c++/4.8.2/iostream" 3
       
# 37 "/usr/include/c++/4.8.2/iostream" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/4.8.2/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 29 "/usr/local/cuda-8.0/include/thrust/system/error_code.h" 2

namespace thrust
{

namespace system
{






class error_condition;
class error_code;



template<typename T> struct is_error_code_enum : public thrust::detail::false_type {};



template<typename T> struct is_error_condition_enum : public thrust::detail::false_type {};



namespace errc
{

enum errc_t
{
  address_family_not_supported = detail::eafnosupport,
  address_in_use = detail::eaddrinuse,
  address_not_available = detail::eaddrnotavail,
  already_connected = detail::eisconn,
  argument_list_too_long = detail::e2big,
  argument_out_of_domain = detail::edom,
  bad_address = detail::efault,
  bad_file_descriptor = detail::ebadf,
  bad_message = detail::ebadmsg,
  broken_pipe = detail::epipe,
  connection_aborted = detail::econnaborted,
  connection_already_in_progress = detail::ealready,
  connection_refused = detail::econnrefused,
  connection_reset = detail::econnreset,
  cross_device_link = detail::exdev,
  destination_address_required = detail::edestaddrreq,
  device_or_resource_busy = detail::ebusy,
  directory_not_empty = detail::enotempty,
  executable_format_error = detail::enoexec,
  file_exists = detail::eexist,
  file_too_large = detail::efbig,
  filename_too_long = detail::enametoolong,
  function_not_supported = detail::enosys,
  host_unreachable = detail::ehostunreach,
  identifier_removed = detail::eidrm,
  illegal_byte_sequence = detail::eilseq,
  inappropriate_io_control_operation = detail::enotty,
  interrupted = detail::eintr,
  invalid_argument = detail::einval,
  invalid_seek = detail::espipe,
  io_error = detail::eio,
  is_a_directory = detail::eisdir,
  message_size = detail::emsgsize,
  network_down = detail::enetdown,
  network_reset = detail::enetreset,
  network_unreachable = detail::enetunreach,
  no_buffer_space = detail::enobufs,
  no_child_process = detail::echild,
  no_link = detail::enolink,
  no_lock_available = detail::enolck,
  no_message_available = detail::enodata,
  no_message = detail::enomsg,
  no_protocol_option = detail::enoprotoopt,
  no_space_on_device = detail::enospc,
  no_stream_resources = detail::enosr,
  no_such_device_or_address = detail::enxio,
  no_such_device = detail::enodev,
  no_such_file_or_directory = detail::enoent,
  no_such_process = detail::esrch,
  not_a_directory = detail::enotdir,
  not_a_socket = detail::enotsock,
  not_a_stream = detail::enostr,
  not_connected = detail::enotconn,
  not_enough_memory = detail::enomem,
  not_supported = detail::enotsup,
  operation_canceled = detail::ecanceled,
  operation_in_progress = detail::einprogress,
  operation_not_permitted = detail::eperm,
  operation_not_supported = detail::eopnotsupp,
  operation_would_block = detail::ewouldblock,
  owner_dead = detail::eownerdead,
  permission_denied = detail::eacces,
  protocol_error = detail::eproto,
  protocol_not_supported = detail::eprotonosupport,
  read_only_file_system = detail::erofs,
  resource_deadlock_would_occur = detail::edeadlk,
  resource_unavailable_try_again = detail::eagain,
  result_out_of_range = detail::erange,
  state_not_recoverable = detail::enotrecoverable,
  stream_timeout = detail::etime,
  text_file_busy = detail::etxtbsy,
  timed_out = detail::etimedout,
  too_many_files_open_in_system = detail::enfile,
  too_many_files_open = detail::emfile,
  too_many_links = detail::emlink,
  too_many_symbolic_link_levels = detail::eloop,
  value_too_large = detail::eoverflow,
  wrong_protocol_type = detail::eprototype
};

}




template<> struct is_error_condition_enum<errc::errc_t> : public thrust::detail::true_type {};
# 154 "/usr/local/cuda-8.0/include/thrust/system/error_code.h"
class error_category
{
  public:


    inline virtual ~error_category(void);







    inline virtual const char *name(void) const = 0;



    inline virtual error_condition default_error_condition(int ev) const;



    inline virtual bool equivalent(int code, const error_condition &condition) const;



    inline virtual bool equivalent(const error_code &code, int condition) const;



    virtual std::string message(int ev) const = 0;



    inline bool operator==(const error_category &rhs) const;



    inline bool operator!=(const error_category &rhs) const;




    inline bool operator<(const error_category &rhs) const;
};
# 208 "/usr/local/cuda-8.0/include/thrust/system/error_code.h"
inline const error_category &generic_category(void);
# 222 "/usr/local/cuda-8.0/include/thrust/system/error_code.h"
inline const error_category &system_category(void);
# 232 "/usr/local/cuda-8.0/include/thrust/system/error_code.h"
class error_code
{
  public:





    inline error_code(void);




    inline error_code(int val, const error_category &cat);




    template <typename ErrorCodeEnum>
      error_code(ErrorCodeEnum e


        , typename thrust::detail::enable_if<is_error_code_enum<ErrorCodeEnum>::value>::type * = 0

        );





    inline void assign(int val, const error_category &cat);



    template <typename ErrorCodeEnum>


      typename thrust::detail::enable_if<is_error_code_enum<ErrorCodeEnum>::value, error_code>::type &



        operator=(ErrorCodeEnum e);



    inline void clear(void);





    inline int value(void) const;



    inline const error_category &category(void) const;



    inline error_condition default_error_condition(void) const;



    inline std::string message(void) const;






    inline operator bool (void) const;



  private:
    int m_val;
    const error_category *m_cat;


};
# 320 "/usr/local/cuda-8.0/include/thrust/system/error_code.h"
inline error_code make_error_code(errc::errc_t e);




inline bool operator<(const error_code &lhs, const error_code &rhs);




template <typename charT, typename traits>
  std::basic_ostream<charT,traits>&
    operator<<(std::basic_ostream<charT,traits>& os, const error_code &ec);
# 344 "/usr/local/cuda-8.0/include/thrust/system/error_code.h"
class error_condition
{
  public:






    inline error_condition(void);





    inline error_condition(int val, const error_category &cat);






    template<typename ErrorConditionEnum>
      error_condition(ErrorConditionEnum e


        , typename thrust::detail::enable_if<is_error_condition_enum<ErrorConditionEnum>::value>::type * = 0

                     );
# 382 "/usr/local/cuda-8.0/include/thrust/system/error_code.h"
    inline void assign(int val, const error_category &cat);







    template<typename ErrorConditionEnum>


      typename thrust::detail::enable_if<is_error_condition_enum<ErrorConditionEnum>::value, error_condition>::type &



        operator=(ErrorConditionEnum e);





    inline void clear(void);





    inline int value(void) const;



    inline const error_category &category(void) const;



    inline std::string message(void) const;






    inline operator bool (void) const;




  private:
    int m_val;
    const error_category *m_cat;



};
# 444 "/usr/local/cuda-8.0/include/thrust/system/error_code.h"
inline error_condition make_error_condition(errc::errc_t e);




inline bool operator<(const error_condition &lhs, const error_condition &rhs);







inline bool operator==(const error_code &lhs, const error_code &rhs);




inline bool operator==(const error_code &lhs, const error_condition &rhs);




inline bool operator==(const error_condition &lhs, const error_code &rhs);




inline bool operator==(const error_condition &lhs, const error_condition &rhs);




inline bool operator!=(const error_code &lhs, const error_code &rhs);




inline bool operator!=(const error_code &lhs, const error_condition &rhs);




inline bool operator!=(const error_condition &lhs, const error_code &rhs);




inline bool operator!=(const error_condition &lhs, const error_condition &rhs);





}



using system::error_category;
using system::error_code;
using system::error_condition;
using system::is_error_code_enum;
using system::is_error_condition_enum;
using system::make_error_code;
using system::make_error_condition;


namespace errc = system::errc;

using system::generic_category;
using system::system_category;

}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/error_category.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/error_category.inl"
       




# 1 "/usr/include/c++/4.8.2/cstring" 1 3
# 39 "/usr/include/c++/4.8.2/cstring" 3
       
# 40 "/usr/include/c++/4.8.2/cstring" 3
# 71 "/usr/include/c++/4.8.2/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 120 "/usr/include/c++/4.8.2/cstring" 3

}
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/error_category.inl" 2

namespace thrust
{

namespace system
{

error_category
  ::~error_category(void)
{
  ;
}


error_condition error_category
  ::default_error_condition(int ev) const
{
  return error_condition(ev, *this);
}


bool error_category
  ::equivalent(int code, const error_condition &condition) const
{
  return default_error_condition(code) == condition;
}


bool error_category
  ::equivalent(const error_code &code, int condition) const
{
  bool result = (this->operator==(code.category())) && (code.value() == condition);
  return result;
}


bool error_category
  ::operator==(const error_category &rhs) const
{
  return this == &rhs;
}


bool error_category
  ::operator!=(const error_category &rhs) const
{
  return !this->operator==(rhs);
}


bool error_category
  ::operator<(const error_category &rhs) const
{
  return thrust::less<const error_category*>()(this,&rhs);
}


namespace detail
{


class generic_error_category
  : public error_category
{
  public:
    inline generic_error_category(void) {}

    inline virtual const char *name(void) const
    {
      return "generic";
    }

    inline virtual std::string message(int ev) const
    {
      static const std::string unknown_err("Unknown error");



      const char *c_str = std::strerror(ev);
      return c_str ? std::string(c_str) : unknown_err;
    }
};


class system_error_category
  : public error_category
{
  public:
    inline system_error_category(void) {}

    inline virtual const char *name(void) const
    {
      return "system";
    }

    inline virtual std::string message(int ev) const
    {
      return generic_category().message(ev);
    }

    inline virtual error_condition default_error_condition(int ev) const
    {
      using namespace errc;

      switch(ev)
      {
        case eafnosupport: return make_error_condition(address_family_not_supported);
        case eaddrinuse: return make_error_condition(address_in_use);
        case eaddrnotavail: return make_error_condition(address_not_available);
        case eisconn: return make_error_condition(already_connected);
        case e2big: return make_error_condition(argument_list_too_long);
        case edom: return make_error_condition(argument_out_of_domain);
        case efault: return make_error_condition(bad_address);
        case ebadf: return make_error_condition(bad_file_descriptor);
        case ebadmsg: return make_error_condition(bad_message);
        case epipe: return make_error_condition(broken_pipe);
        case econnaborted: return make_error_condition(connection_aborted);
        case ealready: return make_error_condition(connection_already_in_progress);
        case econnrefused: return make_error_condition(connection_refused);
        case econnreset: return make_error_condition(connection_reset);
        case exdev: return make_error_condition(cross_device_link);
        case edestaddrreq: return make_error_condition(destination_address_required);
        case ebusy: return make_error_condition(device_or_resource_busy);
        case enotempty: return make_error_condition(directory_not_empty);
        case enoexec: return make_error_condition(executable_format_error);
        case eexist: return make_error_condition(file_exists);
        case efbig: return make_error_condition(file_too_large);
        case enametoolong: return make_error_condition(filename_too_long);
        case enosys: return make_error_condition(function_not_supported);
        case ehostunreach: return make_error_condition(host_unreachable);
        case eidrm: return make_error_condition(identifier_removed);
        case eilseq: return make_error_condition(illegal_byte_sequence);
        case enotty: return make_error_condition(inappropriate_io_control_operation);
        case eintr: return make_error_condition(interrupted);
        case einval: return make_error_condition(invalid_argument);
        case espipe: return make_error_condition(invalid_seek);
        case eio: return make_error_condition(io_error);
        case eisdir: return make_error_condition(is_a_directory);
        case emsgsize: return make_error_condition(message_size);
        case enetdown: return make_error_condition(network_down);
        case enetreset: return make_error_condition(network_reset);
        case enetunreach: return make_error_condition(network_unreachable);
        case enobufs: return make_error_condition(no_buffer_space);
        case echild: return make_error_condition(no_child_process);
        case enolink: return make_error_condition(no_link);
        case enolck: return make_error_condition(no_lock_available);
        case enodata: return make_error_condition(no_message_available);
        case enomsg: return make_error_condition(no_message);
        case enoprotoopt: return make_error_condition(no_protocol_option);
        case enospc: return make_error_condition(no_space_on_device);
        case enosr: return make_error_condition(no_stream_resources);
        case enxio: return make_error_condition(no_such_device_or_address);
        case enodev: return make_error_condition(no_such_device);
        case enoent: return make_error_condition(no_such_file_or_directory);
        case esrch: return make_error_condition(no_such_process);
        case enotdir: return make_error_condition(not_a_directory);
        case enotsock: return make_error_condition(not_a_socket);
        case enostr: return make_error_condition(not_a_stream);
        case enotconn: return make_error_condition(not_connected);
        case enomem: return make_error_condition(not_enough_memory);
        case enotsup: return make_error_condition(not_supported);
        case ecanceled: return make_error_condition(operation_canceled);
        case einprogress: return make_error_condition(operation_in_progress);
        case eperm: return make_error_condition(operation_not_permitted);
        case eopnotsupp: return make_error_condition(operation_not_supported);
        case ewouldblock: return make_error_condition(operation_would_block);
        case eownerdead: return make_error_condition(owner_dead);
        case eacces: return make_error_condition(permission_denied);
        case eproto: return make_error_condition(protocol_error);
        case eprotonosupport: return make_error_condition(protocol_not_supported);
        case erofs: return make_error_condition(read_only_file_system);
        case edeadlk: return make_error_condition(resource_deadlock_would_occur);
        case eagain: return make_error_condition(resource_unavailable_try_again);
        case erange: return make_error_condition(result_out_of_range);
        case enotrecoverable: return make_error_condition(state_not_recoverable);
        case etime: return make_error_condition(stream_timeout);
        case etxtbsy: return make_error_condition(text_file_busy);
        case etimedout: return make_error_condition(timed_out);
        case enfile: return make_error_condition(too_many_files_open_in_system);
        case emfile: return make_error_condition(too_many_files_open);
        case emlink: return make_error_condition(too_many_links);
        case eloop: return make_error_condition(too_many_symbolic_link_levels);
        case eoverflow: return make_error_condition(value_too_large);
        case eprototype: return make_error_condition(wrong_protocol_type);
        default: return error_condition(ev,system_category());
      }
    }
};


}


const error_category &generic_category(void)
{
  static const detail::generic_error_category result;
  return result;
}


const error_category &system_category(void)
{
  static const detail::system_error_category result;
  return result;
}


}

}
# 519 "/usr/local/cuda-8.0/include/thrust/system/error_code.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/error_code.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/error_code.inl"
       



namespace thrust
{

namespace system
{

error_code
  ::error_code(void)
    :m_val(0),m_cat(&system_category())
{
  ;
}


error_code
  ::error_code(int val, const error_category &cat)
    :m_val(val),m_cat(&cat)
{
  ;
}


template <typename ErrorCodeEnum>
  error_code
    ::error_code(ErrorCodeEnum e


                 , typename thrust::detail::enable_if<is_error_code_enum<ErrorCodeEnum>::value>::type *

                )
{
  *this = make_error_code(e);
}


void error_code
  ::assign(int val, const error_category &cat)
{
  m_val = val;
  m_cat = &cat;
}


template <typename ErrorCodeEnum>


  typename thrust::detail::enable_if<is_error_code_enum<ErrorCodeEnum>::value, error_code>::type &



    error_code
      ::operator=(ErrorCodeEnum e)
{
  *this = make_error_code(e);
  return *this;
}


void error_code
  ::clear(void)
{
  m_val = 0;
  m_cat = &system_category();
}


int error_code
  ::value(void) const
{
  return m_val;
}


const error_category &error_code
  ::category(void) const
{
  return *m_cat;
}


error_condition error_code
  ::default_error_condition(void) const
{
  return category().default_error_condition(value());
}


std::string error_code
  ::message(void) const
{
  return category().message(value());
}


error_code
  ::operator bool (void) const
{
  return value() != 0;
}


error_code make_error_code(errc::errc_t e)
{
  return error_code(static_cast<int>(e), generic_category());
}


bool operator<(const error_code &lhs, const error_code &rhs)
{
  bool result = lhs.category().operator<(rhs.category());
  result = result || lhs.category().operator==(rhs.category());
  result = result || lhs.value() < rhs.value();
  return result;
}


template<typename charT, typename traits>
  std::basic_ostream<charT,traits>&
    operator<<(std::basic_ostream<charT,traits> &os, const error_code &ec)
{
  return os << ec.category().name() << ':' << ec.value();
}


bool operator==(const error_code &lhs, const error_code &rhs)
{
  return lhs.category().operator==(rhs.category()) && lhs.value() == rhs.value();
}


bool operator==(const error_code &lhs, const error_condition &rhs)
{
  return lhs.category().equivalent(lhs.value(), rhs) || rhs.category().equivalent(lhs,rhs.value());
}


bool operator==(const error_condition &lhs, const error_code &rhs)
{
  return rhs.category().equivalent(lhs.value(), lhs) || lhs.category().equivalent(rhs, lhs.value());
}


bool operator==(const error_condition &lhs, const error_condition &rhs)
{
  return lhs.category().operator==(rhs.category()) && lhs.value() == rhs.value();
}


bool operator!=(const error_code &lhs, const error_code &rhs)
{
  return !(lhs == rhs);
}


bool operator!=(const error_code &lhs, const error_condition &rhs)
{
  return !(lhs == rhs);
}


bool operator!=(const error_condition &lhs, const error_code &rhs)
{
  return !(lhs == rhs);
}


bool operator!=(const error_condition &lhs, const error_condition &rhs)
{
  return !(lhs == rhs);
}


}

}
# 520 "/usr/local/cuda-8.0/include/thrust/system/error_code.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/error_condition.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/error_condition.inl"
       




namespace thrust
{

namespace system
{

error_condition
  ::error_condition(void)
    :m_val(0),m_cat(&generic_category())
{
  ;
}


error_condition
  ::error_condition(int val, const error_category &cat)
    :m_val(val),m_cat(&cat)
{
  ;
}


template<typename ErrorConditionEnum>
  error_condition
    ::error_condition(ErrorConditionEnum e


                      , typename thrust::detail::enable_if<is_error_condition_enum<ErrorConditionEnum>::value>::type *

                     )
{
  *this = make_error_condition(e);
}


void error_condition
  ::assign(int val, const error_category &cat)
{
  m_val = val;
  m_cat = &cat;
}


template<typename ErrorConditionEnum>


  typename thrust::detail::enable_if<is_error_condition_enum<ErrorConditionEnum>::value, error_condition>::type &



    error_condition
      ::operator=(ErrorConditionEnum e)
{
  *this = make_error_condition(e);
  return *this;
}


void error_condition
  ::clear(void)
{
  m_val = 0;
  m_cat = &generic_category();
}


int error_condition
  ::value(void) const
{
  return m_val;
}


const error_category &error_condition
  ::category(void) const
{
  return *m_cat;
}


std::string error_condition
  ::message(void) const
{
  return category().message(value());
}


error_condition
  ::operator bool (void) const
{
  return value() != 0;
}


error_condition make_error_condition(errc::errc_t e)
{
  return error_condition(static_cast<int>(e), generic_category());
}


bool operator<(const error_condition &lhs,
               const error_condition &rhs)
{
  return lhs.category().operator<(rhs.category()) || (lhs.category().operator==(rhs.category()) && (lhs.value() < rhs.value()));
}


}

}
# 521 "/usr/local/cuda-8.0/include/thrust/system/error_code.h" 2
# 50 "/usr/local/cuda-8.0/include/thrust/system_error.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/system_error.h" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/system_error.h"
       


# 1 "/usr/include/c++/4.8.2/stdexcept" 1 3
# 36 "/usr/include/c++/4.8.2/stdexcept" 3
       
# 37 "/usr/include/c++/4.8.2/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/4.8.2/stdexcept" 3
  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual ~logic_error() throw();



    virtual const char*
    what() const throw();
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
    virtual ~domain_error() throw();
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
    virtual ~invalid_argument() throw();
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
    virtual ~length_error() throw();
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
    virtual ~out_of_range() throw();
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual ~runtime_error() throw();



    virtual const char*
    what() const throw();
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
    virtual ~range_error() throw();
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
    virtual ~overflow_error() throw();
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
    virtual ~underflow_error() throw();
  };




}
# 27 "/usr/local/cuda-8.0/include/thrust/system/system_error.h" 2




namespace thrust
{

namespace system
{
# 89 "/usr/local/cuda-8.0/include/thrust/system/system_error.h"
class system_error
  : public std::runtime_error
{
  public:
# 101 "/usr/local/cuda-8.0/include/thrust/system/system_error.h"
    inline system_error(error_code ec, const std::string &what_arg);







    inline system_error(error_code ec, const char *what_arg);





    inline system_error(error_code ec);
# 124 "/usr/local/cuda-8.0/include/thrust/system/system_error.h"
    inline system_error(int ev, const error_category &ecat, const std::string &what_arg);
# 133 "/usr/local/cuda-8.0/include/thrust/system/system_error.h"
    inline system_error(int ev, const error_category &ecat, const char *what_arg);






    inline system_error(int ev, const error_category &ecat);



    inline virtual ~system_error(void) throw () {};





    inline const error_code &code(void) const throw();





    inline const char *what(void) const throw();



  private:
    error_code m_error_code;
    mutable std::string m_what;



};

}





using system::system_error;

}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/system_error.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/system_error.inl"
       



namespace thrust
{

namespace system
{


system_error
  ::system_error(error_code ec, const std::string &what_arg)
    : std::runtime_error(what_arg), m_error_code(ec)
{

}


system_error
  ::system_error(error_code ec, const char *what_arg)
    : std::runtime_error(what_arg), m_error_code(ec)
{
  ;
}


system_error
  ::system_error(error_code ec)
    : std::runtime_error(""), m_error_code(ec)
{
  ;
}


system_error
  ::system_error(int ev, const error_category &ecat, const std::string &what_arg)
    : std::runtime_error(what_arg), m_error_code(ev,ecat)
{
  ;
}


system_error
  ::system_error(int ev, const error_category &ecat, const char *what_arg)
    : std::runtime_error(what_arg), m_error_code(ev,ecat)
{
  ;
}


system_error
  ::system_error(int ev, const error_category &ecat)
    : std::runtime_error(""), m_error_code(ev,ecat)
{
  ;
}


const error_code &system_error
  ::code(void) const throw()
{
  return m_error_code;
}


const char *system_error
  ::what(void) const throw()
{
  if(m_what.empty())
  {
    try
    {
      m_what = this->std::runtime_error::what();
      if(m_error_code)
      {
        if(!m_what.empty()) m_what += ": ";
        m_what += m_error_code.message();
      }
    }
    catch(...)
    {
      return std::runtime_error::what();
    }
  }

  return m_what.c_str();
}


}

}
# 179 "/usr/local/cuda-8.0/include/thrust/system/system_error.h" 2
# 51 "/usr/local/cuda-8.0/include/thrust/system_error.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/error.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/error.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/guarded_driver_types.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/guarded_driver_types.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/guarded_driver_types.h"
           




           
# 55 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/guarded_driver_types.h"
           



           
# 28 "/usr/local/cuda-8.0/include/thrust/system/cuda/error.h" 2

namespace thrust
{

namespace system
{

namespace cuda
{
# 47 "/usr/local/cuda-8.0/include/thrust/system/cuda/error.h"
namespace errc
{



enum errc_t
{


  success = cudaSuccess,
  missing_configuration = cudaErrorMissingConfiguration,
  memory_allocation = cudaErrorMemoryAllocation,
  initialization_error = cudaErrorInitializationError,
  launch_failure = cudaErrorLaunchFailure,
  prior_launch_failure = cudaErrorPriorLaunchFailure,
  launch_timeout = cudaErrorLaunchTimeout,
  launch_out_of_resources = cudaErrorLaunchOutOfResources,
  invalid_device_function = cudaErrorInvalidDeviceFunction,
  invalid_configuration = cudaErrorInvalidConfiguration,
  invalid_device = cudaErrorInvalidDevice,
  invalid_value = cudaErrorInvalidValue,
  invalid_pitch_value = cudaErrorInvalidPitchValue,
  invalid_symbol = cudaErrorInvalidSymbol,
  map_buffer_object_failed = cudaErrorMapBufferObjectFailed,
  unmap_buffer_object_failed = cudaErrorUnmapBufferObjectFailed,
  invalid_host_pointer = cudaErrorInvalidHostPointer,
  invalid_device_pointer = cudaErrorInvalidDevicePointer,
  invalid_texture = cudaErrorInvalidTexture,
  invalid_texture_binding = cudaErrorInvalidTextureBinding,
  invalid_channel_descriptor = cudaErrorInvalidChannelDescriptor,
  invalid_memcpy_direction = cudaErrorInvalidMemcpyDirection,
  address_of_constant_error = cudaErrorAddressOfConstant,
  texture_fetch_failed = cudaErrorTextureFetchFailed,
  texture_not_bound = cudaErrorTextureNotBound,
  synchronization_error = cudaErrorSynchronizationError,
  invalid_filter_setting = cudaErrorInvalidFilterSetting,
  invalid_norm_setting = cudaErrorInvalidNormSetting,
  mixed_device_execution = cudaErrorMixedDeviceExecution,
  cuda_runtime_unloading = cudaErrorCudartUnloading,
  unknown = cudaErrorUnknown,
  not_yet_implemented = cudaErrorNotYetImplemented,
  memory_value_too_large = cudaErrorMemoryValueTooLarge,
  invalid_resource_handle = cudaErrorInvalidResourceHandle,
  not_ready = cudaErrorNotReady,
  insufficient_driver = cudaErrorInsufficientDriver,
  set_on_active_process_error = cudaErrorSetOnActiveProcess,
  no_device = cudaErrorNoDevice,
  ecc_uncorrectable = cudaErrorECCUncorrectable,


  shared_object_symbol_not_found = cudaErrorSharedObjectSymbolNotFound,
  shared_object_init_failed = cudaErrorSharedObjectInitFailed,
  unsupported_limit = cudaErrorUnsupportedLimit,
  duplicate_variable_name = cudaErrorDuplicateVariableName,
  duplicate_texture_name = cudaErrorDuplicateTextureName,
  duplicate_surface_name = cudaErrorDuplicateSurfaceName,
  devices_unavailable = cudaErrorDevicesUnavailable,
  invalid_kernel_image = cudaErrorInvalidKernelImage,
  no_kernel_image_for_device = cudaErrorNoKernelImageForDevice,
  incompatible_driver_context = cudaErrorIncompatibleDriverContext,
  peer_access_already_enabled = cudaErrorPeerAccessAlreadyEnabled,
  peer_access_not_enabled = cudaErrorPeerAccessNotEnabled,
  device_already_in_use = cudaErrorDeviceAlreadyInUse,
  profiler_disabled = cudaErrorProfilerDisabled,
  assert_triggered = cudaErrorAssert,
  too_many_peers = cudaErrorTooManyPeers,
  host_memory_already_registered = cudaErrorHostMemoryAlreadyRegistered,
  host_memory_not_registered = cudaErrorHostMemoryNotRegistered,
  operating_system_error = cudaErrorOperatingSystem,



  peer_access_unsupported = cudaErrorPeerAccessUnsupported,
  launch_max_depth_exceeded = cudaErrorLaunchMaxDepthExceeded,
  launch_file_scoped_texture_used = cudaErrorLaunchFileScopedTex,
  launch_file_scoped_surface_used = cudaErrorLaunchFileScopedSurf,
  sync_depth_exceeded = cudaErrorSyncDepthExceeded,
  attempted_operation_not_permitted = cudaErrorNotPermitted,
  attempted_operation_not_supported = cudaErrorNotSupported,


  startup_failure = cudaErrorStartupFailure
};


}

}
# 146 "/usr/local/cuda-8.0/include/thrust/system/cuda/error.h"
inline const error_category &cuda_category(void);






template<> struct is_error_code_enum<cuda::errc::errc_t> : thrust::detail::true_type {};





inline error_code make_error_code(cuda::errc::errc_t e);





inline error_condition make_error_condition(cuda::errc::errc_t e);





}

namespace cuda
{


namespace errc = system::cuda::errc;

}

using system::cuda_category;

}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/error.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/error.inl"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/guarded_cuda_runtime_api.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/guarded_cuda_runtime_api.h"
       
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/error.inl" 2

namespace thrust
{

namespace system
{


error_code make_error_code(cuda::errc::errc_t e)
{
  return error_code(static_cast<int>(e), cuda_category());
}


error_condition make_error_condition(cuda::errc::errc_t e)
{
  return error_condition(static_cast<int>(e), cuda_category());
}


namespace cuda
{

namespace detail
{


class cuda_error_category
  : public error_category
{
  public:
    inline cuda_error_category(void) {}

    inline virtual const char *name(void) const
    {
      return "cuda";
    }

    inline virtual std::string message(int ev) const
    {
      static const std::string unknown_err("Unknown error");
      const char *c_str = ::cudaGetErrorString(static_cast<cudaError_t>(ev));
      return c_str ? std::string(c_str) : unknown_err;
    }

    inline virtual error_condition default_error_condition(int ev) const
    {
      using namespace cuda::errc;

      if(ev < ::cudaErrorApiFailureBase)
      {
        return make_error_condition(static_cast<errc_t>(ev));
      }

      return system_category().default_error_condition(ev);
    }
};

}

}


const error_category &cuda_category(void)
{
  static const cuda::detail::cuda_error_category result;
  return result;
}


}

}
# 186 "/usr/local/cuda-8.0/include/thrust/system/cuda/error.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp" 2
# 1 "/usr/include/c++/4.8.2/cstdio" 1 3
# 39 "/usr/include/c++/4.8.2/cstdio" 3
       
# 40 "/usr/include/c++/4.8.2/cstdio" 3
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


inline __attribute__((host)) __attribute__((device))
void throw_on_error(cudaError_t e, const char *message)
{
  if(e)
  {

    throw thrust::system_error(e, thrust::cuda_category(), message);
# 48 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp"
  }
}


}
}
} } } }
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/future.hpp" 2






namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


struct future_core_access;


}


template<typename T> class future;


template<>
class future<void>
{
  public:
    __attribute__((host)) __attribute__((device))
    ~future()
    {
      if(valid())
      {


        cudaError_t e = cudaEventDestroy(m_event);


        if(e)
        {
          printf("CUDA error after cudaEventDestroy in future dtor: %s", cudaGetErrorString(e));
        }


        if(m_owns_stream)
        {
          e = cudaStreamDestroy(m_stream);


          if(e)
          {
            printf("CUDA error after cudaStreamDestroy in future dtor: %s", cudaGetErrorString(e));
          }

        }

      }
    }

    __attribute__((host)) __attribute__((device))
    void wait() const
    {






      bulk_::detail::throw_on_error(cudaEventSynchronize(m_event), "cudaEventSynchronize in future::wait");
# 98 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/future.hpp"
    }

    __attribute__((host)) __attribute__((device))
    bool valid() const
    {
      return m_event != 0;
    }

    __attribute__((host)) __attribute__((device))
    future()
      : m_stream(0), m_event(0), m_owns_stream(false)
    {}



    __attribute__((host)) __attribute__((device))
    future(const future &other)
      : m_stream(0), m_event(0), m_owns_stream(false)
    {
      thrust::swap(m_stream, const_cast<future&>(other).m_stream);
      thrust::swap(m_event, const_cast<future&>(other).m_event);
      thrust::swap(m_owns_stream, const_cast<future&>(other).m_owns_stream);
    }



    __attribute__((host)) __attribute__((device))
    future &operator=(const future &other)
    {
      thrust::swap(m_stream, const_cast<future&>(other).m_stream);
      thrust::swap(m_event, const_cast<future&>(other).m_event);
      thrust::swap(m_owns_stream, const_cast<future&>(other).m_owns_stream);
      return *this;
    }

  private:
    friend struct detail::future_core_access;

    __attribute__((host)) __attribute__((device))
    future(cudaStream_t s, bool owns_stream)
      : m_stream(s),m_owns_stream(owns_stream)
    {

      bulk_::detail::throw_on_error(cudaEventCreateWithFlags(&m_event, create_flags), "cudaEventCreateWithFlags in future ctor");
      bulk_::detail::throw_on_error(cudaEventRecord(m_event, m_stream), "cudaEventRecord in future ctor");

    }



    static const int create_flags = 0x02;

    cudaStream_t m_stream;
    cudaEvent_t m_event;
    bool m_owns_stream;
};


namespace detail
{


struct future_core_access
{
  __attribute__((host)) __attribute__((device))
  inline static future<void> create(cudaStream_t s, bool owns_stream)
  {
    return future<void>(s, owns_stream);
  }

  __attribute__((host)) __attribute__((device))
  inline static cudaEvent_t event(const future<void> &f)
  {
    return f.m_event;
  }
};


}


}
} } } }
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/execution_policy.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.hpp"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launch_config.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launch_config.hpp"
       




# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launch_config.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/detail/minmax.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/minmax.h"
       



namespace thrust
{


template<typename T, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  T min (const T &lhs, const T &rhs, BinaryPredicate comp)
{
  return comp(rhs, lhs) ? rhs : lhs;
}

template<typename T>
__attribute__((host)) __attribute__((device))
  T min (const T &lhs, const T &rhs)
{
  return rhs < lhs ? rhs : lhs;
}

template<typename T, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  T max (const T &lhs, const T &rhs, BinaryPredicate comp)
{
  return comp(lhs,rhs) ? rhs : lhs;
}

template<typename T>
__attribute__((host)) __attribute__((device))
  T max (const T &lhs, const T &rhs)
{
  return lhs < rhs ? rhs : lhs;
}


}
# 25 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launch_config.hpp" 2

namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{




struct device_properties_t
{


  int major;
  int maxGridSize[3];
  int maxThreadsPerBlock;
  int maxThreadsPerMultiProcessor;
  int minor;
  int multiProcessorCount;
  int regsPerBlock;
  size_t sharedMemPerBlock;
  int warpSize;
};




struct function_attributes_t
{


  size_t constSizeBytes;
  size_t localSizeBytes;
  int maxThreadsPerBlock;
  int numRegs;
  int ptxVersion;
  size_t sharedSizeBytes;
};
# 74 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launch_config.hpp"
inline __attribute__((host)) __attribute__((device))
std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes,
                                                        const device_properties_t &properties);
# 89 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launch_config.hpp"
template<typename UnaryFunction>
inline __attribute__((host)) __attribute__((device))
std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes,
                                                        const device_properties_t &properties,
                                                        UnaryFunction block_size_to_dynamic_smem_size);
# 103 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launch_config.hpp"
inline __attribute__((host)) __attribute__((device))
size_t proportional_smem_allocation(const device_properties_t &properties,
                                    const function_attributes_t &attributes,
                                    size_t blocks_per_processor);


template<typename UnaryFunction>
inline __attribute__((host)) __attribute__((device))
size_t max_blocksize_subject_to_smem_usage(const device_properties_t &properties,
                                           const function_attributes_t &attributes,
                                           UnaryFunction blocksize_to_dynamic_smem_usage);



namespace cuda_launch_config_detail
{

using std::size_t;

namespace util
{


template<typename T>
inline __attribute__((host)) __attribute__((device))
T min_(const T &lhs, const T &rhs)
{
  return rhs < lhs ? rhs : lhs;
}


template <typename T>
struct zero_function
{
  inline __attribute__((host)) __attribute__((device))
  T operator()(T)
  {
    return 0;
  }
};



template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L divide_ri(const L x, const R y)
{
    return (x + (y - 1)) / y;
}


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L divide_rz(const L x, const R y)
{
    return x / y;
}


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L round_i(const L x, const R y){ return y * divide_ri(x, y); }


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L round_z(const L x, const R y){ return y * divide_rz(x, y); }

}




inline __attribute__((host)) __attribute__((device))
size_t smem_allocation_unit(const device_properties_t &properties)
{
  switch(properties.major)
  {
    case 1: return 512;
    case 2: return 128;
    case 3: return 256;
    default: return 256;
  }
}



inline __attribute__((host)) __attribute__((device))
int reg_allocation_unit(const device_properties_t &properties, const size_t regsPerThread)
{
  switch(properties.major)
  {
    case 1: return (properties.minor <= 1) ? 256 : 512;
    case 2: switch(regsPerThread)
             {
               case 21:
               case 22:
               case 29:
               case 30:
               case 37:
               case 38:
               case 45:
               case 46:
                 return 128;
               default:
                 return 64;
             }
    case 3: return 256;
    default: return 256;
  }
}



inline __attribute__((host)) __attribute__((device))
size_t warp_allocation_multiple(const device_properties_t &properties)
{
  return (properties.major <= 1) ? 2 : 1;
}


inline __attribute__((host)) __attribute__((device))
size_t num_sides_per_multiprocessor(const device_properties_t &properties)
{
  switch(properties.major)
  {
    case 1: return 1;
    case 2: return 2;
    case 3: return 4;
    default: return 4;
  }
}


inline __attribute__((host)) __attribute__((device))
size_t max_blocks_per_multiprocessor(const device_properties_t &properties)
{
  return (properties.major <= 2) ? 8 : 16;
}


inline __attribute__((host)) __attribute__((device))
size_t max_active_blocks_per_multiprocessor(const device_properties_t &properties,
                                            const function_attributes_t &attributes,
                                            size_t CTA_SIZE,
                                            size_t dynamic_smem_bytes)
{






  const size_t maxThreadsPerSM = properties.maxThreadsPerMultiProcessor;
  const size_t maxBlocksPerSM = max_blocks_per_multiprocessor(properties);


  const size_t ctaLimitThreads = (CTA_SIZE <= size_t(properties.maxThreadsPerBlock)) ? maxThreadsPerSM / CTA_SIZE : 0;
  const size_t ctaLimitBlocks = maxBlocksPerSM;




  const size_t smemAllocationUnit = smem_allocation_unit(properties);
  const size_t smemBytes = attributes.sharedSizeBytes + dynamic_smem_bytes;
  const size_t smemPerCTA = util::round_i(smemBytes, smemAllocationUnit);


  const size_t ctaLimitSMem = smemPerCTA > 0 ? properties.sharedMemPerBlock / smemPerCTA : maxBlocksPerSM;




  const int regAllocationUnit = reg_allocation_unit(properties, attributes.numRegs);
  const size_t warpAllocationMultiple = warp_allocation_multiple(properties);
  const size_t numWarps = util::round_i(util::divide_ri(CTA_SIZE, properties.warpSize), warpAllocationMultiple);


  size_t ctaLimitRegs;
  if(properties.major <= 1)
  {


    const size_t regsPerCTA = util::round_i(attributes.numRegs * properties.warpSize * numWarps, regAllocationUnit);
    ctaLimitRegs = regsPerCTA > 0 ? properties.regsPerBlock / regsPerCTA : maxBlocksPerSM;
  }
  else
  {


    const size_t regsPerWarp = util::round_i(attributes.numRegs * properties.warpSize, regAllocationUnit);
    const size_t numSides = num_sides_per_multiprocessor(properties);
    const size_t numRegsPerSide = properties.regsPerBlock / numSides;
    ctaLimitRegs = regsPerWarp > 0 ? ((numRegsPerSide / regsPerWarp) * numSides) / numWarps : maxBlocksPerSM;
  }




  return util::min_(ctaLimitRegs, util::min_(ctaLimitSMem, util::min_(ctaLimitThreads, ctaLimitBlocks)));
}


}


template<typename UnaryFunction>
inline __attribute__((host)) __attribute__((device))
std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes,
                                                        const device_properties_t &properties,
                                                        UnaryFunction block_size_to_dynamic_smem_size)
{
  size_t max_occupancy = properties.maxThreadsPerMultiProcessor;
  size_t largest_blocksize = cuda_launch_config_detail::util::min_(properties.maxThreadsPerBlock, attributes.maxThreadsPerBlock);
  size_t granularity = properties.warpSize;
  size_t max_blocksize = 0;
  size_t highest_occupancy = 0;

  for(size_t blocksize = largest_blocksize; blocksize != 0; blocksize -= granularity)
  {
    size_t occupancy = blocksize * cuda_launch_config_detail::max_active_blocks_per_multiprocessor(properties, attributes, blocksize, block_size_to_dynamic_smem_size(blocksize));

    if(occupancy > highest_occupancy)
    {
      max_blocksize = blocksize;
      highest_occupancy = occupancy;
    }


    if(highest_occupancy == max_occupancy)
      break;
  }

  return max_blocksize;
}


inline __attribute__((host)) __attribute__((device))
std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes,
                                                        const device_properties_t &properties)
{
  return block_size_with_maximum_potential_occupancy(attributes, properties, cuda_launch_config_detail::util::zero_function<std::size_t>());
}


inline __attribute__((host)) __attribute__((device))
size_t proportional_smem_allocation(const device_properties_t &properties,
                                    const function_attributes_t &attributes,
                                    size_t blocks_per_processor)
{
  size_t smem_per_processor = properties.sharedMemPerBlock;
  size_t smem_allocation_unit = cuda_launch_config_detail::smem_allocation_unit(properties);

  size_t total_smem_per_block = cuda_launch_config_detail::util::round_z(smem_per_processor / blocks_per_processor, smem_allocation_unit);
  size_t static_smem_per_block = attributes.sharedSizeBytes;

  return total_smem_per_block - static_smem_per_block;
}


template<typename UnaryFunction>
inline __attribute__((host)) __attribute__((device))
size_t max_blocksize_subject_to_smem_usage(const device_properties_t &properties,
                                           const function_attributes_t &attributes,
                                           UnaryFunction blocksize_to_dynamic_smem_usage)
{
  size_t largest_blocksize = (thrust::min)(properties.maxThreadsPerBlock, attributes.maxThreadsPerBlock);
  size_t granularity = properties.warpSize;

  for(int blocksize = largest_blocksize; blocksize > 0; blocksize -= granularity)
  {
    size_t total_smem_usage = blocksize_to_dynamic_smem_usage(blocksize) + attributes.sharedSizeBytes;

    if(total_smem_usage <= properties.sharedMemPerBlock)
    {
      return blocksize;
    }
  }

  return 0;
}


}
}
} } } }
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.hpp" 2


# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.hpp" 2






namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{




__attribute__((host)) __attribute__((device))
inline int current_device();




__attribute__((host)) __attribute__((device))
inline device_properties_t device_properties(int device_id);




__attribute__((host)) __attribute__((device))
inline device_properties_t device_properties();




template <typename KernelFunction>
__attribute__((host)) __attribute__((device))
inline function_attributes_t function_attributes(KernelFunction kernel);





__attribute__((host)) __attribute__((device))
inline size_t compute_capability(const device_properties_t &properties);

__attribute__((host)) __attribute__((device))
inline size_t compute_capability();


}
}
} } } }




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/detail/util/blocking.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/detail/util/blocking.h"
       



namespace thrust
{

namespace detail
{

namespace util
{


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L divide_ri(const L x, const R y)
{
    return (x + (y - 1)) / y;
}


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L divide_rz(const L x, const R y)
{
    return x / y;
}


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L round_i(const L x, const R y){ return y * divide_ri(x, y); }


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L round_z(const L x, const R y){ return y * divide_rz(x, y); }

}

}

}
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.inl" 2





namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


__attribute__((host)) __attribute__((device))
inline device_properties_t device_properties_uncached(int device_id)
{
  device_properties_t prop = {0,{0,0,0},0,0,0,0,0,0,0};

  cudaError_t error = cudaErrorNoDevice;


  error = cudaDeviceGetAttribute(&prop.major, cudaDevAttrComputeCapabilityMajor, device_id);
  error = cudaDeviceGetAttribute(&prop.maxGridSize[0], cudaDevAttrMaxGridDimX, device_id);
  error = cudaDeviceGetAttribute(&prop.maxGridSize[1], cudaDevAttrMaxGridDimY, device_id);
  error = cudaDeviceGetAttribute(&prop.maxGridSize[2], cudaDevAttrMaxGridDimZ, device_id);
  error = cudaDeviceGetAttribute(&prop.maxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device_id);
  error = cudaDeviceGetAttribute(&prop.maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device_id);
  error = cudaDeviceGetAttribute(&prop.minor, cudaDevAttrComputeCapabilityMinor, device_id);
  error = cudaDeviceGetAttribute(&prop.multiProcessorCount, cudaDevAttrMultiProcessorCount, device_id);
  error = cudaDeviceGetAttribute(&prop.regsPerBlock, cudaDevAttrMaxRegistersPerBlock, device_id);
  int temp;
  error = cudaDeviceGetAttribute(&temp, cudaDevAttrMaxSharedMemoryPerBlock, device_id);
  prop.sharedMemPerBlock = temp;
  error = cudaDeviceGetAttribute(&prop.warpSize, cudaDevAttrWarpSize, device_id);




  throw_on_error(error, "cudaDeviceGetProperty in get_device_properties");

  return prop;
}


inline device_properties_t device_properties_cached(int device_id)
{


  static const int max_num_devices = 16;

  static bool properties_exist[max_num_devices] = {0};
  static device_properties_t device_properties[max_num_devices] = {};

  if(device_id >= max_num_devices)
  {
    return device_properties_uncached(device_id);
  }

  if(!properties_exist[device_id])
  {
    device_properties[device_id] = device_properties_uncached(device_id);



    __sync_synchronize();

    properties_exist[device_id] = true;
  }

  return device_properties[device_id];
}


__attribute__((host)) __attribute__((device))
inline device_properties_t device_properties(int device_id)
{

  return device_properties_cached(device_id);



}


__attribute__((host)) __attribute__((device))
inline int current_device()
{
  int result = -1;


  bulk_::detail::throw_on_error(cudaGetDevice(&result), "current_device(): after cudaGetDevice");


  if(result < 0)
  {
    bulk_::detail::throw_on_error(cudaErrorNoDevice, "current_device(): after cudaGetDevice");
  }

  return result;
}


__attribute__((host)) __attribute__((device))
inline device_properties_t device_properties()
{
  return device_properties(current_device());
}


template <typename KernelFunction>
__attribute__((host)) __attribute__((device))
inline function_attributes_t function_attributes(KernelFunction kernel)
{

  typedef void (*fun_ptr_type)();

  fun_ptr_type fun_ptr = reinterpret_cast<fun_ptr_type>(kernel);

  cudaFuncAttributes attributes;

  bulk_::detail::throw_on_error(cudaFuncGetAttributes(&attributes, fun_ptr), "function_attributes(): after cudaFuncGetAttributes");


  function_attributes_t result = {
    attributes.constSizeBytes,
    attributes.localSizeBytes,
    attributes.maxThreadsPerBlock,
    attributes.numRegs,
    attributes.ptxVersion,
    attributes.sharedSizeBytes
  };

  return result;



}

__attribute__((host)) __attribute__((device))
inline size_t compute_capability(const device_properties_t &properties)
{
  return 10 * properties.major + properties.minor;
}


__attribute__((host)) __attribute__((device))
inline size_t compute_capability()
{
  return compute_capability(device_properties());
}


}
}
} } } }
# 82 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.hpp" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/execution_policy.hpp" 2
# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/execution_policy.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
# 57 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/execution_policy.hpp"
static const int invalid_index = 2147483647;




template<std::size_t grainsize_ = 1>
class agent
{
  public:
    typedef int size_type;

    static const size_type static_grainsize = grainsize_;

    __attribute__((host)) __attribute__((device))
    agent(size_type i = invalid_index)
      : m_index(i)
    {}

    __attribute__((host)) __attribute__((device))
    size_type index() const
    {
      return m_index;
    }

    __attribute__((host)) __attribute__((device))
    size_type grainsize() const
    {
      return static_grainsize;
    }

  private:
    const size_type m_index;
};


static const int use_default = 2147483647;

static const int dynamic_group_size = 0;


namespace detail
{
namespace group_detail
{


template<typename ExecutionAgent, std::size_t size_>
class group_base
{
  public:
    typedef ExecutionAgent agent_type;

    typedef int size_type;

    static const size_type static_size = size_;

    __attribute__((host)) __attribute__((device))
    group_base(agent_type exec = agent_type(), size_type i = invalid_index)
      : this_exec(exec),
        m_index(i)
    {}

    __attribute__((host)) __attribute__((device))
    size_type index() const
    {
      return m_index;
    }

    __attribute__((host)) __attribute__((device))
    size_type size() const
    {
      return static_size;
    }

    __attribute__((device))
    size_type global_index() const
    {
      return index() * size() + this_exec.index();
    }

    agent_type this_exec;

  private:
    const size_type m_index;
};


template<typename ExecutionAgent>
class group_base<ExecutionAgent,dynamic_group_size>
{
  public:
    typedef ExecutionAgent agent_type;

    typedef int size_type;

    __attribute__((host)) __attribute__((device))
    group_base(size_type sz, agent_type exec = agent_type(), size_type i = invalid_index)
      : this_exec(exec),
        m_size(sz),
        m_index(i)
    {}

    __attribute__((host)) __attribute__((device))
    size_type index() const
    {
      return m_index;
    }

    __attribute__((host)) __attribute__((device))
    size_type size() const
    {
      return m_size;
    }

    __attribute__((host)) __attribute__((device))
    size_type global_index() const
    {
      return index() * size() + this_exec.index();
    }

    agent_type this_exec;

  private:
    const size_type m_size;
    const size_type m_index;
};


}
}



template<typename ExecutionAgent = agent<>,
         std::size_t size_ = dynamic_group_size>
class parallel_group
  : public detail::group_detail::group_base<ExecutionAgent,size_>
{
  private:
    typedef detail::group_detail::group_base<
      ExecutionAgent,
      size_
    > super_t;

  public:
    typedef typename super_t::agent_type agent_type;

    typedef typename super_t::size_type size_type;


    __attribute__((host)) __attribute__((device))
    parallel_group(agent_type exec = agent_type(), size_type i = invalid_index)
      : super_t(exec,i)
    {}
};


template<typename ExecutionAgent>
class parallel_group<ExecutionAgent,dynamic_group_size>
  : public detail::group_detail::group_base<ExecutionAgent,dynamic_group_size>
{
  private:
    typedef detail::group_detail::group_base<
      ExecutionAgent,
      dynamic_group_size
    > super_t;

  public:
    typedef typename super_t::agent_type agent_type;

    typedef typename super_t::size_type size_type;


    __attribute__((host)) __attribute__((device))
    parallel_group(size_type size, agent_type exec = agent_type(), size_type i = invalid_index)
      : super_t(size,exec,i)
    {}
};



inline __attribute__((host)) __attribute__((device))
parallel_group<> par(size_t size)
{
  typedef parallel_group<>::size_type size_type;
  return parallel_group<>(static_cast<size_type>(size));
}



template<typename ExecutionAgent>
__attribute__((host)) __attribute__((device))
parallel_group<ExecutionAgent> par(ExecutionAgent exec, size_t size)
{
  typedef typename parallel_group<ExecutionAgent>::size_type size_type;
  return parallel_group<ExecutionAgent>(static_cast<size_type>(size), exec);
}


template<typename ExecutionAgent>
class async_launch
{
  public:
    __attribute__((host)) __attribute__((device))
    async_launch(ExecutionAgent exec, cudaStream_t s, cudaEvent_t be = 0)
      : stream_valid(true),e(exec),s(s),be(be)
    {}

    __attribute__((host))
    async_launch(ExecutionAgent exec, cudaEvent_t be)
      : stream_valid(false),e(exec),s(0),be(be)
    {}

    __attribute__((host)) __attribute__((device))
    ExecutionAgent exec() const
    {
      return e;
    }

    __attribute__((host)) __attribute__((device))
    cudaStream_t stream() const
    {
      return s;
    }

    __attribute__((host)) __attribute__((device))
    cudaEvent_t before_event() const
    {
      return be;
    }

    __attribute__((host)) __attribute__((device))
    bool is_stream_valid() const
    {
      return stream_valid;
    }

  private:
    bool stream_valid;
    ExecutionAgent e;
    cudaStream_t s;
    cudaEvent_t be;
};


inline __attribute__((host)) __attribute__((device))
async_launch<bulk_::parallel_group<> > par(cudaStream_t s, size_t num_threads)
{
  typedef bulk_::parallel_group<>::size_type size_type;
  return async_launch<bulk_::parallel_group<> >(bulk_::parallel_group<>(static_cast<size_type>(num_threads)), s);
}


template<typename ExecutionAgent>
inline __attribute__((host)) __attribute__((device))
async_launch<bulk_::parallel_group<ExecutionAgent> > par(cudaStream_t s, ExecutionAgent exec, size_t num_groups)
{
  return async_launch<bulk_::parallel_group<ExecutionAgent> >(bulk_::par(exec, num_groups), s);
}


inline async_launch<bulk_::parallel_group<> > par(bulk_::future<void> &before, size_t num_threads)
{
  cudaEvent_t before_event = bulk_::detail::future_core_access::event(before);

  typedef bulk_::parallel_group<>::size_type size_type;
  return async_launch<bulk_::parallel_group<> >(bulk_::parallel_group<>(static_cast<size_type>(num_threads)), before_event);
}



template<typename ExecutionAgent = agent<>,
         std::size_t size_ = dynamic_group_size>
class concurrent_group
  : public parallel_group<ExecutionAgent,size_>
{
  private:
    typedef parallel_group<
      ExecutionAgent,
      size_
    > super_t;

  public:
    typedef typename super_t::agent_type agent_type;
    typedef typename super_t::size_type size_type;


    __attribute__((host)) __attribute__((device))
    concurrent_group(size_type heap_size = use_default,
                     agent_type exec = agent_type(),
                     size_type i = invalid_index)
      : super_t(exec,i),
        m_heap_size(heap_size)
    {}

    __attribute__((device))
    void wait() const
    {




    }

    __attribute__((host)) __attribute__((device))
    size_type heap_size() const
    {
      return m_heap_size;
    }


    __attribute__((host)) __attribute__((device))
    inline static size_type hardware_concurrency()
    {

      return static_cast<size_type>(bulk_::detail::device_properties().multiProcessorCount);



    }

  private:
    size_type m_heap_size;
};


template<typename ExecutionAgent>
class concurrent_group<ExecutionAgent,dynamic_group_size>
  : public parallel_group<ExecutionAgent,dynamic_group_size>
{
  private:
    typedef parallel_group<
      ExecutionAgent,
      dynamic_group_size
    > super_t;

  public:
    typedef typename super_t::agent_type agent_type;

    typedef typename super_t::size_type size_type;


    __attribute__((host)) __attribute__((device))
    concurrent_group(size_type size,
                     size_type heap_size = use_default,
                     agent_type exec = agent_type(),
                     size_type i = invalid_index)
      : super_t(size,exec,i),
        m_heap_size(heap_size)
    {}

    __attribute__((device))
    void wait()
    {




    }

    __attribute__((host)) __attribute__((device))
    size_type heap_size() const
    {
      return m_heap_size;
    }


    __attribute__((host)) __attribute__((device))
    inline static size_type hardware_concurrency()
    {

      return static_cast<size_type>(bulk_::detail::device_properties().multiProcessorCount);



    }

  private:
    size_type m_heap_size;
};



inline __attribute__((host)) __attribute__((device))
concurrent_group<> con(size_t size, size_t heap_size = use_default)
{
  typedef concurrent_group<>::size_type size_type;
  return concurrent_group<>(static_cast<size_type>(size),static_cast<size_type>(heap_size));
}



template<typename ExecutionAgent>
__attribute__((host)) __attribute__((device))
concurrent_group<ExecutionAgent> con(ExecutionAgent exec, size_t size, size_t heap_size = use_default)
{
  typedef typename concurrent_group<ExecutionAgent>::size_type size_type;
  return concurrent_group<ExecutionAgent>(static_cast<size_type>(size),static_cast<size_type>(heap_size),exec);
}



template<std::size_t groupsize, std::size_t grainsize>
__attribute__((host)) __attribute__((device))
concurrent_group<bulk_::agent<grainsize>,groupsize>
con(size_t heap_size)
{
  typedef typename concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;
  return concurrent_group<bulk_::agent<grainsize>,groupsize>(static_cast<size_type>(heap_size));
}



template<std::size_t bound_, typename ExecutionAgent>
class bounded
  : public ExecutionAgent
{
  public:
    typedef typename ExecutionAgent::size_type size_type;

    static const size_type static_bound = bound_;

    __attribute__((host)) __attribute__((device))
    size_type bound() const
    {
      return static_bound;
    }


    __attribute__((host)) __attribute__((device))
    ExecutionAgent &unbound()
    {
      return *this;
    }


    __attribute__((host)) __attribute__((device))
    const ExecutionAgent &unbound() const
    {
      return *this;
    }


  private:

    bounded();

    bounded(const bounded &);
};


template<std::size_t bound_, typename ExecutionAgent>
__attribute__((host)) __attribute__((device))
bounded<bound_, ExecutionAgent> &bound(ExecutionAgent &exec)
{
  return static_cast<bounded<bound_, ExecutionAgent>&>(exec);
}


template<std::size_t bound_, typename ExecutionAgent>
__attribute__((host)) __attribute__((device))
const bounded<bound_, ExecutionAgent> &bound(const ExecutionAgent &exec)
{
  return static_cast<const bounded<bound_, ExecutionAgent>&>(exec);
}


namespace detail
{


template<unsigned int depth, typename ExecutionAgent>
struct agent_at_depth
{
  typedef typename agent_at_depth<
    depth-1,ExecutionAgent
  >::type parent_agent_type;

  typedef typename parent_agent_type::agent_type type;
};


template<typename ExecutionAgent>
struct agent_at_depth<0,ExecutionAgent>
{
  typedef ExecutionAgent type;
};


template<typename Cursor, typename ExecutionGroup>
struct cursor_result
{
  typedef typename agent_at_depth<Cursor::depth,ExecutionGroup>::type & type;
};


template<unsigned int d> struct cursor;


template<unsigned int d>
struct cursor
{
  static const unsigned int depth = d;

  __attribute__((host)) __attribute__((device)) cursor() {}

  cursor<depth+1> this_exec;

  template<typename ExecutionGroup>
  static __attribute__((host)) __attribute__((device))
  typename cursor_result<cursor,ExecutionGroup>::type
  get(ExecutionGroup &root)
  {
    return cursor<depth-1>::get(root.this_exec);
  }
};


template<> struct cursor<3>
{
  static const unsigned int depth = 3;

  __attribute__((host)) __attribute__((device)) cursor() {}

  template<typename ExecutionGroup>
  static __attribute__((host)) __attribute__((device))
  typename cursor_result<cursor,ExecutionGroup>::type
  get(ExecutionGroup &root)
  {
    return cursor<depth-1>::get(root.this_exec);
  }
};


template<> struct cursor<0>
{
  static const unsigned int depth = 0;

  __attribute__((host)) __attribute__((device)) cursor() {}

  cursor<1> this_exec;


  template<typename ExecutionAgent>
  static __attribute__((host)) __attribute__((device))
  ExecutionAgent &get(ExecutionAgent &root)
  {
    return root;
  }
};


template<typename T> struct is_cursor : thrust::detail::false_type {};


template<unsigned int d>
struct is_cursor<cursor<d> >
  : thrust::detail::true_type
{};


}





static const detail::cursor<0> root;




inline __attribute__((host)) __attribute__((device))
parallel_group<concurrent_group<> > grid(size_t num_groups = use_default, size_t group_size = use_default, size_t heap_size = use_default)
{
  return par(con(group_size,heap_size), num_groups);
}




inline __attribute__((host)) __attribute__((device))
async_launch<
  parallel_group<concurrent_group<> >
>
  grid(size_t num_groups, size_t group_size, size_t heap_size, cudaStream_t stream)
{
  return par(stream, con(group_size,heap_size), num_groups);
}


template<std::size_t groupsize, std::size_t grainsize>
__attribute__((host)) __attribute__((device))
parallel_group<
  concurrent_group<
    bulk_::agent<grainsize>,
    groupsize
  >
>
  grid(size_t num_groups, size_t heap_size = use_default)
{
  return par(con<groupsize,grainsize>(heap_size), num_groups);
}


template<std::size_t groupsize, std::size_t grainsize>
__attribute__((host)) __attribute__((device))
async_launch<
  parallel_group<
    concurrent_group<
      bulk_::agent<grainsize>,
      groupsize
    >
  >
>
  grid(size_t num_groups, size_t heap_size, cudaStream_t stream)
{
  return par(stream, con<groupsize,grainsize>(heap_size), num_groups);
}


}
} } } }
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/bulk.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/choose_sizes.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/choose_sizes.hpp"
       






namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<typename Function>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f);


template<typename Function, typename Arg1>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1);


template<typename Function, typename Arg1, typename Arg2>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2);


template<typename Function, typename Arg1, typename Arg2, typename Arg3>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3);


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4);


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5);


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6);


}
} } } }

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/choose_sizes.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/choose_sizes.inl"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/closure.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/closure.hpp"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/apply_from_tuple.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/apply_from_tuple.hpp"
       




namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


template<typename Function>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<> &)
{
  f();
}


template<typename Function, typename Arg1>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1> &args)
{
  f(thrust::get<0>(args));
}


template<typename Function, typename Arg1, typename Arg2>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1,Arg2> &args)
{
  f(thrust::get<0>(args),
    thrust::get<1>(args));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1,Arg2,Arg3> &args)
{
  f(thrust::get<0>(args),
    thrust::get<1>(args),
    thrust::get<2>(args));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1,Arg2,Arg3,Arg4> &args)
{
  f(thrust::get<0>(args),
    thrust::get<1>(args),
    thrust::get<2>(args),
    thrust::get<3>(args));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5> &args)
{
  f(thrust::get<0>(args),
    thrust::get<1>(args),
    thrust::get<2>(args),
    thrust::get<3>(args),
    thrust::get<4>(args));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6> &args)
{
  f(thrust::get<0>(args),
    thrust::get<1>(args),
    thrust::get<2>(args),
    thrust::get<3>(args),
    thrust::get<4>(args),
    thrust::get<5>(args));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7> &args)
{
  f(thrust::get<0>(args),
    thrust::get<1>(args),
    thrust::get<2>(args),
    thrust::get<3>(args),
    thrust::get<4>(args),
    thrust::get<5>(args),
    thrust::get<6>(args));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8> &args)
{
  f(thrust::get<0>(args),
    thrust::get<1>(args),
    thrust::get<2>(args),
    thrust::get<3>(args),
    thrust::get<4>(args),
    thrust::get<5>(args),
    thrust::get<6>(args),
    thrust::get<7>(args));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8,Arg9> &args)
{
  f(thrust::get<0>(args),
    thrust::get<1>(args),
    thrust::get<2>(args),
    thrust::get<3>(args),
    thrust::get<4>(args),
    thrust::get<5>(args),
    thrust::get<6>(args),
    thrust::get<7>(args),
    thrust::get<8>(args));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10>
__attribute__((host)) __attribute__((device))
void apply_from_tuple(Function f, const thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8,Arg9,Arg10> &args)
{
  f(thrust::get<0>(args),
    thrust::get<1>(args),
    thrust::get<2>(args),
    thrust::get<3>(args),
    thrust::get<4>(args),
    thrust::get<5>(args),
    thrust::get<6>(args),
    thrust::get<7>(args),
    thrust::get<8>(args),
    thrust::get<9>(args));
}


}
}
} } } }
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/closure.hpp" 2




namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


template<typename Function, typename Tuple>
class closure
{
  public:
    typedef Function function_type;

    typedef Tuple arguments_type;

    __attribute__((host)) __attribute__((device))
    closure(function_type f, const arguments_type &args)
      :f(f),
       args(args)
    {}


    __attribute__((host)) __attribute__((device))
    void operator()()
    {
      apply_from_tuple(f,args);
    }


    __attribute__((host)) __attribute__((device))
    function_type function() const
    {
      return f;
    }


    __attribute__((host)) __attribute__((device))
    arguments_type arguments() const
    {
      return args;
    }


  private:
    function_type f;
    arguments_type args;
};


template<typename Function, typename Arguments>
__attribute__((host)) __attribute__((device))
const closure<Function,Arguments> &make_closure(const closure<Function,Arguments> &c)
{
  return c;
}


template<typename Function>
__attribute__((host)) __attribute__((device))
closure<Function, thrust::tuple<> > make_closure(Function f)
{
  return closure<Function,thrust::tuple<> >(f, thrust::tuple<>());
}


template<typename Function, typename Arg1>
__attribute__((host)) __attribute__((device))
closure<Function, thrust::tuple<Arg1> > make_closure(Function f, const Arg1 &a1)
{
  return closure<Function,thrust::tuple<Arg1> >(f, thrust::make_tuple(a1));
}


template<typename Function, typename Arg1, typename Arg2>
__attribute__((host)) __attribute__((device))
closure<
  Function,
  thrust::tuple<Arg1,Arg2>
>
  make_closure(Function f, const Arg1 &a1, const Arg2 &a2)
{
  return closure<Function,thrust::tuple<Arg1,Arg2> >(f, thrust::make_tuple(a1,a2));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3>
__attribute__((host)) __attribute__((device))
closure<
  Function,
  thrust::tuple<Arg1,Arg2,Arg3>
>
  make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3)
{
  return closure<Function,thrust::tuple<Arg1,Arg2,Arg3> >(f, thrust::make_tuple(a1,a2,a3));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
__attribute__((host)) __attribute__((device))
closure<
  Function,
  thrust::tuple<Arg1,Arg2,Arg3,Arg4>
>
  make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4)
{
  return closure<Function,thrust::tuple<Arg1,Arg2,Arg3,Arg4> >(f, thrust::make_tuple(a1,a2,a3,a4));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
__attribute__((host)) __attribute__((device))
closure<
  Function,
  thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5>
>
  make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5)
{
  return closure<Function,thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5> >(f, thrust::make_tuple(a1,a2,a3,a4,a5));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
__attribute__((host)) __attribute__((device))
closure<
  Function,
  thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6>
>
  make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6)
{
  return closure<Function,thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6> >(f, thrust::make_tuple(a1,a2,a3,a4,a5,a6));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7>
__attribute__((host)) __attribute__((device))
closure<
  Function,
  thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7>
>
  make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7)
{
  return closure<Function,thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7> >(f, thrust::make_tuple(a1,a2,a3,a4,a5,a6,a7));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8>
__attribute__((host)) __attribute__((device))
closure<
  Function,
  thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>
>
  make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8)
{
  return closure<Function,thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8> >(f, thrust::make_tuple(a1,a2,a3,a4,a5,a6,a7,a8));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9>
__attribute__((host)) __attribute__((device))
closure<
  Function,
  thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8,Arg9>
>
  make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8, const Arg9 &a9)
{
  return closure<Function,thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8,Arg9> >(f, thrust::make_tuple(a1,a2,a3,a4,a5,a6,a7,a8,a9));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10>
__attribute__((host)) __attribute__((device))
closure<
  Function,
  thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8,Arg9,Arg10>
>
  make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8, const Arg9 &a9, const Arg10 &a10)
{
  return closure<Function,thrust::tuple<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8,Arg9,Arg10> >(f, thrust::make_tuple(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10));
}


}
}
} } } }
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/choose_sizes.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launcher.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launcher.hpp"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/alignment.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/alignment.hpp"
       



namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{
namespace alignment_of_detail
{


template<typename T> class alignment_of_impl;

template<typename T, std::size_t size_diff>
  struct helper
{
  static const std::size_t value = size_diff;
};

template<typename T>
  class helper<T,0>
{
  public:
    static const std::size_t value = alignment_of_impl<T>::value;
};

template<typename T>
  class alignment_of_impl
{
  private:
    struct big { T x; char c; };

  public:
    static const std::size_t value = helper<big, sizeof(big) - sizeof(T)>::value;
};


}


template<typename T>
  struct alignment_of
    : alignment_of_detail::alignment_of_impl<T>
{};


template<std::size_t Align> struct aligned_type;
# 190 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/alignment.hpp"
template<std::size_t Align> struct aligned_type
{
  struct __attribute__((aligned(Align))) type { };
};
# 203 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/alignment.hpp"
template<std::size_t Len, std::size_t Align>
  struct aligned_storage
{
  union type
  {
    unsigned char data[Len];

    typename aligned_type<Align>::type align;
  };
};


}
}
} } } }
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launcher.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/malloc.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/malloc.hpp"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/pointer_traits.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/pointer_traits.hpp"
       



namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


inline __attribute__((device)) unsigned int __isShared(const void *ptr)
{

  (void) ptr;

  unsigned int ret;
# 46 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/pointer_traits.hpp"
  ret = 0;


  return ret;
}


inline __attribute__((device)) bool is_shared(const void *ptr)
{
  return __isShared(ptr);
}


inline __attribute__((device)) bool is_global(const void *ptr)
{

  (void) ptr;




  return false;

}


}
}
} } } }
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/malloc.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/uninitialized.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/uninitialized.hpp"
       



# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/uninitialized.hpp" 2



namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<typename T>
  class uninitialized
{
  private:
    typename bulk_::detail::aligned_storage<
      sizeof(T),
      bulk_::detail::alignment_of<T>::value
    >::type storage;

    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    const T* ptr() const
    {
      const void *result = storage.data;
      return reinterpret_cast<const T*>(result);
    }

    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    T* ptr()
    {
      void *result = storage.data;
      return reinterpret_cast<T*>(result);
    }

  public:

    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    uninitialized<T> &operator=(const T &other)
    {
      T& self = *this;
      self = other;
      return *this;
    }

    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    T& get()
    {
      return *ptr();
    }

    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    const T& get() const
    {
      return *ptr();
    }

    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    operator T& ()
    {
      return get();
    }

    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    operator const T&() const
    {
      return get();
    }

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct()
    {
      ::new(ptr()) T();
    }

    #pragma nv_exec_check_disable
    template<typename Arg>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg &a)
    {
      ::new(ptr()) T(a);
    }

    #pragma nv_exec_check_disable
    template<typename Arg1, typename Arg2>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg1 &a1, const Arg2 &a2)
    {
      ::new(ptr()) T(a1,a2);
    }

    #pragma nv_exec_check_disable
    template<typename Arg1, typename Arg2, typename Arg3>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3)
    {
      ::new(ptr()) T(a1,a2,a3);
    }

    #pragma nv_exec_check_disable
    template<typename Arg1, typename Arg2, typename Arg3, typename Arg4>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4)
    {
      ::new(ptr()) T(a1,a2,a3,a4);
    }

    #pragma nv_exec_check_disable
    template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5)
    {
      ::new(ptr()) T(a1,a2,a3,a4,a5);
    }

    #pragma nv_exec_check_disable
    template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6)
    {
      ::new(ptr()) T(a1,a2,a3,a4,a5,a6);
    }

    #pragma nv_exec_check_disable
    template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7)
    {
      ::new(ptr()) T(a1,a2,a3,a4,a5,a6,a7);
    }

    #pragma nv_exec_check_disable
    template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8)
    {
      ::new(ptr()) T(a1,a2,a3,a4,a5,a6,a7,a8);
    }

    #pragma nv_exec_check_disable
    template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8, const Arg9 &a9)
    {
      ::new(ptr()) T(a1,a2,a3,a4,a5,a6,a7,a8,a9);
    }

    #pragma nv_exec_check_disable
    template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8, const Arg9 &a9, const Arg10 &a10)
    {
      ::new(ptr()) T(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
    }

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    void destroy()
    {
      T& self = *this;
      self.~T();
    }
};


template<typename T, std::size_t N>
  class uninitialized_array
{
  public:
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::size_t size_type;

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    iterator begin()
    {
      return data();
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    const_iterator begin() const
    {
      return data();
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    iterator end()
    {
      return begin() + size();
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    const_iterator end() const
    {
      return begin() + size();
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    const_iterator cbegin() const
    {
      return begin();
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    const_iterator cend() const
    {
      return end();
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    size_type size() const
    {
      return N;
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    bool empty() const
    {
      return false;
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    T* data()
    {
      return impl.get();
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    const T* data() const
    {
      return impl.get();
    }


    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    reference operator[](size_type n)
    {
      return data()[n];
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    const_reference operator[](size_type n) const
    {
      return data()[n];
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    reference front()
    {
      return *data();
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    const_reference front() const
    {
      return *data();
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    reference back()
    {
      return data()[size() - size_type(1)];
    }

    __inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device))
    const_reference back() const
    {
      return data()[size() - size_type(1)];
    }

  private:
    uninitialized<T[N]> impl;
};


}
} } } }
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/malloc.hpp" 2

# 1 "/usr/include/c++/4.8.2/cstdlib" 1 3
# 39 "/usr/include/c++/4.8.2/cstdlib" 3
       
# 40 "/usr/include/c++/4.8.2/cstdlib" 3
# 25 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/malloc.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


inline __attribute__((device)) bool is_on_chip(void *ptr)
{
  return bulk_::detail::is_shared(ptr);
}


template<typename T>
inline __attribute__((device)) T *on_chip_cast(T *ptr)
{
  extern __attribute__((shared)) char s_begin[];
  void *result = (reinterpret_cast<char*>(ptr) - s_begin) + s_begin;
  return reinterpret_cast<T*>(result);
}


namespace detail
{


extern __attribute__((shared)) int s_data_segment_begin[];


class os
{
  public:
    __attribute__((device)) inline os(size_t max_data_segment_size)
      : m_program_break(s_data_segment_begin),
        m_max_data_segment_size(max_data_segment_size)
    {
    }


    __attribute__((device)) inline int brk(void *end_data_segment)
    {
      if(end_data_segment <= m_program_break)
      {
        m_program_break = end_data_segment;
        return 0;
      }

      return -1;
    }


    __attribute__((device)) inline void *sbrk(size_t increment)
    {
      if(data_segment_size() + increment <= m_max_data_segment_size)
      {
        m_program_break = reinterpret_cast<char*>(m_program_break) + increment;
      }
      else
      {
        return reinterpret_cast<void*>(-1);
      }

      return m_program_break;
    }


    __attribute__((device)) inline void *program_break() const
    {
      return m_program_break;
    }


    __attribute__((device)) inline void *data_segment_begin() const
    {
      return s_data_segment_begin;
    }


  private:
    __attribute__((device)) inline size_t data_segment_size()
    {
      return reinterpret_cast<char*>(m_program_break) - reinterpret_cast<char*>(s_data_segment_begin);
    }


    void *m_program_break;


    size_t m_max_data_segment_size;
};



class singleton_unsafe_on_chip_allocator
{
  public:
    __attribute__((device)) inline singleton_unsafe_on_chip_allocator(size_t max_data_segment_size)
      : m_os(max_data_segment_size)
    {}

    __attribute__((device)) inline void *allocate(size_t size)
    {
      size_t aligned_size = align8(size);

      block *prev = find_first_free_insertion_point(heap_begin(), heap_end(), aligned_size);

      block *b;

      if(prev != heap_end() && (b = prev->next()) != heap_end())
      {

        if((b->size() - aligned_size) >= sizeof(block))
        {
          split_block(b, aligned_size);
        }

        b->set_is_free(false);
      }
      else
      {

        b = extend_heap(prev, aligned_size);
        if(b == heap_end())
        {
          return 0;
        }
      }

      return b->data();
    }


    __attribute__((device)) inline void deallocate(void *ptr)
    {
      if(ptr != 0)
      {
        block *b = get_block(ptr);


        b->set_is_free(true);


        if(b->prev() && b->prev()->is_free())
        {
          b = b->prev();
          fuse_block(b);
        }


        if(b->next() != heap_end())
        {
          fuse_block(b);
        }
        else
        {

          m_os.brk(b);
        }
      }
    }


  private:

    class block : public bulk_::detail::aligned_type<sizeof(size_t) + sizeof(block*)>::type
    {
      public:
        __attribute__((device)) inline size_t size() const
        {
          return m_size;
        }

        __attribute__((device)) void set_size(size_t sz)
        {
          m_size = sz;
        }

        __attribute__((device)) inline block *prev() const
        {
          return m_prev;
        }

        __attribute__((device)) void set_prev(block *p)
        {
          m_prev = p;
        }


        __attribute__((device)) inline void *byte_at(size_t index) const
        {
          return reinterpret_cast<char*>(data()) + index;
        }

        __attribute__((device)) inline block *next() const
        {
          return reinterpret_cast<block*>(byte_at(size()));
        }

        __attribute__((device)) inline bool is_free() const
        {
          return m_is_free;
        }

        __attribute__((device)) inline void set_is_free(bool f)
        {
          m_is_free = f;
        }

        __attribute__((device)) inline void *data() const
        {
          return reinterpret_cast<char*>(const_cast<block*>(this)) + sizeof(block);
        }

      private:



        bool m_is_free : 1;
        size_t m_size : 8 * sizeof(size_t) - 1;
        block *m_prev;
    };


    os m_os;

    __attribute__((device)) inline block *heap_begin() const
    {
      return reinterpret_cast<block*>(m_os.data_segment_begin());
    }


    __attribute__((device)) inline block *heap_end() const
    {
      return reinterpret_cast<block*>(m_os.program_break());
    }


    __attribute__((device)) inline void split_block(block *b, size_t size)
    {
      block *new_block;


      new_block = reinterpret_cast<block*>(b->byte_at(size));


      new_block->set_size(b->size() - size - sizeof(block));

      new_block->set_prev(b);
      new_block->set_is_free(true);


      b->set_size(size);


      if(new_block->next() != heap_end())
      {
        new_block->next()->set_prev(new_block);
      }
    }


    __attribute__((device)) inline bool fuse_block(block *b)
    {
      if(b->next() != heap_end() && b->next()->is_free())
      {

        b->set_size(sizeof(block) + b->next()->size() + b->size());

        if(b->next() != heap_end())
        {
          b->next()->set_prev(b);
        }

        return true;
      }

      return false;
    }


    __attribute__((device)) inline static block *get_block(void *data)
    {

      void *ptr = reinterpret_cast<char*>(data) - sizeof(block);
      return reinterpret_cast<block *>(ptr);
    }


    __attribute__((device)) inline static block *find_first_free_insertion_point(block *first, block *last, size_t size)
    {
      block *prev = last;

      while(first != last && !(first->is_free() && first->size() >= size))
      {
        prev = first;
        first = first->next();
      }

      return prev;
    }


    __attribute__((device)) inline block *extend_heap(block *prev, size_t size)
    {

      block *new_block = heap_end();


      if(m_os.sbrk(sizeof(block) + size) == reinterpret_cast<void*>(-1))
      {

        return new_block;
      }

      on_chip_cast(new_block)->set_size(size);
      on_chip_cast(new_block)->set_prev(prev);
      on_chip_cast(new_block)->set_is_free(false);

      return new_block;
    }


    __attribute__((device)) inline static size_t align8(size_t size)
    {
      return ((((size - 1) >> 3) << 3) + 8);
    }
};


class singleton_on_chip_allocator
{
  public:

    inline __attribute__((device)) __attribute__((host))
    singleton_on_chip_allocator(size_t max_data_segment_size)
      : m_mutex(),
        m_alloc(max_data_segment_size)
    {}


    inline __attribute__((device))
    void *unsafe_allocate(size_t size)
    {
      return m_alloc.allocate(size);
    }


    inline __attribute__((device))
    void *allocate(size_t size)
    {
      void *result;

      m_mutex.lock();
      {
        result = unsafe_allocate(size);
      }
      m_mutex.unlock();

      return result;
    }


    inline __attribute__((device))
    void unsafe_deallocate(void *ptr)
    {
      m_alloc.deallocate(ptr);
    }


    inline __attribute__((device))
    void deallocate(void *ptr)
    {
      m_mutex.lock();
      {
        unsafe_deallocate(ptr);
      }
      m_mutex.unlock();
    }


  private:
    class mutex
    {
      public:
        inline __attribute__((device))
        mutex()
          : m_in_use(0)
        {}


        inline __attribute__((device))
        bool try_lock()
        {



          return false;

        }


        inline __attribute__((device))
        void lock()
        {

          while(try_lock())
          {
            ;
          }
        }


        inline __attribute__((device))
        void unlock()
        {
          m_in_use = 0;
        }


      private:
        unsigned int m_in_use;
    };


    mutex m_mutex;
    singleton_unsafe_on_chip_allocator m_alloc;
};



namespace
{

__attribute__((shared)) uninitialized<singleton_on_chip_allocator> s_on_chip_allocator;

}


inline __attribute__((device)) void init_on_chip_malloc(size_t max_data_segment_size)
{
  s_on_chip_allocator.construct(max_data_segment_size);
}


inline __attribute__((device)) void *on_chip_malloc(size_t size)
{
  void *result = s_on_chip_allocator.get().allocate(size);
  return on_chip_cast(result);
}


inline __attribute__((device)) void on_chip_free(void *ptr)
{
  s_on_chip_allocator.get().deallocate(ptr);
}


inline __attribute__((device)) void *unsafe_on_chip_malloc(size_t size)
{
  void *result = s_on_chip_allocator.get().unsafe_allocate(size);
  return on_chip_cast(result);
}


inline __attribute__((device)) void unsafe_on_chip_free(void *ptr)
{
  s_on_chip_allocator.get().unsafe_deallocate(ptr);
}


}


inline __attribute__((device)) void *shmalloc(size_t num_bytes)
{

  void *result = detail::on_chip_malloc(num_bytes);
# 510 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/malloc.hpp"
  return result;
}


inline __attribute__((device)) void *unsafe_shmalloc(size_t num_bytes)
{

  void *result = detail::unsafe_on_chip_malloc(num_bytes);
# 526 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/malloc.hpp"
  return result;
}


inline __attribute__((device)) void shfree(void *ptr)
{
# 542 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/malloc.hpp"
  bulk_::detail::on_chip_free(bulk_::on_chip_cast(ptr));

}


inline __attribute__((device)) void unsafe_shfree(void *ptr)
{
# 559 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/malloc.hpp"
  bulk_::detail::unsafe_on_chip_free(bulk_::on_chip_cast(ptr));

}


template<typename ConcurrentGroup>
__attribute__((device))
inline void *malloc(ConcurrentGroup &g, size_t num_bytes)
{
  __attribute__((shared)) void *s_result;



  g.wait();

  if(g.this_exec.index() == 0)
  {
    s_result = bulk_::unsafe_shmalloc(num_bytes);
  }

  g.wait();

  return s_result;
}


template<typename ConcurrentGroup>
__attribute__((device))
inline void free(ConcurrentGroup &g, void *ptr)
{
  if(g.this_exec.index() == 0)
  {
    bulk_::unsafe_shfree(ptr);
  }

  g.wait();
}


}
} } } }
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/tuple_transform.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/tuple_transform.hpp"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/tuple_meta_transform.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/tuple_meta_transform.hpp"
       




namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         unsigned int sz = thrust::tuple_size<Tuple>::value>
  struct tuple_meta_transform;

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,0>
{
  typedef thrust::tuple<> type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,1>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,2>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,3>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,4>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,5>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,6>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,7>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<6,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,8>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<6,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<7,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,9>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<6,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<7,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<8,Tuple>::type>::type
  > type;
};

template<typename Tuple,
         template<typename> class UnaryMetaFunction>
  struct tuple_meta_transform<Tuple,UnaryMetaFunction,10>
{
  typedef thrust::tuple<
    typename UnaryMetaFunction<typename thrust::tuple_element<0,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<1,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<2,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<3,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<4,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<5,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<6,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<7,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<8,Tuple>::type>::type,
    typename UnaryMetaFunction<typename thrust::tuple_element<9,Tuple>::type>::type
  > type;
};


}
}
} } } }
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/tuple_transform.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{

template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction,
         unsigned int sz = thrust::tuple_size<Tuple>::value>
  struct tuple_transform_functor;


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,0>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    return thrust::tuple<>();
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    return thrust::tuple<>();
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,1>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,2>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,3>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,4>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,5>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,6>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,7>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,8>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,9>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)),
                     f(thrust::get<8>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)),
                     f(thrust::get<8>(t)));
  }
};


template<typename Tuple,
         template<typename> class UnaryMetaFunction,
         typename UnaryFunction>
  struct tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction,10>
{
  static __attribute__((host))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)),
                     f(thrust::get<8>(t)),
                     f(thrust::get<9>(t)));
  }

  static __attribute__((host)) __attribute__((device))
  typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
  do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f)
  {
    typedef typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type XfrmTuple;

    return XfrmTuple(f(thrust::get<0>(t)),
                     f(thrust::get<1>(t)),
                     f(thrust::get<2>(t)),
                     f(thrust::get<3>(t)),
                     f(thrust::get<4>(t)),
                     f(thrust::get<5>(t)),
                     f(thrust::get<6>(t)),
                     f(thrust::get<7>(t)),
                     f(thrust::get<8>(t)),
                     f(thrust::get<9>(t)));
  }
};


template<template<typename> class UnaryMetaFunction,
         typename Tuple,
         typename UnaryFunction>
typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
tuple_host_transform(const Tuple &t, UnaryFunction f)
{
  return tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction>::do_it_on_the_host(t,f);
}

template<template<typename> class UnaryMetaFunction,
         typename Tuple,
         typename UnaryFunction>
typename tuple_meta_transform<Tuple,UnaryMetaFunction>::type
__attribute__((host)) __attribute__((device))
tuple_host_device_transform(const Tuple &t, UnaryFunction f)
{
  return tuple_transform_functor<Tuple,UnaryMetaFunction,UnaryFunction>::do_it_on_the_host_or_device(t,f);
}

}
}
} } } }
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp" 2





namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


template<typename ExecutionGroup, typename Closure>
class task_base
{
  public:
    typedef ExecutionGroup group_type;
    typedef Closure closure_type;

    __attribute__((host)) __attribute__((device))
    task_base(group_type g, closure_type c)
      : c(c), g(g)
    {}

  protected:
    __attribute__((host)) __attribute__((device))
    static void substitute_placeholders_and_execute(group_type &g, closure_type &c)
    {

      substituted_arguments_type new_args = substitute_placeholders(g, c.arguments());


      closure<typename closure_type::function_type, substituted_arguments_type> new_c(c.function(), new_args);


      new_c();
    }

    closure_type c;
    group_type g;

  private:
    template<typename T>
    struct substitutor_result
      : thrust::detail::eval_if<
          bulk_::detail::is_cursor<T>::value,
          cursor_result<T,ExecutionGroup>,
          thrust::detail::identity_<T>
        >
    {};

    typedef typename bulk_::detail::tuple_meta_transform<
      typename closure_type::arguments_type,
      substitutor_result
    >::type substituted_arguments_type;

    struct substitutor
    {
      group_type &g;

      __attribute__((device))
      substitutor(group_type &g)
        : g(g)
      {}

      template<unsigned int depth>
      __attribute__((device))
      typename bulk_::detail::cursor_result<cursor<depth>,group_type>::type
      operator()(cursor<depth> c) const
      {
        return c.get(g);
      }

      template<typename T>
      __attribute__((device))
      T &operator()(T &x) const
      {
        return x;
      }
    };

    __attribute__((host)) __attribute__((device))
    static substituted_arguments_type substitute_placeholders(group_type &g, typename closure_type::arguments_type args)
    {
      return bulk_::detail::tuple_host_device_transform<substitutor_result>(args, substitutor(g));
    }
};


template<std::size_t blocksize, std::size_t grainsize>
struct cuda_block
{
  typedef concurrent_group<agent<grainsize>, blocksize> type;
};


template<std::size_t gridsize, std::size_t blocksize, std::size_t grainsize>
struct cuda_grid
{
  typedef parallel_group<
    typename cuda_block<blocksize,grainsize>::type
  > type;
};


template<typename Group, typename Closure> class cuda_task;


template<typename Grid>
struct grid_maker
{
  __attribute__((host)) __attribute__((device))
  static Grid make(typename Grid::size_type size,
                   typename Grid::agent_type block,
                   typename Grid::size_type index)
  {
    return Grid(block, index);
  }
};


template<typename Block>
struct grid_maker<parallel_group<Block,dynamic_group_size> >
{
  __attribute__((host)) __attribute__((device))
  static parallel_group<Block,dynamic_group_size> make(typename parallel_group<Block,dynamic_group_size>::size_type size,
                                                       Block block,
                                                       typename parallel_group<Block,dynamic_group_size>::size_type index)
  {
    return parallel_group<Block,dynamic_group_size>(size, block, index);
  }
};


template<typename Block>
struct block_maker
{
  __attribute__((host)) __attribute__((device))
  static Block make(typename Block::size_type size,
                    typename Block::size_type heap_size,
                    typename Block::agent_type thread,
                    typename Block::size_type index)
  {
    return Block(heap_size, thread, index);
  }
};

template<typename Thread>
struct block_maker<concurrent_group<Thread,dynamic_group_size> >
{
  __attribute__((host)) __attribute__((device))
  static concurrent_group<Thread,dynamic_group_size> make(typename concurrent_group<Thread,dynamic_group_size>::size_type size,
                                                          typename concurrent_group<Thread,dynamic_group_size>::size_type heap_size,
                                                          Thread thread,
                                                          typename concurrent_group<Thread,dynamic_group_size>::size_type index)
  {
    return concurrent_group<Thread,dynamic_group_size>(size, heap_size, thread, index);
  }
};


template<typename Grid>
__attribute__((host)) __attribute__((device))
Grid make_grid(typename Grid::size_type size, typename Grid::agent_type block, typename Grid::size_type index = invalid_index)
{
  return grid_maker<Grid>::make(size, block, index);
}


template<typename Block>
__attribute__((host)) __attribute__((device))
Block make_block(typename Block::size_type size, typename Block::size_type heap_size, typename Block::agent_type thread = typename Block::agent_type(), typename Block::size_type index = invalid_index)
{
  return block_maker<Block>::make(size, heap_size, thread, index);
}



template<std::size_t gridsize, std::size_t blocksize, std::size_t grainsize, typename Closure>
class cuda_task<
  parallel_group<
    concurrent_group<
      agent<grainsize>,
      blocksize
    >,
    gridsize
  >,
  Closure
> : public task_base<typename cuda_grid<gridsize,blocksize,grainsize>::type,Closure>
{
  private:
    typedef task_base<typename cuda_grid<gridsize,blocksize,grainsize>::type,Closure> super_t;

  public:
    typedef typename super_t::group_type grid_type;
    typedef typename grid_type::agent_type block_type;
    typedef typename block_type::agent_type thread_type;
    typedef typename super_t::closure_type closure_type;
    typedef typename grid_type::size_type size_type;

  private:
    size_type block_offset;

  public:

    __attribute__((host)) __attribute__((device))
    cuda_task(grid_type g, closure_type c, size_type offset)
      : super_t(g,c),
        block_offset(offset)
    {}

    __attribute__((device))
    void operator()()
    {
# 263 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
    }
};



template<std::size_t blocksize, std::size_t grainsize, typename Closure>
class cuda_task<
  concurrent_group<
    agent<grainsize>,
    blocksize
  >,
  Closure
> : public task_base<typename cuda_block<blocksize,grainsize>::type,Closure>
{
  private:
    typedef task_base<typename cuda_block<blocksize,grainsize>::type,Closure> super_t;

  public:
    typedef typename super_t::group_type block_type;
    typedef typename block_type::agent_type thread_type;
    typedef typename super_t::closure_type closure_type;
    typedef typename block_type::size_type size_type;

  public:
    __attribute__((host)) __attribute__((device))
    cuda_task(block_type b, closure_type c)
      : super_t(b,c)
    {}

    __attribute__((device))
    void operator()()
    {
# 317 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
    }
};



template<std::size_t groupsize, std::size_t grainsize, typename Closure>
class cuda_task<parallel_group<agent<grainsize>,groupsize>,Closure>
  : public task_base<parallel_group<agent<grainsize>,groupsize>,Closure>
{
  private:
    typedef task_base<parallel_group<agent<grainsize>,groupsize>,Closure> super_t;

  public:
    typedef typename super_t::closure_type closure_type;
    typedef typename super_t::group_type group_type;

    __attribute__((host)) __attribute__((device))
    cuda_task(group_type g, closure_type c)
      : super_t(g,c)
    {}

    __attribute__((device))
    void operator()()
    {
# 361 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
    }
};


}
}
} } } }
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launcher.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/parameter_ptr.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/parameter_ptr.hpp"
       






# 1 "/usr/include/c++/4.8.2/cstring" 1 3
# 39 "/usr/include/c++/4.8.2/cstring" 3
       
# 40 "/usr/include/c++/4.8.2/cstring" 3
# 25 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/parameter_ptr.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{



template<typename T>
class parameter_ptr
{
  public:
    typedef T element_type;

    __attribute__((host)) __attribute__((device))
    explicit parameter_ptr(element_type *ptr)
      : m_ptr(ptr)
    {}


    __attribute__((host)) __attribute__((device))
    parameter_ptr(const parameter_ptr& other_)
    {
      parameter_ptr& other = const_cast<parameter_ptr&>(other_);
      thrust::swap(m_ptr, other.m_ptr);
    }

    __attribute__((host)) __attribute__((device))
    ~parameter_ptr()
    {

      if(m_ptr)
      {
        bulk_::detail::terminate_on_error(cudaFree(m_ptr), "in parameter_ptr dtor");
      }



    }


    __attribute__((host)) __attribute__((device))
    parameter_ptr& operator=(const parameter_ptr& other_)
    {
      parameter_ptr& other = const_cast<parameter_ptr&>(other_);
      thrust::swap(m_ptr, other.m_ptr);
      return *this;
    }

    __attribute__((host)) __attribute__((device))
    T* get() const
    {
      return m_ptr;
    }

  private:
    T *m_ptr;
};


template<typename T>
__attribute__((host)) __attribute__((device))
parameter_ptr<T> make_parameter(const T& x)
{
  T* raw_ptr = 0;



  bulk_::detail::throw_on_error(cudaMalloc(&raw_ptr, sizeof(T)), "make_parameter(): after cudaMalloc");






  bulk_::detail::throw_on_error(cudaMemcpy(raw_ptr, &x, sizeof(T), cudaMemcpyHostToDevice),
                               "make_parameter(): after cudaMemcpy");




  return parameter_ptr<T>(raw_ptr);
}


}
}
} } } }
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp" 2
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{
# 57 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp"
template<unsigned int block_size, typename Function, bool by_value = (sizeof(Function) <= 4096)> struct triple_chevron_launcher_base;


template<unsigned int block_size, typename Function>
__attribute__((global))
__attribute__((launch_bounds(block_size, 0)))
void launch_by_value(Function f)
{
  f();
}


template<unsigned int block_size, typename Function>
struct triple_chevron_launcher_base<block_size,Function,true>
{
  typedef void (*global_function_pointer_t)(Function);

  __attribute__((host)) __attribute__((device))
  static global_function_pointer_t global_function_pointer()
  {
    return launch_by_value<block_size,Function>;
  }
};


template<unsigned int block_size, typename Function>
__attribute__((global))
__attribute__((launch_bounds(block_size, 0)))
void launch_by_pointer(const Function *f)
{

  Function f_reg = *f;
  f_reg();
}


template<unsigned int block_size, typename Function>
struct triple_chevron_launcher_base<block_size,Function,false>
{
  typedef void (*global_function_pointer_t)(const Function*);

  __attribute__((host)) __attribute__((device))
  static global_function_pointer_t global_function_pointer()
  {
    return launch_by_pointer<block_size,Function>;
  }
};




template<unsigned int block_size_, typename Function, bool by_value = sizeof(Function) <= 4096>
class triple_chevron_launcher : protected triple_chevron_launcher_base<block_size_, Function>
{
  private:
    typedef triple_chevron_launcher_base<block_size_,Function> super_t;

  public:
    typedef Function task_type;

    inline __attribute__((host)) __attribute__((device))
    void launch(unsigned int num_blocks, unsigned int block_size, size_t num_dynamic_smem_bytes, cudaStream_t stream, task_type task)
    {
      struct workaround
      {
        __attribute__((host)) __attribute__((device))
        static void supported_path(unsigned int num_blocks, unsigned int block_size, size_t num_dynamic_smem_bytes, cudaStream_t stream, task_type task)
        {


          cudaConfigureCall(dim3(num_blocks), dim3(block_size), num_dynamic_smem_bytes, stream);
          cudaSetupArgument(task, 0);
          bulk_::detail::throw_on_error(cudaLaunch(super_t::global_function_pointer()), "after cudaLaunch in triple_chevron_launcher::launch()");







        }

        __attribute__((host)) __attribute__((device))
        static void unsupported_path(unsigned int, unsigned int, size_t, cudaStream_t, task_type)
        {
          bulk_::detail::terminate_with_message("triple_chevron_launcher::launch(): CUDA kernel launch requires CUDART.");
        }
      };


      workaround::supported_path(num_blocks, block_size, num_dynamic_smem_bytes, stream, task);



    }
};






template<unsigned int block_size_, typename Function>
class triple_chevron_launcher<block_size_,Function,false> : protected triple_chevron_launcher_base<block_size_,Function>
{
  private:
    typedef triple_chevron_launcher_base<block_size_,Function> super_t;

  public:
    typedef Function task_type;

    inline __attribute__((host)) __attribute__((device))
    void launch(unsigned int num_blocks, unsigned int block_size, size_t num_dynamic_smem_bytes, cudaStream_t stream, task_type task)
    {
      struct workaround
      {
        __attribute__((host)) __attribute__((device))
        static void supported_path(unsigned int num_blocks, unsigned int block_size, size_t num_dynamic_smem_bytes, cudaStream_t stream, task_type task)
        {
          bulk_::detail::parameter_ptr<task_type> parm = bulk_::detail::make_parameter<task_type>(task);



          cudaConfigureCall(dim3(num_blocks), dim3(block_size), num_dynamic_smem_bytes, stream);
          cudaSetupArgument(static_cast<const task_type*>(parm.get()), 0);
          bulk_::detail::throw_on_error(cudaLaunch(super_t::global_function_pointer()), "after cudaLaunch in triple_chevron_launcher::launch()");
# 191 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp"
        }

        __attribute__((host)) __attribute__((device))
        static void unsupported_path(unsigned int, unsigned int, size_t, cudaStream_t, task_type)
        {
          bulk_::detail::terminate_with_message("triple_chevron_launcher::launch(): CUDA kernel launch requires CUDART.");
        }
      };


      workaround::supported_path(num_blocks, block_size, num_dynamic_smem_bytes, stream, task);



    }
};


}
}
} } } }
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launcher.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/synchronize.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/synchronize.hpp"
       







namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


inline __attribute__((host)) __attribute__((device))
void synchronize(const char* message = "")
{

  bulk_::detail::throw_on_error(cudaDeviceSynchronize(), message);




}


inline __attribute__((host)) __attribute__((device))
void synchronize_if_enabled(const char* message = "")
{






  (void) message;

}


}
}
} } } }
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launcher.hpp" 2
# 40 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launcher.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{




template<unsigned int block_size_, typename ExecutionGroup, typename Closure>
struct cuda_launcher_base
  : public triple_chevron_launcher<
      block_size_,
      cuda_task<ExecutionGroup,Closure>
    >
{
  typedef triple_chevron_launcher<block_size_, cuda_task<ExecutionGroup,Closure> > super_t;
  typedef typename super_t::task_type task_type;
  typedef typename ExecutionGroup::size_type size_type;


  __attribute__((host)) __attribute__((device))
  cuda_launcher_base()
    : m_device_properties(bulk_::detail::device_properties())
  {}


  __attribute__((host)) __attribute__((device))
  void launch(size_type num_blocks, size_type block_size, size_type num_dynamic_smem_bytes, cudaStream_t stream, task_type task)
  {
    if(num_blocks > 0)
    {
      super_t::launch(num_blocks, block_size, num_dynamic_smem_bytes, stream, task);

      bulk_::detail::synchronize_if_enabled("bulk_kernel_by_value");
    }
  }


  __attribute__((host)) __attribute__((device))
  static size_type max_active_blocks_per_multiprocessor(const device_properties_t &props,
                                                        const function_attributes_t &attr,
                                                        size_type num_threads_per_block,
                                                        size_type num_smem_bytes_per_block)
  {
    return static_cast<size_type>(bulk_::detail::cuda_launch_config_detail::max_active_blocks_per_multiprocessor(props, attr, num_threads_per_block, num_smem_bytes_per_block));
  }





  __attribute__((host)) __attribute__((device))
  static thrust::pair<size_type,size_type> dynamic_smem_occupancy_limit(const device_properties_t &props, const function_attributes_t &attr, size_type num_threads_per_block, size_type num_smem_bytes_per_block)
  {

    size_type occupancy = max_active_blocks_per_multiprocessor(props, attr, num_threads_per_block, num_smem_bytes_per_block);


    if(occupancy < 1) return thrust::make_pair(0,0);

    return thrust::make_pair(static_cast<size_type>(bulk_::detail::proportional_smem_allocation(props, attr, occupancy)), occupancy);
  }


  __attribute__((host)) __attribute__((device))
  size_type choose_heap_size(const device_properties_t &props, size_type group_size, size_type requested_size)
  {
    function_attributes_t attr = bulk_::detail::function_attributes(super_t::global_function_pointer());



    if(attr.ptxVersion < 20 || requested_size == 0)
    {
      return 0;
    }


    size_type result = 0, occupancy = 0;
    thrust::tie(result,occupancy) = dynamic_smem_occupancy_limit(props, attr, group_size, 0);




    if(requested_size != use_default && requested_size > result && occupancy > 1)
    {

      requested_size += 48;


      if(requested_size > result)
      {

        size_type next_level_result = 0, next_level_occupancy = 0;
        thrust::tie(next_level_result, next_level_occupancy) = dynamic_smem_occupancy_limit(props, attr, group_size, requested_size);



        if(next_level_occupancy > 0) result = next_level_result;
      }
    }

    return result;
  }


  __attribute__((host)) __attribute__((device))
  size_type choose_group_size(size_type requested_size)
  {
    size_type result = requested_size;

    if(result == use_default)
    {
      bulk_::detail::function_attributes_t attr = bulk_::detail::function_attributes(super_t::global_function_pointer());

      return static_cast<size_type>(bulk_::detail::block_size_with_maximum_potential_occupancy(attr, device_properties()));
    }

    return result;
  }


  __attribute__((host)) __attribute__((device))
  size_type choose_subscription(size_type block_size)
  {

    return block_size > 0 ? device_properties().maxThreadsPerMultiProcessor / block_size : 0;
  }


  __attribute__((host)) __attribute__((device))
  size_type choose_num_groups(size_type requested_num_groups, size_type group_size)
  {
    size_type result = requested_num_groups;

    if(result == use_default)
    {


      size_type subscription = choose_subscription(group_size);

      result = thrust::min<size_type>(subscription * device_properties().multiProcessorCount, max_physical_grid_size());
    }

    return result;
  }


  __attribute__((host)) __attribute__((device))
  size_type max_physical_grid_size()
  {

    int actual_limit = device_properties().maxGridSize[0];


    int ptx_version = bulk_::detail::function_attributes(super_t::global_function_pointer()).ptxVersion;

    int ptx_limit = 0;


    if(ptx_version < 30)
    {
      ptx_limit = 65535;
    }
    else
    {
      ptx_limit = (1u << 31) - 1;
    }

    return thrust::min<size_type>(actual_limit, ptx_limit);
  }


  __attribute__((host)) __attribute__((device))
  const device_properties_t &device_properties() const
  {
    return m_device_properties;
  }


  device_properties_t m_device_properties;
};


template<typename ExecutionGroup, typename Closure> struct cuda_launcher;


template<std::size_t gridsize, std::size_t blocksize, std::size_t grainsize, typename Closure>
struct cuda_launcher<
  parallel_group<
    concurrent_group<
      agent<grainsize>,
      blocksize
    >,
    gridsize
  >,
  Closure
>
  : public cuda_launcher_base<blocksize, typename cuda_grid<gridsize,blocksize,grainsize>::type,Closure>
{
  typedef cuda_launcher_base<blocksize, typename cuda_grid<gridsize,blocksize,grainsize>::type,Closure> super_t;
  typedef typename super_t::size_type size_type;

  typedef typename cuda_grid<gridsize,blocksize,grainsize>::type grid_type;
  typedef typename grid_type::agent_type block_type;
  typedef typename block_type::agent_type thread_type;

  typedef typename super_t::task_type task_type;


  __attribute__((host)) __attribute__((device))
  void launch(grid_type request, Closure c, cudaStream_t stream)
  {
    grid_type g = configure(request);

    size_type num_blocks = g.size();
    size_type block_size = g.this_exec.size();

    if(num_blocks > 0 && block_size > 0)
    {
      size_type heap_size = g.this_exec.heap_size();

      size_type max_physical_grid_size = super_t::max_physical_grid_size();




      if(block_size > 0)
      {
        size_type num_remaining_physical_blocks = num_blocks;
        for(size_type block_offset = 0;
            block_offset < num_blocks;
            block_offset += max_physical_grid_size)
        {
          task_type task(g, c, block_offset);

          size_type num_physical_blocks = thrust::min<size_type>(num_remaining_physical_blocks, max_physical_grid_size);

          super_t::launch(num_physical_blocks, block_size, heap_size, stream, task);

          num_remaining_physical_blocks -= num_physical_blocks;
        }
      }
    }
  }

  __attribute__((host)) __attribute__((device))
  grid_type configure(grid_type g)
  {
    size_type block_size = super_t::choose_group_size(g.this_exec.size());
    size_type heap_size = super_t::choose_heap_size(device_properties(), block_size, g.this_exec.heap_size());
    size_type num_blocks = g.size();

    return make_grid<grid_type>(num_blocks, make_block<block_type>(block_size, heap_size));
  }


  __attribute__((host)) __attribute__((device))
  thrust::pair<size_type, size_type> choose_sizes(size_type requested_num_groups, size_type requested_group_size)
  {


    size_type group_size = blocksize;
    if(group_size == 0)
    {
      group_size = super_t::choose_group_size(requested_group_size);
    }



    size_type num_groups = gridsize;
    if(num_groups == 0)
    {
      num_groups = super_t::choose_num_groups(requested_num_groups, group_size);
    }

    return thrust::make_pair(num_groups, group_size);
  }
};


template<std::size_t blocksize, std::size_t grainsize, typename Closure>
struct cuda_launcher<
  concurrent_group<
    agent<grainsize>,
    blocksize
  >,
  Closure
>
  : public cuda_launcher_base<blocksize,concurrent_group<agent<grainsize>,blocksize>,Closure>
{
  typedef cuda_launcher_base<blocksize,concurrent_group<agent<grainsize>,blocksize>,Closure> super_t;
  typedef typename super_t::size_type size_type;
  typedef typename super_t::task_type task_type;

  typedef concurrent_group<agent<grainsize>,blocksize> block_type;

  __attribute__((host)) __attribute__((device))
  void launch(block_type request, Closure c, cudaStream_t stream)
  {
    block_type b = configure(request);

    size_type block_size = b.size();
    size_type heap_size = b.heap_size();

    if(block_size > 0)
    {
      task_type task(b, c);
      super_t::launch(1, block_size, heap_size, stream, task);
    }
  }

  __attribute__((host)) __attribute__((device))
  block_type configure(block_type b)
  {
    size_type block_size = super_t::choose_group_size(b.size());
    size_type heap_size = super_t::choose_heap_size(device_properties(), block_size, b.heap_size());
    return make_block<block_type>(block_size, heap_size);
  }
};


template<std::size_t groupsize, std::size_t grainsize, typename Closure>
struct cuda_launcher<
  parallel_group<
    agent<grainsize>,
    groupsize
  >,
  Closure
>
  : public cuda_launcher_base<dynamic_group_size, parallel_group<agent<grainsize>,groupsize>,Closure>
{
  typedef cuda_launcher_base<dynamic_group_size, parallel_group<agent<grainsize>,groupsize>,Closure> super_t;
  typedef typename super_t::size_type size_type;
  typedef typename super_t::task_type task_type;

  typedef parallel_group<agent<grainsize>,groupsize> group_type;

  __attribute__((host)) __attribute__((device))
  void launch(group_type g, Closure c, cudaStream_t stream)
  {
    size_type num_blocks, block_size;
    thrust::tie(num_blocks,block_size) = configure(g);

    if(num_blocks > 0 && block_size > 0)
    {
      task_type task(g, c);

      super_t::launch(num_blocks, block_size, 0, stream, task);
    }
  }

  __attribute__((host)) __attribute__((device))
  thrust::tuple<size_type,size_type> configure(group_type g)
  {
    size_type block_size = thrust::min<size_type>(g.size(), super_t::choose_group_size(use_default));


    size_type max_blocks = super_t::choose_num_groups(bulk_::use_default, block_size);


    size_type num_blocks = (block_size > 0) ? (g.size() + block_size - 1) / block_size : 0;


    num_blocks = thrust::min<size_type>(num_blocks, max_blocks);

    return thrust::make_tuple(num_blocks, block_size);
  }
};


}
}
} } } }
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/choose_sizes.inl" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


template<typename Closure>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Closure)
{
  bulk_::detail::cuda_launcher<
    parallel_group<concurrent_group<> >,
    Closure
  > launcher;

  return launcher.choose_sizes(g.size(), g.this_exec.size());
}


}


template<typename Function>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f)
{
  return bulk_::detail::choose_sizes(g, detail::make_closure(f));
}


template<typename Function, typename Arg1>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1)
{
  return bulk_::detail::choose_sizes(g, detail::make_closure(f,arg1));
}


template<typename Function, typename Arg1, typename Arg2>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2)
{
  return bulk_::detail::choose_sizes(g, detail::make_closure(f,arg1,arg2));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3)
{
  return bulk_::detail::choose_sizes(g, detail::make_closure(f,arg1,arg2,arg3));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
{
  return bulk_::detail::choose_sizes(g, detail::make_closure(f,arg1,arg2,arg3,arg4));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5)
{
  return bulk_::detail::choose_sizes(g, detail::make_closure(f,arg1,arg2,arg3,arg4,arg5));
}


template<typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
__attribute__((host)) __attribute__((device))
thrust::pair<typename parallel_group<concurrent_group<> >::size_type,
             typename concurrent_group<>::size_type>
  choose_sizes(parallel_group<concurrent_group<> > g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6)
{
  return bulk_::detail::choose_sizes(g, detail::make_closure(f,arg1,arg2,arg3,arg4,arg5,arg6));
}


}
} } } }
# 82 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/choose_sizes.hpp" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/bulk.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/async.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/async.hpp"
       





# 1 "/usr/local/cuda-8.0/include/thrust/detail/cstdint.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/cstdint.h"
       





namespace thrust
{
namespace detail
{
# 50 "/usr/local/cuda-8.0/include/thrust/detail/cstdint.h"
typedef ::int8_t int8_t;
typedef ::int16_t int16_t;
typedef ::int32_t int32_t;
typedef ::int64_t int64_t;
typedef ::uint8_t uint8_t;
typedef ::uint16_t uint16_t;
typedef ::uint32_t uint32_t;
typedef ::uint64_t uint64_t;





template<int word_size = sizeof(void*)> struct divine_intptr_t;
template<int word_size = sizeof(void*)> struct divine_uintptr_t;


template<> struct divine_intptr_t<4> { typedef thrust::detail::int32_t type; };
template<> struct divine_uintptr_t<4> { typedef thrust::detail::uint32_t type; };


template<> struct divine_intptr_t<8> { typedef thrust::detail::int64_t type; };
template<> struct divine_uintptr_t<8> { typedef thrust::detail::uint64_t type; };

typedef divine_intptr_t<>::type intptr_t;
typedef divine_uintptr_t<>::type uintptr_t;

}
}
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/async.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<typename ExecutionGroup, typename Function>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f);


template<typename ExecutionGroup, typename Function, typename Arg1>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1);


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2);


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3);


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4);


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5);


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6);


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7);


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8);


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9);


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10);


}
} } } }

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/async.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/async.inl"
namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


template<typename ExecutionGroup, typename Closure>
__attribute__((host)) __attribute__((device))
future<void> async_in_stream(ExecutionGroup g, Closure c, cudaStream_t s, cudaEvent_t before_event)
{

  if(before_event != 0)
  {
    bulk_::detail::throw_on_error(cudaStreamWaitEvent(s, before_event, 0), "cudaStreamWaitEvent in async_in_stream");
  }




  bulk_::detail::cuda_launcher<ExecutionGroup, Closure> launcher;
  launcher.launch(g, c, s);

  return future_core_access::create(s, false);
}


template<typename ExecutionGroup, typename Closure>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Closure c, cudaEvent_t before_event)
{
  cudaStream_t s;




  bulk_::detail::throw_on_error(cudaStreamCreate(&s), "cudaStreamCreate in bulk::detail::async");






  if(before_event != 0)
  {
    bulk_::detail::throw_on_error(cudaStreamWaitEvent(s, before_event, 0), "cudaStreamWaitEvent in bulk::detail::async");
  }




  bulk_::detail::cuda_launcher<ExecutionGroup, Closure> launcher;
  launcher.launch(g, c, s);


  return future_core_access::create(s, true);
}


template<typename ExecutionGroup, typename Closure>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Closure c)
{
  return bulk_::detail::async_in_stream(g, c, 0, 0);
}


template<typename ExecutionGroup, typename Closure>
__attribute__((host)) __attribute__((device))
future<void> async(async_launch<ExecutionGroup> launch, Closure c)
{
  return launch.is_stream_valid() ?
    bulk_::detail::async_in_stream(launch.exec(), c, launch.stream(), launch.before_event()) :
    bulk_::detail::async(launch.exec(), c, launch.before_event());
}


}


template<typename ExecutionGroup, typename Function>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f)
{
  return bulk_::detail::async(g, detail::make_closure(f));
}


template<typename ExecutionGroup, typename Function, typename Arg1>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1));
}


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1,arg2));
}


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1,arg2,arg3));
}


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1,arg2,arg3,arg4));
}


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1,arg2,arg3,arg4,arg5));
}


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1,arg2,arg3,arg4,arg5,arg6));
}


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1,arg2,arg3,arg4,arg5,arg6,arg7));
}


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8));
}


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9));
}


template<typename ExecutionGroup, typename Function, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8, typename Arg9, typename Arg10>
__attribute__((host)) __attribute__((device))
future<void> async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10)
{
  return bulk_::detail::async(g, detail::make_closure(f,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10));
}


}
} } } }
# 90 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/async.hpp" 2
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/bulk.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/is_contiguous_iterator.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/is_contiguous_iterator.hpp"
       




namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


template<typename T>
  struct is_contiguous_iterator
    : thrust::detail::is_trivial_iterator<T>
{};


}
}
} } } }
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp" 2




namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
__inline__ __attribute__((always_inline)) __attribute__((device))
RandomAccessIterator2 copy_n(const bounded<bound,agent<grainsize> > &b,
                             RandomAccessIterator1 first,
                             Size n,
                             RandomAccessIterator2 result)
{
  typedef typename bounded<bound,agent<grainsize> >::size_type size_type;

  if(bound <= n)
  {
    for(size_type i = 0; i < b.bound(); ++i, ++result, ++first)
    {
      *result = *first;
    }
  }
  else
  {
    for(size_type i = 0; i < b.bound(); ++i, ++first)
    {
      if(i < n)
      {
        *result = *first;
        ++result;
      }
    }
  }

  return result;
}



namespace detail
{


template<typename ConcurrentGroup,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
__inline__ __attribute__((always_inline)) __attribute__((device))
RandomAccessIterator2 simple_copy_n(ConcurrentGroup &g, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result)
{
  for(Size i = g.this_exec.index();
      i < n;
      i += g.size())
  {
    result[i] = first[i];
  }

  g.wait();

  return result + n;
}


template<std::size_t size,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
__inline__ __attribute__((always_inline)) __attribute__((device))
typename thrust::detail::enable_if<
  (size * grainsize > 0),
  RandomAccessIterator2
>::type
  simple_copy_n(bulk_::concurrent_group<
                  agent<grainsize>,
                  size
                > &g,
                RandomAccessIterator1 first, Size n,
                RandomAccessIterator2 result)
{
  typedef bulk_::concurrent_group<
    agent<grainsize>,
    size
  > group_type;

  RandomAccessIterator2 return_me = result + n;

  typedef typename group_type::size_type size_type;
  size_type chunk_size = size * grainsize;

  size_type tid = g.this_exec.index();


  if(chunk_size == n)
  {

    first += tid;
    result += tid;

    for(size_type i = 0; i < grainsize; ++i, first += size, result += size)
    {
      *result = *first;
    }
  }
  else
  {

    for(RandomAccessIterator1 last = first + n;
        first < last;
        first += chunk_size, result += chunk_size)
    {

      if((last - first) >= chunk_size)
      {
        for(size_type i = 0; i < grainsize; ++i)
        {
          size_type idx = size * i + tid;
          result[idx] = first[idx];
        }
      }
      else
      {
        for(size_type i = 0; i < grainsize; ++i)
        {
          size_type idx = size * i + tid;
          if(idx < (last - first))
          {
            result[idx] = first[idx];
          }
        }
      }
    }
  }

  g.wait();

  return return_me;
}


template<std::size_t size,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
__inline__ __attribute__((always_inline)) __attribute__((device))
RandomAccessIterator2 copy_n(concurrent_group<
                               agent<grainsize>,
                               size
                             > &g,
                             RandomAccessIterator1 first,
                             Size n,
                             RandomAccessIterator2 result)
{
  return detail::simple_copy_n(g, first, n, result);
}


}


template<std::size_t groupsize,
         typename Executor,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
__inline__ __attribute__((always_inline)) __attribute__((device))
RandomAccessIterator2
  copy_n(bulk_::concurrent_group<Executor,groupsize> &g, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result)
{
  return detail::copy_n(g, first, n, result);
}


template<std::size_t bound, std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2>
__attribute__((device))
typename thrust::detail::enable_if<
  (bound <= groupsize * grainsize),
  RandomAccessIterator2
>::type
copy_n(bulk_::bounded<
         bound,
         concurrent_group<
           agent<grainsize>,
           groupsize
         >
       > &g,
       RandomAccessIterator1 first,
       Size n,
       RandomAccessIterator2 result)
{
  typedef bounded<
    bound,
    concurrent_group<
      agent<grainsize>,
      groupsize
    >
  > group_type;

  typedef typename group_type::size_type size_type;

  size_type tid = g.this_exec.index();

  typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;


  value_type stage[grainsize];


  if(groupsize * grainsize <= n)
  {
    for(size_type i = 0; i < grainsize; ++i)
    {
      size_type src_idx = g.size() * i + tid;
      stage[i] = first[src_idx];
    }

    for(size_type i = 0; i < grainsize; ++i)
    {
      size_type dst_idx = g.size() * i + tid;
      result[dst_idx] = stage[i];
    }
  }
  else
  {
    for(size_type i = 0; i < grainsize; ++i)
    {
      size_type src_idx = g.size() * i + tid;
      if(src_idx < n)
      {
        stage[i] = first[src_idx];
      }
    }

    for(size_type i = 0; i < grainsize; ++i)
    {
      size_type dst_idx = g.size() * i + tid;
      if(dst_idx < n)
      {
        result[dst_idx] = stage[i];
      }
    }
  }

  g.wait();

  return result + thrust::min<Size>(g.size() * grainsize, n);
}


}
} } } }
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/reduce.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/reduce.hpp"
       





# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/iterator/strided_iterator.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/iterator/strided_iterator.hpp"
       





namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<typename Iterator,
         typename Size = typename thrust::iterator_difference<Iterator>::type>
class strided_iterator
  : public thrust::iterator_adaptor<
      strided_iterator<Iterator>,
      Iterator
    >
{
  private:
    typedef thrust::iterator_adaptor<strided_iterator<Iterator>,Iterator> super_t;

  public:
    typedef Size stride_type;

    inline __attribute__((host)) __attribute__((device))
    strided_iterator()
      : super_t(), m_stride(1)
    {}

    inline __attribute__((host)) __attribute__((device))
    strided_iterator(const strided_iterator& other)
      : super_t(other), m_stride(other.m_stride)
    {}

    inline __attribute__((host)) __attribute__((device))
    strided_iterator(const Iterator &base, stride_type stride)
      : super_t(base), m_stride(stride)
    {}

    inline __attribute__((host)) __attribute__((device))
    stride_type stride() const
    {
      return m_stride;
    }

  private:
    friend class thrust::iterator_core_access;

    __attribute__((host)) __attribute__((device))
    void increment()
    {
      super_t::base_reference() += stride();
    }

    __attribute__((host)) __attribute__((device))
    void decrement()
    {
      super_t::base_reference() -= stride();
    }

    __attribute__((host)) __attribute__((device))
    void advance(typename super_t::difference_type n)
    {
      super_t::base_reference() += n * stride();
    }

    template<typename OtherIterator>
    __attribute__((host)) __attribute__((device))
    typename super_t::difference_type distance_to(const strided_iterator<OtherIterator> &other) const
    {
      if(other.base() >= this->base())
      {
        return (other.base() - this->base() + (stride() - 1)) / stride();
      }

      return (other.base() - this->base() - (stride() - 1)) / stride();
    }

    stride_type m_stride;
};


template<typename Iterator, typename Size>
__attribute__((host)) __attribute__((device))
strided_iterator<Iterator,Size> make_strided_iterator(Iterator iter, Size stride)
{
  return strided_iterator<Iterator,Size>(iter, stride);
}


}
} } } }
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/reduce.hpp" 2




namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator,
         typename T,
         typename BinaryFunction>
__inline__ __attribute__((always_inline)) __attribute__((device))
T reduce(const bulk_::bounded<bound,bulk_::agent<grainsize> > &exec,
         RandomAccessIterator first,
         RandomAccessIterator last,
         T init,
         BinaryFunction binary_op)
{
  typedef typename bulk_::bounded<bound,bulk_::agent<grainsize> >::size_type size_type;

  size_type n = last - first;

  for(size_type i = 0; i < exec.bound(); ++i)
  {
    if(i < n)
    {
      init = binary_op(init, first[i]);
    }
  }

  return init;
}


namespace detail
{
namespace reduce_detail
{


template<typename ConcurrentGroup, typename RandomAccessIterator, typename Size, typename T, typename BinaryFunction>
__attribute__((device)) T destructive_reduce_n(ConcurrentGroup &g, RandomAccessIterator first, Size n, T init, BinaryFunction binary_op)
{
  typedef int size_type;

  size_type tid = g.this_exec.index();

  Size m = n;

  while(m > 1)
  {
    Size half_m = m >> 1;

    if(tid < half_m)
    {
      T old_val = first[tid];

      first[tid] = binary_op(old_val, first[m - tid - 1]);
    }

    g.wait();

    m -= half_m;
  }

  g.wait();

  T result = init;
  if(n > 0)
  {
    result = binary_op(result,first[0]);
  }

  g.wait();

  return result;
}


}
}


template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator, typename T, typename BinaryFunction>
__attribute__((device))
T reduce(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &g,
         RandomAccessIterator first,
         RandomAccessIterator last,
         T init,
         BinaryFunction binary_op)
{
  typedef int size_type;

  const size_type elements_per_group = groupsize * grainsize;

  size_type tid = g.this_exec.index();

  T this_sum;

  bool this_sum_defined = false;

  size_type n = last - first;




  for(size_type offset = 0; offset < n; first += elements_per_group, offset += elements_per_group)
  {
    size_type partition_size = thrust::min<size_type>(elements_per_group, last - first);

    typedef typename thrust::iterator_value<RandomAccessIterator>::type input_type;


    input_type local_inputs[grainsize];



    strided_iterator<RandomAccessIterator,size_type> local_first = make_strided_iterator(first + tid, static_cast<size_type>(groupsize));




    size_type local_size = 0;
    if(partition_size < elements_per_group)
    {
# 163 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/reduce.hpp"
      RandomAccessIterator iter = local_first.base();
      size_type index = tid;
      for(size_type i = 0; i < grainsize; ++i, index += groupsize, iter += groupsize)
      {
        if(index < partition_size)
        {
          local_inputs[i] = *iter;
          ++local_size;
        }
      }
    }
    else
    {
      local_size = grainsize;





      RandomAccessIterator iter = local_first.base();
      for(size_type i = 0; i < grainsize; ++i, iter += groupsize)
      {
        local_inputs[i] = *iter;
      }
    }


    this_sum = this_sum_defined ?
      bulk_::reduce(bulk_::bound<grainsize>(g.this_exec), local_inputs, local_inputs + local_size, this_sum, binary_op) :
      bulk_::reduce(bulk_::bound<grainsize-1>(g.this_exec), local_inputs + 1, local_inputs + local_size, T(local_inputs[0]), binary_op);

    this_sum_defined = true;
  }




  __attribute__((shared)) bulk_::uninitialized_array<T,groupsize> buffer_impl;
  T *buffer = buffer_impl.data();


  if(this_sum_defined)
  {
    buffer[tid] = this_sum;
  }

  g.wait();


  T result = bulk_::detail::reduce_detail::destructive_reduce_n(g, buffer, thrust::min<size_type>(groupsize,n), init, binary_op);





  return result;
}


template<typename RandomAccessIterator, typename T, typename BinaryFunction>
__attribute__((device))
T reduce(bulk_::concurrent_group<> &g,
         RandomAccessIterator first,
         RandomAccessIterator last,
         T init,
         BinaryFunction binary_op)
{
  typedef int size_type;

  size_type tid = g.this_exec.index();

  T this_sum;

  bool this_sum_defined = false;

  typename thrust::iterator_difference<RandomAccessIterator>::type n = last - first;

  T *buffer = reinterpret_cast<T*>(bulk_::malloc(g, g.size() * sizeof(T)));

  for(size_type i = tid; i < n; i += g.size())
  {
    typedef typename thrust::iterator_value<RandomAccessIterator>::type input_type;
    input_type x = first[i];
    this_sum = this_sum_defined ? binary_op(this_sum, x) : x;

    this_sum_defined = true;
  }

  if(this_sum_defined)
  {
    buffer[tid] = this_sum;
  }

  g.wait();


  T result = detail::reduce_detail::destructive_reduce_n(g, buffer, thrust::min<size_type>(g.size(),n), init, binary_op);

  bulk_::free(g,buffer);

  return result;
}


}
} } } }
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
       





# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/accumulate.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/accumulate.hpp"
       







namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator,
         typename T,
         typename BinaryFunction>
__inline__ __attribute__((always_inline)) __attribute__((device))
T accumulate(const bounded<bound,bulk_::agent<grainsize> > &exec,
             RandomAccessIterator first,
             RandomAccessIterator last,
             T init,
             BinaryFunction binary_op)
{
  typedef typename bounded<bound,bulk_::agent<grainsize> >::size_type size_type;

  size_type n = last - first;

  for(size_type i = 0; i < exec.bound(); ++i)
  {
    if(i < n)
    {
      init = binary_op(init, first[i]);
    }
  }

  return init;
}


namespace detail
{
namespace accumulate_detail
{




template<typename ConcurrentGroup, typename RandomAccessIterator, typename Size, typename T, typename BinaryFunction>
__attribute__((device)) T destructive_accumulate_n(ConcurrentGroup &g, RandomAccessIterator first, Size n, T init, BinaryFunction binary_op)
{
  typedef typename ConcurrentGroup::size_type size_type;

  size_type tid = g.this_exec.index();

  T x = init;
  if(tid < n)
  {
    x = first[tid];
  }

  g.wait();

  for(size_type offset = 1; offset < g.size(); offset += offset)
  {
    if(tid >= offset && tid - offset < n)
    {
      x = binary_op(first[tid - offset], x);
    }

    g.wait();

    if(tid < n)
    {
      first[tid] = x;
    }

    g.wait();
  }

  T result = binary_op(init, first[n - 1]);

  g.wait();

  return result;
}


template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator, typename T>
struct buffer
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;

  union
  {
    uninitialized_array<value_type, groupsize * grainsize> inputs;
    uninitialized_array<T, groupsize> sums;
  };
};


template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator, typename T, typename BinaryFunction>
__attribute__((device))
T accumulate(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &g,
             RandomAccessIterator first,
             RandomAccessIterator last,
             T init,
             BinaryFunction binary_op)
{
  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;

  const size_type elements_per_group = groupsize * grainsize;

  size_type tid = g.this_exec.index();

  T sum = init;

  typename thrust::iterator_difference<RandomAccessIterator>::type n = last - first;

  typedef detail::accumulate_detail::buffer<
    groupsize,
    grainsize,
    RandomAccessIterator,
    T
  > buffer_type;




  __attribute__((shared)) uninitialized<buffer_type> buffer_impl;
  buffer_type *buffer = &buffer_impl.get();


  for(; first < last; first += elements_per_group)
  {


    size_type partition_size = thrust::min<size_type>(elements_per_group, last - first);


    bulk_::copy_n(g, first, partition_size, buffer->inputs.data());

    T this_sum;
    size_type local_offset = grainsize * g.this_exec.index();

    size_type local_size = thrust::max<size_type>(0,thrust::min<size_type>(grainsize, partition_size - grainsize * tid));

    if(local_size)
    {
      this_sum = buffer->inputs[local_offset];
      this_sum = bulk_::accumulate(bound<grainsize-1>(g.this_exec),
                                  buffer->inputs.data() + local_offset + 1,
                                  buffer->inputs.data() + local_offset + local_size,
                                  this_sum,
                                  binary_op);
    }

    g.wait();

    if(local_size)
    {
      buffer->sums[tid] = this_sum;
    }

    g.wait();


    sum = accumulate_detail::destructive_accumulate_n(g, buffer->sums.data(), thrust::min<size_type>(groupsize,n), sum, binary_op);
  }





  return sum;
}
}
}


template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator, typename T, typename BinaryFunction>
__attribute__((device))
T accumulate(bulk_::concurrent_group<bulk_::agent<grainsize>, groupsize> &g,
             RandomAccessIterator first,
             RandomAccessIterator last,
             T init,
             BinaryFunction binary_op)
{

  if(thrust::detail::is_commutative<BinaryFunction>::value)
  {
    init = bulk_::reduce(g, first, last, init, binary_op);
  }
  else
  {
    init = detail::accumulate_detail::accumulate(g, first, last, init, binary_op);
  }

  return init;
}


}
} } } }
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp" 2



# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/iterator/is_output_iterator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/iterator/is_output_iterator.h"
       





# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/any_assign.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/any_assign.h"
       



namespace thrust
{
namespace detail
{



struct any_assign
{
  inline __attribute__((host)) __attribute__((device)) any_assign(void)
  {}

  template<typename T>
  inline __attribute__((host)) __attribute__((device)) any_assign(T)
  {}

  template<typename T>
  inline __attribute__((host)) __attribute__((device))
  any_assign &operator=(T)
  {
    if(0)
    {

      int *x = 0;
      *x = 13;
    }

    return *this;
  }
};


}
}
# 24 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/iterator/is_output_iterator.h" 2

namespace thrust
{

namespace detail
{


template<typename T>
  struct is_void_like
    : thrust::detail::or_<
        thrust::detail::is_void<T>,
        thrust::detail::is_same<T,thrust::detail::any_assign>
      >
{};


template<typename T>
  struct lazy_is_void_like
    : is_void_like<typename T::type>
{};
# 53 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/iterator/is_output_iterator.h"
template<typename T>
  struct is_output_iterator
    : eval_if<
        is_metafunction_defined<thrust::iterator_value<T> >::value,
        lazy_is_void_like<thrust::iterator_value<T> >,
        thrust::detail::true_type
      >::type
{
};

}

}
# 28 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<std::size_t bound, std::size_t grainsize, typename RandomAccessIterator1, typename RandomAccessIterator2, typename T, typename BinaryFunction>
__inline__ __attribute__((always_inline)) __attribute__((device))
RandomAccessIterator2
  inclusive_scan(const bounded<bound, bulk_::agent<grainsize> > &exec,
                 RandomAccessIterator1 first,
                 RandomAccessIterator1 last,
                 RandomAccessIterator2 result,
                 T init,
                 BinaryFunction binary_op)
{
  for(int i = 0; i < exec.bound(); ++i)
  {
    if(first + i < last)
    {
      init = binary_op(init, first[i]);
      result[i] = init;
    }
  }

  return result + (last - first);
}


template<std::size_t bound, std::size_t grainsize, typename RandomAccessIterator1, typename RandomAccessIterator2, typename T, typename BinaryFunction>
__inline__ __attribute__((always_inline)) __attribute__((device))
RandomAccessIterator2
  exclusive_scan(const bounded<bound, bulk_::agent<grainsize> > &exec,
                 RandomAccessIterator1 first,
                 RandomAccessIterator1 last,
                 RandomAccessIterator2 result,
                 T init,
                 BinaryFunction binary_op)
{
  for(int i = 0; i < exec.bound(); ++i)
  {
    if(first + i < last)
    {
      result[i] = init;
      init = binary_op(init, first[i]);
    }
  }

  return result + (last - first);
}


namespace detail
{
namespace scan_detail
{


template<typename InputIterator, typename OutputIterator, typename BinaryFunction>
struct scan_intermediate
  : thrust::detail::eval_if<
      thrust::detail::has_result_type<BinaryFunction>::value,
      thrust::detail::result_type<BinaryFunction>,
      thrust::detail::eval_if<
        thrust::detail::is_output_iterator<OutputIterator>::value,
        thrust::iterator_value<InputIterator>,
        thrust::iterator_value<OutputIterator>
      >
    >
{};


template<typename ConcurrentGroup, typename RandomAccessIterator, typename T, typename BinaryFunction>
__attribute__((device)) T inplace_exclusive_scan(ConcurrentGroup &g, RandomAccessIterator first, T init, BinaryFunction binary_op)
{
  typedef typename ConcurrentGroup::size_type size_type;

  size_type tid = g.this_exec.index();

  if(tid == 0)
  {
    first[0] = binary_op(init, first[0]);
  }

  T x = first[tid];

  g.wait();

  for(size_type offset = 1; offset < g.size(); offset += offset)
  {
    if(tid >= offset)
    {
      x = binary_op(first[tid - offset], x);
    }

    g.wait();

    first[tid] = x;

    g.wait();
  }

  T result = first[g.size() - 1];

  if(tid == 0)
  {
    x = init;
  }
  else
  {
    x = first[tid - 1];
  }

  g.wait();

  first[tid] = x;

  g.wait();

  return result;
}


template<typename ConcurrentGroup, typename RandomAccessIterator, typename Size, typename T, typename BinaryFunction>
__attribute__((device)) T small_inplace_exclusive_scan(ConcurrentGroup &g, RandomAccessIterator first, Size n, T init, BinaryFunction binary_op)
{
  typedef typename ConcurrentGroup::size_type size_type;

  size_type tid = g.this_exec.index();

  if(tid == 0)
  {
    first[0] = binary_op(init, first[0]);
  }

  T x = tid < n ? first[tid] : init;

  g.wait();

  for(size_type offset = 1; offset < g.size(); offset += offset)
  {
    if(tid >= offset && tid - offset < n)
    {
      x = binary_op(first[tid - offset], x);
    }

    g.wait();

    if(tid < n)
    {
      first[tid] = x;
    }

    g.wait();
  }

  T result = first[n - 1];

  if(tid < n)
  {
    if(tid == 0)
    {
      x = init;
    }
    else
    {
      x = first[tid - 1];
    }
  }

  g.wait();

  if(tid < n)
  {
    first[tid] = x;
  }

  g.wait();

  return result;
}



template<typename ConcurrentGroup, typename RandomAccessIterator, typename Size, typename T, typename BinaryFunction>
__attribute__((device)) T bounded_inplace_exclusive_scan(ConcurrentGroup &g, RandomAccessIterator first, Size n, T init, BinaryFunction binary_op)
{
  return (n == g.size()) ?
    inplace_exclusive_scan(g, first, init, binary_op) :
    small_inplace_exclusive_scan(g, first, n, init, binary_op);
}


template<bool inclusive,
         std::size_t bound, std::size_t groupsize, std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename T,
         typename BinaryFunction>
__attribute__((device))





T
scan(bulk_::bounded<
       bound,
       bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>
     > &g,
     RandomAccessIterator1 first, RandomAccessIterator1 last,
     RandomAccessIterator2 result,
     T carry_in,
     BinaryFunction binary_op)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type input_type;

  typedef typename scan_intermediate<
    RandomAccessIterator1,
    RandomAccessIterator2,
    BinaryFunction
  >::type intermediate_type;

  typedef typename bulk_::bounded<
    bound,
    bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>
  >::size_type size_type;

  size_type tid = g.this_exec.index();
  size_type n = last - first;


  input_type local_inputs[grainsize];

  size_type local_offset = grainsize * tid;
  size_type local_size = thrust::max<size_type>(0,thrust::min<size_type>(grainsize, n - grainsize * tid));

  bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), first + local_offset, local_size, local_inputs);


  intermediate_type x;

  if(local_size)
  {
    x = local_inputs[0];
    x = bulk_::accumulate(bulk_::bound<grainsize-1>(g.this_exec), local_inputs + 1, local_inputs + local_size, x, binary_op);
  }

  g.wait();

  if(local_size)
  {
    result[tid] = x;
  }

  g.wait();


  const size_type spine_n = (n >= g.size() * g.this_exec.grainsize()) ? g.size() : (n + g.this_exec.grainsize() - 1) / g.this_exec.grainsize();




  carry_in = bounded_inplace_exclusive_scan(g, result, spine_n, carry_in, binary_op);

  if(local_size)
  {
    x = result[tid];
  }

  g.wait();

  if(inclusive)
  {
    bulk_::inclusive_scan(bulk_::bound<grainsize>(g.this_exec), local_inputs, local_inputs + local_size, result + local_offset, x, binary_op);
  }
  else
  {
    bulk_::exclusive_scan(bulk_::bound<grainsize>(g.this_exec), local_inputs, local_inputs + local_size, result + local_offset, x, binary_op);
  }

  g.wait();

  return carry_in;
}


template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator1, typename RandomAccessIterator2, typename BinaryFunction>
struct scan_buffer
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type input_type;

  typedef typename scan_intermediate<
    RandomAccessIterator1,
    RandomAccessIterator2,
    BinaryFunction
  >::type intermediate_type;

  union
  {
    uninitialized_array<input_type, groupsize * grainsize> inputs;
    uninitialized_array<intermediate_type, groupsize * grainsize> results;
  };
};


template<bool inclusive, std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator1, typename RandomAccessIterator2, typename T, typename BinaryFunction>
__attribute__((device)) void scan_with_buffer(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &g,
                                 RandomAccessIterator1 first, RandomAccessIterator1 last,
                                 RandomAccessIterator2 result,
                                 T carry_in,
                                 BinaryFunction binary_op,
                                 scan_buffer<groupsize,grainsize,RandomAccessIterator1,RandomAccessIterator2,BinaryFunction> &buffer)
{
  typedef scan_buffer<
    groupsize,
    grainsize,
    RandomAccessIterator1,
    RandomAccessIterator2,
    BinaryFunction
  > buffer_type;

  typedef typename buffer_type::input_type input_type;
  typedef typename buffer_type::intermediate_type intermediate_type;




  union {
    input_type *inputs;
    intermediate_type *results;
  } stage;

  stage.inputs = buffer.inputs.data();

  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;

  size_type tid = g.this_exec.index();

  const size_type elements_per_group = groupsize * grainsize;

  for(; first < last; first += elements_per_group, result += elements_per_group)
  {
    size_type partition_size = thrust::min<size_type>(elements_per_group, last - first);


    bulk_::copy_n(g, first, partition_size, stage.inputs);

    carry_in = scan<inclusive>(bulk_::bound<elements_per_group>(g),
                               stage.inputs, stage.inputs + partition_size,
                               stage.results,
                               carry_in,
                               binary_op);


    bulk_::copy_n(g, stage.results, partition_size, result);
  }
}


}
}


template<std::size_t bound,
         std::size_t groupsize,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename T,
         typename BinaryFunction>
__attribute__((device))
typename thrust::detail::enable_if<
  bound <= groupsize * grainsize,
  RandomAccessIterator2
>::type
inclusive_scan(bulk_::bounded<
                 bound,
                 bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>
               > &g,
               RandomAccessIterator1 first, RandomAccessIterator1 last,
               RandomAccessIterator2 result,
               T carry_in,
               BinaryFunction binary_op)
{
  detail::scan_detail::scan<true>(g, first, last, result, carry_in, binary_op);
  return result + (last - first);
}


template<std::size_t bound,
         std::size_t groupsize,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename BinaryFunction>
__attribute__((device))
typename thrust::detail::enable_if<
  bound <= groupsize * grainsize,
  RandomAccessIterator2
>::type
inclusive_scan(bulk_::bounded<
                 bound,
                 bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>
               > &g,
               RandomAccessIterator1 first, RandomAccessIterator1 last,
               RandomAccessIterator2 result,
               BinaryFunction binary_op)
{
  if(bound > 0 && first < last)
  {
    typename thrust::iterator_value<RandomAccessIterator1>::type init = *first;


    g.wait();

    if(g.this_exec.index() == 0)
    {
      *result = init;
    }

    detail::scan_detail::scan<true>(g, first + 1, last, result + 1, init, binary_op);
  }

  return result + (last - first);
}


template<std::size_t groupsize,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename T,
         typename BinaryFunction>
__attribute__((device)) void inclusive_scan(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &g,
                               RandomAccessIterator1 first, RandomAccessIterator1 last,
                               RandomAccessIterator2 result,
                               T init,
                               BinaryFunction binary_op)
{
  typedef detail::scan_detail::scan_buffer<groupsize,grainsize,RandomAccessIterator1,RandomAccessIterator2,BinaryFunction> buffer_type;
# 485 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
  __attribute__((shared)) uninitialized<buffer_type> buffer;
  detail::scan_detail::scan_with_buffer<true>(g, first, last, result, init, binary_op, buffer.get());

}


template<std::size_t size,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename BinaryFunction>
__attribute__((device))
RandomAccessIterator2
inclusive_scan(bulk_::concurrent_group<bulk_::agent<grainsize>,size> &this_group,
               RandomAccessIterator1 first,
               RandomAccessIterator1 last,
               RandomAccessIterator2 result,
               BinaryFunction binary_op)
{
  if(first < last)
  {




    typename detail::scan_detail::scan_intermediate<
      RandomAccessIterator1,
      RandomAccessIterator2,
      BinaryFunction
    >::type init = *first;


    this_group.wait();

    if(this_group.this_exec.index() == 0)
    {
      *result = init;
    }

    bulk_::inclusive_scan(this_group, first + 1, last, result + 1, init, binary_op);
  }

  return result + (last - first);
}


template<std::size_t bound, std::size_t groupsize, std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename T,
         typename BinaryFunction>
__attribute__((device))
typename thrust::detail::enable_if<
  bound <= groupsize * grainsize,
  RandomAccessIterator2
>::type
exclusive_scan(bulk_::bounded<
                 bound,
                 bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>
               > &g,
               RandomAccessIterator1 first, RandomAccessIterator1 last,
               RandomAccessIterator2 result,
               T carry_in,
               BinaryFunction binary_op)
{
  detail::scan_detail::scan<true>(g, first, last, result, carry_in, binary_op);
  return result + (last - first);
}


template<std::size_t groupsize,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename T,
         typename BinaryFunction>
__attribute__((device))
typename thrust::detail::enable_if<
  (groupsize > 0),
  RandomAccessIterator2
>::type
exclusive_scan(bulk_::concurrent_group<agent<grainsize>,groupsize> &g,
               RandomAccessIterator1 first, RandomAccessIterator1 last,
               RandomAccessIterator2 result,
               T init,
               BinaryFunction binary_op)
{
  typedef detail::scan_detail::scan_buffer<groupsize,grainsize,RandomAccessIterator1,RandomAccessIterator2,BinaryFunction> buffer_type;
# 588 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
  __attribute__((shared)) uninitialized<buffer_type> buffer;
  detail::scan_detail::scan_with_buffer<false>(g, first, last, result, init, binary_op, buffer.get());


  return result + (last - first);
}


}
} } } }
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
       





# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/gather.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/gather.hpp"
       




# 1 "/usr/local/cuda-8.0/include/thrust/iterator/permutation_iterator.h" 1
# 32 "/usr/local/cuda-8.0/include/thrust/iterator/permutation_iterator.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/permutation_iterator_base.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/permutation_iterator_base.h"
       






namespace thrust
{

template<typename,typename> class permutation_iterator;


namespace detail
{

template<typename ElementIterator,
         typename IndexIterator>
  struct permutation_iterator_base
{
  typedef typename thrust::iterator_system<ElementIterator>::type System1;
  typedef typename thrust::iterator_system<IndexIterator>::type System2;

  typedef thrust::iterator_adaptor<
    permutation_iterator<ElementIterator,IndexIterator>,
    IndexIterator,
    typename thrust::iterator_value<ElementIterator>::type,
    typename detail::minimum_system<System1,System2>::type,
    thrust::use_default,
    typename thrust::iterator_reference<ElementIterator>::type
  > type;
};

}

}
# 37 "/usr/local/cuda-8.0/include/thrust/iterator/permutation_iterator.h" 2



namespace thrust
{
# 118 "/usr/local/cuda-8.0/include/thrust/iterator/permutation_iterator.h"
template <typename ElementIterator,
          typename IndexIterator>
  class permutation_iterator
    : public thrust::detail::permutation_iterator_base<
        ElementIterator,
        IndexIterator
      >::type
{


  private:
    typedef typename detail::permutation_iterator_base<ElementIterator,IndexIterator>::type super_t;

    friend class thrust::iterator_core_access;



  public:



    __attribute__((host)) __attribute__((device))
    permutation_iterator()
      : m_element_iterator() {}
# 150 "/usr/local/cuda-8.0/include/thrust/iterator/permutation_iterator.h"
    __attribute__((host)) __attribute__((device))
    explicit permutation_iterator(ElementIterator x, IndexIterator y)
      : super_t(y), m_element_iterator(x) {}




    template<typename OtherElementIterator, typename OtherIndexIterator>
    __attribute__((host)) __attribute__((device))
    permutation_iterator(permutation_iterator<OtherElementIterator,OtherIndexIterator> const &r

    , typename detail::enable_if_convertible<OtherElementIterator, ElementIterator>::type* = 0
    , typename detail::enable_if_convertible<OtherIndexIterator, IndexIterator>::type* = 0
    )
      : super_t(r.base()), m_element_iterator(r.m_element_iterator)
    {}



  private:
    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    typename super_t::reference dereference() const
    {
      return *(m_element_iterator + *this->base());
    }


    template<typename,typename> friend class permutation_iterator;

    ElementIterator m_element_iterator;


};
# 196 "/usr/local/cuda-8.0/include/thrust/iterator/permutation_iterator.h"
template<typename ElementIterator, typename IndexIterator>
__attribute__((host)) __attribute__((device))
permutation_iterator<ElementIterator,IndexIterator> make_permutation_iterator(ElementIterator e, IndexIterator i)
{
  return permutation_iterator<ElementIterator,IndexIterator>(e,i);
}







}
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/gather.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{



template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3>
__inline__ __attribute__((always_inline)) __attribute__((device))
RandomAccessIterator3 gather(const bounded<bound,agent<grainsize> > &,
                             RandomAccessIterator1 map_first,
                             RandomAccessIterator1 map_last,
                             RandomAccessIterator2 input_first,
                             RandomAccessIterator3 result)
{
  typedef typename bulk_::bounded<bound,bulk_::agent<grainsize> >::size_type size_type;

  size_type n = map_last - map_first;

  if(bound <= n)
  {
    for(size_type i = 0; i < bound; ++i)
    {
      result[i] = input_first[map_first[i]];
    }
  }
  else
  {
    for(size_type i = 0; i < bound; ++i)
    {
      if(i < n)
      {
        result[i] = input_first[map_first[i]];
      }
    }
  }

  return result + n;
}


template<typename ExecutionGroup, typename RandomAccessIterator1, typename RandomAccessIterator2, typename RandomAccessIterator3>
__inline__ __attribute__((always_inline)) __attribute__((device))
RandomAccessIterator3 gather(ExecutionGroup &g,
                             RandomAccessIterator1 map_first,
                             RandomAccessIterator1 map_last,
                             RandomAccessIterator2 input_first,
                             RandomAccessIterator3 result)
{
  return bulk_::copy_n(g,
                      thrust::make_permutation_iterator(input_first, map_first),
                      map_last - map_first,
                      result);
}


}
} } } }
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp" 2

# 1 "/usr/local/cuda-8.0/include/thrust/iterator/counting_iterator.h" 1
# 32 "/usr/local/cuda-8.0/include/thrust/iterator/counting_iterator.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/counting_iterator.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/counting_iterator.inl"
       



# 1 "/usr/local/cuda-8.0/include/thrust/detail/numeric_traits.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/numeric_traits.h"
       






namespace thrust
{

namespace detail
{


typedef long long intmax_t;

template<typename Number>
  struct is_signed
    : integral_constant<bool, std::numeric_limits<Number>::is_signed>
{};


template<typename T>
  struct num_digits
    : eval_if<
        std::numeric_limits<T>::is_specialized,
        integral_constant<
          int,
          std::numeric_limits<T>::digits
        >,
        integral_constant<
          int,
          sizeof(T) * std::numeric_limits<unsigned char>::digits - (is_signed<T>::value ? 1 : 0)
        >
      >::type
{};


template<typename Integer>
  struct integer_difference
# 70 "/usr/local/cuda-8.0/include/thrust/detail/numeric_traits.h"
{
  private:


    template<bool x, bool y>
      struct and_
    {
      static const bool value = false;
    };

    template<bool y>
      struct and_<true,y>
    {
      static const bool value = y;
    };

  public:
    typedef typename
      eval_if<
        and_<
          std::numeric_limits<Integer>::is_signed,

          (!std::numeric_limits<Integer>::is_bounded || (int(std::numeric_limits<Integer>::digits) + 1 >= num_digits<intmax_t>::value))
        >::value,
        identity_<Integer>,
        eval_if<
          int(std::numeric_limits<Integer>::digits) + 1 < num_digits<signed int>::value,
          identity_<signed int>,
          eval_if<
            int(std::numeric_limits<Integer>::digits) + 1 < num_digits<signed long>::value,
            identity_<signed long>,
            identity_<intmax_t>
          >
        >
      >::type type;
};


template<typename Number>
  struct numeric_difference
    : eval_if<
      is_integral<Number>::value,
      integer_difference<Number>,
      identity_<Number>
    >
{};


template<typename Number>
__attribute__((host)) __attribute__((device))
typename numeric_difference<Number>::type
numeric_distance(Number x, Number y)
{
  typedef typename numeric_difference<Number>::type difference_type;
  return difference_type(y) - difference_type(x);
}

}

}
# 22 "/usr/local/cuda-8.0/include/thrust/iterator/detail/counting_iterator.inl" 2

# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 24 "/usr/local/cuda-8.0/include/thrust/iterator/detail/counting_iterator.inl" 2

namespace thrust
{


template <typename Incrementable, typename System, typename Traversal, typename Difference>
  class counting_iterator;

namespace detail
{

template <typename Incrementable, typename System, typename Traversal, typename Difference>
  struct counting_iterator_base
{
  typedef typename thrust::detail::eval_if<

    thrust::detail::is_same<System,use_default>::value,
    thrust::detail::identity_<thrust::any_system_tag>,
    thrust::detail::identity_<System>
  >::type system;

  typedef typename thrust::detail::ia_dflt_help<
      Traversal,
      thrust::detail::eval_if<
          thrust::detail::is_numeric<Incrementable>::value,
          thrust::detail::identity_<random_access_traversal_tag>,
          thrust::iterator_traversal<Incrementable>
      >
  >::type traversal;



  typedef typename thrust::detail::ia_dflt_help<
    Difference,
    thrust::detail::eval_if<
      thrust::detail::is_numeric<Incrementable>::value,
        thrust::detail::eval_if<
          thrust::detail::is_integral<Incrementable>::value,
          thrust::detail::numeric_difference<Incrementable>,
          thrust::detail::identity_<std::ptrdiff_t>
        >,
      thrust::iterator_difference<Incrementable>
    >
  >::type difference;





  typedef thrust::iterator_adaptor<
    counting_iterator<Incrementable, System, Traversal, Difference>,
    Incrementable,
    Incrementable,
    system,
    traversal,
    Incrementable,
    difference
  > type;
};


template<typename Difference, typename Incrementable1, typename Incrementable2>
  struct iterator_distance
{
  __attribute__((host)) __attribute__((device))
  static Difference distance(Incrementable1 x, Incrementable2 y)
  {
    return y - x;
  }
};


template<typename Difference, typename Incrementable1, typename Incrementable2>
  struct number_distance
{
  __attribute__((host)) __attribute__((device))
  static Difference distance(Incrementable1 x, Incrementable2 y)
  {
      return static_cast<Difference>(numeric_distance(x,y));
  }
};


template<typename Difference, typename Incrementable1, typename Incrementable2, typename Enable = void>
  struct counting_iterator_equal
{
  __attribute__((host)) __attribute__((device))
  static bool equal(Incrementable1 x, Incrementable2 y)
  {
    return x == y;
  }
};



template<typename Difference, typename Incrementable1, typename Incrementable2>
  struct counting_iterator_equal<
    Difference,
    Incrementable1,
    Incrementable2,
    typename thrust::detail::enable_if<
      thrust::detail::is_floating_point<Incrementable1>::value ||
      thrust::detail::is_floating_point<Incrementable2>::value
    >::type
  >
{
  __attribute__((host)) __attribute__((device))
  static bool equal(Incrementable1 x, Incrementable2 y)
  {
    typedef number_distance<Difference,Incrementable1,Incrementable2> d;
    return d::distance(x,y) == 0;
  }
};


}
}
# 41 "/usr/local/cuda-8.0/include/thrust/iterator/counting_iterator.h" 2

namespace thrust
{
# 128 "/usr/local/cuda-8.0/include/thrust/iterator/counting_iterator.h"
template<typename Incrementable,
         typename System = use_default,
         typename Traversal = use_default,
         typename Difference = use_default>
  class counting_iterator
    : public detail::counting_iterator_base<Incrementable, System, Traversal, Difference>::type
{


    typedef typename detail::counting_iterator_base<Incrementable, System, Traversal, Difference>::type super_t;

    friend class thrust::iterator_core_access;

  public:
    typedef typename super_t::reference reference;
    typedef typename super_t::difference_type difference_type;







    __attribute__((host)) __attribute__((device))
    counting_iterator(void){};






    __attribute__((host)) __attribute__((device))
    counting_iterator(counting_iterator const &rhs):super_t(rhs.base()){}






    template<typename OtherSystem>
    __attribute__((host)) __attribute__((device))
    counting_iterator(counting_iterator<Incrementable, OtherSystem, Traversal, Difference> const &rhs,
                      typename thrust::detail::enable_if_convertible<
                        typename thrust::iterator_system<counting_iterator<Incrementable,OtherSystem,Traversal,Difference> >::type,
                        typename thrust::iterator_system<super_t>::type
                      >::type * = 0)
      : super_t(rhs.base()){}







    __attribute__((host)) __attribute__((device))
    explicit counting_iterator(Incrementable x):super_t(x){}



  private:
    __attribute__((host)) __attribute__((device))
    reference dereference(void) const
    {
      return this->base_reference();
    }


    template <typename OtherIncrementable, typename OtherSystem, typename OtherTraversal, typename OtherDifference>
    __attribute__((host)) __attribute__((device))
    bool equal(counting_iterator<OtherIncrementable, OtherSystem, OtherTraversal, OtherDifference> const& y) const
    {
      typedef thrust::detail::counting_iterator_equal<difference_type,Incrementable,OtherIncrementable> e;
      return e::equal(this->base(), y.base());
    }

    template <class OtherIncrementable>
    __attribute__((host)) __attribute__((device))
    difference_type
    distance_to(counting_iterator<OtherIncrementable, System, Traversal, Difference> const& y) const
    {
      typedef typename
      thrust::detail::eval_if<
        thrust::detail::is_numeric<Incrementable>::value,
        thrust::detail::identity_<thrust::detail::number_distance<difference_type, Incrementable, OtherIncrementable> >,
        thrust::detail::identity_<thrust::detail::iterator_distance<difference_type, Incrementable, OtherIncrementable> >
      >::type d;

      return d::distance(this->base(), y.base());
    }



};
# 229 "/usr/local/cuda-8.0/include/thrust/iterator/counting_iterator.h"
template <typename Incrementable>
inline __attribute__((host)) __attribute__((device))
counting_iterator<Incrementable> make_counting_iterator(Incrementable x)
{
  return counting_iterator<Incrementable>(x);
}







}
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/join_iterator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/join_iterator.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/iterator/detail/join_iterator.h"
namespace thrust
{
namespace detail
{


template<typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Difference,
         typename Reference>
class join_iterator;


namespace join_iterator_detail
{


template<typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Difference,
         typename Reference>
struct join_iterator_base
{
  typedef typename thrust::detail::remove_reference<Reference>::type value_type;

  typedef typename thrust::iterator_system<RandomAccessIterator1>::type system1;
  typedef typename thrust::iterator_system<RandomAccessIterator2>::type system2;
  typedef typename thrust::detail::minimum_system<system1,system2>::type system;

  typedef thrust::iterator_adaptor<
    join_iterator<RandomAccessIterator1,RandomAccessIterator2,Difference,Reference>,
    thrust::counting_iterator<Difference>,
    value_type,
    system,
    thrust::random_access_traversal_tag,
    Reference,
    Difference
  > type;
};


}


template<typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Difference = typename thrust::iterator_difference<RandomAccessIterator1>::type,
         typename Reference = typename thrust::iterator_value<RandomAccessIterator1>::type>
class join_iterator
  : public join_iterator_detail::join_iterator_base<RandomAccessIterator1, RandomAccessIterator2, Difference, Reference>::type
{
  private:
    typedef typename join_iterator_detail::join_iterator_base<RandomAccessIterator1, RandomAccessIterator2, Difference, Reference>::type super_t;
    typedef typename super_t::difference_type size_type;

  public:
    inline __attribute__((host)) __attribute__((device))
    join_iterator(RandomAccessIterator1 first1, size_type n, RandomAccessIterator2 first2)
      : super_t(thrust::counting_iterator<size_type>(0)),
        m_n1(n),
        m_iter1(first1),
        m_iter2(first2 - m_n1)
    {}


    inline __attribute__((host)) __attribute__((device))
    join_iterator(const join_iterator &other)
      : super_t(other),
        m_n1(other.m_n1),
        m_iter1(other.m_iter1),
        m_iter2(other.m_iter2)
    {}


  private:
    friend class thrust::iterator_core_access;


    __attribute__((host)) __attribute__((device))
    typename super_t::reference dereference() const
    {
      size_type i = *super_t::base();
      return (i < m_n1) ? m_iter1[i] : static_cast<typename super_t::reference>(m_iter2[i]);
    }


    size_type m_n1;
    RandomAccessIterator1 m_iter1;
    RandomAccessIterator2 m_iter2;
};


template<typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
join_iterator<RandomAccessIterator1,RandomAccessIterator2,Size> make_join_iterator(RandomAccessIterator1 first1, Size n1, RandomAccessIterator2 first2)
{
  return join_iterator<RandomAccessIterator1,RandomAccessIterator2,Size>(first1, n1, first2);
}


}
}
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp" 2



namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2, typename Compare>
__attribute__((device))
Size merge_path(RandomAccessIterator1 first1, Size n1,
                RandomAccessIterator2 first2, Size n2,
                Size diag,
                Compare comp)
{
  Size begin = thrust::max<Size>(Size(0), diag - n2);
  Size end = thrust::min<Size>(diag, n1);

  while(begin < end)
  {
    Size mid = (begin + end) >> 1;

    if(comp(first2[diag - 1 - mid], first1[mid]))
    {
      end = mid;
    }
    else
    {
      begin = mid + 1;
    }
  }

  return begin;
}


template<std::size_t bound,
         std::size_t grainsize,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Compare>
__attribute__((device))
OutputIterator merge(const bulk_::bounded<bound,agent<grainsize> > &e,
                     InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result,
                     Compare comp)
{
  typedef typename bulk_::bounded<bound,bulk_::agent<grainsize> >::size_type size_type;

  typedef typename thrust::iterator_value<InputIterator1>::type value_type1;
  typedef typename thrust::iterator_value<InputIterator2>::type value_type2;

  size_type n = (last1 - first1) + (last2 - first2);



  value_type1 key_a;
  size_type n1 = last1 - first1;
  size_type idx1 = 0;

  if(n1 > 0)
  {

    key_a = first1[idx1];
  }


  value_type2 key_b;
  size_type n2 = last2 - first2;
  size_type idx2 = 0;

  if(n2 > 0)
  {

    key_b = first2[idx2];
  }


  if(bound <= n)
  {
    for(size_type i = 0; i < grainsize; ++i)
    {
      bool p = (idx2 >= n2) || ((idx1 < n1) && !comp(key_b, key_a));

      result[i] = p ? key_a : key_b;

      if(p)
      {
        ++idx1;


        key_a = first1[min(idx1, n1 - 1)];
      }
      else
      {
        ++idx2;


        key_b = first2[min(idx2, n2 - 1)];
      }
    }
  }
  else
  {
    for(size_type i = 0; i < grainsize; ++i)
    {
      if(i < n)
      {
        bool p = (idx2 >= n2) || ((idx1 < n1) && !comp(key_b, key_a));

        result[i] = p ? key_a : key_b;

        if(p)
        {
          ++idx1;


          key_a = first1[min(idx1, n1 - 1)];
        }
        else
        {
          ++idx2;


          key_b = first2[min(idx2, n2 - 1)];
        }
      }
    }
  }
# 169 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
  return result + n;
}


template<std::size_t bound, std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename RandomAccessIterator4,
         typename RandomAccessIterator5,
         typename RandomAccessIterator6,
         typename Compare>
__attribute__((device))
thrust::pair<RandomAccessIterator5,RandomAccessIterator6>
  merge_by_key(const bulk_::bounded<bound,bulk_::agent<grainsize> > &,
               RandomAccessIterator1 keys_first1, RandomAccessIterator1 keys_last1,
               RandomAccessIterator2 keys_first2, RandomAccessIterator2 keys_last2,
               RandomAccessIterator3 values_first1,
               RandomAccessIterator4 values_first2,
               RandomAccessIterator5 keys_result,
               RandomAccessIterator6 values_result,
               Compare comp)
{
  typedef typename bulk_::bounded<bound,bulk_::agent<grainsize> >::size_type size_type;

  typedef typename thrust::iterator_value<RandomAccessIterator1>::type key_type1;
  typedef typename thrust::iterator_value<RandomAccessIterator2>::type key_type2;

  typedef typename thrust::iterator_value<RandomAccessIterator3>::type value_type1;
  typedef typename thrust::iterator_value<RandomAccessIterator4>::type value_type2;

  size_type n = (keys_last1 - keys_first1) + (keys_last2 - keys_first2);




  key_type1 key_a;
  value_type1 val_a;
  size_type n1 = keys_last1 - keys_first1;
  size_type idx1 = 0;

  if(n1 > 0)
  {


    key_a = keys_first1[idx1];
    val_a = values_first1[idx1];
  }



  key_type2 key_b;
  value_type2 val_b;
  size_type n2 = keys_last2 - keys_first2;
  size_type idx2 = 0;

  if(n2 > 0)
  {


    key_b = keys_first2[idx2];
    val_b = values_first2[idx2];
  }


  if(bound <= n)
  {
    for(size_type i = 0; i < grainsize; ++i)
    {
      bool p = (idx2 >= n2) || ((idx1 < n1) && !comp(key_b, key_a));

      keys_result[i] = p ? key_a : key_b;
      values_result[i] = p ? val_a : val_b;

      if(p)
      {
        ++idx1;


        key_a = keys_first1[min(idx1, n1 - 1)];
        val_a = values_first1[min(idx1, n1 - 1)];
      }
      else
      {
        ++idx2;


        key_b = keys_first2[min(idx2, n2 - 1)];
        val_b = values_first2[min(idx2, n2 - 1)];
      }
    }
  }
  else
  {
    for(size_type i = 0; i < grainsize; ++i)
    {
      if(i < n)
      {
        bool p = (idx2 >= n2) || ((idx1 < n1) && !comp(key_b, key_a));

        keys_result[i] = p ? key_a : key_b;
        values_result[i] = p ? val_a : val_b;

        if(p)
        {
          ++idx1;


          key_a = keys_first1[min(idx1, n1 - 1)];
          val_a = values_first1[min(idx1, n1 - 1)];
        }
        else
        {
          ++idx2;


          key_b = keys_first2[min(idx2, n2 - 1)];
          val_b = values_first2[min(idx2, n2 - 1)];
        }
      }
    }
  }
# 304 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
  return thrust::make_pair(keys_result + n, values_result + n);
}


template<std::size_t bound, std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator, typename Compare>
__attribute__((device))
typename thrust::detail::enable_if<
  (bound <= groupsize * grainsize)
>::type
inplace_merge(bulk_::bounded<
                bound,
                bulk_::concurrent_group<
                  bulk_::agent<grainsize>,
                  groupsize
                >
              > &g,
              RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last,
              Compare comp)
{
  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;

  size_type n1 = middle - first;
  size_type n2 = last - middle;


  size_type local_offset = grainsize * g.this_exec.index();

  size_type mp = bulk_::merge_path(first, n1, middle, n2, local_offset, comp);


  size_type local_offset1 = mp;
  size_type local_offset2 = n1 + local_offset - mp;

  typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;
  value_type local_result[grainsize];
  bulk_::merge(bulk_::bound<grainsize>(g.this_exec),
              first + local_offset1, middle,
              first + local_offset2, last,
              local_result,
              comp);

  g.wait();



  size_type local_size = thrust::max<size_type>(0, thrust::min<size_type>(grainsize, n1 + n2 - local_offset));
  bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), local_result, local_size, first + local_offset);

  g.wait();
}


template<std::size_t bound, std::size_t groupsize, std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename Compare>
__attribute__((device))
typename thrust::detail::enable_if<
  (bound <= groupsize * grainsize),
  RandomAccessIterator3
>::type
merge(bulk_::bounded<
        bound,
        bulk_::concurrent_group<
          bulk_::agent<grainsize>,
          groupsize
        >
      > &g,
      RandomAccessIterator1 first1, RandomAccessIterator1 last1,
      RandomAccessIterator2 first2, RandomAccessIterator2 last2,
      RandomAccessIterator3 result,
      Compare comp)
{
  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;

  size_type n1 = last1 - first1;
  size_type n2 = last2 - first2;


  size_type local_offset = grainsize * g.this_exec.index();

  size_type mp = bulk_::merge_path(first1, n1, first2, n2, local_offset, comp);


  size_type local_offset1 = mp;
  size_type local_offset2 = local_offset - mp;

  typedef typename thrust::iterator_value<RandomAccessIterator3>::type value_type;
  value_type local_result[grainsize];
  bulk_::merge(bulk_::bound<grainsize>(g.this_exec),
              first1 + local_offset1, last1,
              first2 + local_offset2, last2,
              local_result,
              comp);



  size_type local_size = thrust::max<size_type>(0, thrust::min<size_type>(grainsize, n1 + n2 - local_offset));
  bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), local_result, local_size, result + local_offset);

  g.wait();

  return result + thrust::min<size_type>(groupsize * grainsize, n1 + n2);
}


namespace detail
{
namespace merge_detail
{



template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator1, typename RandomAccessIterator2, typename RandomAccessIterator3, typename RandomAccessIterator4, typename Compare>
__attribute__((device))
RandomAccessIterator4
  bounded_merge_with_buffer(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &exec,
                            RandomAccessIterator1 first1, RandomAccessIterator1 last1,
                            RandomAccessIterator2 first2, RandomAccessIterator2 last2,
                            RandomAccessIterator3 buffer,
                            RandomAccessIterator4 result,
                            Compare comp)
{
  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;

  size_type n1 = last1 - first1;
  size_type n2 = last2 - first2;


  bulk_::copy_n(bulk_::bound<groupsize * grainsize>(exec),
               thrust::detail::make_join_iterator(first1, n1, first2),
               n1 + n2,
               buffer);


  bulk_::inplace_merge(bulk_::bound<groupsize * grainsize>(exec),
                      buffer, buffer + n1, buffer + n1 + n2,
                      comp);



  return bulk_::copy_n(exec, buffer, n1 + n2, result);
}


}
}


template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator1, typename RandomAccessIterator2, typename RandomAccessIterator3, typename Compare>
__attribute__((device))
RandomAccessIterator3 merge(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &exec,
                            RandomAccessIterator1 first1, RandomAccessIterator1 last1,
                            RandomAccessIterator2 first2, RandomAccessIterator2 last2,
                            RandomAccessIterator3 result,
                            Compare comp)
{
  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;

  typedef typename thrust::iterator_value<RandomAccessIterator3>::type value_type;

  value_type *buffer = reinterpret_cast<value_type*>(bulk_::malloc(exec, exec.size() * exec.grainsize() * sizeof(value_type)));

  size_type chunk_size = exec.size() * exec.this_exec.grainsize();

  size_type n1 = last1 - first1;
  size_type n2 = last2 - first2;


  if(n1 + n2 <= chunk_size)
  {
    result = detail::merge_detail::bounded_merge_with_buffer(exec, first1, last1, first2, last2, buffer, result, comp);
  }
  else
  {
    while((first1 < last1) || (first2 < last2))
    {
      size_type n1 = last1 - first1;
      size_type n2 = last2 - first2;

      size_type diag = thrust::min<size_type>(chunk_size, n1 + n2);

      size_type mp = bulk_::merge_path(first1, n1, first2, n2, diag, comp);

      result = detail::merge_detail::bounded_merge_with_buffer(exec,
                                                               first1, first1 + mp,
                                                               first2, first2 + diag - mp,
                                                               buffer,
                                                               result,
                                                               comp);

      first1 += mp;
      first2 += diag - mp;
    }
  }

  bulk_::free(exec, buffer);

  return result;
}


template<std::size_t groupsize, std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename RandomAccessIterator4,
         typename RandomAccessIterator5,
         typename RandomAccessIterator6,
         typename Compare>
__attribute__((device))
thrust::pair<RandomAccessIterator5,RandomAccessIterator6>
merge_by_key(bulk_::bounded<
               groupsize*grainsize,
               bulk_::concurrent_group<bulk_::agent<grainsize>, groupsize>
             > &g,
             RandomAccessIterator1 keys_first1, RandomAccessIterator1 keys_last1,
             RandomAccessIterator2 keys_first2, RandomAccessIterator2 keys_last2,
             RandomAccessIterator3 values_first1,
             RandomAccessIterator4 values_first2,
             RandomAccessIterator5 keys_result,
             RandomAccessIterator6 values_result,
             Compare comp)
{
  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;

  typedef typename thrust::iterator_value<RandomAccessIterator5>::type key_type;
# 542 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
  __attribute__((shared)) union
  {
    key_type keys[groupsize * grainsize];
    size_type indices[groupsize * grainsize];
  } stage;


  size_type n1 = keys_last1 - keys_first1;
  size_type n2 = keys_last2 - keys_first2;
  size_type n = n1 + n2;


  bulk_::copy_n(g,
               thrust::detail::make_join_iterator(keys_first1, n1, keys_first2),
               n,
               stage.keys);


  size_type diag = thrust::min<size_type>(n1 + n2, grainsize * g.this_exec.index());
  size_type mp = bulk_::merge_path(stage.keys, n1, stage.keys + n1, n2, diag, comp);


  size_type start1 = mp;
  size_type start2 = n1 + diag - mp;

  size_type end1 = n1;
  size_type end2 = n1 + n2;


  key_type results[grainsize];
  size_type indices[grainsize];
  bulk_::merge_by_key(bulk_::bound<grainsize>(g.this_exec),
                     stage.keys + start1, stage.keys + end1,
                     stage.keys + start2, stage.keys + end2,
                     thrust::make_counting_iterator<size_type>(start1),
                     thrust::make_counting_iterator<size_type>(start2),
                     results,
                     indices,
                     comp);
  g.wait();


  size_type local_offset = grainsize * g.this_exec.index();
  size_type local_size = thrust::max<size_type>(0, thrust::min<size_type>(grainsize, n - local_offset));
  bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), results, local_size, stage.keys + local_offset);
  g.wait();


  keys_result = bulk_::copy_n(g, stage.keys, n, keys_result);


  bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), indices, local_size, stage.indices + local_offset);
  g.wait();


  values_result = bulk_::gather(g,
                               stage.indices, stage.indices + n,
                               thrust::detail::make_join_iterator(values_first1, n1, values_first2),
                               values_result);





  return thrust::make_pair(keys_result, values_result);
}


}
} } } }
# 25 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/scatter.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/scatter.hpp"
       




namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename RandomAccessIterator4>
__inline__ __attribute__((always_inline)) __attribute__((device))
void scatter_if(const bounded<bound,agent<grainsize> > &exec,
                RandomAccessIterator1 first,
                RandomAccessIterator1 last,
                RandomAccessIterator2 map,
                RandomAccessIterator3 stencil,
                RandomAccessIterator4 result)
{
  typedef int size_type;

  size_type n = last - first;

  for(size_type i = 0; i < bound; ++i)
  {
    if(i < n && stencil[i])
    {
      result[map[i]] = first[i];
    }
  }
}


template<std::size_t bound,
         std::size_t groupsize,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename RandomAccessIterator4>
__attribute__((device))
typename thrust::detail::enable_if<
  bound <= groupsize * grainsize
>::type
scatter_if(bulk_::bounded<
             bound,
             bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>
           > &g,
           RandomAccessIterator1 first,
           RandomAccessIterator1 last,
           RandomAccessIterator2 map,
           RandomAccessIterator3 stencil,
           RandomAccessIterator4 result)
{
  typedef typename bulk_::bounded<
    bound,
    bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>
  >::size_type size_type;

  size_type n = last - first;

  size_type tid = g.this_exec.index();


  if(n == bound)
  {
    for(size_type i = 0; i < g.this_exec.grainsize(); ++i)
    {
      size_type idx = g.size() * i + tid;

      if(stencil[idx])
      {
        result[map[idx]] = first[idx];
      }
    }
  }
  else if(n < bound)
  {
    for(size_type i = 0; i < g.this_exec.grainsize(); ++i)
    {
      size_type idx = g.size() * i + tid;

      if(idx < (last - first) && stencil[idx])
      {
        result[map[idx]] = first[idx];
      }
    }
  }

  g.wait();
}


template<std::size_t groupsize,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename RandomAccessIterator4>
__attribute__((device))
void scatter_if(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &g,
                RandomAccessIterator1 first,
                RandomAccessIterator1 last,
                RandomAccessIterator2 map,
                RandomAccessIterator3 stencil,
                RandomAccessIterator4 result)
{
  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;

  size_type chunk_size = g.size() * grainsize;

  size_type n = last - first;

  size_type tid = g.this_exec.index();


  if(chunk_size == n)
  {
    for(size_type i = 0; i < grainsize; ++i)
    {
      size_type idx = g.size() * i + tid;

      if(stencil[idx])
      {
        result[map[idx]] = first[idx];
      }
    }
  }
  else if(n < chunk_size)
  {
    for(size_type i = 0; i < grainsize; ++i)
    {
      size_type idx = g.size() * i + tid;

      if(idx < (last - first) && stencil[idx])
      {
        result[map[idx]] = first[idx];
      }
    }
  }
  else
  {
    for(;
        first < last;
        first += chunk_size, map += chunk_size, stencil += chunk_size)
    {
      if((last - first) >= chunk_size)
      {

        for(size_type i = 0; i < grainsize; ++i)
        {
          size_type idx = g.size() * i + tid;

          if(stencil[idx])
          {
            result[map[idx]] = first[idx];
          }
        }
      }
      else
      {
        for(size_type i = 0; i < grainsize; ++i)
        {
          size_type idx = g.size() * i + tid;

          if(idx < (last - first) && stencil[idx])
          {
            result[map[idx]] = first[idx];
          }
        }
      }
    }
  }

  g.wait();
}


}
} } } }
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/adjacent_difference.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/adjacent_difference.hpp"
       




namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{


template<std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename T,
         typename BinaryOperation>
__attribute__((device))
RandomAccessIterator2 adjacent_difference(bulk_::agent<grainsize> &exec,
                                          RandomAccessIterator1 first, RandomAccessIterator1 last,
                                          RandomAccessIterator2 result,
                                          T init,
                                          BinaryOperation binary_op)
{
  for(; first != last; ++first, ++result)
  {
    T temp = *first;
    *result = binary_op(temp, init);
    init = temp;
  }

  return result;
}


template<std::size_t groupsize,
         std::size_t grainsize_,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename T,
         typename BinaryOperation>
__attribute__((device))
RandomAccessIterator2 adjacent_difference(bulk_::concurrent_group<bulk_::agent<grainsize_>,groupsize> &g,
                                          RandomAccessIterator1 first, RandomAccessIterator1 last,
                                          RandomAccessIterator2 result,
                                          T init,
                                          BinaryOperation binary_op)
{




  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize_>,groupsize>::size_type size_type;

  RandomAccessIterator2 return_me = result + (last - first);

  const size_type grainsize = g.this_exec.grainsize();
  const size_type tile_size = g.size() * grainsize;


  RandomAccessIterator1 first_init = first + grainsize * g.this_exec.index() - 1;
  if(first <= first_init && first_init < last)
  {
    init = *first_init;
  }

  g.wait();

  for(; first < last; first += tile_size, result += tile_size)
  {
    size_type local_offset = grainsize * g.this_exec.index();
    size_type local_size = thrust::max(0, thrust::min<size_type>(grainsize, last - (first + local_offset)));


    T next_init = (first + local_offset + tile_size - 1 < last) ? first[tile_size-1] : init;

    g.wait();


    bulk_::adjacent_difference(g.this_exec,
                              first + local_offset,
                              first + local_offset + local_size,
                              result + local_offset,
                              init,
                              binary_op);

    init = next_init;
  }

  g.wait();

  return return_me;
}


template<std::size_t groupsize,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename BinaryOperation>
__attribute__((device))
RandomAccessIterator2 adjacent_difference(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &g,
                                          RandomAccessIterator1 first, RandomAccessIterator1 last,
                                          RandomAccessIterator2 result,
                                          BinaryOperation binary_op)
{
  if(first < last)
  {
    typename thrust::iterator_value<RandomAccessIterator1>::type init = *first;


    g.wait();

    if(g.this_exec.index() == 0)
    {
      *result = init;
    }

    result = bulk_::adjacent_difference(g, first + 1, last, result + 1, init, binary_op);
  }

  return result;
}


}
} } } }
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/reduce_by_key.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/reduce_by_key.hpp"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/head_flags.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/head_flags.hpp"
       


# 1 "/usr/local/cuda-8.0/include/thrust/iterator/transform_iterator.h" 1
# 33 "/usr/local/cuda-8.0/include/thrust/iterator/transform_iterator.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/transform_iterator.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/iterator/detail/transform_iterator.inl"
namespace thrust
{

template <class UnaryFunction, class Iterator, class Reference, class Value>
  class transform_iterator;

namespace detail
{


template <class UnaryFunc, class Iterator, class Reference, class Value>
struct transform_iterator_base
{
 private:

    typedef typename thrust::detail::ia_dflt_help<
      Reference,
      thrust::detail::result_of_adaptable_function<UnaryFunc(typename thrust::iterator_value<Iterator>::type)>
    >::type reference;






    typedef typename thrust::detail::ia_dflt_help<
      Value,
      thrust::detail::remove_reference<reference>
    >::type cv_value_type;

 public:
    typedef thrust::iterator_adaptor
    <
        transform_iterator<UnaryFunc, Iterator, Reference, Value>
      , Iterator
      , cv_value_type
      , thrust::use_default




        , typename thrust::iterator_traits<Iterator>::iterator_category
      , reference
    > type;
};


}
}
# 39 "/usr/local/cuda-8.0/include/thrust/iterator/transform_iterator.h" 2




namespace thrust
{
# 189 "/usr/local/cuda-8.0/include/thrust/iterator/transform_iterator.h"
template <class AdaptableUnaryFunction, class Iterator, class Reference = use_default, class Value = use_default>
  class transform_iterator
    : public detail::transform_iterator_base<AdaptableUnaryFunction, Iterator, Reference, Value>::type
{


  public:
    typedef typename
    detail::transform_iterator_base<AdaptableUnaryFunction, Iterator, Reference, Value>::type
    super_t;

    friend class thrust::iterator_core_access;



  public:


    __attribute__((host)) __attribute__((device))
    transform_iterator() {}







    __attribute__((host)) __attribute__((device))
    transform_iterator(Iterator const& x, AdaptableUnaryFunction f)
      : super_t(x), m_f(f) {
    }






    __attribute__((host)) __attribute__((device))
    explicit transform_iterator(Iterator const& x)
      : super_t(x) { }






    template<typename OtherAdaptableUnaryFunction,
             typename OtherIterator,
             typename OtherReference,
             typename OtherValue>
    __attribute__((host)) __attribute__((device))
    transform_iterator(const transform_iterator<OtherAdaptableUnaryFunction, OtherIterator, OtherReference, OtherValue> &other,
                       typename thrust::detail::enable_if_convertible<OtherIterator, Iterator>::type* = 0,
                       typename thrust::detail::enable_if_convertible<OtherAdaptableUnaryFunction, AdaptableUnaryFunction>::type* = 0)
      : super_t(other.base()), m_f(other.functor()) {}
# 255 "/usr/local/cuda-8.0/include/thrust/iterator/transform_iterator.h"
    __attribute__((host)) __attribute__((device))
    transform_iterator &operator=(const transform_iterator &other)
    {
      return do_assign(other,




          typename thrust::detail::is_copy_assignable<AdaptableUnaryFunction>::type()

      );
    }




    __attribute__((host)) __attribute__((device))
    AdaptableUnaryFunction functor() const
      { return m_f; }



  private:
    __attribute__((host)) __attribute__((device))
    transform_iterator &do_assign(const transform_iterator &other, thrust::detail::true_type)
    {
      super_t::operator=(other);


      m_f = other.functor();

      return *this;
    }

    __attribute__((host)) __attribute__((device))
    transform_iterator &do_assign(const transform_iterator &other, thrust::detail::false_type)
    {
      super_t::operator=(other);



      return *this;
    }

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    typename super_t::reference dereference() const
    {


      typename thrust::iterator_value<Iterator>::type x = *this->base();
      return m_f(x);
    }



    mutable AdaptableUnaryFunction m_f;



};
# 329 "/usr/local/cuda-8.0/include/thrust/iterator/transform_iterator.h"
template <class AdaptableUnaryFunction, class Iterator>
inline __attribute__((host)) __attribute__((device))
transform_iterator<AdaptableUnaryFunction, Iterator>
make_transform_iterator(Iterator it, AdaptableUnaryFunction fun)
{
  return transform_iterator<AdaptableUnaryFunction, Iterator>(it, fun);
}







}
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/head_flags.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/zip_iterator.h" 1
# 32 "/usr/local/cuda-8.0/include/thrust/iterator/zip_iterator.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/zip_iterator_base.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/zip_iterator_base.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/minimum_category.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/minimum_category.h"
       



namespace thrust
{

namespace detail
{

template<typename T1,
         typename T2 = minimum_type_detail::any_conversion,
         typename T3 = minimum_type_detail::any_conversion,
         typename T4 = minimum_type_detail::any_conversion,
         typename T5 = minimum_type_detail::any_conversion,
         typename T6 = minimum_type_detail::any_conversion,
         typename T7 = minimum_type_detail::any_conversion,
         typename T8 = minimum_type_detail::any_conversion,
         typename T9 = minimum_type_detail::any_conversion,
         typename T10 = minimum_type_detail::any_conversion,
         typename T11 = minimum_type_detail::any_conversion,
         typename T12 = minimum_type_detail::any_conversion,
         typename T13 = minimum_type_detail::any_conversion,
         typename T14 = minimum_type_detail::any_conversion,
         typename T15 = minimum_type_detail::any_conversion,
         typename T16 = minimum_type_detail::any_conversion>
  struct minimum_category
    : minimum_type<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16>
{
};

}

}
# 23 "/usr/local/cuda-8.0/include/thrust/iterator/detail/zip_iterator_base.h" 2







namespace thrust
{


template<typename IteratorTuple> class zip_iterator;

namespace detail
{




template<typename DiffType>
class advance_iterator
{
public:
  inline __attribute__((host)) __attribute__((device))
  advance_iterator(DiffType step) : m_step(step) {}

  #pragma nv_exec_check_disable
  template<typename Iterator>
  inline __attribute__((host)) __attribute__((device))
  void operator()(Iterator& it) const
  { it += m_step; }

private:
  DiffType m_step;
};


struct increment_iterator
{
  #pragma nv_exec_check_disable
  template<typename Iterator>
  inline __attribute__((host)) __attribute__((device))
  void operator()(Iterator& it)
  { ++it; }
};


struct decrement_iterator
{
  #pragma nv_exec_check_disable
  template<typename Iterator>
  inline __attribute__((host)) __attribute__((device))
  void operator()(Iterator& it)
  { --it; }
};


struct dereference_iterator
{
  template<typename Iterator>
  struct apply
  {
    typedef typename
      iterator_traits<Iterator>::reference
    type;
  };


  #pragma nv_exec_check_disable
  template<typename Iterator>
  __attribute__((host)) __attribute__((device))
    typename apply<Iterator>::type operator()(Iterator const& it)
  {
    return *it;
  }
};




namespace tuple_impl_specific
{


template<typename UnaryMetaFunctionClass, class Arg>
  struct apply1
    : UnaryMetaFunctionClass::template apply<Arg>
{
};



template<typename UnaryMetaFunctionClass, class Arg1, class Arg2>
  struct apply2
    : UnaryMetaFunctionClass::template apply<Arg1,Arg2>
{
};






template<class Tuple, class BinaryMetaFun, class StartType>
  struct tuple_meta_accumulate;

template<
    typename Tuple
  , class BinaryMetaFun
  , typename StartType
>
  struct tuple_meta_accumulate_impl
{
   typedef typename apply2<
       BinaryMetaFun
     , typename Tuple::head_type
     , typename tuple_meta_accumulate<
           typename Tuple::tail_type
         , BinaryMetaFun
         , StartType
       >::type
   >::type type;
};


template<
    typename Tuple
  , class BinaryMetaFun
  , typename StartType
>
struct tuple_meta_accumulate
  : thrust::detail::eval_if<
        thrust::detail::is_same<Tuple, thrust::null_type>::value
      , thrust::detail::identity_<StartType>
      , tuple_meta_accumulate_impl<
            Tuple
          , BinaryMetaFun
          , StartType
        >
    >
{
};
# 187 "/usr/local/cuda-8.0/include/thrust/iterator/detail/zip_iterator_base.h"
template<typename Fun>
inline __attribute__((host)) __attribute__((device))
Fun tuple_for_each(thrust::null_type, Fun f)
{
  return f;
}


template<typename Tuple, typename Fun>
inline __attribute__((host)) __attribute__((device))
Fun tuple_for_each(Tuple& t, Fun f)
{
  f( t.get_head() );
  return tuple_for_each(t.get_tail(), f);
}







__attribute__((host)) __attribute__((device))
inline bool tuple_equal(thrust::null_type, thrust::null_type)
{ return true; }


template<typename Tuple1, typename Tuple2>
__attribute__((host)) __attribute__((device))
bool tuple_equal(Tuple1 const& t1, Tuple2 const& t2)
{
  return t1.get_head() == t2.get_head() &&
  tuple_equal(t1.get_tail(), t2.get_tail());
}

}





template<typename IteratorTuple>
  struct tuple_of_value_types
    : tuple_meta_transform<
          IteratorTuple,
          iterator_value
        >
{
};


struct minimum_category_lambda
{
  template<typename T1, typename T2>
    struct apply : minimum_category<T1,T2>
  {};
};






template<typename IteratorTuple>
struct minimum_traversal_category_in_iterator_tuple
{
  typedef typename tuple_meta_transform<
      IteratorTuple
    , thrust::iterator_traversal
  >::type tuple_of_traversal_tags;

  typedef typename tuple_impl_specific::tuple_meta_accumulate<
      tuple_of_traversal_tags
    , minimum_category_lambda
    , thrust::random_access_traversal_tag
  >::type type;
};


struct minimum_system_lambda
{
  template<typename T1, typename T2>
    struct apply : minimum_system<T1,T2>
  {};
};





template<typename IteratorTuple>
struct minimum_system_in_iterator_tuple
{
  typedef typename thrust::detail::tuple_meta_transform<
    IteratorTuple,
    thrust::iterator_system
  >::type tuple_of_system_tags;

  typedef typename tuple_impl_specific::tuple_meta_accumulate<
    tuple_of_system_tags,
    minimum_system_lambda,
    thrust::any_system_tag
  >::type type;
};

namespace zip_iterator_base_ns
{


template<int i, typename Tuple>
  struct tuple_elements_helper
    : eval_if<
        (i < tuple_size<Tuple>::value),
        tuple_element<i,Tuple>,
        identity_<thrust::null_type>
      >
{};


template<typename Tuple>
  struct tuple_elements
{
  typedef typename tuple_elements_helper<0,Tuple>::type T0;
  typedef typename tuple_elements_helper<1,Tuple>::type T1;
  typedef typename tuple_elements_helper<2,Tuple>::type T2;
  typedef typename tuple_elements_helper<3,Tuple>::type T3;
  typedef typename tuple_elements_helper<4,Tuple>::type T4;
  typedef typename tuple_elements_helper<5,Tuple>::type T5;
  typedef typename tuple_elements_helper<6,Tuple>::type T6;
  typedef typename tuple_elements_helper<7,Tuple>::type T7;
  typedef typename tuple_elements_helper<8,Tuple>::type T8;
  typedef typename tuple_elements_helper<9,Tuple>::type T9;
};


template<typename IteratorTuple>
  struct tuple_of_iterator_references
{

  typedef typename tuple_meta_transform<
    IteratorTuple,
    iterator_reference
  >::type tuple_of_references;


  typedef tuple_elements<tuple_of_references> elements;


  typedef thrust::detail::tuple_of_iterator_references<
    typename elements::T0,
    typename elements::T1,
    typename elements::T2,
    typename elements::T3,
    typename elements::T4,
    typename elements::T5,
    typename elements::T6,
    typename elements::T7,
    typename elements::T8,
    typename elements::T9
  > type;
};


}
# 359 "/usr/local/cuda-8.0/include/thrust/iterator/detail/zip_iterator_base.h"
template<typename IteratorTuple>
  struct zip_iterator_base
{



    typedef typename zip_iterator_base_ns::tuple_of_iterator_references<IteratorTuple>::type reference;



    typedef typename tuple_of_value_types<IteratorTuple>::type value_type;


    typedef typename thrust::iterator_traits<
      typename thrust::tuple_element<0, IteratorTuple>::type
    >::difference_type difference_type;



    typedef typename
    minimum_system_in_iterator_tuple<IteratorTuple>::type system;



    typedef typename
    minimum_traversal_category_in_iterator_tuple<IteratorTuple>::type traversal_category;

 public:



    typedef thrust::iterator_facade<
        zip_iterator<IteratorTuple>,
        value_type,
        system,
        traversal_category,
        reference,
        difference_type
    > type;
};

}

}
# 36 "/usr/local/cuda-8.0/include/thrust/iterator/zip_iterator.h" 2



namespace thrust
{
# 139 "/usr/local/cuda-8.0/include/thrust/iterator/zip_iterator.h"
template <typename IteratorTuple>
  class zip_iterator
    : public detail::zip_iterator_base<IteratorTuple>::type
{
  public:


    inline __attribute__((host)) __attribute__((device))
    zip_iterator(void);






    inline __attribute__((host)) __attribute__((device))
    zip_iterator(IteratorTuple iterator_tuple);






    template<typename OtherIteratorTuple>
    inline __attribute__((host)) __attribute__((device))
    zip_iterator(const zip_iterator<OtherIteratorTuple> &other,
                 typename thrust::detail::enable_if_convertible<
                   OtherIteratorTuple,
                   IteratorTuple
                 >::type * = 0);







    inline __attribute__((host)) __attribute__((device))
    const IteratorTuple &get_iterator_tuple() const;



  private:
    typedef typename
    detail::zip_iterator_base<IteratorTuple>::type super_t;

    friend class thrust::iterator_core_access;



    __attribute__((host)) __attribute__((device))
    typename super_t::reference dereference() const;




    template<typename OtherIteratorTuple>
    inline __attribute__((host)) __attribute__((device))
    bool equal(const zip_iterator<OtherIteratorTuple> &other) const;


    inline __attribute__((host)) __attribute__((device))
    void advance(typename super_t::difference_type n);


    inline __attribute__((host)) __attribute__((device))
    void increment();


    inline __attribute__((host)) __attribute__((device))
    void decrement();


    template<typename OtherIteratorTuple>
    inline __attribute__((host)) __attribute__((device))
      typename super_t::difference_type
        distance_to(const zip_iterator<OtherIteratorTuple> &other) const;


    IteratorTuple m_iterator_tuple;



};
# 232 "/usr/local/cuda-8.0/include/thrust/iterator/zip_iterator.h"
template<typename IteratorTuple>
inline __attribute__((host)) __attribute__((device))
zip_iterator<IteratorTuple> make_zip_iterator(IteratorTuple t);







}

# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/zip_iterator.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/zip_iterator.inl"
       




namespace thrust
{


template<typename IteratorTuple>
__attribute__((host)) __attribute__((device))
  zip_iterator<IteratorTuple>
    ::zip_iterator(void)
{
}


template<typename IteratorTuple>
__attribute__((host)) __attribute__((device))
  zip_iterator<IteratorTuple>
    ::zip_iterator(IteratorTuple iterator_tuple)
      :m_iterator_tuple(iterator_tuple)
{
}


template<typename IteratorTuple>
  template<typename OtherIteratorTuple>
  __attribute__((host)) __attribute__((device))
    zip_iterator<IteratorTuple>
      ::zip_iterator(const zip_iterator<OtherIteratorTuple> &other,
                     typename thrust::detail::enable_if_convertible<
                       OtherIteratorTuple,
                       IteratorTuple
                     >::type *)
        :m_iterator_tuple(other.get_iterator_tuple())
{
}


template<typename IteratorTuple>
__attribute__((host)) __attribute__((device))
const IteratorTuple &zip_iterator<IteratorTuple>
  ::get_iterator_tuple(void) const
{
  return m_iterator_tuple;
}


template<typename IteratorTuple>
  typename zip_iterator<IteratorTuple>::super_t::reference
  __attribute__((host)) __attribute__((device))
    zip_iterator<IteratorTuple>
      ::dereference(void) const
{
  using namespace detail::tuple_impl_specific;

  return thrust::detail::tuple_host_device_transform<detail::dereference_iterator::template apply>(get_iterator_tuple(), detail::dereference_iterator());
}


 #pragma nv_exec_check_disable
template<typename IteratorTuple>
  template<typename OtherIteratorTuple>
  __attribute__((host)) __attribute__((device))
    bool zip_iterator<IteratorTuple>
      ::equal(const zip_iterator<OtherIteratorTuple> &other) const
{
  return get<0>(get_iterator_tuple()) == get<0>(other.get_iterator_tuple());
}


template<typename IteratorTuple>
__attribute__((host)) __attribute__((device))
  void zip_iterator<IteratorTuple>
    ::advance(typename super_t::difference_type n)
{
  using namespace detail::tuple_impl_specific;
  tuple_for_each(m_iterator_tuple,
                 detail::advance_iterator<typename super_t::difference_type>(n));
}


template<typename IteratorTuple>
__attribute__((host)) __attribute__((device))
  void zip_iterator<IteratorTuple>
    ::increment(void)
{
  using namespace detail::tuple_impl_specific;
  tuple_for_each(m_iterator_tuple, detail::increment_iterator());
}


template<typename IteratorTuple>
__attribute__((host)) __attribute__((device))
  void zip_iterator<IteratorTuple>
    ::decrement(void)
{
  using namespace detail::tuple_impl_specific;
  tuple_for_each(m_iterator_tuple, detail::decrement_iterator());
}


 #pragma nv_exec_check_disable
template<typename IteratorTuple>
  template <typename OtherIteratorTuple>
  __attribute__((host)) __attribute__((device))
    typename zip_iterator<IteratorTuple>::super_t::difference_type
      zip_iterator<IteratorTuple>
        ::distance_to(const zip_iterator<OtherIteratorTuple> &other) const
{
  return get<0>(other.get_iterator_tuple()) - get<0>(get_iterator_tuple());
}


template<typename IteratorTuple>
__attribute__((host)) __attribute__((device))
  zip_iterator<IteratorTuple> make_zip_iterator(IteratorTuple t)
{
  return zip_iterator<IteratorTuple>(t);
}


}
# 245 "/usr/local/cuda-8.0/include/thrust/iterator/zip_iterator.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/head_flags.hpp" 2





namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


template<typename RandomAccessIterator,
         typename BinaryPredicate = thrust::equal_to<typename thrust::iterator_value<RandomAccessIterator>::type>,
         typename ValueType = bool,
         typename IndexType = typename thrust::iterator_difference<RandomAccessIterator>::type>
  class head_flags_with_init
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type init_type;



  public:
    struct head_flag_functor
    {
      BinaryPredicate binary_pred;
      init_type init;
      IndexType n;

      typedef ValueType result_type;

      __attribute__((host)) __attribute__((device))
      head_flag_functor(init_type init, IndexType n)
        : binary_pred(), init(init), n(n)
      {}

      __attribute__((host)) __attribute__((device))
      head_flag_functor(init_type init, IndexType n, BinaryPredicate binary_pred)
        : binary_pred(binary_pred), init(init), n(n)
      {}

      template<typename Tuple>
      __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
      result_type operator()(const Tuple &t)
      {
        const IndexType i = thrust::get<0>(t);

        if(i == 0)
        {
          return !binary_pred(init, thrust::get<1>(t));
        }

        return !binary_pred(thrust::get<1>(t), thrust::get<2>(t));
      }
    };

    typedef thrust::counting_iterator<IndexType> counting_iterator;

  public:
    typedef thrust::transform_iterator<
      head_flag_functor,
      thrust::zip_iterator<thrust::tuple<counting_iterator,RandomAccessIterator,RandomAccessIterator> >
    > iterator;

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    head_flags_with_init(RandomAccessIterator first, RandomAccessIterator last, init_type init)
      : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(thrust::counting_iterator<IndexType>(0), first, first - 1)),
                                                head_flag_functor(init, last - first))),
        m_end(m_begin + (last - first))
    {}

    __attribute__((host)) __attribute__((device))
    head_flags_with_init(RandomAccessIterator first, RandomAccessIterator last, init_type init, BinaryPredicate binary_pred)
      : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(thrust::counting_iterator<IndexType>(0), first, first - 1)),
                                                head_flag_functor(init, last - first, binary_pred))),
        m_end(m_begin + (last - first))
    {}

    __attribute__((host)) __attribute__((device))
    iterator begin() const
    {
      return m_begin;
    }

    __attribute__((host)) __attribute__((device))
    iterator end() const
    {
      return m_end;
    }

    template<typename OtherIndex>
    __attribute__((host)) __attribute__((device))
    typename iterator::reference operator[](OtherIndex i)
    {
      return *(begin() + i);
    }

  private:
    iterator m_begin, m_end;
};



template<typename RandomAccessIterator,
         typename BinaryPredicate = thrust::equal_to<typename thrust::iterator_value<RandomAccessIterator>::type>,
         typename ValueType = bool,
         typename IndexType = typename thrust::iterator_difference<RandomAccessIterator>::type>

  class head_flags_
{


  public:
    struct head_flag_functor
    {
      BinaryPredicate binary_pred;
      IndexType n;

      typedef ValueType result_type;

      __attribute__((host)) __attribute__((device))
      head_flag_functor(IndexType n)
        : binary_pred(), n(n)
      {}

      __attribute__((host)) __attribute__((device))
      head_flag_functor(IndexType n, BinaryPredicate binary_pred)
        : binary_pred(binary_pred), n(n)
      {}

      template<typename Tuple>
      __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
      result_type operator()(const Tuple &t)
      {
        const IndexType i = thrust::get<0>(t);



        return (i == 0 || !binary_pred(thrust::get<1>(t), thrust::get<2>(t)));
      }
    };

    typedef thrust::counting_iterator<IndexType> counting_iterator;

  public:
    typedef thrust::transform_iterator<
      head_flag_functor,
      thrust::zip_iterator<thrust::tuple<counting_iterator,RandomAccessIterator,RandomAccessIterator> >
    > iterator;

    __attribute__((host)) __attribute__((device))

    head_flags_(RandomAccessIterator first, RandomAccessIterator last)
      : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(thrust::counting_iterator<IndexType>(0), first, first - 1)),
                                                head_flag_functor(last - first))),
        m_end(m_begin + (last - first))
    {}

    __attribute__((host)) __attribute__((device))

    head_flags_(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
      : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(thrust::counting_iterator<IndexType>(0), first, first - 1)),
                                                head_flag_functor(last - first, binary_pred))),
        m_end(m_begin + (last - first))
    {}

    __attribute__((host)) __attribute__((device))
    iterator begin() const
    {
      return m_begin;
    }

    __attribute__((host)) __attribute__((device))
    iterator end() const
    {
      return m_end;
    }

    template<typename OtherIndex>
    __attribute__((host)) __attribute__((device))
    typename iterator::reference operator[](OtherIndex i)
    {
      return *(begin() + i);
    }

  private:
    iterator m_begin, m_end;
};


template<typename RandomAccessIterator, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))

head_flags_<RandomAccessIterator, BinaryPredicate>
  make_head_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
{

  return head_flags_<RandomAccessIterator, BinaryPredicate>(first, last, binary_pred);
}


template<typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))

head_flags_<RandomAccessIterator>
  make_head_flags(RandomAccessIterator first, RandomAccessIterator last)
{

  return head_flags_<RandomAccessIterator>(first, last);
}


}
}
} } } }
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/reduce_by_key.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/tail_flags.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/tail_flags.hpp"
       
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/detail/tail_flags.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{


template<typename RandomAccessIterator,
         typename BinaryPredicate = thrust::equal_to<typename thrust::iterator_value<RandomAccessIterator>::type>,
         typename ValueType = bool,
         typename IndexType = typename thrust::iterator_difference<RandomAccessIterator>::type>
  class tail_flags_
{


  public:
    struct tail_flag_functor
    {
      BinaryPredicate binary_pred;
      RandomAccessIterator iter;
      IndexType n;

      typedef ValueType result_type;

      __attribute__((host)) __attribute__((device))
      tail_flag_functor(RandomAccessIterator first, RandomAccessIterator last)
        : binary_pred(), iter(first), n(last - first)
      {}

      __attribute__((host)) __attribute__((device))
      tail_flag_functor(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
        : binary_pred(binary_pred), iter(first), n(last - first)
      {}

      __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
      result_type operator()(const IndexType &i)
      {
        return (i == (n - 1) || !binary_pred(iter[i], iter[i+1]));
      }
    };

    typedef thrust::counting_iterator<IndexType> counting_iterator;

  public:
    typedef thrust::transform_iterator<
      tail_flag_functor,
      counting_iterator
    > iterator;

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    tail_flags_(RandomAccessIterator first, RandomAccessIterator last)
      : m_begin(thrust::make_transform_iterator(thrust::counting_iterator<IndexType>(0),
                                                tail_flag_functor(first, last))),
        m_end(m_begin + (last - first))
    {}

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    tail_flags_(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
      : m_begin(thrust::make_transform_iterator(thrust::counting_iterator<IndexType>(0),
                                                tail_flag_functor(first, last, binary_pred))),
        m_end(m_begin + (last - first))
    {}

    __attribute__((host)) __attribute__((device))
    iterator begin() const
    {
      return m_begin;
    }

    __attribute__((host)) __attribute__((device))
    iterator end() const
    {
      return m_end;
    }

    template<typename OtherIndex>
    __attribute__((host)) __attribute__((device))
    typename iterator::reference operator[](OtherIndex i)
    {
      return *(begin() + i);
    }

  private:
    iterator m_begin, m_end;
};


template<typename RandomAccessIterator, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))

tail_flags_<RandomAccessIterator, BinaryPredicate>
  make_tail_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
{

  return tail_flags_<RandomAccessIterator, BinaryPredicate>(first, last, binary_pred);
}


template<typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))

tail_flags_<RandomAccessIterator>
  make_tail_flags(RandomAccessIterator first, RandomAccessIterator last)
{

  return tail_flags_<RandomAccessIterator>(first, last);
}


}
}
} } } }
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/reduce_by_key.hpp" 2





namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{
namespace reduce_by_key_detail
{


template<typename FlagType, typename ValueType, typename BinaryFunction>
struct scan_head_flags_functor
{
  BinaryFunction binary_op;

  typedef thrust::tuple<FlagType,ValueType> result_type;
  typedef result_type first_argument_type;
  typedef result_type second_argument_type;

  __attribute__((host)) __attribute__((device))
  scan_head_flags_functor(BinaryFunction binary_op)
    : binary_op(binary_op)
  {}

  __attribute__((host)) __attribute__((device))
  result_type operator()(const first_argument_type &a, const second_argument_type &b)
  {
    ValueType val = thrust::get<0>(b) ? thrust::get<1>(b) : binary_op(thrust::get<1>(a), thrust::get<1>(b));
    FlagType flag = thrust::get<0>(a) + thrust::get<0>(b);
    return result_type(flag, val);
  }
};


template<typename ConcurrentGroup,
         typename InputIterator1,
         typename Size,
         typename InputIterator2,
         typename InputIterator3,
         typename OutputIterator1,
         typename OutputIterator2>
__attribute__((device))
void scatter_tails_n(ConcurrentGroup &group,
                     InputIterator1 flags_first,
                     Size n,
                     InputIterator2 keys_first,
                     InputIterator3 values_first,
                     OutputIterator1 keys_result,
                     OutputIterator2 values_result)
{
# 94 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/reduce_by_key.hpp"
  bulk_::scatter_if(group,
                   values_first,
                   values_first + n - 1,
                   thrust::make_transform_iterator(flags_first, thrust::placeholders::_1 - 1),
                   bulk_::detail::make_tail_flags(flags_first, flags_first + n).begin(),
                   values_result);

  bulk_::scatter_if(group,
                   keys_first,
                   keys_first + n - 1,
                   thrust::make_transform_iterator(flags_first, thrust::placeholders::_1 - 1),
                   bulk_::detail::make_tail_flags(flags_first, flags_first + n).begin(),
                   keys_result);

}


}
}


template<std::size_t groupsize,
         std::size_t grainsize,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename T1,
         typename T2,
         typename BinaryPredicate,
         typename BinaryFunction>
thrust::tuple<
  OutputIterator1,
  OutputIterator2,
  typename thrust::iterator_value<InputIterator1>::type,
  typename thrust::iterator_value<OutputIterator2>::type
>
__attribute__((device))
reduce_by_key(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &g,
              InputIterator1 keys_first, InputIterator1 keys_last,
              InputIterator2 values_first,
              OutputIterator1 keys_result,
              OutputIterator2 values_result,
              T1 init_key,
              T2 init_value,
              BinaryPredicate pred,
              BinaryFunction binary_op)
{
  typedef typename thrust::iterator_value<InputIterator2>::type value_type;

  typedef typename bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize>::size_type size_type;

  const size_type interval_size = groupsize * grainsize;





  __attribute__((shared)) uninitialized_array<size_type,interval_size> s_flags_impl;
  size_type *s_flags = s_flags_impl.data();

  __attribute__((shared)) uninitialized_array<value_type,interval_size> s_values_impl;
  value_type *s_values = s_values_impl.data();


  for(; keys_first < keys_last; keys_first += interval_size, values_first += interval_size)
  {

    size_type n = thrust::min<size_type>(interval_size, keys_last - keys_first);

    bulk_::detail::head_flags_with_init<
      InputIterator1,
      BinaryPredicate,
      size_type
    > flags(keys_first, keys_first + n, init_key, pred);

    detail::reduce_by_key_detail::scan_head_flags_functor<size_type, value_type, BinaryFunction> f(binary_op);


    bulk_::copy_n(bulk_::bound<interval_size>(g),
                 thrust::make_zip_iterator(thrust::make_tuple(flags.begin(), values_first)),
                 n,
                 thrust::make_zip_iterator(thrust::make_tuple(s_flags, s_values)));


    bulk_::inclusive_scan(bulk_::bound<interval_size>(g),
                         thrust::make_zip_iterator(thrust::make_tuple(s_flags, s_values)),
                         thrust::make_zip_iterator(thrust::make_tuple(s_flags + n, s_values)),
                         thrust::make_zip_iterator(thrust::make_tuple(s_flags, s_values)),
                         thrust::make_tuple(1, init_value),
                         f);


    detail::reduce_by_key_detail::scatter_tails_n(bulk_::bound<interval_size>(g),
                                                  s_flags, n,
                                                  keys_first, s_values,
                                                  keys_result, values_result);



    if(g.this_exec.index() == 0 && s_flags[0] > 1)
    {
      keys_result[0] = init_key;
      values_result[0] = init_value;
    }

    size_type result_size = s_flags[n - 1] - 1;

    keys_result += result_size;
    values_result += result_size;
    init_key = keys_first[n-1];
    init_value = s_values[n - 1];

    g.wait();
  }






  return thrust::make_tuple(keys_result, values_result, init_key, init_value);
}


}
} } } }
# 28 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/detail/stable_merge_sort.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/detail/stable_merge_sort.hpp"
       
# 28 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/detail/stable_merge_sort.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{



template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Compare>
__inline__ __attribute__((always_inline)) __attribute__((device))
void stable_sort_by_key(const bounded<bound,agent<grainsize> > &exec,
                        RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last,
                        RandomAccessIterator2 values_first,
                        Compare comp);


namespace detail
{
namespace stable_merge_sort_detail
{


template<std::size_t bound, std::size_t groupsize, std::size_t grainsize, typename KeyType, typename ValType, typename Compare>
__attribute__((device))
typename thrust::detail::enable_if<
  bound <= groupsize * grainsize
>::type
inplace_merge_adjacent_partitions(bulk_::bounded<bound,bulk_::concurrent_group<bulk_::agent<grainsize>, groupsize> > &g,
                                  KeyType local_keys[grainsize], ValType local_values[grainsize], void* stage_ptr, int count, int local_size, Compare comp)
{
  union stage_t
  {
    KeyType *keys;
    ValType *vals;
  };

  stage_t stage;
  stage.keys = reinterpret_cast<KeyType*>(stage_ptr);

  typedef typename bulk_::agent<grainsize>::size_type size_type;

  size_type local_offset = grainsize * g.this_exec.index();



  for(size_type num_agents_per_merge = 2; num_agents_per_merge <= groupsize; num_agents_per_merge *= 2)
  {

    bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), local_keys, local_size, stage.keys + local_offset);

    g.wait();


    size_type list = ~(num_agents_per_merge - 1) & g.this_exec.index();
    size_type diag = thrust::min<size_type>(count, grainsize * ((num_agents_per_merge - 1) & g.this_exec.index()));
    size_type start = grainsize * list;


    size_type input_size = grainsize * (num_agents_per_merge / 2);

    size_type partition_first1 = thrust::min<size_type>(count, start);
    size_type partition_first2 = thrust::min<size_type>(count, partition_first1 + input_size);
    size_type partition_last2 = thrust::min<size_type>(count, partition_first2 + input_size);

    size_type n1 = partition_first2 - partition_first1;
    size_type n2 = partition_last2 - partition_first2;

    size_type mp = bulk_::merge_path(stage.keys + partition_first1, n1, stage.keys + partition_first2, n2, diag, comp);



    size_type gather_indices[grainsize];
    bulk_::merge_by_key(bulk_::bound<grainsize>(g.this_exec),
                       stage.keys + partition_first1 + mp, stage.keys + partition_first2,
                       stage.keys + partition_first2 + diag - mp, stage.keys + partition_last2,
                       thrust::make_counting_iterator<size_type>(partition_first1 + mp),
                       thrust::make_counting_iterator<size_type>(partition_first2 + diag - mp),
                       local_keys,
                       gather_indices,
                       comp);


    bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), local_values, local_size, stage.vals + local_offset);


    bulk_::gather(bulk_::bound<grainsize>(g.this_exec), gather_indices, gather_indices + local_size, stage.vals, local_values);

    g.wait();
  }
}


}


template<std::size_t bound, std::size_t groupsize, std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Compare>
__attribute__((device))
typename thrust::detail::enable_if<
  bound <= groupsize * grainsize
>::type
stable_merge_sort_by_key(bulk_::bounded<bound,bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> > &g,
                         RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last,
                         RandomAccessIterator2 values_first,
                         Compare comp)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type key_type;
  typedef typename thrust::iterator_value<RandomAccessIterator2>::type value_type;

  typedef typename bulk_::agent<grainsize>::size_type size_type;

  size_type n = keys_last - keys_first;
  const size_type tile_size = groupsize * grainsize;

  size_type local_offset = grainsize * g.this_exec.index();
  size_type local_size = thrust::max<size_type>(0, thrust::min<size_type>(grainsize, n - local_offset));
# 158 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/detail/stable_merge_sort.hpp"
  __attribute__((shared)) union
  {
    key_type keys[tile_size];
    value_type values[tile_size];
  } stage;



  bulk_::copy_n(bulk_::bound<tile_size>(g), keys_first, n, stage.keys);

  key_type local_keys[grainsize];
  bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), stage.keys + local_offset, local_size, local_keys);


  bulk_::copy_n(bulk_::bound<tile_size>(g), values_first, n, stage.values);

  value_type local_values[grainsize];
  bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), stage.values + local_offset, local_size, local_values);


  bulk_::stable_sort_by_key(bulk_::bound<grainsize>(g.this_exec), local_keys, local_keys + local_size, local_values, comp);



  if(n == tile_size)
  {
    stable_merge_sort_detail::inplace_merge_adjacent_partitions(g, local_keys, local_values, stage.keys, tile_size, grainsize, comp);
  }
  else
  {
    stable_merge_sort_detail::inplace_merge_adjacent_partitions(g, local_keys, local_values, stage.keys, n, local_size, comp);
  }


  bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), local_keys, local_size, stage.keys + local_offset);
  g.wait();

  bulk_::copy_n(bulk_::bound<tile_size>(g), stage.keys, n, keys_first);


  bulk_::copy_n(bulk_::bound<grainsize>(g.this_exec), local_values, local_size, stage.values + local_offset);
  g.wait();

  bulk_::copy_n(bulk_::bound<tile_size>(g), stage.values, n, values_first);




}


}
}
} } } }
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp" 2


namespace thrust { namespace system { namespace cuda { namespace detail {
namespace bulk_
{
namespace detail
{
namespace sort_detail
{


template<int i, int bound>
struct stable_odd_even_transpose_sort_by_key_impl
{
  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Compare>
  static __attribute__((device))
  void sort(RandomAccessIterator1 keys, RandomAccessIterator2 values, int n, Compare comp)
  {
    for(int j = 1 & i; j < bound - 1; j += 2)
    {
      if(j + 1 < n && comp(keys[j + 1], keys[j]))
      {
        using thrust::swap;

       swap(keys[j], keys[j + 1]);
       swap(values[j], values[j + 1]);
      }
    }

    stable_odd_even_transpose_sort_by_key_impl<i + 1, bound>::sort(keys, values, n, comp);
  }
};


template<int i> struct stable_odd_even_transpose_sort_by_key_impl<i, i>
{
  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Compare>
  static __attribute__((device)) void sort(RandomAccessIterator1, RandomAccessIterator2, int, Compare) { }
};


template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Compare>
__inline__ __attribute__((always_inline)) __attribute__((device))
void stable_odd_even_transpose_sort_by_key(const bounded<bound,agent<grainsize> > &,
                                           RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last,
                                           RandomAccessIterator2 values_first,
                                           Compare comp)
{
  stable_odd_even_transpose_sort_by_key_impl<0, bound>::sort(keys_first, values_first, keys_last - keys_first, comp);
}


template<int i, int bound>
struct stable_odd_even_transpose_sort_impl
{
  template<typename RandomAccessIterator, typename Compare>
  static __attribute__((device))
  void sort(RandomAccessIterator keys, int n, Compare comp)
  {
    for(int j = 1 & i; j < bound - 1; j += 2)
    {
      if(j + 1 < n && comp(keys[j + 1], keys[j]))
      {
        using thrust::swap;

       swap(keys[j], keys[j + 1]);
      }
    }

    stable_odd_even_transpose_sort_impl<i + 1, bound>::sort(keys, n, comp);
  }
};


template<int i> struct stable_odd_even_transpose_sort_impl<i, i>
{
  template<typename RandomAccessIterator, typename Compare>
  static __attribute__((device)) void sort(RandomAccessIterator, int, Compare) { }
};


template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator,
         typename Compare>
__inline__ __attribute__((always_inline)) __attribute__((device))
void stable_odd_even_transpose_sort(const bounded<bound,agent<grainsize> > &,
                                    RandomAccessIterator first, RandomAccessIterator last,
                                    Compare comp)
{
  stable_odd_even_transpose_sort_impl<0, bound>::sort(first, last - first, comp);
}


}
}


template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Compare>
__inline__ __attribute__((always_inline)) __attribute__((device))
void stable_sort_by_key(const bounded<bound,agent<grainsize> > &exec,
                        RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last,
                        RandomAccessIterator2 values_first,
                        Compare comp)
{
  bulk_::detail::sort_detail::stable_odd_even_transpose_sort_by_key(exec, keys_first, keys_last, values_first, comp);
}


template<std::size_t bound,
         std::size_t grainsize,
         typename RandomAccessIterator,
         typename Compare>
__inline__ __attribute__((always_inline)) __attribute__((device))
void stable_sort(const bounded<bound,agent<grainsize> > &exec,
                 RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp)
{
  bulk_::detail::sort_detail::stable_odd_even_transpose_sort(exec, first, last, comp);
}


template<std::size_t bound, std::size_t groupsize, std::size_t grainsize,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Compare>
__attribute__((device))
typename thrust::detail::enable_if<
  bound <= groupsize * grainsize
>::type
stable_sort_by_key(bulk_::bounded<bound,bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> > &g,
                   RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first,
                   Compare comp)
{
  bulk_::detail::stable_merge_sort_by_key(g, keys_first, keys_last, values_first, comp);
}


}
} } } }
# 29 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/algorithm.hpp" 2
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/bulk.hpp" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/iterator.hpp" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/iterator.hpp"
       
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk/bulk.hpp" 2
# 48 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/bulk.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/for_each.inl" 2

# 1 "/usr/local/cuda-8.0/include/thrust/detail/seq.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/seq.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/detail/execute_with_allocator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/execute_with_allocator.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/detail/execute_with_allocator.h"
namespace thrust
{
namespace detail
{

template<typename ToPointer, typename FromPointer>
__attribute__((host)) __attribute__((device))
ToPointer reinterpret_pointer_cast(FromPointer ptr)
{
  typedef typename thrust::detail::pointer_element<ToPointer>::type to_element;
  return ToPointer(reinterpret_cast<to_element*>(thrust::raw_pointer_cast(ptr)));
}


template<typename Allocator, template <typename> class BaseSystem>
  struct execute_with_allocator
    : BaseSystem<execute_with_allocator<Allocator, BaseSystem> >
{
  typedef BaseSystem<
    execute_with_allocator<Allocator, BaseSystem>
  > super_t;

  Allocator &m_alloc;

  __attribute__((host)) __attribute__((device))
  execute_with_allocator(const super_t &super, Allocator &alloc)
    : super_t(super),
      m_alloc(alloc)
  {}

  __attribute__((host)) __attribute__((device))
  execute_with_allocator(Allocator &alloc)
    : m_alloc(alloc)
  {}

  template<typename T>
  __attribute__((host)) __attribute__((device))
    friend thrust::pair<T*,std::ptrdiff_t>
      get_temporary_buffer(execute_with_allocator &system, std::ptrdiff_t n)
  {
    typedef typename thrust::detail::allocator_traits<Allocator> alloc_traits;
    typedef typename alloc_traits::void_pointer void_pointer;
    typedef typename alloc_traits::size_type size_type;
    typedef typename alloc_traits::value_type value_type;


    size_type num_elements = thrust::detail::util::divide_ri(sizeof(T) * n, sizeof(value_type));


    void_pointer ptr = alloc_traits::allocate(system.m_alloc, num_elements);


    return thrust::make_pair(thrust::detail::reinterpret_pointer_cast<T*>(ptr),n);
  }

  template<typename Pointer>
    friend void return_temporary_buffer(execute_with_allocator &system, Pointer p)
  {
    typedef typename thrust::detail::allocator_traits<Allocator> alloc_traits;
    typedef typename alloc_traits::pointer pointer;


    pointer to_ptr = thrust::detail::reinterpret_pointer_cast<pointer>(p);
    alloc_traits::deallocate(system.m_alloc, to_ptr, 0);
  }
};


}
}
# 22 "/usr/local/cuda-8.0/include/thrust/detail/seq.h" 2


namespace thrust
{
namespace detail
{


struct seq_t : thrust::system::detail::sequential::execution_policy<seq_t>
{
  __attribute__((host)) __attribute__((device))
  seq_t() : thrust::system::detail::sequential::execution_policy<seq_t>() {}


  template<typename DerivedPolicy>
  __attribute__((host)) __attribute__((device))
  seq_t(const thrust::execution_policy<DerivedPolicy> &)
    : thrust::system::detail::sequential::execution_policy<seq_t>()
  {}

  template<typename Allocator>
    thrust::detail::execute_with_allocator<Allocator, thrust::system::detail::sequential::execution_policy>
      operator()(Allocator &alloc) const
  {
    return thrust::detail::execute_with_allocator<Allocator, thrust::system::detail::sequential::execution_policy>(alloc);
  }
};


}





static const detail::seq_t seq;



}
# 28 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/for_each.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/execute_on_stream.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/execute_on_stream.h"
       





namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


__attribute__((host)) __attribute__((device))
inline cudaStream_t legacy_stream()
{



  return ((cudaStream_t)0x1);

}


__attribute__((host)) __attribute__((device))
inline cudaStream_t default_stream()
{

  return legacy_stream();
}



template<typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
inline cudaStream_t stream(const execution_policy<DerivedPolicy> &exec)
{
  return default_stream();
}



template<typename DerivedPolicy>
class execute_on_stream_base
  : public thrust::system::cuda::detail::execution_policy<DerivedPolicy>
{
  public:
    __attribute__((host)) __attribute__((device))
    execute_on_stream_base()
      : m_stream(default_stream())
    {}

    __attribute__((host)) __attribute__((device))
    execute_on_stream_base(cudaStream_t stream)
      : m_stream(stream)
    {}

    __attribute__((host)) __attribute__((device))
    DerivedPolicy on(const cudaStream_t &s) const
    {


      DerivedPolicy result = thrust::detail::derived_cast(*this);


      result.set_stream(s);

      return result;
    }

  private:

    __attribute__((host)) __attribute__((device))
    friend inline cudaStream_t stream(const execute_on_stream_base &exec)
    {
      return exec.m_stream;
    }

    __attribute__((host)) __attribute__((device))
    inline void set_stream(const cudaStream_t &s)
    {
      m_stream = s;
    }

    cudaStream_t m_stream;
};



class execute_on_stream
  : public execute_on_stream_base<execute_on_stream>
{
  typedef execute_on_stream_base<execute_on_stream> super_t;

  public:
    __attribute__((host)) __attribute__((device))
    inline execute_on_stream(cudaStream_t stream)
      : super_t(stream)
    {}
};


}
}
}
}
# 29 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/for_each.inl" 2


namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace for_each_n_detail
{


struct for_each_kernel
{
  template<typename Iterator, typename Function, typename Size>
  __attribute__((host)) __attribute__((device))
  void operator()(bulk_::parallel_group<bulk_::concurrent_group<> > &grid, Iterator first, Function f, Size n)
  {
    Size grid_size = grid.size() * grid.this_exec.size();

    Size i = grid.this_exec.index() * grid.this_exec.size() + grid.this_exec.this_exec.index();

    first += i;

    while(i < n)
    {
      f(*first);
      i += grid_size;
      first += grid_size;
    }
  }
};


template<typename Size>
__attribute__((host)) __attribute__((device))
bool use_wide_counter(Size n, unsigned int narrow_grid_size)
{



  Size threshold = static_cast<Size>((2147483647 * 2U + 1U));

  bool result = (sizeof(Size) > sizeof(unsigned int)) && (n > threshold);

  if(!result)
  {

    unsigned int narrow_n = static_cast<unsigned int>(n);

    if((narrow_n - 1u) + narrow_grid_size < narrow_n)
    {
      result = true;
    }
  }

  return result;
}


}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename Size,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
RandomAccessIterator for_each_n(execution_policy<DerivedPolicy> &exec,
                                RandomAccessIterator first,
                                Size n,
                                UnaryFunction f)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<RandomAccessIterator, 3 == 3>::value) ) >)> thrust_static_assert_typedef_109 __attribute__((unused));

  struct workaround
  {
    __attribute__((host)) __attribute__((device))
    static RandomAccessIterator parallel_path(execution_policy<DerivedPolicy> &exec, RandomAccessIterator first, Size n, UnaryFunction f)
    {
      thrust::detail::wrapped_function<UnaryFunction,void> wrapped_f(f);



      unsigned int narrow_n = static_cast<unsigned int>(n);
      unsigned int narrow_num_groups = 0;
      unsigned int narrow_group_size = 0;


      thrust::tie(narrow_num_groups, narrow_group_size) = bulk_::choose_sizes(bulk_::grid(), for_each_n_detail::for_each_kernel(), bulk_::root, first, wrapped_f, narrow_n);


      if(for_each_n_detail::use_wide_counter(n, narrow_num_groups * narrow_group_size))
      {
        Size num_groups = 0;
        Size group_size = 0;
        thrust::tie(num_groups, group_size) = bulk_::choose_sizes(bulk_::grid(), for_each_n_detail::for_each_kernel(), bulk_::root, first, wrapped_f, n);

        num_groups = thrust::min<Size>(num_groups, thrust::detail::util::divide_ri(n, group_size));

        bulk_::async(bulk_::grid(num_groups,group_size,0,stream(thrust::detail::derived_cast(exec))), for_each_n_detail::for_each_kernel(), bulk_::root, first, wrapped_f, n);
      }
      else
      {

        narrow_num_groups = thrust::min<unsigned int>(narrow_num_groups, thrust::detail::util::divide_ri(narrow_n, narrow_group_size));

        bulk_::async(bulk_::grid(narrow_num_groups,narrow_group_size,0,stream(thrust::detail::derived_cast(exec))), for_each_n_detail::for_each_kernel(), bulk_::root, first, wrapped_f, narrow_n);
      }

      return first + n;
    }

    __attribute__((host)) __attribute__((device))
    static RandomAccessIterator sequential_path(execution_policy<DerivedPolicy> &, RandomAccessIterator first, Size n, UnaryFunction f)
    {
      return thrust::for_each_n(thrust::seq, first, n, f);
    }
  };


  return workaround::parallel_path(exec, first, n, f);



}


template<typename DerivedPolicy,
         typename InputIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
InputIterator for_each(execution_policy<DerivedPolicy> &exec,
                       InputIterator first,
                       InputIterator last,
                       UnaryFunction f)
{
  return cuda::detail::for_each_n(exec, first, thrust::distance(first,last), f);
}


}
}
}
}
# 65 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/for_each.h" 2
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/for_each.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/for_each.inl" 2

namespace thrust
{

 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
  InputIterator for_each(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         InputIterator first,
                         InputIterator last,
                         UnaryFunction f)
{
  using thrust::system::detail::generic::for_each;

  return for_each(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, f);
}


template<typename InputIterator,
         typename UnaryFunction>
InputIterator for_each(InputIterator first,
                       InputIterator last,
                       UnaryFunction f)
{
  using thrust::system::detail::generic::select_system;
  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;
  return thrust::for_each(select_system(system), first, last, f);
}

 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename Size, typename UnaryFunction>
__attribute__((host)) __attribute__((device))
  InputIterator for_each_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                           InputIterator first,
                           Size n,
                           UnaryFunction f)
{
  using thrust::system::detail::generic::for_each_n;

  return for_each_n(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, n, f);
}


template<typename InputIterator,
         typename Size,
         typename UnaryFunction>
InputIterator for_each_n(InputIterator first,
                         Size n,
                         UnaryFunction f)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;
  return thrust::for_each_n(select_system(system), first, n, f);
}


}
# 280 "/usr/local/cuda-8.0/include/thrust/for_each.h" 2
# 20 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform.inl" 2






namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator transform(thrust::execution_policy<DerivedPolicy> &exec,
                           InputIterator first,
                           InputIterator last,
                           OutputIterator result,
                           UnaryFunction op)
{
  typedef thrust::detail::unary_transform_functor<UnaryFunction> UnaryTransformFunctor;


  typedef thrust::tuple<InputIterator,OutputIterator> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ZipIterator zipped_result =
    thrust::for_each(exec,
                     thrust::make_zip_iterator(thrust::make_tuple(first,result)),
                     thrust::make_zip_iterator(thrust::make_tuple(last,result)),
                     UnaryTransformFunctor(op));

  return thrust::get<1>(zipped_result.get_iterator_tuple());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator transform(thrust::execution_policy<DerivedPolicy> &exec,
                           InputIterator1 first1,
                           InputIterator1 last1,
                           InputIterator2 first2,
                           OutputIterator result,
                           BinaryFunction op)
{

  typedef thrust::detail::binary_transform_functor<BinaryFunction> BinaryTransformFunctor;


  typedef thrust::tuple<InputIterator1,InputIterator2,OutputIterator> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ZipIterator zipped_result =
    thrust::for_each(exec,
                     thrust::make_zip_iterator(thrust::make_tuple(first1,first2,result)),
                     thrust::make_zip_iterator(thrust::make_tuple(last1,first2,result)),
                     BinaryTransformFunctor(op));

  return thrust::get<2>(zipped_result.get_iterator_tuple());
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(thrust::execution_policy<DerivedPolicy> &exec,
                               InputIterator first,
                               InputIterator last,
                               ForwardIterator result,
                               UnaryFunction unary_op,
                               Predicate pred)
{
  typedef thrust::detail::unary_transform_if_functor<UnaryFunction,Predicate> UnaryTransformIfFunctor;


  typedef thrust::tuple<InputIterator,ForwardIterator> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ZipIterator zipped_result =
    thrust::for_each(exec,
                     thrust::make_zip_iterator(thrust::make_tuple(first,result)),
                     thrust::make_zip_iterator(thrust::make_tuple(last,result)),
                     UnaryTransformIfFunctor(unary_op,pred));

  return thrust::get<1>(zipped_result.get_iterator_tuple());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(thrust::execution_policy<DerivedPolicy> &exec,
                               InputIterator1 first,
                               InputIterator1 last,
                               InputIterator2 stencil,
                               ForwardIterator result,
                               UnaryFunction unary_op,
                               Predicate pred)
{
  typedef thrust::detail::unary_transform_if_with_stencil_functor<UnaryFunction,Predicate> UnaryTransformIfFunctor;


  typedef thrust::tuple<InputIterator1,InputIterator2,ForwardIterator> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ZipIterator zipped_result =
    thrust::for_each(exec,
                     thrust::make_zip_iterator(thrust::make_tuple(first,stencil,result)),
                     thrust::make_zip_iterator(thrust::make_tuple(last,stencil,result)),
                     UnaryTransformIfFunctor(unary_op,pred));

  return thrust::get<2>(zipped_result.get_iterator_tuple());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename ForwardIterator,
         typename BinaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(thrust::execution_policy<DerivedPolicy> &exec,
                               InputIterator1 first1,
                               InputIterator1 last1,
                               InputIterator2 first2,
                               InputIterator3 stencil,
                               ForwardIterator result,
                               BinaryFunction binary_op,
                               Predicate pred)
{
  typedef thrust::detail::binary_transform_if_functor<BinaryFunction,Predicate> BinaryTransformIfFunctor;


  typedef thrust::tuple<InputIterator1,InputIterator2,InputIterator3,ForwardIterator> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ZipIterator zipped_result =
    thrust::for_each(exec,
                     thrust::make_zip_iterator(thrust::make_tuple(first1,first2,stencil,result)),
                     thrust::make_zip_iterator(thrust::make_tuple(last1,first2,stencil,result)),
                     BinaryTransformIfFunctor(binary_op,pred));

  return thrust::get<3>(zipped_result.get_iterator_tuple());
}


}
}
}
}
# 106 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/transform.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/transform.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/transform.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/transform.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/transform.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/transform.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/transform.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/transform.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/transform.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/transform.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/transform.h"
       
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/transform.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/transform.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename UnaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator transform(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                           InputIterator first, InputIterator last,
                           OutputIterator result,
                           UnaryFunction op)
{
  using thrust::system::detail::generic::transform;
  return transform(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, op);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator transform(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                           InputIterator1 first1, InputIterator1 last1,
                           InputIterator2 first2,
                           OutputIterator result,
                           BinaryFunction op)
{
  using thrust::system::detail::generic::transform;
  return transform(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, result, op);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                               InputIterator first, InputIterator last,
                               ForwardIterator result,
                               UnaryFunction op,
                               Predicate pred)
{
  using thrust::system::detail::generic::transform_if;
  return transform_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, op, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                               InputIterator1 first, InputIterator1 last,
                               InputIterator2 stencil,
                               ForwardIterator result,
                               UnaryFunction op,
                               Predicate pred)
{
  using thrust::system::detail::generic::transform_if;
  return transform_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, result, op, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename ForwardIterator,
         typename BinaryFunction,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator transform_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                               InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2,
                               InputIterator3 stencil,
                               ForwardIterator result,
                               BinaryFunction binary_op,
                               Predicate pred)
{
  using thrust::system::detail::generic::transform_if;
  return transform_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, stencil, result, binary_op, pred);
}


template<typename InputIterator,
         typename OutputIterator,
         typename UnaryFunction>
  OutputIterator transform(InputIterator first,
                           InputIterator last,
                           OutputIterator result,
                           UnaryFunction op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::transform(select_system(system1,system2), first, last, result, op);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryFunction>
  OutputIterator transform(InputIterator1 first1,
                           InputIterator1 last1,
                           InputIterator2 first2,
                           OutputIterator result,
                           BinaryFunction op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::transform(select_system(system1,system2,system3), first1, last1, first2, result, op);
}


template<typename InputIterator,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
  ForwardIterator transform_if(InputIterator first,
                               InputIterator last,
                               ForwardIterator result,
                               UnaryFunction unary_op,
                               Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<ForwardIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::transform_if(select_system(system1,system2), first, last, result, unary_op, pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename ForwardIterator,
         typename UnaryFunction,
         typename Predicate>
  ForwardIterator transform_if(InputIterator1 first,
                               InputIterator1 last,
                               InputIterator2 stencil,
                               ForwardIterator result,
                               UnaryFunction unary_op,
                               Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<ForwardIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::transform_if(select_system(system1,system2,system3), first, last, stencil, result, unary_op, pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename ForwardIterator,
         typename BinaryFunction,
         typename Predicate>
  ForwardIterator transform_if(InputIterator1 first1,
                               InputIterator1 last1,
                               InputIterator2 first2,
                               InputIterator3 stencil,
                               ForwardIterator result,
                               BinaryFunction binary_op,
                               Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<InputIterator3>::type System3;
  typedef typename thrust::iterator_system<ForwardIterator>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::transform_if(select_system(system1,system2,system3,system4), first1, last1, first2, stencil, result, binary_op, pred);
}


}
# 725 "/usr/local/cuda-8.0/include/thrust/transform.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy.inl" 2





namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy(thrust::execution_policy<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      OutputIterator result)
{
  typedef typename thrust::iterator_value<InputIterator>::type T;
  return thrust::transform(exec, first, last, result, thrust::identity<T>());
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_n(thrust::execution_policy<DerivedPolicy> &exec,
                        InputIterator first,
                        Size n,
                        OutputIterator result)
{
  typedef typename thrust::iterator_value<InputIterator>::type value_type;
  typedef thrust::identity<value_type> xfrm_type;

  typedef thrust::detail::unary_transform_functor<xfrm_type> functor_type;

  typedef thrust::tuple<InputIterator,OutputIterator> iterator_tuple;
  typedef thrust::zip_iterator<iterator_tuple> zip_iter;

  zip_iter zipped = thrust::make_zip_iterator(thrust::make_tuple(first,result));

  return thrust::get<1>(thrust::for_each_n(exec, zipped, n, functor_type(xfrm_type())).get_iterator_tuple());
}


}
}
}
}
# 59 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/detail/copy.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy(sequential::execution_policy<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      OutputIterator result);


template<typename DerivedPolicy,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_n(sequential::execution_policy<DerivedPolicy> &exec,
                        InputIterator first,
                        Size n,
                        OutputIterator result);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/detail/dispatch/is_trivial_copy.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/detail/dispatch/is_trivial_copy.h"
       





namespace thrust
{

namespace detail
{

namespace dispatch
{





template<typename FromIterator, typename ToIterator>
  struct is_trivial_copy :
    integral_constant<
      bool,
      is_same<
        typename thrust::iterator_value<FromIterator>::type,
        typename thrust::iterator_value<ToIterator>::type
      >::value
      && is_trivial_iterator<FromIterator>::value
      && is_trivial_iterator<ToIterator>::value
      && has_trivial_assign<typename thrust::iterator_value<ToIterator>::type>::value
    > {};

}

}

}
# 20 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy.inl" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/general_copy.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/general_copy.h"
       





namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{
namespace general_copy_detail
{


template<typename T1, typename T2>
struct lazy_is_assignable
  : thrust::detail::is_assignable<
      typename T1::type,
      typename T2::type
    >
{};




template<typename InputIterator, typename OutputIterator>
struct reference_is_assignable
  : thrust::detail::eval_if<
      thrust::detail::is_same<
        typename thrust::iterator_reference<OutputIterator>::type, void
      >::value,
      thrust::detail::true_type,
      lazy_is_assignable<
        thrust::iterator_reference<OutputIterator>,
        thrust::iterator_reference<InputIterator>
      >
    >::type
{};





 #pragma nv_exec_check_disable
template<typename OutputIterator, typename InputIterator>
inline __attribute__((host)) __attribute__((device))
typename thrust::detail::enable_if<
  reference_is_assignable<InputIterator,OutputIterator>::value
>::type
iter_assign(OutputIterator dst, InputIterator src)
{
  *dst = *src;
}


 #pragma nv_exec_check_disable
template<typename OutputIterator, typename InputIterator>
inline __attribute__((host)) __attribute__((device))
typename thrust::detail::disable_if<
  reference_is_assignable<InputIterator,OutputIterator>::value
>::type
iter_assign(OutputIterator dst, InputIterator src)
{
  typedef typename thrust::iterator_value<InputIterator>::type value_type;


  *dst = static_cast<value_type>(*src);
}


}


 #pragma nv_exec_check_disable
template<typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator general_copy(InputIterator first,
                              InputIterator last,
                              OutputIterator result)
{
  for(; first != last; ++first, ++result)
  {




    general_copy_detail::iter_assign(result, first);

  }

  return result;
}


 #pragma nv_exec_check_disable
template<typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator general_copy_n(InputIterator first,
                                Size n,
                                OutputIterator result)
{
  for(; n > Size(0); ++first, ++result, --n)
  {




    general_copy_detail::iter_assign(result, first);

  }

  return result;
}


}
}
}
}
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/trivial_copy.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/trivial_copy.h"
       


# 1 "/usr/include/c++/4.8.2/cstring" 1 3
# 39 "/usr/include/c++/4.8.2/cstring" 3
       
# 40 "/usr/include/c++/4.8.2/cstring" 3
# 25 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/trivial_copy.h" 2


namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename T>
__attribute__((host)) __attribute__((device))
  T *trivial_copy_n(const T *first,
                    std::ptrdiff_t n,
                    T *result)
{

  std::memmove(result, first, n * sizeof(T));
  return result + n;



}


}
}
}
}
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy.inl" 2



namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{
namespace copy_detail
{



template<typename Pointer>
__attribute__((host)) __attribute__((device))
  typename thrust::detail::pointer_traits<Pointer>::raw_pointer
    get(Pointer ptr)
{
  return thrust::detail::pointer_traits<Pointer>::get(ptr);
}


 #pragma nv_exec_check_disable
template<typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy(InputIterator first,
                      InputIterator last,
                      OutputIterator result,
                      thrust::detail::true_type)
{
  typedef typename thrust::iterator_difference<InputIterator>::type Size;

  const Size n = last - first;
  thrust::system::detail::sequential::trivial_copy_n(get(&*first), n, get(&*result));
  return result + n;
}


 #pragma nv_exec_check_disable
template<typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy(InputIterator first,
                      InputIterator last,
                      OutputIterator result,
                      thrust::detail::false_type)
{
  return thrust::system::detail::sequential::general_copy(first,last,result);
}


 #pragma nv_exec_check_disable
template<typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_n(InputIterator first,
                        Size n,
                        OutputIterator result,
                        thrust::detail::true_type)
{
  thrust::system::detail::sequential::trivial_copy_n(get(&*first), n, get(&*result));
  return result + n;
}


template<typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_n(InputIterator first,
                        Size n,
                        OutputIterator result,
                        thrust::detail::false_type)
{
  return thrust::system::detail::sequential::general_copy_n(first,n,result);
}


}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy(sequential::execution_policy<DerivedPolicy> &,
                      InputIterator first,
                      InputIterator last,
                      OutputIterator result)
{
  return thrust::system::detail::sequential::copy_detail::copy(first, last, result,
    typename thrust::detail::dispatch::is_trivial_copy<InputIterator,OutputIterator>::type());
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_n(sequential::execution_policy<DerivedPolicy> &,
                        InputIterator first,
                        Size n,
                        OutputIterator result)
{
  return thrust::system::detail::sequential::copy_detail::copy_n(first, n, result,
    typename thrust::detail::dispatch::is_trivial_copy<InputIterator,OutputIterator>::type());
}


}
}
}
}
# 63 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/copy.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/copy.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
OutputIterator copy(execution_policy<DerivedPolicy> &exec,
                    InputIterator first,
                    InputIterator last,
                    OutputIterator result);


template<typename System1,
         typename System2,
         typename InputIterator,
         typename OutputIterator>
OutputIterator copy(cross_system<System1,System2> exec,
                    InputIterator first,
                    InputIterator last,
                    OutputIterator result);


template<typename DerivedPolicy,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
OutputIterator copy_n(execution_policy<DerivedPolicy> &exec,
                      InputIterator first,
                      Size n,
                      OutputIterator result);


template<typename System1,
         typename System2,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
OutputIterator copy_n(cross_system<System1,System2> exec,
                      InputIterator first,
                      Size n,
                      OutputIterator result);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_device_to_device.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_device_to_device.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
OutputIterator copy_device_to_device(execution_policy<DerivedPolicy> &exec,
                                     InputIterator begin,
                                     InputIterator end,
                                     OutputIterator result);

}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_device_to_device.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_device_to_device.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_cross_system.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_cross_system.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename System1,
         typename System2,
         typename InputIterator,
         typename OutputIterator>
  OutputIterator copy_cross_system(cross_system<System1,System2> systems,
                                   InputIterator begin,
                                   InputIterator end,
                                   OutputIterator result);


template<typename System1,
         typename System2,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
  OutputIterator copy_cross_system_n(cross_system<System1,System2> systems,
                                     InputIterator begin,
                                     Size n,
                                     OutputIterator result);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_cross_system.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_cross_system.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/detail/temporary_array.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/temporary_array.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/tagged_iterator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/tagged_iterator.h"
       






namespace thrust
{
namespace detail
{

template <typename,typename> class tagged_iterator;

template<typename Iterator, typename Tag>
  struct tagged_iterator_base
{
  typedef thrust::iterator_adaptor<
    tagged_iterator<Iterator,Tag>,
    Iterator,
    typename thrust::iterator_value<Iterator>::type,
    Tag,
    typename thrust::iterator_traversal<Iterator>::type,
    typename thrust::iterator_reference<Iterator>::type,
    typename thrust::iterator_difference<Iterator>::type
  > type;
};

template<typename Iterator, typename Tag>
  class tagged_iterator
    : public tagged_iterator_base<Iterator,Tag>::type
{
  private:
    typedef typename tagged_iterator_base<Iterator,Tag>::type super_t;

  public:
    __attribute__((host)) __attribute__((device))
    tagged_iterator(void) {}

    __attribute__((host)) __attribute__((device))
    explicit tagged_iterator(Iterator x)
      : super_t(x) {}
};



template<typename> struct is_trivial_iterator;


template<typename BaseIterator, typename Tag>
  struct is_trivial_iterator<tagged_iterator<BaseIterator,Tag> >
    : is_trivial_iterator<BaseIterator>
{};


}
}
# 26 "/usr/local/cuda-8.0/include/thrust/detail/temporary_array.h" 2

# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/temporary_allocator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/allocator/temporary_allocator.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/tagged_allocator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/allocator/tagged_allocator.h"
       





namespace thrust
{
namespace detail
{

template<typename T, typename Tag, typename Pointer> class tagged_allocator;

template<typename Tag, typename Pointer>
  class tagged_allocator<void, Tag, Pointer>
{
  public:
    typedef void value_type;
    typedef typename thrust::detail::pointer_traits<Pointer>::template rebind<void>::other pointer;
    typedef typename thrust::detail::pointer_traits<Pointer>::template rebind<const void>::other const_pointer;
    typedef std::size_t size_type;
    typedef typename thrust::detail::pointer_traits<Pointer>::difference_type difference_type;
    typedef Tag system_type;

    template<typename U>
      struct rebind
    {
      typedef tagged_allocator<U,Tag,Pointer> other;
    };
};

template<typename T, typename Tag, typename Pointer>
  class tagged_allocator
{
  public:
    typedef T value_type;
    typedef typename thrust::detail::pointer_traits<Pointer>::template rebind<T>::other pointer;
    typedef typename thrust::detail::pointer_traits<Pointer>::template rebind<const T>::other const_pointer;
    typedef typename thrust::iterator_reference<pointer>::type reference;
    typedef typename thrust::iterator_reference<const_pointer>::type const_reference;
    typedef std::size_t size_type;
    typedef typename thrust::detail::pointer_traits<pointer>::difference_type difference_type;
    typedef Tag system_type;

    template<typename U>
      struct rebind
    {
      typedef tagged_allocator<U,Tag,Pointer> other;
    };

    __attribute__((host)) __attribute__((device))
    inline tagged_allocator();

    __attribute__((host)) __attribute__((device))
    inline tagged_allocator(const tagged_allocator &);

    template<typename U, typename OtherPointer>
    __attribute__((host)) __attribute__((device))
    inline tagged_allocator(const tagged_allocator<U, Tag, OtherPointer> &);

    __attribute__((host)) __attribute__((device))
    inline ~tagged_allocator();

    __attribute__((host)) __attribute__((device))
    pointer address(reference x) const;

    __attribute__((host)) __attribute__((device))
    const_pointer address(const_reference x) const;

    size_type max_size() const;
};

template<typename T1, typename Pointer1, typename T2, typename Pointer2, typename Tag>
__attribute__((host)) __attribute__((device))
bool operator==(const tagged_allocator<T1,Pointer1,Tag> &, const tagged_allocator<T2,Pointer2,Tag> &);

template<typename T1, typename Pointer1, typename T2, typename Pointer2, typename Tag>
__attribute__((host)) __attribute__((device))
bool operator!=(const tagged_allocator<T1,Pointer1,Tag> &, const tagged_allocator<T2,Pointer2,Tag> &);

}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/tagged_allocator.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/allocator/tagged_allocator.inl"
namespace thrust
{
namespace detail
{


template<typename T, typename Tag, typename Pointer>
  tagged_allocator<T,Tag,Pointer>
    ::tagged_allocator()
{}


template<typename T, typename Tag, typename Pointer>
  tagged_allocator<T,Tag,Pointer>
    ::tagged_allocator(const tagged_allocator<T,Tag,Pointer> &)
{}


template<typename T, typename Tag, typename Pointer>
  template<typename U, typename OtherPointer>
    tagged_allocator<T,Tag,Pointer>
      ::tagged_allocator(const tagged_allocator<U,Tag,OtherPointer> &)
{}


template<typename T, typename Tag, typename Pointer>
  tagged_allocator<T,Tag,Pointer>
    ::~tagged_allocator()
{}


template<typename T, typename Tag, typename Pointer>
  typename tagged_allocator<T,Tag,Pointer>::pointer
    tagged_allocator<T,Tag,Pointer>
      ::address(reference x) const
{
  return &x;
}


template<typename T, typename Tag, typename Pointer>
  typename tagged_allocator<T,Tag,Pointer>::const_pointer
    tagged_allocator<T,Tag,Pointer>
      ::address(const_reference x) const
{
  return &x;
}


template<typename T, typename Tag, typename Pointer>
  typename tagged_allocator<T,Tag,Pointer>::size_type
    tagged_allocator<T,Tag,Pointer>
      ::max_size() const
{
  return (std::numeric_limits<size_type>::max)() / sizeof(T);
}


template<typename T1, typename Pointer1, typename T2, typename Pointer2, typename Tag>
__attribute__((host)) __attribute__((device))
bool operator==(const tagged_allocator<T1,Pointer1,Tag> &, const tagged_allocator<T2,Pointer2,Tag> &)
{
  return true;
}


template<typename T1, typename Pointer1, typename T2, typename Pointer2, typename Tag>
__attribute__((host)) __attribute__((device))
bool operator!=(const tagged_allocator<T1,Pointer1,Tag> &, const tagged_allocator<T2,Pointer2,Tag> &)
{
  return false;
}


}
}
# 101 "/usr/local/cuda-8.0/include/thrust/detail/allocator/tagged_allocator.h" 2
# 21 "/usr/local/cuda-8.0/include/thrust/detail/allocator/temporary_allocator.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/memory.h" 1
# 24 "/usr/local/cuda-8.0/include/thrust/memory.h"
# 1 "/usr/local/cuda-8.0/include/thrust/detail/pointer.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/pointer.h"
       
# 28 "/usr/local/cuda-8.0/include/thrust/detail/pointer.h"
namespace thrust
{


template<typename Element, typename Tag, typename Reference = use_default, typename Derived = use_default> class pointer;

}






namespace thrust
{

template<typename Element, typename Tag, typename Reference, typename Derived>
  struct iterator_traits<thrust::pointer<Element,Tag,Reference,Derived> >
{
  private:
    typedef thrust::pointer<Element,Tag,Reference,Derived> ptr;

  public:
    typedef typename ptr::iterator_category iterator_category;
    typedef typename ptr::value_type value_type;
    typedef typename ptr::difference_type difference_type;

    typedef void pointer;
    typedef typename ptr::reference reference;
};

}


namespace thrust
{

namespace detail
{


template<typename Element, typename Tag, typename Reference, typename Derived>
  struct pointer_base
{


  typedef typename thrust::detail::eval_if<
    thrust::detail::is_void<typename thrust::detail::remove_const<Element>::type>::value,
    thrust::detail::identity_<void>,
    thrust::detail::remove_cv<Element>
  >::type value_type;


  typedef typename thrust::detail::eval_if<
    thrust::detail::is_same<Derived,use_default>::value,
    thrust::detail::identity_<pointer<Element,Tag,Reference,Derived> >,
    thrust::detail::identity_<Derived>
  >::type derived_type;



  typedef typename thrust::detail::eval_if<
    thrust::detail::is_void<typename thrust::detail::remove_const<Element>::type>::value,
    thrust::detail::identity_<void>,
    thrust::detail::eval_if<
      thrust::detail::is_same<Reference,use_default>::value,
      thrust::detail::identity_<reference<Element,derived_type> >,
      thrust::detail::identity_<Reference>
    >
  >::type reference_arg;

  typedef thrust::iterator_adaptor<
    derived_type,
    Element *,
    value_type,
    Tag,
    thrust::random_access_traversal_tag,
    reference_arg,
    std::ptrdiff_t
  > type;
};


}
# 121 "/usr/local/cuda-8.0/include/thrust/detail/pointer.h"
template<typename Element, typename Tag, typename Reference, typename Derived>
  class pointer
    : public thrust::detail::pointer_base<Element,Tag,Reference,Derived>::type
{
  private:
    typedef typename thrust::detail::pointer_base<Element,Tag,Reference,Derived>::type super_t;

    typedef typename thrust::detail::pointer_base<Element,Tag,Reference,Derived>::derived_type derived_type;


    friend class thrust::iterator_core_access;

    __attribute__((host)) __attribute__((device))
    typename super_t::reference dereference() const;


    using super_t::base;
    using typename super_t::base_type;

  public:
    typedef typename super_t::base_type raw_pointer;



    __attribute__((host)) __attribute__((device))
    pointer();



    template<typename OtherElement>
    __attribute__((host)) __attribute__((device))
    explicit pointer(OtherElement *ptr);



    template<typename OtherPointer>
    __attribute__((host)) __attribute__((device))
    pointer(const OtherPointer &other,
            typename thrust::detail::enable_if_pointer_is_convertible<
              OtherPointer,
              pointer<Element,Tag,Reference,Derived>
            >::type * = 0);





    template<typename OtherPointer>
    __attribute__((host)) __attribute__((device))
    typename thrust::detail::enable_if_pointer_is_convertible<
      OtherPointer,
      pointer,
      derived_type &
    >::type
    operator=(const OtherPointer &other);



    __attribute__((host)) __attribute__((device))
    Element *get() const;
};


template<typename Element, typename Tag, typename Reference, typename Derived,
         typename charT, typename traits>
std::basic_ostream<charT, traits> &
operator<<(std::basic_ostream<charT, traits> &os,
           const pointer<Element, Tag, Reference, Derived> &p);

}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/pointer.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/pointer.inl"
namespace thrust
{


template<typename Element, typename Tag, typename Reference, typename Derived>
  pointer<Element,Tag,Reference,Derived>
    ::pointer()
      : super_t(static_cast<Element*>(0))
{}


template<typename Element, typename Tag, typename Reference, typename Derived>
  template<typename OtherElement>
    pointer<Element,Tag,Reference,Derived>
      ::pointer(OtherElement *other)
        : super_t(other)
{}


template<typename Element, typename Tag, typename Reference, typename Derived>
  template<typename OtherPointer>
    pointer<Element,Tag,Reference,Derived>
      ::pointer(const OtherPointer &other,
                typename thrust::detail::enable_if_pointer_is_convertible<
                  OtherPointer,
                  pointer<Element,Tag,Reference,Derived>
                 >::type *)
        : super_t(thrust::detail::pointer_traits<OtherPointer>::get(other))
{}


template<typename Element, typename Tag, typename Reference, typename Derived>
  template<typename OtherPointer>
    typename thrust::detail::enable_if_pointer_is_convertible<
      OtherPointer,
      pointer<Element,Tag,Reference,Derived>,
      typename pointer<Element,Tag,Reference,Derived>::derived_type &
    >::type
      pointer<Element,Tag,Reference,Derived>
        ::operator=(const OtherPointer &other)
{
  super_t::base_reference() = thrust::detail::pointer_traits<OtherPointer>::get(other);
  return static_cast<derived_type&>(*this);
}


template<typename Element, typename Tag, typename Reference, typename Derived>
  typename pointer<Element,Tag,Reference,Derived>::super_t::reference
    pointer<Element,Tag,Reference,Derived>
      ::dereference() const
{
  return typename super_t::reference(static_cast<const derived_type&>(*this));
}


template<typename Element, typename Tag, typename Reference, typename Derived>
  Element *pointer<Element,Tag,Reference,Derived>
    ::get() const
{
  return super_t::base();
}

template<typename Element, typename Tag, typename Reference, typename Derived,
         typename charT, typename traits>
std::basic_ostream<charT, traits> &
operator<<(std::basic_ostream<charT, traits> &os,
           const pointer<Element, Tag, Reference, Derived> &p) {
  return os << p.get();
}

namespace detail
{
# 146 "/usr/local/cuda-8.0/include/thrust/detail/pointer.inl"
}


}
# 193 "/usr/local/cuda-8.0/include/thrust/detail/pointer.h" 2
# 25 "/usr/local/cuda-8.0/include/thrust/memory.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/reference.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/reference.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/detail/reference.h"
namespace thrust
{
namespace detail
{

template<typename> struct is_wrapped_reference;

}
# 42 "/usr/local/cuda-8.0/include/thrust/detail/reference.h"
template<typename Element, typename Pointer, typename Derived>
  class reference
{
  private:
    typedef typename thrust::detail::eval_if<
      thrust::detail::is_same<Derived,use_default>::value,
      thrust::detail::identity_<reference>,
      thrust::detail::identity_<Derived>
    >::type derived_type;



    struct wrapped_reference_hint {};
    template<typename> friend struct thrust::detail::is_wrapped_reference;

  public:
    typedef Pointer pointer;
    typedef typename thrust::detail::remove_const<Element>::type value_type;

    __attribute__((host)) __attribute__((device))
    explicit reference(const pointer &ptr);

    template<typename OtherElement, typename OtherPointer, typename OtherDerived>
    __attribute__((host)) __attribute__((device))
    reference(const reference<OtherElement,OtherPointer,OtherDerived> &other,
              typename thrust::detail::enable_if_convertible<
                typename reference<OtherElement,OtherPointer,OtherDerived>::pointer,
                pointer
              >::type * = 0);

    __attribute__((host)) __attribute__((device))
    derived_type &operator=(const reference &other);


    template<typename OtherElement, typename OtherPointer, typename OtherDerived>
    __attribute__((host)) __attribute__((device))
    derived_type &operator=(const reference<OtherElement,OtherPointer,OtherDerived> &other);

    __attribute__((host)) __attribute__((device))
    derived_type &operator=(const value_type &x);

    __attribute__((host)) __attribute__((device))
    pointer operator&() const;

    __attribute__((host)) __attribute__((device))
    operator value_type () const;

    __attribute__((host)) __attribute__((device))
    void swap(derived_type &other);

    derived_type &operator++();

    value_type operator++(int);


    derived_type &operator+=(const value_type &rhs);

    derived_type &operator--();

    value_type operator--(int);


    derived_type &operator-=(const value_type &rhs);


    derived_type &operator*=(const value_type &rhs);


    derived_type &operator/=(const value_type &rhs);


    derived_type &operator%=(const value_type &rhs);


    derived_type &operator<<=(const value_type &rhs);


    derived_type &operator>>=(const value_type &rhs);


    derived_type &operator&=(const value_type &rhs);


    derived_type &operator|=(const value_type &rhs);


    derived_type &operator^=(const value_type &rhs);

  private:
    const pointer m_ptr;


    template <typename OtherElement, typename OtherPointer, typename OtherDerived> friend class reference;

    template<typename System>
    __attribute__((host)) __attribute__((device))
    inline value_type strip_const_get_value(const System &system) const;

    template<typename OtherPointer>
    __attribute__((host)) __attribute__((device))
    inline void assign_from(OtherPointer src);


    template<typename System1, typename System2, typename OtherPointer>
    inline __attribute__((host)) __attribute__((device))
    void assign_from(System1 *system1, System2 *system2, OtherPointer src);

    template<typename System, typename OtherPointer>
    __attribute__((host)) __attribute__((device))
    inline void strip_const_assign_value(const System &system, OtherPointer src);


    template<typename System>
    inline __attribute__((host)) __attribute__((device))
    void swap(System *system, derived_type &other);


    template<typename System>
    inline __attribute__((host)) __attribute__((device))
    value_type convert_to_value_type(System *system) const;
};


template<typename Element, typename Pointer, typename Derived,
         typename charT, typename traits>
std::basic_ostream<charT, traits> &
operator<<(std::basic_ostream<charT, traits> &os,
           const reference<Element, Pointer, Derived> &y);

}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/reference.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/detail/reference.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/memory.h" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/memory.h"
       
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/memory.h"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{

template<typename DerivedPolicy, typename Size>
__attribute__((host)) __attribute__((device))
void malloc(thrust::execution_policy<DerivedPolicy> &, Size);

template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
thrust::pointer<T,DerivedPolicy> malloc(thrust::execution_policy<DerivedPolicy> &s, std::size_t n);

template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
void free(thrust::execution_policy<DerivedPolicy> &, Pointer);

template<typename Pointer1, typename Pointer2>
__attribute__((host)) __attribute__((device))
void assign_value(tag, Pointer1, Pointer2);

template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
void get_value(thrust::execution_policy<DerivedPolicy> &, Pointer);

template<typename Pointer1, typename Pointer2>
__attribute__((host)) __attribute__((device))
void iter_swap(tag, Pointer1, Pointer2);

}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/memory.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/memory.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/malloc_and_free.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/malloc_and_free.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/malloc_and_free.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/malloc_and_free.h"
       



# 1 "/usr/include/c++/4.8.2/cstdlib" 1 3
# 39 "/usr/include/c++/4.8.2/cstdlib" 3
       
# 40 "/usr/include/c++/4.8.2/cstdlib" 3
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/malloc_and_free.h" 2


namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename DerivedPolicy>
inline __attribute__((host)) __attribute__((device))
void *malloc(execution_policy<DerivedPolicy> &, std::size_t n)
{

  return std::malloc(n);



}


template<typename DerivedPolicy, typename Pointer>
inline __attribute__((host)) __attribute__((device))
void free(sequential::execution_policy<DerivedPolicy> &, Pointer ptr)
{

  std::free(thrust::raw_pointer_cast(ptr));

}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/malloc_and_free.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/malloc_and_free.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/malloc_and_free.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/malloc_and_free.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/malloc_and_free.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/malloc_and_free.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/bad_alloc.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/bad_alloc.h"
       




namespace thrust
{
namespace system
{
namespace detail
{


class bad_alloc
  : public std::bad_alloc
{
  public:
    inline bad_alloc(const std::string &w)
      : std::bad_alloc(), m_what()
    {
      m_what = std::bad_alloc::what();
      m_what += ": ";
      m_what += w;
    }

    inline virtual ~bad_alloc(void) throw () {};

    inline virtual const char *what(void) const throw()
    {
      return m_what.c_str();
    }

  private:
    std::string m_what;
};

}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/malloc_and_free.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/throw_on_error.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/throw_on_error.h"
       



# 1 "/usr/include/c++/4.8.2/cstdio" 1 3
# 39 "/usr/include/c++/4.8.2/cstdio" 3
       
# 40 "/usr/include/c++/4.8.2/cstdio" 3
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/throw_on_error.h" 2


namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


inline __attribute__((host)) __attribute__((device))
void throw_on_error(cudaError_t error, const char *message)
{
  thrust::system::cuda::detail::bulk_::detail::throw_on_error(error, message);
}


}
}
}
}
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/malloc_and_free.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/malloc_and_free.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/malloc_and_free.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/detail/malloc_and_free.h"
namespace thrust
{

 #pragma nv_exec_check_disable
template<typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
pointer<void,DerivedPolicy> malloc(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, std::size_t n)
{
  using thrust::system::detail::generic::malloc;


  void *raw_ptr = static_cast<void*>(thrust::raw_pointer_cast(malloc(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), n)));

  return pointer<void,DerivedPolicy>(raw_ptr);
}

 #pragma nv_exec_check_disable
template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
pointer<T,DerivedPolicy> malloc(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, std::size_t n)
{
  using thrust::system::detail::generic::malloc;

  T *raw_ptr = static_cast<T*>(thrust::raw_pointer_cast(malloc<T>(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), n)));

  return pointer<T,DerivedPolicy>(raw_ptr);
}
# 71 "/usr/local/cuda-8.0/include/thrust/detail/malloc_and_free.h"
 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
void free(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, Pointer ptr)
{
  using thrust::system::detail::generic::free;

  free(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), ptr);
}




}
# 28 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/malloc_and_free.h" 2



namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{




template<typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
void *malloc(execution_policy<DerivedPolicy> &, std::size_t n)
{
  void *result = 0;



  cudaError_t error = cudaMalloc(reinterpret_cast<void**>(&result), n);

  if(error)
  {
    throw thrust::system::detail::bad_alloc(thrust::cuda_category().message(error).c_str());
  }




  return result;
}


template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
void free(execution_policy<DerivedPolicy> &, Pointer ptr)
{


  throw_on_error(cudaFree(thrust::raw_pointer_cast(ptr)), "cudaFree in free");



}


}
}
}
}
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/malloc_and_free.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/memory.inl" 2



namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename Size>
__attribute__((host)) __attribute__((device))
  void malloc(thrust::execution_policy<DerivedPolicy> &, Size)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<Size, false>::value) ) >)> thrust_static_assert_typedef_40 __attribute__((unused));
}


template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
  thrust::pointer<T,DerivedPolicy>
    malloc(thrust::execution_policy<DerivedPolicy> &exec, std::size_t n)
{
  thrust::pointer<void,DerivedPolicy> void_ptr = thrust::malloc(exec, sizeof(T) * n);

  return pointer<T,DerivedPolicy>(static_cast<T*>(void_ptr.get()));
}


template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
  void free(thrust::execution_policy<DerivedPolicy> &, Pointer)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<Pointer, false>::value) ) >)> thrust_static_assert_typedef_60 __attribute__((unused));
}


template<typename DerivedPolicy, typename Pointer1, typename Pointer2>
__attribute__((host)) __attribute__((device))
void assign_value(thrust::execution_policy<DerivedPolicy> &, Pointer1, Pointer2)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<Pointer1, false>::value) ) >)> thrust_static_assert_typedef_69 __attribute__((unused));
}


template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
void get_value(thrust::execution_policy<DerivedPolicy> &, Pointer)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<Pointer, false>::value) ) >)> thrust_static_assert_typedef_78 __attribute__((unused));
}


template<typename Pointer1, typename Pointer2>
__attribute__((host)) __attribute__((device))
void iter_swap(tag, Pointer1, Pointer2)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<Pointer1, false>::value) ) >)> thrust_static_assert_typedef_87 __attribute__((unused));
}


}
}
}
}
# 72 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/memory.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/detail/reference.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/get_value.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/get_value.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/get_value.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/get_value.h"
       





namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
  typename thrust::iterator_value<Pointer>::type
    get_value(sequential::execution_policy<DerivedPolicy> &, Pointer ptr)
{
  return *thrust::raw_pointer_cast(ptr);
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/get_value.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/get_value.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/get_value.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/get_value.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/get_value.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/get_value.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/assign_value.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/assign_value.h"
       






namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
# 77 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/assign_value.h"
template<typename DerivedPolicy, typename Pointer1, typename Pointer2>
inline __attribute__((host)) __attribute__((device))
  void assign_value(thrust::cuda::execution_policy<DerivedPolicy> &exec, Pointer1 dst, Pointer2 src)
{

  struct war_nvbugs_881631
  {
    __attribute__((host)) inline static void host_path(thrust::cuda::execution_policy<DerivedPolicy> &exec, Pointer1 dst, Pointer2 src)
    {
      thrust::copy(exec, src, src + 1, dst);
    }

    __attribute__((device)) inline static void device_path(thrust::cuda::execution_policy<DerivedPolicy> &, Pointer1 dst, Pointer2 src)
    {
      *thrust::raw_pointer_cast(dst) = *thrust::raw_pointer_cast(src);
    }
  };


  war_nvbugs_881631::host_path(exec,dst,src);



}
# 159 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/assign_value.h"
template<typename System1, typename System2, typename Pointer1, typename Pointer2>
inline __attribute__((host)) __attribute__((device))
  void assign_value(cross_system<System1,System2> &systems, Pointer1 dst, Pointer2 src)
{

  struct war_nvbugs_881631
  {
    __attribute__((host)) inline static void host_path(cross_system<System1,System2> &systems, Pointer1 dst, Pointer2 src)
    {


      cross_system<System2,System1> rotated_systems = systems.rotate();
      thrust::copy(rotated_systems, src, src + 1, dst);
    }

    __attribute__((device)) inline static void device_path(cross_system<System1,System2> &systems, Pointer1 dst, Pointer2 src)
    {


      thrust::cuda::tag cuda_tag;
      thrust::system::cuda::detail::assign_value(cuda_tag, dst, src);
    }
  };




  war_nvbugs_881631::host_path(systems,dst,src);

}





}
}
}
}
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/get_value.h" 2



namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


namespace
{


template<typename DerivedPolicy, typename Pointer>
inline __attribute__((host)) __attribute__((device))
  typename thrust::iterator_value<Pointer>::type
    get_value_msvc2005_war(execution_policy<DerivedPolicy> &exec, Pointer ptr)
{
  typedef typename thrust::iterator_value<Pointer>::type result_type;


  struct war_nvbugs_881631
  {
    __attribute__((host)) inline static result_type host_path(execution_policy<DerivedPolicy> &exec, Pointer ptr)
    {


      result_type result;

      thrust::host_system_tag host_tag;
      cross_system<thrust::host_system_tag, DerivedPolicy> systems(host_tag, exec);
      assign_value(systems, &result, ptr);

      return result;
    }

    __attribute__((device)) inline static result_type device_path(execution_policy<DerivedPolicy> &, Pointer ptr)
    {

      return *thrust::raw_pointer_cast(ptr);
    }
  };


  return war_nvbugs_881631::host_path(exec, ptr);



}


}


template<typename DerivedPolicy, typename Pointer>
inline __attribute__((host)) __attribute__((device))
  typename thrust::iterator_value<Pointer>::type
    get_value(execution_policy<DerivedPolicy> &exec, Pointer ptr)
{
  return get_value_msvc2005_war(exec,ptr);
}


}
}
}
}
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/get_value.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/detail/reference.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/assign_value.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/assign_value.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/assign_value.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/assign_value.h"
       





namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{

template<typename DerivedPolicy, typename Pointer1, typename Pointer2>
__attribute__((host)) __attribute__((device))
  void assign_value(sequential::execution_policy<DerivedPolicy> &, Pointer1 dst, Pointer2 src)
{
  *thrust::raw_pointer_cast(dst) = *thrust::raw_pointer_cast(src);
}

}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/assign_value.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/assign_value.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/assign_value.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/assign_value.h" 2
# 25 "/usr/local/cuda-8.0/include/thrust/detail/reference.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/iter_swap.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/iter_swap.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/iter_swap.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/iter_swap.h"
       






namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename Pointer1, typename Pointer2>
__attribute__((host)) __attribute__((device))
  void iter_swap(tag, Pointer1 a, Pointer2 b)
{
  using thrust::swap;
  swap(*thrust::raw_pointer_cast(a), *thrust::raw_pointer_cast(b));
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/iter_swap.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/iter_swap.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/iter_swap.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/iter_swap.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/iter_swap.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/iter_swap.h"
       



# 1 "/usr/local/cuda-8.0/include/thrust/swap.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/swap.h"
       
# 30 "/usr/local/cuda-8.0/include/thrust/swap.h"
namespace thrust
{
# 65 "/usr/local/cuda-8.0/include/thrust/swap.h"
template<typename Assignable1, typename Assignable2>
__attribute__((host)) __attribute__((device))
inline void swap(Assignable1 &a, Assignable2 &b);
# 127 "/usr/local/cuda-8.0/include/thrust/swap.h"
template<typename DerivedPolicy,
         typename ForwardIterator1,
         typename ForwardIterator2>
__attribute__((host)) __attribute__((device))
  ForwardIterator2 swap_ranges(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                               ForwardIterator1 first1,
                               ForwardIterator1 last1,
                               ForwardIterator2 first2);
# 177 "/usr/local/cuda-8.0/include/thrust/swap.h"
template<typename ForwardIterator1,
         typename ForwardIterator2>
  ForwardIterator2 swap_ranges(ForwardIterator1 first1,
                               ForwardIterator1 last1,
                               ForwardIterator2 first2);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/swap.inl" 1
# 20 "/usr/local/cuda-8.0/include/thrust/detail/swap.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/detail/swap_ranges.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/swap_ranges.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/swap_ranges.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/swap_ranges.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{

template<typename DerivedPolicy,
         typename ForwardIterator1,
         typename ForwardIterator2>
__attribute__((host)) __attribute__((device))
  ForwardIterator2 swap_ranges(thrust::execution_policy<DerivedPolicy> &exec,
                               ForwardIterator1 first1,
                               ForwardIterator1 last1,
                               ForwardIterator2 first2);

}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/swap_ranges.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/swap_ranges.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace detail
{




struct swap_pair_elements
{
  template <typename Tuple>
  __attribute__((host)) __attribute__((device))
  void operator()(Tuple t)
  {

    using thrust::swap;
    swap(thrust::get<0>(t), thrust::get<1>(t));
  }
};


}


template<typename DerivedPolicy,
         typename ForwardIterator1,
         typename ForwardIterator2>
__attribute__((host)) __attribute__((device))
  ForwardIterator2 swap_ranges(thrust::execution_policy<DerivedPolicy> &exec,
                               ForwardIterator1 first1,
                               ForwardIterator1 last1,
                               ForwardIterator2 first2)
{
  typedef thrust::tuple<ForwardIterator1,ForwardIterator2> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ZipIterator result = thrust::for_each(exec,
                                        thrust::make_zip_iterator(thrust::make_tuple(first1, first2)),
                                        thrust::make_zip_iterator(thrust::make_tuple(last1, first2)),
                                        detail::swap_pair_elements());
  return thrust::get<1>(result.get_iterator_tuple());
}


}
}
}
}
# 47 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/swap_ranges.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/swap_ranges.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/swap_ranges.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/swap_ranges.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/swap_ranges.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/swap_ranges.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/swap_ranges.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/swap_ranges.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/swap_ranges.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/swap_ranges.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/swap_ranges.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/swap_ranges.h"
       
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/swap_ranges.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/swap_ranges.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator1,
         typename ForwardIterator2>
__attribute__((host)) __attribute__((device))
  ForwardIterator2 swap_ranges(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                               ForwardIterator1 first1,
                               ForwardIterator1 last1,
                               ForwardIterator2 first2)
{
  using thrust::system::detail::generic::swap_ranges;
  return swap_ranges(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2);
}


template<typename ForwardIterator1,
         typename ForwardIterator2>
  ForwardIterator2 swap_ranges(ForwardIterator1 first1,
                               ForwardIterator1 last1,
                               ForwardIterator2 first2)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator1>::type System1;
  typedef typename thrust::iterator_system<ForwardIterator2>::type System2;

  System1 system1;
  System2 system2;

  return thrust::swap_ranges(select_system(system1,system2), first1, last1, first2);
}


}
# 21 "/usr/local/cuda-8.0/include/thrust/detail/swap.inl" 2
# 191 "/usr/local/cuda-8.0/include/thrust/swap.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/iter_swap.h" 2

namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename Pointer1, typename Pointer2>
inline __attribute__((host)) __attribute__((device))
void iter_swap(tag, Pointer1 a, Pointer2 b)
{

  struct war_nvbugs_881631
  {
    __attribute__((host)) inline static void host_path(Pointer1 a, Pointer2 b)
    {
      thrust::swap_ranges(a, a + 1, b);
    }

    __attribute__((device)) inline static void device_path(Pointer1 a, Pointer2 b)
    {
      using thrust::swap;
      swap(*thrust::raw_pointer_cast(a),
           *thrust::raw_pointer_cast(b));
    }
  };


  return war_nvbugs_881631::host_path(a,b);



}


}
}
}
}
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/iter_swap.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/reference.inl" 2


namespace thrust
{


template<typename Element, typename Pointer, typename Derived>
  template<typename OtherElement, typename OtherPointer, typename OtherDerived>
    reference<Element,Pointer,Derived>
      ::reference(const reference<OtherElement,OtherPointer,OtherDerived> &other,
                  typename thrust::detail::enable_if_convertible<
                    typename reference<OtherElement,OtherPointer,OtherDerived>::pointer,
                    pointer
                  >::type *)
        : m_ptr(other.m_ptr)
{}


template<typename Element, typename Pointer, typename Derived>
  reference<Element,Pointer,Derived>
    ::reference(const pointer &ptr)
      : m_ptr(ptr)
{}


template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::pointer
    reference<Element,Pointer,Derived>
      ::operator&() const
{
  return m_ptr;
}


template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator=(const value_type &v)
{
  assign_from(&v);
  return static_cast<derived_type&>(*this);
}


template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator=(const reference &other)
{
  assign_from(&other);
  return static_cast<derived_type&>(*this);
}


template<typename Element, typename Pointer, typename Derived>
  template<typename OtherElement, typename OtherPointer, typename OtherDerived>
    typename reference<Element,Pointer,Derived>::derived_type &
      reference<Element,Pointer,Derived>
        ::operator=(const reference<OtherElement,OtherPointer,OtherDerived> &other)
{
  assign_from(&other);
  return static_cast<derived_type&>(*this);
}


template<typename Element, typename Pointer, typename Derived>
  template<typename System>
    typename reference<Element,Pointer,Derived>::value_type
      reference<Element,Pointer,Derived>
        ::convert_to_value_type(System *system) const
{
  using thrust::system::detail::generic::select_system;
  return strip_const_get_value(select_system(*system));
}


template<typename Element, typename Pointer, typename Derived>
  reference<Element,Pointer,Derived>
    ::operator typename reference<Element,Pointer,Derived>::value_type () const
{
  typedef typename thrust::iterator_system<pointer>::type System;





  System *system = 0;

  return convert_to_value_type(system);
}


template<typename Element, typename Pointer, typename Derived>
  template<typename System>
    typename reference<Element,Pointer,Derived>::value_type
      reference<Element,Pointer,Derived>
        ::strip_const_get_value(const System &system) const
{
  System &non_const_system = const_cast<System&>(system);

  using thrust::system::detail::generic::get_value;

  return get_value(thrust::detail::derived_cast(non_const_system), m_ptr);
}


template<typename Element, typename Pointer, typename Derived>
  template<typename System1, typename System2, typename OtherPointer>
    void reference<Element,Pointer,Derived>
      ::assign_from(System1 *system1, System2 *system2, OtherPointer src)
{
  using thrust::system::detail::generic::select_system;

  strip_const_assign_value(select_system(*system1, *system2), src);
}


template<typename Element, typename Pointer, typename Derived>
  template<typename OtherPointer>
    void reference<Element,Pointer,Derived>
      ::assign_from(OtherPointer src)
{
  typedef typename thrust::iterator_system<pointer>::type System1;
  typedef typename thrust::iterator_system<OtherPointer>::type System2;





  System1 *system1 = 0;
  System2 *system2 = 0;

  assign_from(system1, system2, src);
}


template<typename Element, typename Pointer, typename Derived>
  template<typename System, typename OtherPointer>
    void reference<Element,Pointer,Derived>
      ::strip_const_assign_value(const System &system, OtherPointer src)
{
  System &non_const_system = const_cast<System&>(system);

  using thrust::system::detail::generic::assign_value;

  assign_value(thrust::detail::derived_cast(non_const_system), m_ptr, src);
}


template<typename Element, typename Pointer, typename Derived>
  template<typename System>
    void reference<Element,Pointer,Derived>
      ::swap(System *system, derived_type &other)
{
  using thrust::system::detail::generic::select_system;
  using thrust::system::detail::generic::iter_swap;

  iter_swap(select_system(*system, *system), m_ptr, other.m_ptr);
}


template<typename Element, typename Pointer, typename Derived>
  void reference<Element,Pointer,Derived>
    ::swap(derived_type &other)
{
  typedef typename thrust::iterator_system<pointer>::type System;





  System *system = 0;

  swap(system, other);
}


template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator++(void)
{
  value_type temp = *this;
  ++temp;
  *this = temp;
  return static_cast<derived_type&>(*this);
}


template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::value_type
    reference<Element,Pointer,Derived>
      ::operator++(int)
{
  value_type temp = *this;
  value_type result = temp++;
  *this = temp;
  return result;
}


template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator+=(const value_type &rhs)
{
  value_type temp = *this;
  temp += rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator--(void)
{
  value_type temp = *this;
  --temp;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::value_type
    reference<Element,Pointer,Derived>
      ::operator--(int)
{
  value_type temp = *this;
  value_type result = temp--;
  *this = temp;
  return result;
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator-=(const value_type &rhs)
{
  value_type temp = *this;
  temp -= rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator*=(const value_type &rhs)
{
  value_type temp = *this;
  temp *= rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator/=(const value_type &rhs)
{
  value_type temp = *this;
  temp /= rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator%=(const value_type &rhs)
{
  value_type temp = *this;
  temp %= rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator<<=(const value_type &rhs)
{
  value_type temp = *this;
  temp <<= rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator>>=(const value_type &rhs)
{
  value_type temp = *this;
  temp >>= rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator&=(const value_type &rhs)
{
  value_type temp = *this;
  temp &= rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator|=(const value_type &rhs)
{
  value_type temp = *this;
  temp |= rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived>
  typename reference<Element,Pointer,Derived>::derived_type &
    reference<Element,Pointer,Derived>
      ::operator^=(const value_type &rhs)
{
  value_type temp = *this;
  temp ^= rhs;
  *this = temp;
  return static_cast<derived_type&>(*this);
}

template<typename Element, typename Pointer, typename Derived,
         typename charT, typename traits>
std::basic_ostream<charT, traits> &
operator<<(std::basic_ostream<charT, traits> &os,
           const reference<Element, Pointer, Derived> &y) {
  typedef typename reference<Element, Pointer, Derived>::value_type value_type;
  return os << static_cast<value_type>(y);
}

}
# 174 "/usr/local/cuda-8.0/include/thrust/detail/reference.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/memory.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/detail/temporary_buffer.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/temporary_buffer.h"
       






# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/temporary_buffer.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/temporary_buffer.h"
       






namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
  thrust::pair<thrust::pointer<T,DerivedPolicy>, typename thrust::pointer<T,DerivedPolicy>::difference_type>
    get_temporary_buffer(thrust::execution_policy<DerivedPolicy> &exec, typename thrust::pointer<T,DerivedPolicy>::difference_type n);


template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
  void return_temporary_buffer(thrust::execution_policy<DerivedPolicy> &exec, Pointer p);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/temporary_buffer.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/temporary_buffer.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
  thrust::pair<thrust::pointer<T,DerivedPolicy>, typename thrust::pointer<T,DerivedPolicy>::difference_type>
    get_temporary_buffer(thrust::execution_policy<DerivedPolicy> &exec, typename thrust::pointer<T,DerivedPolicy>::difference_type n)
{
  thrust::pointer<T,DerivedPolicy> ptr = thrust::malloc<T>(exec, n);


  if(!ptr.get())
  {
    n = 0;
  }

  return thrust::make_pair(ptr, n);
}


template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
  void return_temporary_buffer(thrust::execution_policy<DerivedPolicy> &exec, Pointer p)
{
  thrust::free(exec, p);
}


}
}
}
}
# 51 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/temporary_buffer.h" 2
# 25 "/usr/local/cuda-8.0/include/thrust/detail/temporary_buffer.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/temporary_buffer.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/temporary_buffer.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/temporary_buffer.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/temporary_buffer.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/temporary_buffer.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/temporary_buffer.h" 2

namespace thrust
{
namespace detail
{
namespace get_temporary_buffer_detail
{


template<typename T, typename DerivedPolicy, typename Pair>
__attribute__((host)) __attribute__((device))
  thrust::pair<thrust::pointer<T,DerivedPolicy>, typename thrust::pointer<T,DerivedPolicy>::difference_type>
    down_cast_pair(Pair p)
{

  thrust::pointer<T,DerivedPolicy> ptr = thrust::pointer<T,DerivedPolicy>(static_cast<T*>(thrust::raw_pointer_cast(p.first)));

  typedef thrust::pair<thrust::pointer<T,DerivedPolicy>, typename thrust::pointer<T,DerivedPolicy>::difference_type> result_type;
  return result_type(ptr, p.second);
}


}
}


 #pragma nv_exec_check_disable
template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
  thrust::pair<thrust::pointer<T,DerivedPolicy>, typename thrust::pointer<T,DerivedPolicy>::difference_type>
    get_temporary_buffer(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, typename thrust::pointer<T,DerivedPolicy>::difference_type n)
{
  using thrust::system::detail::generic::get_temporary_buffer;

  return thrust::detail::get_temporary_buffer_detail::down_cast_pair<T,DerivedPolicy>(get_temporary_buffer<T>(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), n));
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
  void return_temporary_buffer(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, Pointer p)
{
  using thrust::system::detail::generic::return_temporary_buffer;

  return return_temporary_buffer(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), p);
}


}
# 30 "/usr/local/cuda-8.0/include/thrust/memory.h" 2

namespace thrust
{
# 303 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
pointer<void,DerivedPolicy> malloc(const thrust::detail::execution_policy_base<DerivedPolicy> &system, std::size_t n);
# 341 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
pointer<T,DerivedPolicy> malloc(const thrust::detail::execution_policy_base<DerivedPolicy> &system, std::size_t n);
# 394 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
thrust::pair<thrust::pointer<T,DerivedPolicy>, typename thrust::pointer<T,DerivedPolicy>::difference_type>
get_temporary_buffer(const thrust::detail::execution_policy_base<DerivedPolicy> &system, typename thrust::pointer<T,DerivedPolicy>::difference_type n);
# 437 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
void free(const thrust::detail::execution_policy_base<DerivedPolicy> &system, Pointer ptr);
# 483 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
void return_temporary_buffer(const thrust::detail::execution_policy_base<DerivedPolicy> &system, Pointer p);
# 499 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename Pointer>
__attribute__((host)) __attribute__((device))
inline typename thrust::detail::pointer_traits<Pointer>::raw_pointer
  raw_pointer_cast(const Pointer &ptr);
# 516 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename T>
__attribute__((host)) __attribute__((device))
inline typename detail::raw_reference<T>::type
  raw_reference_cast(T &ref);
# 533 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename T>
__attribute__((host)) __attribute__((device))
inline typename detail::raw_reference<const T>::type
  raw_reference_cast(const T &ref);





}
# 24 "/usr/local/cuda-8.0/include/thrust/detail/allocator/temporary_allocator.h" 2


namespace thrust
{
namespace detail
{





template<typename T, typename System>
  class temporary_allocator
    : public thrust::detail::tagged_allocator<
               T, System, thrust::pointer<T,System>
             >
{
  private:
    typedef thrust::detail::tagged_allocator<
      T, System, thrust::pointer<T,System>
    > super_t;

    System &m_system;

  public:
    typedef typename super_t::pointer pointer;
    typedef typename super_t::size_type size_type;

    inline __attribute__((host)) __attribute__((device))
    temporary_allocator(const temporary_allocator &other) :
      super_t(),
      m_system(other.m_system)
    {}

    inline __attribute__((host)) __attribute__((device))
    explicit temporary_allocator(thrust::execution_policy<System> &system) :
      super_t(),
      m_system(thrust::detail::derived_cast(system))
    {}

    __attribute__((host)) __attribute__((device))
    pointer allocate(size_type cnt);

    __attribute__((host)) __attribute__((device))
    void deallocate(pointer p, size_type n);

    __attribute__((host)) __attribute__((device))
    inline System &system()
    {
      return m_system;
    }

  private:
    typedef thrust::pair<pointer, size_type> pointer_and_size;
};


}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/temporary_allocator.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/allocator/temporary_allocator.inl"
# 1 "/usr/include/c++/4.8.2/cassert" 1 3
# 41 "/usr/include/c++/4.8.2/cassert" 3
       
# 42 "/usr/include/c++/4.8.2/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 43 "/usr/include/c++/4.8.2/cassert" 2 3
# 22 "/usr/local/cuda-8.0/include/thrust/detail/allocator/temporary_allocator.inl" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/terminate.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/terminate.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


inline __attribute__((device))
void terminate()
{
  thrust::system::cuda::detail::bulk_::detail::terminate();
}


__attribute__((host)) __attribute__((device))
inline void terminate_with_message(const char* message)
{
  thrust::system::cuda::detail::bulk_::detail::terminate_with_message(message);
}


}
}
}
}
# 25 "/usr/local/cuda-8.0/include/thrust/detail/allocator/temporary_allocator.inl" 2


namespace thrust
{
namespace detail
{


template<typename T, typename System>
__attribute__((host)) __attribute__((device))
  typename temporary_allocator<T,System>::pointer
    temporary_allocator<T,System>
      ::allocate(typename temporary_allocator<T,System>::size_type cnt)
{
  pointer_and_size result = thrust::get_temporary_buffer<T>(system(), cnt);


  if(result.second < cnt)
  {


    deallocate(result.first, cnt);


    throw thrust::system::detail::bad_alloc("temporary_buffer::allocate: get_temporary_buffer failed");



  }

  return result.first;
}


template<typename T, typename System>
__attribute__((host)) __attribute__((device))
  void temporary_allocator<T,System>
    ::deallocate(typename temporary_allocator<T,System>::pointer p, typename temporary_allocator<T,System>::size_type n)
{
  return thrust::return_temporary_buffer(system(), p);
}


}
}
# 85 "/usr/local/cuda-8.0/include/thrust/detail/allocator/temporary_allocator.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/temporary_array.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/no_throw_allocator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/allocator/no_throw_allocator.h"
       



namespace thrust
{
namespace detail
{

template<typename BaseAllocator>
  struct no_throw_allocator : BaseAllocator
{
  private:
    typedef BaseAllocator super_t;

  public:
    inline __attribute__((host)) __attribute__((device))
    no_throw_allocator(const BaseAllocator &other = BaseAllocator())
      : super_t(other)
    {}

    template<typename U>
      struct rebind
    {
      typedef no_throw_allocator<typename super_t::template rebind<U>::other> other;
    };

    __attribute__((host)) __attribute__((device))
    void deallocate(typename super_t::pointer p, typename super_t::size_type n)
    {

      try
      {
        super_t::deallocate(p, n);
      }
      catch(...)
      {

      }



    }

    inline __attribute__((host)) __attribute__((device))
    bool operator==(no_throw_allocator const &other) { return super_t::operator==(other); }

    inline __attribute__((host)) __attribute__((device))
    bool operator!=(no_throw_allocator const &other) { return super_t::operator!=(other); }
};

}
}
# 29 "/usr/local/cuda-8.0/include/thrust/detail/temporary_array.h" 2


namespace thrust
{
namespace detail
{


template<typename T, typename System>
  class temporary_array
    : public contiguous_storage<
               T,
               no_throw_allocator<
                 temporary_allocator<T,System>
               >
             >
{
  private:
    typedef contiguous_storage<
      T,
      no_throw_allocator<
        temporary_allocator<T,System>
      >
    > super_t;


    typedef no_throw_allocator<temporary_allocator<T,System> > alloc_type;

  public:
    typedef typename super_t::size_type size_type;

    __attribute__((host)) __attribute__((device))
    temporary_array(thrust::execution_policy<System> &system);

    __attribute__((host)) __attribute__((device))
    temporary_array(thrust::execution_policy<System> &system, size_type n);


    __attribute__((host)) __attribute__((device))
    temporary_array(int uninit, thrust::execution_policy<System> &system, size_type n);

    template<typename InputIterator>
    __attribute__((host)) __attribute__((device))
    temporary_array(thrust::execution_policy<System> &system,
                    InputIterator first,
                    size_type n);

    template<typename InputIterator, typename InputSystem>
    __attribute__((host)) __attribute__((device))
    temporary_array(thrust::execution_policy<System> &system,
                    thrust::execution_policy<InputSystem> &input_system,
                    InputIterator first,
                    size_type n);

    template<typename InputIterator>
    __attribute__((host)) __attribute__((device))
    temporary_array(thrust::execution_policy<System> &system,
                    InputIterator first,
                    InputIterator last);

    template<typename InputSystem, typename InputIterator>
    __attribute__((host)) __attribute__((device))
    temporary_array(thrust::execution_policy<System> &system,
                    thrust::execution_policy<InputSystem> &input_system,
                    InputIterator first,
                    InputIterator last);

    __attribute__((host)) __attribute__((device))
    ~temporary_array();
};



template<typename Iterator, typename System>
  class tagged_iterator_range
{
  public:
    typedef thrust::detail::tagged_iterator<Iterator,System> iterator;

    template<typename Ignored1, typename Ignored2>
    tagged_iterator_range(const Ignored1 &, const Ignored2 &, Iterator first, Iterator last)
      : m_begin(first),
        m_end(last)
    {}

    iterator begin(void) const { return m_begin; }
    iterator end(void) const { return m_end; }

  private:
    iterator m_begin, m_end;
};





template<typename Iterator, typename FromSystem, typename ToSystem>
  struct move_to_system_base
    : public eval_if<
        is_convertible<
          FromSystem,
          ToSystem
        >::value,
        identity_<
          tagged_iterator_range<Iterator,ToSystem>
        >,
        identity_<
          temporary_array<
            typename thrust::iterator_value<Iterator>::type,
            ToSystem
          >
        >
      >
{};


template<typename Iterator, typename FromSystem, typename ToSystem>
  class move_to_system
    : public move_to_system_base<
        Iterator,
        FromSystem,
        ToSystem
      >::type
{
  typedef typename move_to_system_base<Iterator,FromSystem,ToSystem>::type super_t;

  public:
    move_to_system(thrust::execution_policy<FromSystem> &from_system,
                   thrust::execution_policy<ToSystem> &to_system,
                   Iterator first,
                   Iterator last)
      : super_t(to_system, from_system, first, last) {}
};


}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/temporary_array.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/detail/temporary_array.inl"
namespace thrust
{

namespace detail
{
namespace temporary_array_detail
{


template<typename T> struct avoid_initialization : thrust::detail::has_trivial_copy_constructor<T> {};


template<typename T, typename TemporaryArray, typename Size>
__attribute__((host)) __attribute__((device))
typename thrust::detail::enable_if<
  avoid_initialization<T>::value
>::type
  construct_values(TemporaryArray &,
                   Size)
{

}


template<typename T, typename TemporaryArray, typename Size>
__attribute__((host)) __attribute__((device))
typename thrust::detail::disable_if<
  avoid_initialization<T>::value
>::type
  construct_values(TemporaryArray &a,
                   Size n)
{
  a.default_construct_n(a.begin(), n);
}


}


template<typename T, typename System>
__attribute__((host)) __attribute__((device))
  temporary_array<T,System>
    ::temporary_array(thrust::execution_policy<System> &system)
      :super_t(alloc_type(temporary_allocator<T,System>(system)))
{
}


template<typename T, typename System>
__attribute__((host)) __attribute__((device))
  temporary_array<T,System>
    ::temporary_array(thrust::execution_policy<System> &system, size_type n)
      :super_t(n, alloc_type(temporary_allocator<T,System>(system)))
{
  temporary_array_detail::construct_values<T>(*this, n);
}


template<typename T, typename System>
__attribute__((host)) __attribute__((device))
  temporary_array<T,System>
    ::temporary_array(int, thrust::execution_policy<System> &system, size_type n)
      :super_t(n, alloc_type(temporary_allocator<T,System>(system)))
{

  ;
}


template<typename T, typename System>
  template<typename InputIterator>
  __attribute__((host)) __attribute__((device))
    temporary_array<T,System>
      ::temporary_array(thrust::execution_policy<System> &system,
                        InputIterator first,
                        size_type n)
        : super_t(alloc_type(temporary_allocator<T,System>(system)))
{
  super_t::allocate(n);

  super_t::uninitialized_copy_n(system, first, n, super_t::begin());
}


template<typename T, typename System>
  template<typename InputIterator, typename InputSystem>
  __attribute__((host)) __attribute__((device))
    temporary_array<T,System>
      ::temporary_array(thrust::execution_policy<System> &system,
                        thrust::execution_policy<InputSystem> &input_system,
                        InputIterator first,
                        size_type n)
        : super_t(alloc_type(temporary_allocator<T,System>(system)))
{
  super_t::allocate(n);

  super_t::uninitialized_copy_n(input_system, first, n, super_t::begin());
}


template<typename T, typename System>
  template<typename InputIterator>
  __attribute__((host)) __attribute__((device))
    temporary_array<T,System>
      ::temporary_array(thrust::execution_policy<System> &system,
                        InputIterator first,
                        InputIterator last)
        : super_t(alloc_type(temporary_allocator<T,System>(system)))
{
  super_t::allocate(thrust::distance(first,last));

  super_t::uninitialized_copy(system, first, last, super_t::begin());
}


template<typename T, typename System>
  template<typename InputSystem, typename InputIterator>
  __attribute__((host)) __attribute__((device))
    temporary_array<T,System>
      ::temporary_array(thrust::execution_policy<System> &system,
                        thrust::execution_policy<InputSystem> &input_system,
                        InputIterator first,
                        InputIterator last)
        : super_t(alloc_type(temporary_allocator<T,System>(system)))
{
  super_t::allocate(thrust::distance(first,last));

  super_t::uninitialized_copy(input_system, first, last, super_t::begin());
}


template<typename T, typename System>
__attribute__((host)) __attribute__((device))
  temporary_array<T,System>
    ::~temporary_array()
{

  super_t::destroy(super_t::begin(), super_t::end());
}

}

}
# 168 "/usr/local/cuda-8.0/include/thrust/detail/temporary_array.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_cross_system.inl" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.h" 1
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.h"
namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void trivial_copy_n(execution_policy<DerivedPolicy> &exec,
                    RandomAccessIterator1 first,
                    Size n,
                    RandomAccessIterator2 result);


template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
void trivial_copy_n(cross_system<System1,System2> &exec,
                    RandomAccessIterator1 first,
                    Size n,
                    RandomAccessIterator2 result);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.inl"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.h" 1
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.h"
namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void trivial_copy_n(execution_policy<DerivedPolicy> &exec,
                    RandomAccessIterator1 first,
                    Size n,
                    RandomAccessIterator2 result);


template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
void trivial_copy_n(cross_system<System1,System2> &exec,
                    RandomAccessIterator1 first,
                    Size n,
                    RandomAccessIterator2 result);


}
}
}
}
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.inl" 2




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/synchronize.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/synchronize.h"
       



namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


inline __attribute__((host)) __attribute__((device))
void synchronize(const char *message = "");

inline __attribute__((host)) __attribute__((device))
void synchronize(cudaStream_t stream, const char *message = "");


inline __attribute__((host)) __attribute__((device))
void synchronize_if_enabled(const char *message = "");



}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/synchronize.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/synchronize.inl"
namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


inline __attribute__((host)) __attribute__((device))
void synchronize(const char *message)
{
  throw_on_error(cudaDeviceSynchronize(), message);
}


inline __attribute__((host)) __attribute__((device))
void synchronize(cudaStream_t stream, const char *message)
{

  throw_on_error(cudaStreamSynchronize(stream), message);



}

inline __attribute__((host)) __attribute__((device))
void synchronize_if_enabled(const char *message)
{






  (void) message;

}


}
}
}
}
# 50 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/synchronize.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.inl" 2






namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace trivial_copy_detail
{

inline void checked_cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream)
{
  cudaError_t error = cudaMemcpyAsync(dst,src,count,kind,stream);
  if(error)
  {
    throw thrust::system_error(error, thrust::cuda_category());
  }
}


template<typename System1,
         typename System2>
cudaMemcpyKind cuda_memcpy_kind(const thrust::cuda::execution_policy<System1> &,
                                const thrust::cpp::execution_policy<System2> &)
{
  return cudaMemcpyDeviceToHost;
}


template<typename System1,
         typename System2>
cudaMemcpyKind cuda_memcpy_kind(const thrust::cpp::execution_policy<System1> &,
                                const thrust::cuda::execution_policy<System2> &)
{
  return cudaMemcpyHostToDevice;
}

template<typename System>
cudaMemcpyKind cuda_memcpy_kind(const thrust::cuda::execution_policy<System> &,
                                const thrust::cuda::execution_policy<System> &)
{







  return cudaMemcpyDefault;

}

namespace {






template<class T>
bool is_valid_policy(T const& t)
{
  volatile size_t value = reinterpret_cast<size_t>(&t);
  if (value)
  {
    if (value == 0)
    {
      fprintf(stderr, " clang WAR failed. Terminate.\n");
      std::terminate();
    }
    return true;
  }
  return false;
}
}

template<typename System1,
         typename System2>
cudaStream_t cuda_memcpy_stream(const thrust::cuda::execution_policy<System1> &exec,
                                const thrust::cpp::execution_policy<System2> &)
{
  if (is_valid_policy(exec))
    return stream(derived_cast(exec));
  return legacy_stream();
}

template<typename System1,
         typename System2>
cudaStream_t cuda_memcpy_stream(const thrust::cpp::execution_policy<System1> &,
                                const thrust::cuda::execution_policy<System2> &exec)
{
  if (is_valid_policy(exec))
    return stream(derived_cast(exec));
  return legacy_stream();
}


template<typename System>
cudaStream_t cuda_memcpy_stream(const thrust::cuda::execution_policy<System> &,
                                const thrust::cuda::execution_policy<System> &exec)
{
  if (is_valid_policy(exec))
    return stream(derived_cast(exec));
  return legacy_stream();
}



template<class System>
cudaStream_t cuda_memcpy_stream(const thrust::system::cuda::detail::execute_on_stream &exec,
                                const thrust::cuda::execution_policy<System> &)
{
  if (is_valid_policy(exec))
    return stream(exec);
  return legacy_stream();
}





}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void trivial_copy_n(execution_policy<DerivedPolicy> &exec,
                    RandomAccessIterator1 first,
                    Size n,
                    RandomAccessIterator2 result)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type T;


  void *dst = thrust::raw_pointer_cast(&*result);
  const void *src = thrust::raw_pointer_cast(&*first);






  cudaMemcpyKind kind = trivial_copy_detail::cuda_memcpy_kind(thrust::detail::derived_cast(exec), thrust::detail::derived_cast(exec));
  trivial_copy_detail::checked_cudaMemcpyAsync(dst, src, n * sizeof(T), kind, stream(thrust::detail::derived_cast(exec)));



}


template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
void trivial_copy_n(cross_system<System1,System2> &systems,
                    RandomAccessIterator1 first,
                    Size n,
                    RandomAccessIterator2 result)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type T;

  void *dst = thrust::raw_pointer_cast(&*result);
  const void *src = thrust::raw_pointer_cast(&*first);

  cudaMemcpyKind kind = trivial_copy_detail::cuda_memcpy_kind(thrust::detail::derived_cast(systems.system1), thrust::detail::derived_cast(systems.system2));



  cudaStream_t s = trivial_copy_detail::cuda_memcpy_stream(derived_cast(systems.system1), derived_cast(systems.system2));
  trivial_copy_detail::checked_cudaMemcpyAsync(dst, src, n * sizeof(T), kind, s);
  synchronize(s, "failed synchronize in thrust::system::cuda::detail::trivial_copy_n");
}


}
}
}
}
# 58 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_cross_system.inl" 2

namespace thrust
{
namespace detail
{


template<typename,typename> class temporary_array;

}

namespace system
{
namespace cuda
{
namespace detail
{



template<typename System1,
         typename System2,
         typename InputIterator,
         typename RandomAccessIterator>
  RandomAccessIterator copy_cross_system(cross_system<System1,System2> systems,
                                         InputIterator begin,
                                         InputIterator end,
                                         RandomAccessIterator result,
                                         thrust::incrementable_traversal_tag,
                                         thrust::random_access_traversal_tag)
{




  typedef typename thrust::iterator_value<InputIterator>::type InputType;


  thrust::detail::temporary_array<InputType, System1> temp(systems.system1,begin,end);
  return thrust::copy(systems, temp.begin(), temp.end(), result);
}

template<typename System1,
         typename System2,
         typename InputIterator,
         typename Size,
         typename RandomAccessIterator>
  RandomAccessIterator copy_cross_system_n(cross_system<System1,System2> systems,
                                           InputIterator first,
                                           Size n,
                                           RandomAccessIterator result,
                                           thrust::incrementable_traversal_tag,
                                           thrust::random_access_traversal_tag)
{
  typedef typename thrust::iterator_value<InputIterator>::type InputType;


  thrust::detail::temporary_array<InputType, System1> temp(systems.system1, first, n);


  return copy_cross_system(systems, temp.begin(), temp.end(), result);
}



template<typename System1,
         typename System2,
         typename RandomAccessIterator,
         typename OutputIterator>
  OutputIterator copy_cross_system(cross_system<System1,System2> systems,
                                   RandomAccessIterator begin,
                                   RandomAccessIterator end,
                                   OutputIterator result,
                                   thrust::random_access_traversal_tag,
                                   thrust::incrementable_traversal_tag)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type InputType;


  thrust::detail::temporary_array<InputType,System2> temp(systems.system2, systems.system1, begin, end);

  return thrust::copy(systems.system2, temp.begin(), temp.end(), result);
}

template<typename System1,
         typename System2,
         typename RandomAccessIterator,
         typename Size,
         typename OutputIterator>
  OutputIterator copy_cross_system_n(cross_system<System1,System2> systems,
                                     RandomAccessIterator first,
                                     Size n,
                                     OutputIterator result,
                                     thrust::random_access_traversal_tag,
                                     thrust::incrementable_traversal_tag)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type InputType;


  thrust::detail::temporary_array<InputType,System2> temp(systems.system2, systems.system1, first, n);


  return thrust::copy(systems.system2, temp.begin(), temp.end(), result);
}



template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  RandomAccessIterator2 copy_cross_system(cross_system<System1,System2> systems,
                                          RandomAccessIterator1 begin,
                                          RandomAccessIterator1 end,
                                          RandomAccessIterator2 result,
                                          thrust::random_access_traversal_tag,
                                          thrust::random_access_traversal_tag,
                                          thrust::detail::true_type)
{






  typename thrust::iterator_traits<RandomAccessIterator1>::difference_type n = end - begin;

  thrust::system::cuda::detail::trivial_copy_n(systems, begin, n, result);

  return result + n;
}


namespace detail
{


template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  RandomAccessIterator2 non_trivial_random_access_copy_cross_system(cross_system<System1,System2> systems,
                                                                    RandomAccessIterator1 begin,
                                                                    RandomAccessIterator1 end,
                                                                    RandomAccessIterator2 result,
                                                                    thrust::detail::false_type)
{

  typedef typename thrust::iterator_value<RandomAccessIterator2>::type OutputType;


  thrust::detail::temporary_array<OutputType,System1> temp(systems.system1, begin, end);


  return copy_cross_system(systems, temp.begin(), temp.end(), result);
}

template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  RandomAccessIterator2 non_trivial_random_access_copy_cross_system(cross_system<System1,System2> systems,
                                                                    RandomAccessIterator1 begin,
                                                                    RandomAccessIterator1 end,
                                                                    RandomAccessIterator2 result,
                                                                    thrust::detail::true_type)
{
  typename thrust::iterator_difference<RandomAccessIterator1>::type n = thrust::distance(begin, end);




  typedef typename thrust::iterator_value<RandomAccessIterator1>::type InputType;
  thrust::detail::temporary_array<InputType,System2> temp(0, systems.system2, n);






  thrust::system::cuda::detail::trivial_copy_n(systems, begin, n, temp.begin());


  return thrust::copy(systems.system2, temp.begin(), temp.end(), result);
}

}



template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  RandomAccessIterator2 copy_cross_system(cross_system<System1,System2> systems,
                                          RandomAccessIterator1 begin,
                                          RandomAccessIterator1 end,
                                          RandomAccessIterator2 result,
                                          thrust::random_access_traversal_tag,
                                          thrust::random_access_traversal_tag,
                                          thrust::detail::false_type)
{

  return detail::non_trivial_random_access_copy_cross_system(systems, begin, end, result,
      typename thrust::detail::is_trivial_iterator<RandomAccessIterator1>::type());
}


template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  RandomAccessIterator2 copy_cross_system(cross_system<System1,System2> systems,
                                          RandomAccessIterator1 begin,
                                          RandomAccessIterator1 end,
                                          RandomAccessIterator2 result,
                                          thrust::random_access_traversal_tag input_traversal,
                                          thrust::random_access_traversal_tag output_traversal)
{

  return copy_cross_system(systems, begin, end, result, input_traversal, output_traversal,
          typename thrust::detail::dispatch::is_trivial_copy<RandomAccessIterator1,RandomAccessIterator2>::type());
}

template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
  RandomAccessIterator2 copy_cross_system_n(cross_system<System1,System2> systems,
                                            RandomAccessIterator1 first,
                                            Size n,
                                            RandomAccessIterator2 result,
                                            thrust::random_access_traversal_tag input_traversal,
                                            thrust::random_access_traversal_tag output_traversal)
{

  return copy_cross_system(systems, first, first + n, result, input_traversal, output_traversal);
}





template<typename System1,
         typename System2,
         typename InputIterator,
         typename OutputIterator>
  OutputIterator copy_cross_system(cross_system<System1,System2> systems,
                                   InputIterator begin,
                                   InputIterator end,
                                   OutputIterator result)
{
  return copy_cross_system(systems, begin, end, result,
          typename thrust::iterator_traversal<InputIterator>::type(),
          typename thrust::iterator_traversal<OutputIterator>::type());
}

template<typename System1,
         typename System2,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
  OutputIterator copy_cross_system_n(cross_system<System1,System2> systems,
                                     InputIterator begin,
                                     Size n,
                                     OutputIterator result)
{
  return copy_cross_system_n(systems, begin, n, result,
          typename thrust::iterator_traversal<InputIterator>::type(),
          typename thrust::iterator_traversal<OutputIterator>::type());
}

}
}
}
}
# 59 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_cross_system.h" 2
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_device_to_device.inl" 2






# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.h" 1
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/trivial_copy.h"
namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void trivial_copy_n(execution_policy<DerivedPolicy> &exec,
                    RandomAccessIterator1 first,
                    Size n,
                    RandomAccessIterator2 result);


template<typename System1,
         typename System2,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2>
void trivial_copy_n(cross_system<System1,System2> &exec,
                    RandomAccessIterator1 first,
                    Size n,
                    RandomAccessIterator2 result);


}
}
}
}
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_device_to_device.inl" 2

namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
OutputIterator copy_device_to_device(execution_policy<DerivedPolicy> &exec,
                                     InputIterator begin,
                                     InputIterator end,
                                     OutputIterator result,
                                     thrust::detail::false_type)
{

    typedef typename thrust::iterator_traits<InputIterator>::value_type InputType;


    return thrust::transform(exec, begin, end, result, thrust::identity<InputType>());
# 72 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_device_to_device.inl"
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
OutputIterator copy_device_to_device(execution_policy<DerivedPolicy> &exec,
                                     InputIterator begin,
                                     InputIterator end,
                                     OutputIterator result,
                                     thrust::detail::true_type)
{




  typename thrust::iterator_traits<OutputIterator>::difference_type n = end - begin;

  thrust::system::cuda::detail::trivial_copy_n(exec, begin, n, result);

  return result + n;
}


}







template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
OutputIterator copy_device_to_device(execution_policy<DerivedPolicy> &exec,
                                     InputIterator begin,
                                     InputIterator end,
                                     OutputIterator result)
{
  typedef typename thrust::iterator_traits<InputIterator>::value_type InputType;
  typedef typename thrust::iterator_traits<OutputIterator>::value_type OutputType;

  const bool use_trivial_copy =
      thrust::detail::is_same<InputType, OutputType>::value
      && thrust::detail::is_trivial_iterator<InputIterator>::value
      && thrust::detail::is_trivial_iterator<OutputIterator>::value;


  (void) use_trivial_copy;

  return detail::copy_device_to_device(exec, begin, end, result,
          thrust::detail::integral_constant<bool, use_trivial_copy>());
}


}
}
}
}
# 52 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_device_to_device.h" 2
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy.inl" 2


namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename System,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
OutputIterator copy(execution_policy<System> &system,
                    InputIterator first,
                    InputIterator last,
                    OutputIterator result)
{
  return thrust::system::cuda::detail::copy_device_to_device(system,first,last,result);
}


template<typename System1,
         typename System2,
         typename InputIterator,
         typename OutputIterator>
OutputIterator copy(cross_system<System1,System2> systems,
                    InputIterator first,
                    InputIterator last,
                    OutputIterator result)
{
  return thrust::system::cuda::detail::copy_cross_system(systems,first,last,result);
}


template<typename System,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
OutputIterator copy_n(execution_policy<System> &system,
                      InputIterator first,
                      Size n,
                      OutputIterator result)
{
  return thrust::system::cuda::detail::copy_device_to_device(system,first,first+n,result);
}


template<typename System1,
         typename System2,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
OutputIterator copy_n(cross_system<System1,System2> systems,
                      InputIterator first,
                      Size n,
                      OutputIterator result)
{
  return thrust::system::cuda::detail::copy_cross_system_n(systems,first,n,result);
}


}
}
}
}
# 81 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy.h" 2
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/detail/copy.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      OutputIterator result)
{
  using thrust::system::detail::generic::copy;
  return copy(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename Size, typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                        InputIterator first,
                        Size n,
                        OutputIterator result)
{
  using thrust::system::detail::generic::copy_n;
  return copy_n(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, n, result);
}


namespace detail
{


 #pragma nv_exec_check_disable
template<typename System1,
         typename System2,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator two_system_copy(const thrust::execution_policy<System1> &system1,
                                 const thrust::execution_policy<System2> &system2,
                                 InputIterator first,
                                 InputIterator last,
                                 OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  return thrust::copy(select_system(thrust::detail::derived_cast(thrust::detail::strip_const(system1)), thrust::detail::derived_cast(thrust::detail::strip_const(system2))), first, last, result);
}


 #pragma nv_exec_check_disable
template<typename System1,
         typename System2,
         typename InputIterator,
         typename Size,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator two_system_copy_n(const thrust::execution_policy<System1> &system1,
                                   const thrust::execution_policy<System2> &system2,
                                   InputIterator first,
                                   Size n,
                                   OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  return thrust::copy_n(select_system(thrust::detail::derived_cast(thrust::detail::strip_const(system1)), thrust::detail::derived_cast(thrust::detail::strip_const(system2))), first, n, result);
}


}


template<typename InputIterator,
         typename OutputIterator>
  OutputIterator copy(InputIterator first,
                      InputIterator last,
                      OutputIterator result)
{
  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::detail::two_system_copy(system1, system2, first, last, result);
}


template<typename InputIterator,
         typename Size,
         typename OutputIterator>
  OutputIterator copy_n(InputIterator first,
                        Size n,
                        OutputIterator result)
{
  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::detail::two_system_copy_n(system1, system2, first, n, result);
}


}
# 91 "/usr/local/cuda-8.0/include/thrust/detail/copy.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/detail/allocator/copy_construct_range.inl" 2







namespace thrust
{
namespace detail
{
namespace allocator_traits_detail
{


template<typename Allocator, typename InputType, typename OutputType>
  struct copy_construct_with_allocator
{
  Allocator &a;

  __attribute__((host)) __attribute__((device))
  copy_construct_with_allocator(Allocator &a)
    : a(a)
  {}

  template<typename Tuple>
  inline __attribute__((host)) __attribute__((device))
  void operator()(Tuple t)
  {
    const InputType &in = thrust::get<0>(t);
    OutputType &out = thrust::get<1>(t);

    allocator_traits<Allocator>::construct(a, &out, in);
  }
};






template<typename Allocator, typename T>
  struct needs_copy_construct_via_allocator
    : integral_constant<
        bool,
        (has_member_construct2<Allocator,T,T>::value || !has_trivial_copy_constructor<T>::value)
      >
{};




template<typename U, typename T>
  struct needs_copy_construct_via_allocator<std::allocator<U>, T>
    : integral_constant<
        bool,
        !has_trivial_copy_constructor<T>::value
      >
{};






template<typename Allocator, typename FromSystem, typename ToSystem, typename InputIterator, typename Pointer>
__attribute__((host)) __attribute__((device))
  typename enable_if_convertible<
    FromSystem,
    ToSystem,
    Pointer
  >::type
    uninitialized_copy_with_allocator(Allocator &a,
                                      const thrust::execution_policy<FromSystem> &from_system,
                                      const thrust::execution_policy<ToSystem> &to_system,
                                      InputIterator first,
                                      InputIterator last,
                                      Pointer result)
{

  typedef thrust::tuple<InputIterator,Pointer> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ZipIterator begin = thrust::make_zip_iterator(thrust::make_tuple(first,result));
  ZipIterator end = begin;


  const typename thrust::iterator_difference<InputIterator>::type n = thrust::distance(first,last);
  thrust::advance(end,n);


  typedef typename iterator_traits<InputIterator>::value_type InputType;
  typedef typename iterator_traits<Pointer>::value_type OutputType;



  thrust::for_each(to_system, begin, end, copy_construct_with_allocator<Allocator,InputType,OutputType>(a));


  return thrust::get<1>(end.get_iterator_tuple());
}






template<typename Allocator, typename FromSystem, typename ToSystem, typename InputIterator, typename Size, typename Pointer>
__attribute__((host)) __attribute__((device))
  typename enable_if_convertible<
    FromSystem,
    ToSystem,
    Pointer
  >::type
    uninitialized_copy_with_allocator_n(Allocator &a,
                                        const thrust::execution_policy<FromSystem> &from_system,
                                        const thrust::execution_policy<ToSystem> &to_system,
                                        InputIterator first,
                                        Size n,
                                        Pointer result)
{

  typedef thrust::tuple<InputIterator,Pointer> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ZipIterator begin = thrust::make_zip_iterator(thrust::make_tuple(first,result));


  typedef typename iterator_traits<InputIterator>::value_type InputType;
  typedef typename iterator_traits<Pointer>::value_type OutputType;



  ZipIterator end = thrust::for_each_n(to_system, begin, n, copy_construct_with_allocator<Allocator,InputType,OutputType>(a));


  return thrust::get<1>(end.get_iterator_tuple());
}


template<typename Allocator, typename FromSystem, typename ToSystem, typename InputIterator, typename Pointer>
__attribute__((host)) __attribute__((device))
  typename disable_if_convertible<
    FromSystem,
    ToSystem,
    Pointer
  >::type
    uninitialized_copy_with_allocator(Allocator &,
                                      const thrust::execution_policy<FromSystem> &from_system,
                                      const thrust::execution_policy<ToSystem> &to_system,
                                      InputIterator first,
                                      InputIterator last,
                                      Pointer result)
{


  return thrust::detail::two_system_copy(from_system, to_system, first, last, result);
}


template<typename Allocator, typename FromSystem, typename ToSystem, typename InputIterator, typename Size, typename Pointer>
__attribute__((host)) __attribute__((device))
  typename disable_if_convertible<
    FromSystem,
    ToSystem,
    Pointer
  >::type
    uninitialized_copy_with_allocator_n(Allocator &,
                                        const thrust::execution_policy<FromSystem> &from_system,
                                        const thrust::execution_policy<ToSystem> &to_system,
                                        InputIterator first,
                                        Size n,
                                        Pointer result)
{


  return thrust::detail::two_system_copy_n(from_system, to_system, first, n, result);
}


template<typename FromSystem, typename Allocator, typename InputIterator, typename Pointer>
__attribute__((host)) __attribute__((device))
  typename disable_if<
    needs_copy_construct_via_allocator<
      Allocator,
      typename pointer_element<Pointer>::type
    >::value,
    Pointer
  >::type
    copy_construct_range(thrust::execution_policy<FromSystem> &from_system,
                         Allocator &a,
                         InputIterator first,
                         InputIterator last,
                         Pointer result)
{

  return thrust::detail::two_system_copy(from_system, allocator_system<Allocator>::get(a), first, last, result);
}


template<typename FromSystem, typename Allocator, typename InputIterator, typename Size, typename Pointer>
__attribute__((host)) __attribute__((device))
  typename disable_if<
    needs_copy_construct_via_allocator<
      Allocator,
      typename pointer_element<Pointer>::type
    >::value,
    Pointer
  >::type
    copy_construct_range_n(thrust::execution_policy<FromSystem> &from_system,
                           Allocator &a,
                           InputIterator first,
                           Size n,
                           Pointer result)
{

  return thrust::detail::two_system_copy_n(from_system, allocator_system<Allocator>::get(a), first, n, result);
}


template<typename FromSystem, typename Allocator, typename InputIterator, typename Pointer>
__attribute__((host)) __attribute__((device))
  typename enable_if<
    needs_copy_construct_via_allocator<
      Allocator,
      typename pointer_element<Pointer>::type
    >::value,
    Pointer
  >::type
    copy_construct_range(thrust::execution_policy<FromSystem> &from_system,
                         Allocator &a,
                         InputIterator first,
                         InputIterator last,
                         Pointer result)
{
  return uninitialized_copy_with_allocator(a, from_system, allocator_system<Allocator>::get(a), first, last, result);
}


template<typename FromSystem, typename Allocator, typename InputIterator, typename Size, typename Pointer>
__attribute__((host)) __attribute__((device))
  typename enable_if<
    needs_copy_construct_via_allocator<
      Allocator,
      typename pointer_element<Pointer>::type
    >::value,
    Pointer
  >::type
    copy_construct_range_n(thrust::execution_policy<FromSystem> &from_system,
                           Allocator &a,
                           InputIterator first,
                           Size n,
                           Pointer result)
{
  return uninitialized_copy_with_allocator_n(a, from_system, allocator_system<Allocator>::get(a), first, n, result);
}


}


template<typename System, typename Allocator, typename InputIterator, typename Pointer>
__attribute__((host)) __attribute__((device))
  Pointer copy_construct_range(thrust::execution_policy<System> &from_system,
                               Allocator &a,
                               InputIterator first,
                               InputIterator last,
                               Pointer result)
{
  return allocator_traits_detail::copy_construct_range(from_system, a, first, last, result);
}


template<typename System, typename Allocator, typename InputIterator, typename Size, typename Pointer>
__attribute__((host)) __attribute__((device))
  Pointer copy_construct_range_n(thrust::execution_policy<System> &from_system,
                                 Allocator &a,
                                 InputIterator first,
                                 Size n,
                                 Pointer result)
{
  return allocator_traits_detail::copy_construct_range_n(from_system, a, first, n, result);
}


}
}
# 47 "/usr/local/cuda-8.0/include/thrust/detail/allocator/copy_construct_range.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/default_construct_range.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/allocator/default_construct_range.h"
       



namespace thrust
{
namespace detail
{


template<typename Allocator, typename Pointer, typename Size>
__attribute__((host)) __attribute__((device))
inline void default_construct_range(Allocator &a, Pointer p, Size n);


}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/default_construct_range.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/detail/allocator/default_construct_range.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/uninitialized_fill.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/uninitialized_fill.h"
       




namespace thrust
{
# 90 "/usr/local/cuda-8.0/include/thrust/uninitialized_fill.h"
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void uninitialized_fill(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          ForwardIterator first,
                          ForwardIterator last,
                          const T &x);
# 146 "/usr/local/cuda-8.0/include/thrust/uninitialized_fill.h"
template<typename ForwardIterator, typename T>
  void uninitialized_fill(ForwardIterator first,
                          ForwardIterator last,
                          const T &x);
# 206 "/usr/local/cuda-8.0/include/thrust/uninitialized_fill.h"
template<typename DerivedPolicy, typename ForwardIterator, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator uninitialized_fill_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       ForwardIterator first,
                                       Size n,
                                       const T &x);
# 263 "/usr/local/cuda-8.0/include/thrust/uninitialized_fill.h"
template<typename ForwardIterator, typename Size, typename T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first,
                                       Size n,
                                       const T &x);





}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/uninitialized_fill.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/uninitialized_fill.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/uninitialized_fill.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/uninitialized_fill.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{

template<typename DerivedPolicy,
         typename ForwardIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  void uninitialized_fill(thrust::execution_policy<DerivedPolicy> &exec,
                          ForwardIterator first,
                          ForwardIterator last,
                          const T &x);

template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Size,
         typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator uninitialized_fill_n(thrust::execution_policy<DerivedPolicy> &exec,
                                       ForwardIterator first,
                                       Size n,
                                       const T &x);

}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/uninitialized_fill.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/uninitialized_fill.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/fill.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/fill.h"
       




namespace thrust
{
# 74 "/usr/local/cuda-8.0/include/thrust/fill.h"
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void fill(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
            ForwardIterator first,
            ForwardIterator last,
            const T &value);
# 113 "/usr/local/cuda-8.0/include/thrust/fill.h"
template<typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void fill(ForwardIterator first,
            ForwardIterator last,
            const T &value);
# 156 "/usr/local/cuda-8.0/include/thrust/fill.h"
template<typename DerivedPolicy, typename OutputIterator, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator fill_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                        OutputIterator first,
                        Size n,
                        const T &value);
# 195 "/usr/local/cuda-8.0/include/thrust/fill.h"
template<typename OutputIterator, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator fill_n(OutputIterator first,
                        Size n,
                        const T &value);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/fill.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/fill.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/fill.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/fill.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/generate.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/generate.h"
       




namespace thrust
{
# 72 "/usr/local/cuda-8.0/include/thrust/generate.h"
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Generator>
__attribute__((host)) __attribute__((device))
  void generate(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                Generator gen);
# 114 "/usr/local/cuda-8.0/include/thrust/generate.h"
template<typename ForwardIterator,
         typename Generator>
  void generate(ForwardIterator first,
                ForwardIterator last,
                Generator gen);
# 157 "/usr/local/cuda-8.0/include/thrust/generate.h"
template<typename DerivedPolicy,
         typename OutputIterator,
         typename Size,
         typename Generator>
__attribute__((host)) __attribute__((device))
  OutputIterator generate_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            OutputIterator first,
                            Size n,
                            Generator gen);
# 199 "/usr/local/cuda-8.0/include/thrust/generate.h"
template<typename OutputIterator,
         typename Size,
         typename Generator>
  OutputIterator generate_n(OutputIterator first,
                            Size n,
                            Generator gen);





}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/generate.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/generate.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/generate.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/generate.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{

template<typename ExecutionPolicy,
         typename ForwardIterator,
         typename Generator>
__attribute__((host)) __attribute__((device))
  void generate(thrust::execution_policy<ExecutionPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                Generator gen);

template<typename ExecutionPolicy,
         typename OutputIterator,
         typename Size,
         typename Generator>
__attribute__((host)) __attribute__((device))
  OutputIterator generate_n(thrust::execution_policy<ExecutionPolicy> &exec,
                            OutputIterator first,
                            Size n,
                            Generator gen);

}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/generate.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/generate.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{

template<typename ExecutionPolicy,
         typename ForwardIterator,
         typename Generator>
__attribute__((host)) __attribute__((device))
  void generate(thrust::execution_policy<ExecutionPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                Generator gen)
{
  thrust::for_each(exec, first, last, typename thrust::detail::generate_functor<ExecutionPolicy,Generator>::type(gen));
}

template<typename ExecutionPolicy,
         typename OutputIterator,
         typename Size,
         typename Generator>
__attribute__((host)) __attribute__((device))
  OutputIterator generate_n(thrust::execution_policy<ExecutionPolicy> &exec,
                            OutputIterator first,
                            Size n,
                            Generator gen)
{
  return thrust::for_each_n(exec, first, n, typename thrust::detail::generate_functor<ExecutionPolicy,Generator>::type(gen));
}

}
}
}
}
# 57 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/generate.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/generate.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/generate.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/generate.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/generate.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/generate.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/generate.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/generate.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/generate.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/generate.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/generate.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Generator>
__attribute__((host)) __attribute__((device))
  void generate(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                Generator gen)
{
  using thrust::system::detail::generic::generate;
  return generate(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, gen);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename OutputIterator,
         typename Size,
         typename Generator>
__attribute__((host)) __attribute__((device))
  OutputIterator generate_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            OutputIterator first,
                            Size n,
                            Generator gen)
{
  using thrust::system::detail::generic::generate_n;
  return generate_n(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, n, gen);
}


template<typename ForwardIterator,
         typename Generator>
  void generate(ForwardIterator first,
                ForwardIterator last,
                Generator gen)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::generate(select_system(system), first, last, gen);
}


template<typename OutputIterator,
         typename Size,
         typename Generator>
  OutputIterator generate_n(OutputIterator first,
                            Size n,
                            Generator gen)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<OutputIterator>::type System;

  System system;

  return thrust::generate_n(select_system(system), first, n, gen);
}


}
# 213 "/usr/local/cuda-8.0/include/thrust/generate.h" 2
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/fill.h" 2


namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename OutputIterator, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator fill_n(thrust::execution_policy<DerivedPolicy> &exec,
                        OutputIterator first,
                        Size n,
                        const T &value)
{

  return thrust::generate_n(exec, first, n, thrust::detail::fill_functor<T>(value));
}

template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void fill(thrust::execution_policy<DerivedPolicy> &exec,
            ForwardIterator first,
            ForwardIterator last,
            const T &value)
{

  thrust::generate(exec, first, last, thrust::detail::fill_functor<T>(value));
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/detail/fill.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/fill.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/fill.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/fill.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/fill.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/fill.h" 2






# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/fill.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/fill.h"
       
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/fill.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/fill.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void fill(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
            ForwardIterator first,
            ForwardIterator last,
            const T &value)
{
  using thrust::system::detail::generic::fill;
  return fill(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename OutputIterator, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator fill_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                        OutputIterator first,
                        Size n,
                        const T &value)
{
  using thrust::system::detail::generic::fill_n;
  return fill_n(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, n, value);
}


template<typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void fill(ForwardIterator first,
            ForwardIterator last,
            const T &value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  thrust::fill(select_system(system), first, last, value);
}


template<typename OutputIterator, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator fill_n(OutputIterator first,
                        Size n,
                        const T &value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<OutputIterator>::type System;

  System system;

  return thrust::fill_n(select_system(system), first, n, value);
}


}
# 209 "/usr/local/cuda-8.0/include/thrust/fill.h" 2
# 20 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/uninitialized_fill.inl" 2




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace detail
{

template<typename DerivedPolicy,
         typename ForwardIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  void uninitialized_fill(thrust::execution_policy<DerivedPolicy> &exec,
                          ForwardIterator first,
                          ForwardIterator last,
                          const T &x,
                          thrust::detail::true_type)
{
  thrust::fill(exec, first, last, x);
}

template<typename DerivedPolicy,
         typename ForwardIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  void uninitialized_fill(thrust::execution_policy<DerivedPolicy> &exec,
                          ForwardIterator first,
                          ForwardIterator last,
                          const T &x,
                          thrust::detail::false_type)
{
  typedef typename iterator_traits<ForwardIterator>::value_type ValueType;

  thrust::for_each(exec, first, last, thrust::detail::uninitialized_fill_functor<ValueType>(x));
}

template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Size,
         typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator uninitialized_fill_n(thrust::execution_policy<DerivedPolicy> &exec,
                                       ForwardIterator first,
                                       Size n,
                                       const T &x,
                                       thrust::detail::true_type)
{
  return thrust::fill_n(exec, first, n, x);
}

template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Size,
         typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator uninitialized_fill_n(thrust::execution_policy<DerivedPolicy> &exec,
                                       ForwardIterator first,
                                       Size n,
                                       const T &x,
                                       thrust::detail::false_type)
{
  typedef typename iterator_traits<ForwardIterator>::value_type ValueType;

  return thrust::for_each_n(exec, first, n, thrust::detail::uninitialized_fill_functor<ValueType>(x));
}

}

template<typename DerivedPolicy,
         typename ForwardIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  void uninitialized_fill(thrust::execution_policy<DerivedPolicy> &exec,
                          ForwardIterator first,
                          ForwardIterator last,
                          const T &x)
{
  typedef typename iterator_traits<ForwardIterator>::value_type ValueType;

  typedef thrust::detail::has_trivial_copy_constructor<ValueType> ValueTypeHasTrivialCopyConstructor;

  thrust::system::detail::generic::detail::uninitialized_fill(exec, first, last, x,
    ValueTypeHasTrivialCopyConstructor());
}

template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Size,
         typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator uninitialized_fill_n(thrust::execution_policy<DerivedPolicy> &exec,
                                       ForwardIterator first,
                                       Size n,
                                       const T &x)
{
  typedef typename iterator_traits<ForwardIterator>::value_type ValueType;

  typedef thrust::detail::has_trivial_copy_constructor<ValueType> ValueTypeHasTrivialCopyConstructor;

  return thrust::system::detail::generic::detail::uninitialized_fill_n(exec, first, n, x,
    ValueTypeHasTrivialCopyConstructor());
}

}
}
}
}
# 57 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/uninitialized_fill.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/uninitialized_fill.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/uninitialized_fill.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/uninitialized_fill.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/uninitialized_fill.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/uninitialized_fill.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/uninitialized_fill.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/uninitialized_fill.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void uninitialized_fill(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          ForwardIterator first,
                          ForwardIterator last,
                          const T &x)
{
  using thrust::system::detail::generic::uninitialized_fill;
  return uninitialized_fill(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, x);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator uninitialized_fill_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       ForwardIterator first,
                                       Size n,
                                       const T &x)
{
  using thrust::system::detail::generic::uninitialized_fill_n;
  return uninitialized_fill_n(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, n, x);
}


template<typename ForwardIterator,
         typename T>
  void uninitialized_fill(ForwardIterator first,
                          ForwardIterator last,
                          const T &x)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  thrust::uninitialized_fill(select_system(system), first, last, x);
}


template<typename ForwardIterator,
         typename Size,
         typename T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first,
                                       Size n,
                                       const T &x)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::uninitialized_fill_n(select_system(system), first, n, x);
}


}
# 275 "/usr/local/cuda-8.0/include/thrust/uninitialized_fill.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/detail/allocator/default_construct_range.inl" 2

namespace thrust
{
namespace detail
{
namespace allocator_traits_detail
{


template<typename Allocator>
  struct construct1_via_allocator
{
  Allocator &a;

  __attribute__((host)) __attribute__((device))
  construct1_via_allocator(Allocator &a)
    : a(a)
  {}

  template<typename T>
  inline __attribute__((host)) __attribute__((device))
  void operator()(T &x)
  {
    allocator_traits<Allocator>::construct(a, &x);
  }
};



template<typename Allocator, typename T>
  struct needs_default_construct_via_allocator
    : thrust::detail::or_<
        has_member_construct1<Allocator,T>,
        thrust::detail::not_<has_trivial_constructor<T> >
      >
{};





template<typename U, typename T>
  struct needs_default_construct_via_allocator<std::allocator<U>, T>
    : thrust::detail::not_<has_trivial_constructor<T> >
{};


template<typename Allocator, typename Pointer, typename Size>
__attribute__((host)) __attribute__((device))
  typename enable_if<
    needs_default_construct_via_allocator<
      Allocator,
      typename pointer_element<Pointer>::type
    >::value
  >::type
    default_construct_range(Allocator &a, Pointer p, Size n)
{
  thrust::for_each_n(allocator_system<Allocator>::get(a), p, n, construct1_via_allocator<Allocator>(a));
}


template<typename Allocator, typename Pointer, typename Size>
__attribute__((host)) __attribute__((device))
  typename disable_if<
    needs_default_construct_via_allocator<
      Allocator,
      typename pointer_element<Pointer>::type
    >::value
  >::type
    default_construct_range(Allocator &a, Pointer p, Size n)
{
  thrust::uninitialized_fill_n(allocator_system<Allocator>::get(a), p, n, typename pointer_element<Pointer>::type());
}


}


template<typename Allocator, typename Pointer, typename Size>
__attribute__((host)) __attribute__((device))
  void default_construct_range(Allocator &a, Pointer p, Size n)
{
  return allocator_traits_detail::default_construct_range(a,p,n);
}


}
}
# 36 "/usr/local/cuda-8.0/include/thrust/detail/allocator/default_construct_range.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/destroy_range.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/allocator/destroy_range.h"
       



namespace thrust
{
namespace detail
{

template<typename Allocator, typename Pointer, typename Size>
__attribute__((host)) __attribute__((device))
  inline void destroy_range(Allocator &a, Pointer p, Size n);

}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/destroy_range.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/detail/allocator/destroy_range.inl"
namespace thrust
{
namespace detail
{
namespace allocator_traits_detail
{
# 38 "/usr/local/cuda-8.0/include/thrust/detail/allocator/destroy_range.inl"
template<typename Allocator, typename T>
  struct has_effectful_member_destroy
    : has_member_destroy<Allocator,T>
{};


template<typename U, typename T>
  struct has_effectful_member_destroy<std::allocator<U>, T>
    : thrust::detail::false_type
{};


template<typename Allocator, typename Pointer>
  struct enable_if_destroy_range_case1
    : thrust::detail::enable_if<
        has_effectful_member_destroy<
          Allocator,
          typename pointer_element<Pointer>::type
        >::value
      >
{};


template<typename Allocator, typename Pointer>
  struct enable_if_destroy_range_case2
    : thrust::detail::enable_if<
        !has_effectful_member_destroy<
          Allocator,
          typename pointer_element<Pointer>::type
        >::value &&
        !has_trivial_destructor<
          typename pointer_element<Pointer>::type
        >::value
      >
{};


template<typename Allocator, typename Pointer>
  struct enable_if_destroy_range_case3
    : thrust::detail::enable_if<
        !has_effectful_member_destroy<
          Allocator,
          typename pointer_element<Pointer>::type
        >::value &&
        has_trivial_destructor<
          typename pointer_element<Pointer>::type
        >::value
      >
{};



template<typename Allocator>
  struct destroy_via_allocator
{
  Allocator &a;

  __attribute__((host)) __attribute__((device))
  destroy_via_allocator(Allocator &a)
    : a(a)
  {}

  template<typename T>
  inline __attribute__((host)) __attribute__((device))
  void operator()(T &x)
  {
    allocator_traits<Allocator>::destroy(a, &x);
  }
};



template<typename Allocator, typename Pointer, typename Size>
__attribute__((host)) __attribute__((device))
  typename enable_if_destroy_range_case1<Allocator,Pointer>::type
    destroy_range(Allocator &a, Pointer p, Size n)
{
  thrust::for_each_n(allocator_system<Allocator>::get(a), p, n, destroy_via_allocator<Allocator>(a));
}



struct gozer
{
  #pragma nv_exec_check_disable
  template<typename T>
  inline __attribute__((host)) __attribute__((device))
  void operator()(T &x)
  {
    x.~T();
  }
};


template<typename Allocator, typename Pointer, typename Size>
__attribute__((host)) __attribute__((device))
  typename enable_if_destroy_range_case2<Allocator,Pointer>::type
    destroy_range(Allocator &a, Pointer p, Size n)
{
  thrust::for_each_n(allocator_system<Allocator>::get(a), p, n, gozer());
}



template<typename Allocator, typename Pointer, typename Size>
__attribute__((host)) __attribute__((device))
  typename enable_if_destroy_range_case3<Allocator,Pointer>::type
    destroy_range(Allocator &, Pointer, Size)
{

}


}


template<typename Allocator, typename Pointer, typename Size>
__attribute__((host)) __attribute__((device))
  void destroy_range(Allocator &a, Pointer p, Size n)
{
  return allocator_traits_detail::destroy_range(a,p,n);
}


}
}
# 34 "/usr/local/cuda-8.0/include/thrust/detail/allocator/destroy_range.h" 2
# 25 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/fill_construct_range.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/allocator/fill_construct_range.h"
       



namespace thrust
{
namespace detail
{


template<typename Allocator, typename Pointer, typename Size, typename T>
__attribute__((host)) __attribute__((device))
inline void fill_construct_range(Allocator &a, Pointer p, Size n, const T &value);


}
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/allocator/fill_construct_range.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/allocator/fill_construct_range.inl"
namespace thrust
{
namespace detail
{
namespace allocator_traits_detail
{







template<typename Allocator, typename T, typename Arg1>
  struct has_effectful_member_construct2
    : has_member_construct2<Allocator,T,Arg1>
{};


template<typename U, typename T, typename Arg1>
  struct has_effectful_member_construct2<std::allocator<U>,T,Arg1>
    : thrust::detail::false_type
{};


template<typename Allocator, typename Arg1>
  struct construct2_via_allocator
{
  Allocator &a;
  Arg1 arg;

  __attribute__((host)) __attribute__((device))
  construct2_via_allocator(Allocator &a, const Arg1 &arg)
    : a(a), arg(arg)
  {}

  template<typename T>
  inline __attribute__((host)) __attribute__((device))
  void operator()(T &x)
  {
    allocator_traits<Allocator>::construct(a, &x, arg);
  }
};


template<typename Allocator, typename Pointer, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  typename enable_if<
    has_effectful_member_construct2<
      Allocator,
      typename pointer_element<Pointer>::type,
      T
    >::value
  >::type
    fill_construct_range(Allocator &a, Pointer p, Size n, const T &value)
{
  thrust::for_each_n(allocator_system<Allocator>::get(a), p, n, construct2_via_allocator<Allocator,T>(a, value));
}


template<typename Allocator, typename Pointer, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  typename disable_if<
    has_effectful_member_construct2<
      Allocator,
      typename pointer_element<Pointer>::type,
      T
    >::value
  >::type
    fill_construct_range(Allocator &a, Pointer p, Size n, const T &value)
{
  thrust::uninitialized_fill_n(allocator_system<Allocator>::get(a), p, n, value);
}


}


template<typename Alloc, typename Pointer, typename Size, typename T>
__attribute__((host)) __attribute__((device))
  void fill_construct_range(Alloc &a, Pointer p, Size n, const T &value)
{
  return allocator_traits_detail::fill_construct_range(a,p,n,value);
}


}
}
# 36 "/usr/local/cuda-8.0/include/thrust/detail/allocator/fill_construct_range.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.inl" 2


namespace thrust
{

namespace detail
{

 #pragma nv_exec_check_disable
template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  contiguous_storage<T,Alloc>
    ::contiguous_storage(const Alloc &alloc)
      :m_allocator(alloc),
       m_begin(pointer(static_cast<T*>(0))),
       m_size(0)
{
  ;
}

 #pragma nv_exec_check_disable
template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  contiguous_storage<T,Alloc>
    ::contiguous_storage(size_type n, const Alloc &alloc)
      :m_allocator(alloc),
       m_begin(pointer(static_cast<T*>(0))),
       m_size(0)
{
  allocate(n);
}

 #pragma nv_exec_check_disable
template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  contiguous_storage<T,Alloc>
    ::~contiguous_storage(void)
{
  deallocate();
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  typename contiguous_storage<T,Alloc>::size_type
    contiguous_storage<T,Alloc>
      ::size(void) const
{
  return m_size;
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  typename contiguous_storage<T,Alloc>::size_type
    contiguous_storage<T,Alloc>
      ::max_size(void) const
{
  return alloc_traits::max_size(m_allocator);
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  typename contiguous_storage<T,Alloc>::iterator
    contiguous_storage<T,Alloc>
      ::begin(void)
{
  return m_begin;
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  typename contiguous_storage<T,Alloc>::const_iterator
    contiguous_storage<T,Alloc>
      ::begin(void) const
{
  return m_begin;
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  typename contiguous_storage<T,Alloc>::iterator
    contiguous_storage<T,Alloc>
      ::end(void)
{
  return m_begin + size();
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  typename contiguous_storage<T,Alloc>::const_iterator
    contiguous_storage<T,Alloc>
      ::end(void) const
{
  return m_begin + size();
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  typename contiguous_storage<T,Alloc>::reference
    contiguous_storage<T,Alloc>
      ::operator[](size_type n)
{
  return m_begin[n];
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  typename contiguous_storage<T,Alloc>::const_reference
    contiguous_storage<T,Alloc>
      ::operator[](size_type n) const
{
  return m_begin[n];
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  typename contiguous_storage<T,Alloc>::allocator_type
    contiguous_storage<T,Alloc>
      ::get_allocator(void) const
{
  return m_allocator;
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  void contiguous_storage<T,Alloc>
    ::allocate(size_type n)
{
  if(n > 0)
  {
    m_begin = iterator(alloc_traits::allocate(m_allocator,n));
    m_size = n;
  }
  else
  {
    m_begin = iterator(pointer(static_cast<T*>(0)));
    m_size = 0;
  }
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  void contiguous_storage<T,Alloc>
    ::deallocate(void)
{
  if(size() > 0)
  {
    alloc_traits::deallocate(m_allocator,m_begin.base(), size());
    m_begin = iterator(pointer(static_cast<T*>(0)));
    m_size = 0;
  }
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  void contiguous_storage<T,Alloc>
    ::swap(contiguous_storage &x)
{
  thrust::swap(m_begin, x.m_begin);
  thrust::swap(m_size, x.m_size);

  thrust::swap(m_allocator, x.m_allocator);
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  void contiguous_storage<T,Alloc>
    ::default_construct_n(iterator first, size_type n)
{
  default_construct_range(m_allocator, first.base(), n);
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  void contiguous_storage<T,Alloc>
    ::uninitialized_fill_n(iterator first, size_type n, const value_type &x)
{
  fill_construct_range(m_allocator, first.base(), n, x);
}

template<typename T, typename Alloc>
  template<typename System, typename InputIterator>
  __attribute__((host)) __attribute__((device))
    typename contiguous_storage<T,Alloc>::iterator
      contiguous_storage<T,Alloc>
        ::uninitialized_copy(thrust::execution_policy<System> &from_system, InputIterator first, InputIterator last, iterator result)
{
  return iterator(copy_construct_range(from_system, m_allocator, first, last, result.base()));
}

template<typename T, typename Alloc>
  template<typename InputIterator>
  __attribute__((host)) __attribute__((device))
    typename contiguous_storage<T,Alloc>::iterator
      contiguous_storage<T,Alloc>
        ::uninitialized_copy(InputIterator first, InputIterator last, iterator result)
{

  typename thrust::iterator_system<InputIterator>::type from_system;

  return iterator(copy_construct_range(from_system, m_allocator, first, last, result.base()));
}

template<typename T, typename Alloc>
  template<typename System, typename InputIterator, typename Size>
  __attribute__((host)) __attribute__((device))
    typename contiguous_storage<T,Alloc>::iterator
      contiguous_storage<T,Alloc>
        ::uninitialized_copy_n(thrust::execution_policy<System> &from_system, InputIterator first, Size n, iterator result)
{
  return iterator(copy_construct_range_n(from_system, m_allocator, first, n, result.base()));
}

template<typename T, typename Alloc>
  template<typename InputIterator, typename Size>
  __attribute__((host)) __attribute__((device))
    typename contiguous_storage<T,Alloc>::iterator
      contiguous_storage<T,Alloc>
        ::uninitialized_copy_n(InputIterator first, Size n, iterator result)
{

  typename thrust::iterator_system<InputIterator>::type from_system;

  return iterator(copy_construct_range_n(from_system, m_allocator, first, n, result.base()));
}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  void contiguous_storage<T,Alloc>
    ::destroy(iterator first, iterator last)
{
  destroy_range(m_allocator, first.base(), last - first);
}

}

template<typename T, typename Alloc>
__attribute__((host)) __attribute__((device))
  void swap(detail::contiguous_storage<T,Alloc> &lhs, detail::contiguous_storage<T,Alloc> &rhs)
{
  lhs.swap(rhs);
}

}
# 156 "/usr/local/cuda-8.0/include/thrust/detail/contiguous_storage.h" 2
# 30 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h" 2
# 1 "/usr/include/c++/4.8.2/vector" 1 3
# 58 "/usr/include/c++/4.8.2/vector" 3
       
# 59 "/usr/include/c++/4.8.2/vector" 3





# 1 "/usr/include/c++/4.8.2/bits/stl_vector.h" 1 3
# 66 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
# 101 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
 void _M_swap_data(_Vector_impl& __x)
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }
# 159 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 209 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 294 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 310 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 397 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 414 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 426 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 478 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 501 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 529 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 644 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 703 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 724 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





     
     
# 734 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
     
# 733 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      bool
      empty() const
      { return begin() == end(); }
# 754 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 769 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 784 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 809 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 827 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 876 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      pointer

      data()
      { return std::__addressof(front()); }




      const_pointer

      data() const
      { return std::__addressof(front()); }
# 900 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else



   _M_insert_aux(end(), __x);

      }
# 936 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 972 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1022 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1048 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1074 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 1095 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1107 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      void
      swap(vector& __x)



      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1159 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)



     push_back(*__first);

 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1237 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1277 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
# 1322 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      void
      _M_insert_aux(iterator __position, const value_type& __x);
# 1335 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
# 1389 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
    };
# 1402 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline
   
# 1404 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
   
# 1403 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
           bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1419 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline
   
# 1421 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
   
# 1420 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
           bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline
   
# 1428 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
   
# 1427 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
           bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline
   
# 1434 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
   
# 1433 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
           bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline
   
# 1440 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
   
# 1439 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
           bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline
   
# 1446 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
   
# 1445 "/usr/include/c++/4.8.2/bits/stl_vector.h" 3
           bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 65 "/usr/include/c++/4.8.2/vector" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 1 3
# 63 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

   
   
# 98 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
   
# 97 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

   
   
# 102 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
   
# 101 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };
# 136 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

   
   
# 180 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
   
# 179 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

   
   
# 184 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
   
# 183 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

   
   
# 191 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
   
# 190 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

   
   
# 195 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
   
# 194 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

   
   
# 199 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
   
# 198 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

   
   
# 203 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
   
# 202 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }







      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
# 465 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(_S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 517 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;





  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }
# 572 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }


    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
# 611 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }


    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
# 661 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }
# 672 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }
# 687 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
# 737 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

   
   
# 758 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
   
# 757 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }
# 877 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }


    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }






    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }







    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);
# 977 "/usr/include/c++/4.8.2/bits/stl_bvector.h" 3
    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };


}
# 66 "/usr/include/c++/4.8.2/vector" 2 3



# 1 "/usr/include/c++/4.8.2/bits/vector.tcc" 1 3
# 59 "/usr/include/c++/4.8.2/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     (this->_M_impl._M_start),
     (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
# 105 "/usr/include/c++/4.8.2/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
# 127 "/usr/include/c++/4.8.2/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::copy(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
# 184 "/usr/include/c++/4.8.2/bits/vector.tcc" 3
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
# 316 "/usr/include/c++/4.8.2/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              (*(this->_M_impl._M_finish - 1))
                            );
   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;

   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,



                                __x);

       __new_finish = 0;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }
# 439 "/usr/include/c++/4.8.2/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }
# 591 "/usr/include/c++/4.8.2/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
      iterator(__q, 0));
      this->_M_deallocate();
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }
# 811 "/usr/include/c++/4.8.2/bits/vector.tcc" 3

}
# 70 "/usr/include/c++/4.8.2/vector" 2 3
# 31 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h" 2

namespace thrust
{

namespace detail
{

template<typename T, typename Alloc>
  class vector_base
{
  private:
    typedef thrust::detail::contiguous_storage<T,Alloc> storage_type;

  public:

    typedef typename storage_type::value_type value_type;
    typedef typename storage_type::pointer pointer;
    typedef typename storage_type::const_pointer const_pointer;
    typedef typename storage_type::reference reference;
    typedef typename storage_type::const_reference const_reference;
    typedef typename storage_type::size_type size_type;
    typedef typename storage_type::difference_type difference_type;
    typedef typename storage_type::allocator_type allocator_type;

    typedef typename storage_type::iterator iterator;
    typedef typename storage_type::const_iterator const_iterator;

    typedef thrust::reverse_iterator<iterator> reverse_iterator;
    typedef thrust::reverse_iterator<const_iterator> const_reverse_iterator;



    vector_base(void);





    explicit vector_base(size_type n);






    explicit vector_base(size_type n, const value_type &value);




    vector_base(const vector_base &v);




    vector_base &operator=(const vector_base &v);





    template<typename OtherT, typename OtherAlloc>
    vector_base(const vector_base<OtherT, OtherAlloc> &v);





    template<typename OtherT, typename OtherAlloc>
    vector_base &operator=(const vector_base<OtherT,OtherAlloc> &v);







    template<typename OtherT, typename OtherAlloc>
    vector_base(const std::vector<OtherT, OtherAlloc> &v);







    template<typename OtherT, typename OtherAlloc>
    vector_base &operator=(const std::vector<OtherT,OtherAlloc> &v);





    template<typename InputIterator>
    vector_base(InputIterator first, InputIterator last);



    ~vector_base(void);
# 140 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h"
    void resize(size_type new_size);
# 152 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h"
    void resize(size_type new_size, const value_type &x);



    size_type size(void) const;




    size_type max_size(void) const;







    void reserve(size_type n);




    size_type capacity(void) const;




    void shrink_to_fit(void);
# 189 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h"
    reference operator[](size_type n);
# 199 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h"
    const_reference operator[](size_type n) const;





    iterator begin(void);





    const_iterator begin(void) const;





    const_iterator cbegin(void) const;






    reverse_iterator rbegin(void);






    const_reverse_iterator rbegin(void) const;






    const_reverse_iterator crbegin(void) const;





    iterator end(void);





    const_iterator end(void) const;





    const_iterator cend(void) const;





    reverse_iterator rend(void);





    const_reverse_iterator rend(void) const;





    const_reverse_iterator crend(void) const;





    const_reference front(void) const;





    reference front(void);





    const_reference back(void) const;





    reference back(void);




    pointer data(void);




    const_pointer data(void) const;



    void clear(void);




    bool empty(void) const;




    void push_back(const value_type &x);




    void pop_back(void);




    void swap(vector_base &v);






    iterator erase(iterator pos);







    iterator erase(iterator first, iterator last);







    iterator insert(iterator position, const T &x);







    void insert(iterator position, size_type n, const T &x);
# 374 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h"
    template<typename InputIterator>
    void insert(iterator position, InputIterator first, InputIterator last);






    void assign(size_type n, const T &x);







    template<typename InputIterator>
    void assign(InputIterator first, InputIterator last);




    allocator_type get_allocator(void) const;

  protected:

    storage_type m_storage;


    size_type m_size;

  private:

    template<typename IteratorOrIntegralType>
      void init_dispatch(IteratorOrIntegralType begin, IteratorOrIntegralType end, false_type);

    template<typename IteratorOrIntegralType>
      void init_dispatch(IteratorOrIntegralType n, IteratorOrIntegralType value, true_type);

    template<typename InputIterator>
      void range_init(InputIterator first, InputIterator last);

    template<typename InputIterator>
      void range_init(InputIterator first, InputIterator last, thrust::incrementable_traversal_tag);

    template<typename ForwardIterator>
      void range_init(ForwardIterator first, ForwardIterator last, thrust::random_access_traversal_tag);

    void default_init(size_type n);

    void fill_init(size_type n, const T &x);


    template<typename InputIteratorOrIntegralType>
      void insert_dispatch(iterator position, InputIteratorOrIntegralType first, InputIteratorOrIntegralType last, false_type);


    template<typename InputIteratorOrIntegralType>
      void insert_dispatch(iterator position, InputIteratorOrIntegralType n, InputIteratorOrIntegralType x, true_type);


    void append(size_type n);


    void fill_insert(iterator position, size_type n, const T &x);


    template<typename InputIterator>
      void copy_insert(iterator position, InputIterator first, InputIterator last);


    template<typename InputIterator>
      void assign_dispatch(InputIterator first, InputIterator last, false_type);


    template<typename Integral>
      void assign_dispatch(Integral n, Integral x, true_type);


    template<typename InputIterator>
      void range_assign(InputIterator first, InputIterator last);


    template<typename RandomAccessIterator>
      void range_assign(RandomAccessIterator first, RandomAccessIterator last, thrust::random_access_traversal_tag);


    template<typename InputIterator>
      void range_assign(InputIterator first, InputIterator last, thrust::incrementable_traversal_tag);


    void fill_assign(size_type n, const T &x);


    template<typename ForwardIterator>
    void allocate_and_copy(size_type requested_size,
                           ForwardIterator first, ForwardIterator last,
                           storage_type &new_storage);
};

}
# 484 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h"
template<typename T, typename Alloc>
  void swap(detail::vector_base<T,Alloc> &a,
            detail::vector_base<T,Alloc> &b);
# 495 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h"
template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator==(const detail::vector_base<T1,Alloc1>& lhs,
                const detail::vector_base<T2,Alloc2>& rhs);

template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator==(const detail::vector_base<T1,Alloc1>& lhs,
                const std::vector<T2,Alloc2>& rhs);

template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator==(const std::vector<T1,Alloc1>& lhs,
                const detail::vector_base<T2,Alloc2>& rhs);







template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator!=(const detail::vector_base<T1,Alloc1>& lhs,
                const detail::vector_base<T2,Alloc2>& rhs);

template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator!=(const detail::vector_base<T1,Alloc1>& lhs,
                const std::vector<T2,Alloc2>& rhs);

template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator!=(const std::vector<T1,Alloc1>& lhs,
                const detail::vector_base<T2,Alloc2>& rhs);

}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/detail/overlapped_copy.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/overlapped_copy.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/detail/overlapped_copy.h"
namespace thrust
{
namespace detail
{


template<typename InputIterator,
         typename OutputIterator>
  OutputIterator sequential_copy(InputIterator first,
                                 InputIterator last,
                                 OutputIterator result)
{
  for(; first != last; ++first, ++result)
  {
    *result = *first;
  }

  return result;
}


template<typename BidirectionalIterator1,
         typename BidirectionalIterator2>
  BidirectionalIterator2 sequential_copy_backward(BidirectionalIterator1 first,
                                                  BidirectionalIterator1 last,
                                                  BidirectionalIterator2 result)
{


  while(first != last)
  {
    *--result = *--last;
  }

  return result;
}


namespace dispatch
{


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  RandomAccessIterator2 overlapped_copy(thrust::system::cpp::detail::execution_policy<DerivedPolicy> &,
                                        RandomAccessIterator1 first,
                                        RandomAccessIterator1 last,
                                        RandomAccessIterator2 result)
{
  if(first < last && first <= result && result < last)
  {


    thrust::detail::sequential_copy_backward(first, last, result + (last - first));
    result += (last - first);
  }
  else
  {


    result = thrust::detail::sequential_copy(first, last, result);
  }

  return result;
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  RandomAccessIterator2 overlapped_copy(thrust::execution_policy<DerivedPolicy> &exec,
                                        RandomAccessIterator1 first,
                                        RandomAccessIterator1 last,
                                        RandomAccessIterator2 result)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;


  thrust::detail::temporary_array<value_type, DerivedPolicy> temp(exec, first, last);
  return thrust::copy(exec, temp.begin(), temp.end(), result);
}

}


template<typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  RandomAccessIterator2 overlapped_copy(RandomAccessIterator1 first,
                                        RandomAccessIterator1 last,
                                        RandomAccessIterator2 result)
{
  typedef typename thrust::iterator_system<RandomAccessIterator2>::type System1;
  typedef typename thrust::iterator_system<RandomAccessIterator2>::type System2;

  typedef typename thrust::detail::minimum_system<System1, System2>::type System;


  System system;

  return thrust::detail::dispatch::overlapped_copy(system, first, last, result);
}

}
}
# 25 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/equal.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/equal.h"
       




namespace thrust
{
# 79 "/usr/local/cuda-8.0/include/thrust/equal.h"
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2>
__attribute__((host)) __attribute__((device))
bool equal(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);
# 119 "/usr/local/cuda-8.0/include/thrust/equal.h"
template <typename InputIterator1, typename InputIterator2>
bool equal(InputIterator1 first1, InputIterator1 last1,
           InputIterator2 first2);
# 175 "/usr/local/cuda-8.0/include/thrust/equal.h"
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
bool equal(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred);
# 225 "/usr/local/cuda-8.0/include/thrust/equal.h"
template <typename InputIterator1, typename InputIterator2,
          typename BinaryPredicate>
bool equal(InputIterator1 first1, InputIterator1 last1,
           InputIterator2 first2, BinaryPredicate binary_pred);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/equal.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/equal.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/equal.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/equal.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2>
__attribute__((host)) __attribute__((device))
bool equal(thrust::execution_policy<DerivedPolicy> &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
bool equal(thrust::execution_policy<DerivedPolicy> &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/equal.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/equal.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/mismatch.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/mismatch.h"
       





namespace thrust
{
# 89 "/usr/local/cuda-8.0/include/thrust/mismatch.h"
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2>
__attribute__((host)) __attribute__((device))
thrust::pair<InputIterator1, InputIterator2> mismatch(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                                      InputIterator1 first1,
                                                      InputIterator1 last1,
                                                      InputIterator2 first2);
# 140 "/usr/local/cuda-8.0/include/thrust/mismatch.h"
template <typename InputIterator1, typename InputIterator2>
thrust::pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,
                                                      InputIterator1 last1,
                                                      InputIterator2 first2);
# 195 "/usr/local/cuda-8.0/include/thrust/mismatch.h"
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
thrust::pair<InputIterator1, InputIterator2> mismatch(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                                      InputIterator1 first1,
                                                      InputIterator1 last1,
                                                      InputIterator2 first2,
                                                      BinaryPredicate pred);
# 248 "/usr/local/cuda-8.0/include/thrust/mismatch.h"
template <typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
thrust::pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,
                                                      InputIterator1 last1,
                                                      InputIterator2 first2,
                                                      BinaryPredicate pred);




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/mismatch.inl" 1
# 27 "/usr/local/cuda-8.0/include/thrust/detail/mismatch.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/mismatch.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/mismatch.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<InputIterator1, InputIterator2>
    mismatch(thrust::execution_policy<DerivedPolicy> &exec,
             InputIterator1 first1,
             InputIterator1 last1,
             InputIterator2 first2);


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<InputIterator1, InputIterator2>
    mismatch(thrust::execution_policy<DerivedPolicy> &exec,
             InputIterator1 first1,
             InputIterator1 last1,
             InputIterator2 first2,
             BinaryPredicate pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/mismatch.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/mismatch.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/find.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/find.h"
       




namespace thrust
{
# 79 "/usr/local/cuda-8.0/include/thrust/find.h"
template<typename DerivedPolicy, typename InputIterator, typename T>
__attribute__((host)) __attribute__((device))
InputIterator find(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   InputIterator first,
                   InputIterator last,
                   const T& value);
# 121 "/usr/local/cuda-8.0/include/thrust/find.h"
template <typename InputIterator, typename T>
InputIterator find(InputIterator first,
                   InputIterator last,
                   const T& value);
# 186 "/usr/local/cuda-8.0/include/thrust/find.h"
template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
InputIterator find_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      Predicate pred);
# 247 "/usr/local/cuda-8.0/include/thrust/find.h"
template <typename InputIterator, typename Predicate>
InputIterator find_if(InputIterator first,
                      InputIterator last,
                      Predicate pred);
# 312 "/usr/local/cuda-8.0/include/thrust/find.h"
template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
InputIterator find_if_not(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          InputIterator first,
                          InputIterator last,
                          Predicate pred);
# 373 "/usr/local/cuda-8.0/include/thrust/find.h"
template <typename InputIterator, typename Predicate>
InputIterator find_if_not(InputIterator first,
                          InputIterator last,
                          Predicate pred);





}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/find.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/find.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/find.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/find.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename InputIterator, typename T>
__attribute__((host)) __attribute__((device))
InputIterator find(thrust::execution_policy<DerivedPolicy> &exec,
                   InputIterator first,
                   InputIterator last,
                   const T& value);


template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
InputIterator find_if(thrust::execution_policy<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      Predicate pred);


template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
InputIterator find_if_not(thrust::execution_policy<DerivedPolicy> &exec,
                          InputIterator first,
                          InputIterator last,
                          Predicate pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/find.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/find.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/reduce.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/reduce.h"
       






namespace thrust
{
# 82 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename DerivedPolicy, typename InputIterator>
__attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::value_type
    reduce(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, InputIterator first, InputIterator last);
# 127 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename InputIterator> typename
  thrust::iterator_traits<InputIterator>::value_type reduce(InputIterator first, InputIterator last);
# 176 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename DerivedPolicy, typename InputIterator, typename T>
__attribute__((host)) __attribute__((device))
  T reduce(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
           InputIterator first,
           InputIterator last,
           T init);
# 223 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename InputIterator, typename T>
  T reduce(InputIterator first,
           InputIterator last,
           T init);
# 281 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename T,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  T reduce(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
           InputIterator first,
           InputIterator last,
           T init,
           BinaryFunction binary_op);
# 338 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename InputIterator,
         typename T,
         typename BinaryFunction>
  T reduce(InputIterator first,
           InputIterator last,
           T init,
           BinaryFunction binary_op);
# 402 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output);
# 466 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2>
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output);
# 536 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output,
                BinaryPredicate binary_pred);
# 605 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate>
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output,
                BinaryPredicate binary_pred);
# 684 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output,
                BinaryPredicate binary_pred,
                BinaryFunction binary_op);
# 762 "/usr/local/cuda-8.0/include/thrust/reduce.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output,
                BinaryPredicate binary_pred,
                BinaryFunction binary_op);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/reduce.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/reduce.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce.h"
       





namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename InputIterator>
__attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::value_type
    reduce(thrust::execution_policy<DerivedPolicy> &exec, InputIterator first, InputIterator last);


template<typename DerivedPolicy, typename InputIterator, typename T>
__attribute__((host)) __attribute__((device))
  T reduce(thrust::execution_policy<DerivedPolicy> &exec, InputIterator first, InputIterator last, T init);


template<typename DerivedPolicy,
         typename InputIterator,
         typename T,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  T reduce(thrust::execution_policy<DerivedPolicy> &exec, InputIterator first, InputIterator last, T init, BinaryFunction binary_op);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce.inl"
       







namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename ExecutionPolicy, typename InputIterator>
__attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::value_type
    reduce(thrust::execution_policy<ExecutionPolicy> &exec, InputIterator first, InputIterator last)
{
  typedef typename thrust::iterator_value<InputIterator>::type InputType;


  return thrust::reduce(exec, first, last, InputType(0));
}


template<typename ExecutionPolicy, typename InputIterator, typename T>
__attribute__((host)) __attribute__((device))
  T reduce(thrust::execution_policy<ExecutionPolicy> &exec, InputIterator first, InputIterator last, T init)
{

  return thrust::reduce(exec, first, last, init, thrust::plus<T>());
}


template<typename ExecutionPolicy,
         typename RandomAccessIterator,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputType reduce(thrust::execution_policy<ExecutionPolicy> &exec,
                    RandomAccessIterator first,
                    RandomAccessIterator last,
                    OutputType init,
                    BinaryFunction binary_op)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<RandomAccessIterator, false>::value) ) >)> thrust_static_assert_typedef_68 __attribute__((unused));
  return OutputType();
}


}
}
}
}
# 59 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/reduce.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce_by_key.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce_by_key.h"
       





namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    reduce_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                  InputIterator1 keys_first,
                  InputIterator1 keys_last,
                  InputIterator2 values_first,
                  OutputIterator1 keys_output,
                  OutputIterator2 values_output);

template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    reduce_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                  InputIterator1 keys_first,
                  InputIterator1 keys_last,
                  InputIterator2 values_first,
                  OutputIterator1 keys_output,
                  OutputIterator2 values_output,
                  BinaryPredicate binary_pred);

template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    reduce_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                  InputIterator1 keys_first,
                  InputIterator1 keys_last,
                  InputIterator2 values_first,
                  OutputIterator1 keys_output,
                  OutputIterator2 values_output,
                  BinaryPredicate binary_pred,
                  BinaryFunction binary_op);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce_by_key.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce_by_key.inl"
       







# 1 "/usr/local/cuda-8.0/include/thrust/scatter.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/scatter.h"
       




namespace thrust
{
# 89 "/usr/local/cuda-8.0/include/thrust/scatter.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void scatter(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
               InputIterator1 first,
               InputIterator1 last,
               InputIterator2 map,
               RandomAccessIterator result);
# 147 "/usr/local/cuda-8.0/include/thrust/scatter.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator>
  void scatter(InputIterator1 first,
               InputIterator1 last,
               InputIterator2 map,
               RandomAccessIterator result);
# 203 "/usr/local/cuda-8.0/include/thrust/scatter.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void scatter_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                  InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output);
# 259 "/usr/local/cuda-8.0/include/thrust/scatter.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator>
  void scatter_if(InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output);
# 331 "/usr/local/cuda-8.0/include/thrust/scatter.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  void scatter_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                  InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output,
                  Predicate pred);
# 403 "/usr/local/cuda-8.0/include/thrust/scatter.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator,
         typename Predicate>
  void scatter_if(InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output,
                  Predicate pred);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/scatter.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/scatter.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scatter.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scatter.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void scatter(thrust::execution_policy<DerivedPolicy> &exec,
               InputIterator1 first,
               InputIterator1 last,
               InputIterator2 map,
               RandomAccessIterator output);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void scatter_if(thrust::execution_policy<DerivedPolicy> &exec,
                  InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  void scatter_if(thrust::execution_policy<DerivedPolicy> &exec,
                  InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output,
                  Predicate pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scatter.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scatter.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void scatter(thrust::execution_policy<DerivedPolicy> &exec,
               InputIterator1 first,
               InputIterator1 last,
               InputIterator2 map,
               RandomAccessIterator output)
{
  thrust::transform(exec,
                    first,
                    last,
                    thrust::make_permutation_iterator(output, map),
                    thrust::identity<typename thrust::iterator_value<InputIterator1>::type>());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void scatter_if(thrust::execution_policy<DerivedPolicy> &exec,
                  InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output)
{

  typedef typename thrust::iterator_value<InputIterator3>::type StencilType;
  thrust::scatter_if(exec, first, last, map, stencil, output, thrust::identity<StencilType>());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  void scatter_if(thrust::execution_policy<DerivedPolicy> &exec,
                  InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output,
                  Predicate pred)
{
  typedef typename thrust::iterator_value<InputIterator1>::type InputType;
  thrust::transform_if(exec, first, last, stencil, thrust::make_permutation_iterator(output, map), thrust::identity<InputType>(), pred);
}


}
}
}
}
# 81 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scatter.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/scatter.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scatter.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scatter.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/scatter.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/scatter.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scatter.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/scatter.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void scatter(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
               InputIterator1 first,
               InputIterator1 last,
               InputIterator2 map,
               RandomAccessIterator output)
{
  using thrust::system::detail::generic::scatter;
  return scatter(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, map, output);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void scatter_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                  InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output)
{
  using thrust::system::detail::generic::scatter_if;
  return scatter_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, map, stencil, output);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  void scatter_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                  InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output,
                  Predicate pred)
{
  using thrust::system::detail::generic::scatter_if;
  return scatter_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, map, stencil, output, pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator>
  void scatter(InputIterator1 first,
               InputIterator1 last,
               InputIterator2 map,
               RandomAccessIterator output)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<RandomAccessIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::scatter(select_system(system1,system2,system3), first, last, map, output);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator>
  void scatter_if(InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<InputIterator3>::type System3;
  typedef typename thrust::iterator_system<RandomAccessIterator>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::scatter_if(select_system(system1,system2,system3,system4), first, last, map, stencil, output);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename RandomAccessIterator,
         typename Predicate>
  void scatter_if(InputIterator1 first,
                  InputIterator1 last,
                  InputIterator2 map,
                  InputIterator3 stencil,
                  RandomAccessIterator output,
                  Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<InputIterator3>::type System3;
  typedef typename thrust::iterator_system<RandomAccessIterator>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::scatter_if(select_system(system1,system2,system3,system4), first, last, map, stencil, output, pred);
}


}
# 423 "/usr/local/cuda-8.0/include/thrust/scatter.h" 2
# 31 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce_by_key.inl" 2




# 1 "/usr/local/cuda-8.0/include/thrust/scan.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/scan.h"
       




namespace thrust
{
# 93 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result);
# 148 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator,
         typename OutputIterator>
  OutputIterator inclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result);
# 203 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                AssociativeOperator binary_op);
# 258 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator,
         typename OutputIterator,
         typename AssociativeOperator>
  OutputIterator inclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                AssociativeOperator binary_op);
# 313 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result);
# 362 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator,
         typename OutputIterator>
  OutputIterator exclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result);
# 414 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init);
# 465 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator,
         typename OutputIterator,
         typename T>
  OutputIterator exclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init);
# 528 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init,
                                AssociativeOperator binary_op);
# 589 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator,
         typename OutputIterator,
         typename T,
         typename AssociativeOperator>
  OutputIterator exclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init,
                                AssociativeOperator binary_op);
# 663 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result);
# 725 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
  OutputIterator inclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result);
# 796 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred);
# 865 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate>
  OutputIterator inclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred);
# 943 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op);
# 1019 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate,
         typename AssociativeOperator>
  OutputIterator inclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op);
# 1079 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result);
# 1132 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
  OutputIterator exclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result);
# 1187 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init);
# 1241 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T>
  OutputIterator exclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init);
# 1306 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred);
# 1370 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate>
  OutputIterator exclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred);
# 1455 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op);
# 1538 "/usr/local/cuda-8.0/include/thrust/scan.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate,
         typename AssociativeOperator>
  OutputIterator exclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op);
# 1561 "/usr/local/cuda-8.0/include/thrust/scan.h"
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/scan.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/scan.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result);



template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                BinaryFunction binary_op);


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result);


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init);



template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init,
                                BinaryFunction binary_op);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan.inl"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result)
{







  typedef typename thrust::detail::eval_if<
      thrust::detail::is_output_iterator<OutputIterator>::value,
      thrust::iterator_value<InputIterator>,
      thrust::iterator_value<OutputIterator>
  >::type ValueType;


  return thrust::inclusive_scan(exec, first, last, result, thrust::plus<ValueType>());
}


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result)
{







  typedef typename thrust::detail::eval_if<
      thrust::detail::is_output_iterator<OutputIterator>::value,
      thrust::iterator_value<InputIterator>,
      thrust::iterator_value<OutputIterator>
  >::type ValueType;


  return thrust::exclusive_scan(exec, first, last, result, ValueType(0));
}


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init)
{

  return thrust::exclusive_scan(exec, first, last, result, init, thrust::plus<T>());
}


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                BinaryFunction binary_op)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator, false>::value) ) >)> thrust_static_assert_typedef_121 __attribute__((unused));
  return result;
}


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(thrust::execution_policy<ExecutionPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init,
                                BinaryFunction binary_op)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator, false>::value) ) >)> thrust_static_assert_typedef_140 __attribute__((unused));
  return result;
}


}
}
}
}
# 99 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/scan.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan_by_key.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan_by_key.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op);

}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan_by_key.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan_by_key.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/replace.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/replace.h"
       




namespace thrust
{
# 86 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void replace(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
               ForwardIterator first, ForwardIterator last,
               const T &old_value,
               const T &new_value);
# 136 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename ForwardIterator, typename T>
  void replace(ForwardIterator first, ForwardIterator last, const T &old_value,
               const T &new_value);
# 200 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename DerivedPolicy, typename ForwardIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  void replace_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                  ForwardIterator first, ForwardIterator last,
                  Predicate pred,
                  const T &new_value);
# 261 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename ForwardIterator, typename Predicate, typename T>
  void replace_if(ForwardIterator first, ForwardIterator last,
                  Predicate pred,
                  const T &new_value);
# 334 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  void replace_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                  ForwardIterator first, ForwardIterator last,
                  InputIterator stencil,
                  Predicate pred,
                  const T &new_value);
# 404 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename ForwardIterator, typename InputIterator, typename Predicate, typename T>
  void replace_if(ForwardIterator first, ForwardIterator last,
                  InputIterator stencil,
                  Predicate pred,
                  const T &new_value);
# 463 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                              InputIterator first, InputIterator last,
                              OutputIterator result,
                              const T &old_value,
                              const T &new_value);
# 519 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename InputIterator, typename OutputIterator, typename T>
  OutputIterator replace_copy(InputIterator first, InputIterator last,
                              OutputIterator result, const T &old_value,
                              const T &new_value);
# 588 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                 InputIterator first, InputIterator last,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value);
# 655 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename InputIterator, typename OutputIterator, typename Predicate, typename T>
  OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value);
# 732 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                 InputIterator1 first, InputIterator1 last,
                                 InputIterator2 stencil,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value);
# 807 "/usr/local/cuda-8.0/include/thrust/replace.h"
template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate, typename T>
  OutputIterator replace_copy_if(InputIterator1 first, InputIterator1 last,
                                 InputIterator2 stencil,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value);







}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/replace.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/replace.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/replace.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/replace.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                                 InputIterator first,
                                 InputIterator last,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value);


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                                 InputIterator1 first,
                                 InputIterator1 last,
                                 InputIterator2 stencil,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value);


template<typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy(thrust::execution_policy<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              OutputIterator result,
                              const T &old_value,
                              const T &new_value);


template<typename DerivedPolicy, typename ForwardIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  void replace_if(thrust::execution_policy<DerivedPolicy> &exec,
                  ForwardIterator first,
                  ForwardIterator last,
                  Predicate pred,
                  const T &new_value);


template<typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  void replace_if(thrust::execution_policy<DerivedPolicy> &exec,
                  ForwardIterator first,
                  ForwardIterator last,
                  InputIterator stencil,
                  Predicate pred,
                  const T &new_value);


template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void replace(thrust::execution_policy<DerivedPolicy> &exec,
               ForwardIterator first,
               ForwardIterator last,
               const T &old_value,
               const T &new_value);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/replace.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/replace.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace detail
{




template<typename Predicate, typename NewType, typename OutputType>
  struct new_value_if
{
  __attribute__((host)) __attribute__((device))
  new_value_if(Predicate p, NewType nv):pred(p),new_value(nv){}

  template<typename InputType>
  __attribute__((host)) __attribute__((device))
  OutputType operator()(const InputType &x) const
  {
    return pred(x) ? new_value : x;
  }



  template<typename InputType, typename PredicateArgumentType>
  __attribute__((host)) __attribute__((device))
  OutputType operator()(const InputType &x, const PredicateArgumentType &y)
  {
    return pred(y) ? new_value : x;
  }

  Predicate pred;
  NewType new_value;
};



template<typename T>
  struct constant_unary
{
  __attribute__((host)) __attribute__((device))
  constant_unary(T _c):c(_c){}

  template<typename U>
  __attribute__((host)) __attribute__((device))
  T operator()(U &x)
  {
    return c;
  }

  T c;
};


}


template<typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                                 InputIterator first,
                                 InputIterator last,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value)
{
  typedef typename thrust::iterator_traits<OutputIterator>::value_type OutputType;

  detail::new_value_if<Predicate,T,OutputType> op(pred,new_value);
  return thrust::transform(exec, first, last, result, op);
}


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                                 InputIterator1 first,
                                 InputIterator1 last,
                                 InputIterator2 stencil,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value)
{
  typedef typename thrust::iterator_traits<OutputIterator>::value_type OutputType;

  detail::new_value_if<Predicate,T,OutputType> op(pred,new_value);
  return thrust::transform(exec, first, last, stencil, result, op);
}


template<typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy(thrust::execution_policy<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              OutputIterator result,
                              const T &old_value,
                              const T &new_value)
{
  thrust::detail::equal_to_value<T> pred(old_value);
  return thrust::replace_copy_if(exec, first, last, result, pred, new_value);
}


template<typename DerivedPolicy, typename ForwardIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  void replace_if(thrust::execution_policy<DerivedPolicy> &exec,
                  ForwardIterator first,
                  ForwardIterator last,
                  Predicate pred,
                  const T &new_value)
{
  detail::constant_unary<T> f(new_value);
  thrust::transform_if(exec, first, last, first, first, f, pred);
}


template<typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  void replace_if(thrust::execution_policy<DerivedPolicy> &exec,
                  ForwardIterator first,
                  ForwardIterator last,
                  InputIterator stencil,
                  Predicate pred,
                  const T &new_value)
{
  detail::constant_unary<T> f(new_value);
  thrust::transform_if(exec, first, last, stencil, first, f, pred);
}


template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void replace(thrust::execution_policy<DerivedPolicy> &exec,
               ForwardIterator first,
               ForwardIterator last,
               const T &old_value,
               const T &new_value)
{
  thrust::detail::equal_to_value<T> pred(old_value);
  return thrust::replace_if(exec, first, last, pred, new_value);
}


}
}
}
}
# 98 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/replace.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/replace.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/replace.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/replace.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/replace.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/replace.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/replace.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/replace.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void replace(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
               ForwardIterator first, ForwardIterator last,
               const T &old_value,
               const T &new_value)
{
  using thrust::system::detail::generic::replace;
  return replace(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, old_value, new_value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  void replace_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                  ForwardIterator first, ForwardIterator last,
                  Predicate pred,
                  const T &new_value)
{
  using thrust::system::detail::generic::replace_if;
  return replace_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, pred, new_value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  void replace_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                  ForwardIterator first, ForwardIterator last,
                  InputIterator stencil,
                  Predicate pred,
                  const T &new_value)
{
  using thrust::system::detail::generic::replace_if;
  return replace_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, pred, new_value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                              InputIterator first, InputIterator last,
                              OutputIterator result,
                              const T &old_value,
                              const T &new_value)
{
  using thrust::system::detail::generic::replace_copy;
  return replace_copy(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, old_value, new_value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                 InputIterator first, InputIterator last,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value)
{
  using thrust::system::detail::generic::replace_copy_if;
  return replace_copy_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, pred, new_value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate, typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator replace_copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                 InputIterator1 first, InputIterator1 last,
                                 InputIterator2 stencil,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value)
{
  using thrust::system::detail::generic::replace_copy_if;
  return replace_copy_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, result, pred, new_value);
}


template<typename InputIterator, typename OutputIterator, typename Predicate, typename T>
  OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::replace_copy_if(select_system(system1,system2), first, last, result, pred, new_value);
}


template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate, typename T>
  OutputIterator replace_copy_if(InputIterator1 first, InputIterator1 last,
                                 InputIterator2 stencil,
                                 OutputIterator result,
                                 Predicate pred,
                                 const T &new_value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::replace_copy_if(select_system(system1,system2,system3), first, last, stencil, result, pred, new_value);
}


template<typename InputIterator, typename OutputIterator, typename T>
  OutputIterator replace_copy(InputIterator first, InputIterator last,
                              OutputIterator result,
                              const T &old_value,
                              const T &new_value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::replace_copy(select_system(system1,system2), first, last, result, old_value, new_value);
}


template<typename ForwardIterator, typename Predicate, typename T>
  void replace_if(ForwardIterator first, ForwardIterator last,
                  Predicate pred,
                  const T &new_value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::replace_if(select_system(system), first, last, pred, new_value);
}


template<typename ForwardIterator, typename InputIterator, typename Predicate, typename T>
  void replace_if(ForwardIterator first, ForwardIterator last,
                  InputIterator stencil,
                  Predicate pred,
                  const T &new_value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System1;
  typedef typename thrust::iterator_system<InputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::replace_if(select_system(system1,system2), first, last, stencil, pred, new_value);
}


template<typename ForwardIterator, typename T>
  void replace(ForwardIterator first, ForwardIterator last,
               const T &old_value,
               const T &new_value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::replace(select_system(system), first, last, old_value, new_value);
}


}
# 823 "/usr/local/cuda-8.0/include/thrust/replace.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan_by_key.inl" 2






namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace detail
{


template <typename OutputType, typename HeadFlagType, typename AssociativeOperator>
struct segmented_scan_functor
{
  AssociativeOperator binary_op;

  typedef typename thrust::tuple<OutputType, HeadFlagType> result_type;

  __attribute__((host)) __attribute__((device))
  segmented_scan_functor(AssociativeOperator _binary_op) : binary_op(_binary_op) {}

  __attribute__((host)) __attribute__((device))
  result_type operator()(result_type a, result_type b)
  {
    return result_type(thrust::get<1>(b) ? thrust::get<0>(b) : binary_op(thrust::get<0>(a), thrust::get<0>(b)),
                       thrust::get<1>(a) | thrust::get<1>(b));
  }
};


}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result)
{
  typedef typename thrust::iterator_traits<InputIterator1>::value_type InputType1;
  return thrust::inclusive_scan_by_key(exec, first1, last1, first2, result, thrust::equal_to<InputType1>());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred)
{
  typedef typename thrust::iterator_traits<OutputIterator>::value_type OutputType;
  return thrust::inclusive_scan_by_key(exec, first1, last1, first2, result, binary_pred, thrust::plus<OutputType>());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op)
{
  typedef typename thrust::iterator_traits<OutputIterator>::value_type OutputType;
  typedef unsigned int HeadFlagType;

  const size_t n = last1 - first1;

  if(n != 0)
  {

    thrust::detail::temporary_array<HeadFlagType,DerivedPolicy> flags(exec, n);
    flags[0] = 1; thrust::transform(exec, first1, last1 - 1, first1 + 1, flags.begin() + 1, thrust::detail::not2(binary_pred));






    thrust::inclusive_scan(exec,
                           thrust::make_zip_iterator(thrust::make_tuple(first2, flags.begin())),
                           thrust::make_zip_iterator(thrust::make_tuple(first2, flags.begin())) + n,
                           thrust::make_zip_iterator(thrust::make_tuple(result, flags.begin())),
                           detail::segmented_scan_functor<OutputType, HeadFlagType, AssociativeOperator>(binary_op));
  }

  return result + n;
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result)
{
  typedef typename thrust::iterator_traits<OutputIterator>::value_type OutputType;
  return thrust::exclusive_scan_by_key(exec, first1, last1, first2, result, OutputType(0));
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init)
{
  typedef typename thrust::iterator_traits<InputIterator1>::value_type InputType1;
  return thrust::exclusive_scan_by_key(exec, first1, last1, first2, result, init, thrust::equal_to<InputType1>());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred)
{
  typedef typename thrust::iterator_traits<OutputIterator>::value_type OutputType;
  return thrust::exclusive_scan_by_key(exec, first1, last1, first2, result, init, binary_pred, thrust::plus<OutputType>());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op)
{
  typedef typename thrust::iterator_traits<OutputIterator>::value_type OutputType;
  typedef unsigned int HeadFlagType;

  const size_t n = last1 - first1;

  if(n != 0)
  {
    InputIterator2 last2 = first2 + n;


    thrust::detail::temporary_array<HeadFlagType,DerivedPolicy> flags(exec, n);
    flags[0] = 1; thrust::transform(exec, first1, last1 - 1, first1 + 1, flags.begin() + 1, thrust::detail::not2(binary_pred));


    thrust::detail::temporary_array<OutputType,DerivedPolicy> temp(exec, n);
    thrust::replace_copy_if(exec, first2, last2 - 1, flags.begin() + 1, temp.begin() + 1, thrust::negate<HeadFlagType>(), init);
    temp[0] = init;






    thrust::inclusive_scan(exec,
                           thrust::make_zip_iterator(thrust::make_tuple(temp.begin(), flags.begin())),
                           thrust::make_zip_iterator(thrust::make_tuple(temp.begin(), flags.begin())) + n,
                           thrust::make_zip_iterator(thrust::make_tuple(result, flags.begin())),
                           detail::segmented_scan_functor<OutputType, HeadFlagType, AssociativeOperator>(binary_op));
  }

  return result + n;
}


}
}
}
}
# 144 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/scan_by_key.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/scan.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scan.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scan.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/scan.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/scan.h"
       
# 32 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/scan.h"
namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan(sequential::execution_policy<DerivedPolicy> &,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                BinaryFunction binary_op)
{
# 66 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/scan.h"
  using namespace thrust::detail;

  typedef typename eval_if<
    has_result_type<BinaryFunction>::value,
    result_type<BinaryFunction>,
    eval_if<
      is_output_iterator<OutputIterator>::value,
      thrust::iterator_value<InputIterator>,
      thrust::iterator_value<OutputIterator>
    >
  >::type ValueType;


  thrust::detail::wrapped_function<
    BinaryFunction,
    ValueType
  > wrapped_binary_op(binary_op);

  if(first != last)
  {
    ValueType sum = *first;

    *result = sum;

    for(++first, ++result; first != last; ++first, ++result)
      *result = sum = wrapped_binary_op(sum,*first);
  }

  return result;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(sequential::execution_policy<DerivedPolicy> &,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init,
                                BinaryFunction binary_op)
{
# 124 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/scan.h"
  using namespace thrust::detail;

  typedef typename eval_if<
    has_result_type<BinaryFunction>::value,
    result_type<BinaryFunction>,
    eval_if<
      is_output_iterator<OutputIterator>::value,
      thrust::iterator_value<InputIterator>,
      thrust::iterator_value<OutputIterator>
    >
  >::type ValueType;

  if(first != last)
  {
    ValueType tmp = *first;
    ValueType sum = init;

    *result = sum;
    sum = binary_op(sum, tmp);

    for(++first, ++result; first != last; ++first, ++result)
    {
      tmp = *first;
      *result = sum;
      sum = binary_op(sum, tmp);
    }
  }

  return result;
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scan.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/scan.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/scan.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scan.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/scan.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/scan.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
OutputIterator inclusive_scan(execution_policy<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              OutputIterator result,
                              AssociativeOperator binary_op);


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
OutputIterator exclusive_scan(execution_policy<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              OutputIterator result,
                              T init,
                              AssociativeOperator binary_op);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/scan.inl" 1
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/scan.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/decomposition.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/decomposition.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename Size>
class trivial_decomposition
{
  public:
    typedef Size size_type;

    typedef thrust::pair<size_type,size_type> range;

    __attribute__((host)) __attribute__((device))
    trivial_decomposition()
      : m_n(0)
    {}

    __attribute__((host)) __attribute__((device))
    trivial_decomposition(size_type n)
      : m_n(n)
    {}

    __attribute__((host)) __attribute__((device))
    range operator[](size_type) const
    {
      return range(0, n());
    }

    __attribute__((host)) __attribute__((device))
    size_type size() const
    {
      return 1;
    }


    __attribute__((host)) __attribute__((device))
    size_type n() const
    {
      return m_n;
    }

  private:
    Size m_n;
};


template<typename Size>
__attribute__((host)) __attribute__((device))
trivial_decomposition<Size> make_trivial_decomposition(Size n)
{
  return trivial_decomposition<Size>(n);
}


template<typename Size>
class blocked_decomposition
{
  public:
    typedef Size size_type;

    typedef thrust::pair<size_type,size_type> range;

    __attribute__((host)) __attribute__((device))
    blocked_decomposition()
      : m_n(0),
        m_block_size(0),
        m_num_partitions(0)
    {}

    __attribute__((host)) __attribute__((device))
    blocked_decomposition(size_type n, Size block_size)
      : m_n(n),
        m_block_size(block_size),
        m_num_partitions((n + block_size - 1) / block_size)
    {}

    __attribute__((host)) __attribute__((device))
    range operator[](size_type i) const
    {
      size_type first = i * m_block_size;
      size_type last = thrust::min(m_n, first + m_block_size);

      return range(first, last);
    }

    __attribute__((host)) __attribute__((device))
    size_type size() const
    {
      return m_num_partitions;
    }


    __attribute__((host)) __attribute__((device))
    size_type n() const
    {
      return m_n;
    }

  private:
    Size m_n;
    Size m_block_size;
    Size m_num_partitions;
};


template<typename Size>
__attribute__((host)) __attribute__((device))
blocked_decomposition<Size> make_blocked_decomposition(Size n, Size block_size)
{
  return blocked_decomposition<Size>(n,block_size);
}


template<typename Size>
class uniform_decomposition
  : public blocked_decomposition<Size>
{
  private:
    typedef blocked_decomposition<Size> super_t;

  public:
    __attribute__((host)) __attribute__((device))
    uniform_decomposition()
      : super_t()
    {}

    __attribute__((host)) __attribute__((device))
    uniform_decomposition(Size n, Size num_partitions)
      : super_t(n, n / num_partitions)
    {}
};


template<typename Size>
__attribute__((host)) __attribute__((device))
uniform_decomposition<Size> make_uniform_decomposition(Size n, Size num_partitions)
{
  return uniform_decomposition<Size>(n,num_partitions);
}


template<typename Size>
class aligned_decomposition
{
  public:
    typedef Size size_type;

    typedef thrust::pair<size_type,size_type> range;

    __attribute__((host)) __attribute__((device))
    aligned_decomposition()
      : m_n(0),
        m_num_partitions(0),
        m_tile_size(0)
    {}

    __attribute__((host)) __attribute__((device))
    aligned_decomposition(Size n, Size num_partitions, Size aligned_size)
      : m_n(n),
        m_num_partitions(num_partitions),
        m_tile_size(aligned_size)
    {
      size_type num_tiles = (n + m_tile_size - 1) / m_tile_size;

      m_num_tiles_per_partition = num_tiles / size();
      m_last_partial_tile_size = num_tiles % size();
    }

    __attribute__((host)) __attribute__((device))
    range operator[](Size i) const
    {
      range result = range_in_tiles(i);
      result.first *= m_tile_size;
      result.second = thrust::min<size_type>(m_n, result.second * m_tile_size);
      return result;
    }

    __attribute__((host)) __attribute__((device))
    size_type size() const
    {
      return m_num_partitions;
    }


    __attribute__((host)) __attribute__((device))
    size_type n() const
    {
      return m_n;
    }

  private:
    __attribute__((host)) __attribute__((device))
    range range_in_tiles(size_type i) const
    {
      range result;

      result.first = m_num_tiles_per_partition * i;
      result.first += thrust::min<size_type>(i, m_last_partial_tile_size);

      result.second = result.first + m_num_tiles_per_partition + (i < m_last_partial_tile_size);

      return result;
    }

    size_type m_n;
    size_type m_num_partitions;
    size_type m_num_tiles_per_partition;
    size_type m_tile_size;
    size_type m_last_partial_tile_size;
};


template<typename Size>
__attribute__((host)) __attribute__((device))
aligned_decomposition<Size> make_aligned_decomposition(Size n, Size num_partitions, Size aligned_size)
{
  return aligned_decomposition<Size>(n,num_partitions,aligned_size);
}


}
}
}
}
# 28 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/scan.inl" 2



namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace scan_detail
{


struct inclusive_scan_n
{
  template<typename ConcurrentGroup, typename InputIterator, typename Size, typename OutputIterator, typename T, typename BinaryFunction>
  __attribute__((device)) void operator()(ConcurrentGroup &this_group, InputIterator first, Size n, OutputIterator result, T init, BinaryFunction binary_op)
  {
    bulk_::inclusive_scan(this_group, first, first + n, result, init, binary_op);
  }


  template<typename ConcurrentGroup, typename InputIterator, typename Size, typename OutputIterator, typename BinaryFunction>
  __attribute__((device)) void operator()(ConcurrentGroup &this_group, InputIterator first, Size n, OutputIterator result, BinaryFunction binary_op)
  {
    bulk_::inclusive_scan(this_group, first, first + n, result, binary_op);
  }
};


struct exclusive_scan_n
{
  template<typename ConcurrentGroup, typename InputIterator, typename Size, typename OutputIterator, typename T, typename BinaryFunction>
  __attribute__((device)) void operator()(ConcurrentGroup &this_group, InputIterator first, Size n, OutputIterator result, T init, BinaryFunction binary_op)
  {
    bulk_::exclusive_scan(this_group, first, first + n, result, init, binary_op);
  }
};


struct inclusive_downsweep
{
  template<typename ConcurrentGroup, typename RandomAccessIterator1, typename Decomposition, typename RandomAccessIterator2, typename RandomAccessIterator3, typename BinaryFunction>
  __attribute__((device)) void operator()(ConcurrentGroup &this_group,
                             RandomAccessIterator1 first,
                             Decomposition decomp,
                             RandomAccessIterator2 carries_first,
                             RandomAccessIterator3 result,
                             BinaryFunction binary_op)
  {
    typename Decomposition::range range = decomp[this_group.index()];

    RandomAccessIterator1 last = first + range.second;
    first += range.first;
    result += range.first;

    if(this_group.index() == 0)
    {
      bulk_::inclusive_scan(this_group, first, last, result, binary_op);
    }
    else
    {
      typename thrust::iterator_value<RandomAccessIterator2>::type carry = carries_first[this_group.index() - 1];

      bulk_::inclusive_scan(this_group, first, last, result, carry, binary_op);
    }
  }
};


struct exclusive_downsweep
{
  template<typename ConcurrentGroup, typename RandomAccessIterator1, typename Decomposition, typename RandomAccessIterator2, typename RandomAccessIterator3, typename BinaryFunction>
  __attribute__((device)) void operator()(ConcurrentGroup &this_group,
                             RandomAccessIterator1 first,
                             Decomposition decomp,
                             RandomAccessIterator2 carries_first,
                             RandomAccessIterator3 result,
                             BinaryFunction binary_op)
  {
    typename Decomposition::range range = decomp[this_group.index()];

    RandomAccessIterator1 last = first + range.second;
    first += range.first;
    result += range.first;

    typename thrust::iterator_value<RandomAccessIterator2>::type carry = carries_first[this_group.index()];

    bulk_::exclusive_scan(this_group, first, last, result, carry, binary_op);
  }
};


template<typename T> struct accumulate_tiles_tuning_impl;


template<> struct accumulate_tiles_tuning_impl<int>
{

  static const int groupsize = 128;
  static const int grainsize = 9;
};


template<> struct accumulate_tiles_tuning_impl<double>
{

  static const int groupsize = 128;
  static const int grainsize = 9;
};



template<typename T>
  struct accumulate_tiles_tuning
{
  static const int groupsize =
    sizeof(T) <= sizeof(int) ? accumulate_tiles_tuning_impl<int>::groupsize :
    sizeof(T) <= 2 * sizeof(int) ? accumulate_tiles_tuning_impl<double>::groupsize :
    128;

  static const int grainsize =
    sizeof(T) <= sizeof(int) ? accumulate_tiles_tuning_impl<int>::grainsize :
    sizeof(T) <= 2 * sizeof(int) ? accumulate_tiles_tuning_impl<double>::grainsize :
    3;
};



template<typename T1, typename T2>
  struct accumulate_tiles_tuning<thrust::tuple<T1,T2> >
{

  static const int groupsize = 128;
  static const int grainsize = ((sizeof(T1) + sizeof(T2)) <= (2 * sizeof(double))) ? 5 : 3;
};





struct accumulate_tiles
{
  template<typename ConcurrentGroup, typename RandomAccessIterator1, typename Decomposition, typename RandomAccessIterator2, typename BinaryFunction>
  __attribute__((device)) void operator()(ConcurrentGroup &this_group,
                             RandomAccessIterator1 first,
                             Decomposition decomp,
                             RandomAccessIterator2 result,
                             BinaryFunction binary_op)
  {
    typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;

    typename Decomposition::range range = decomp[this_group.index()];

    const bool commutative = thrust::detail::is_commutative<BinaryFunction>::value;


    value_type init = commutative ? first[range.second-1] : first[range.first];

    value_type sum = commutative ?
      bulk_::accumulate(this_group, first + range.first, first + range.second - 1, init, binary_op) :
      bulk_::accumulate(this_group, first + range.first + 1, first + range.second, init, binary_op);

    if(this_group.this_exec.index() == 0)
    {
      result[this_group.index()] = sum;
    }
  }
};


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
OutputIterator inclusive_scan(execution_policy<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              OutputIterator result,
                              AssociativeOperator binary_op)
{
  typedef typename bulk_::detail::scan_detail::scan_intermediate<
    InputIterator,
    OutputIterator,
    AssociativeOperator
  >::type intermediate_type;

  typedef typename thrust::iterator_difference<InputIterator>::type Size;

  Size n = last - first;

  cudaStream_t s = stream(thrust::detail::derived_cast(exec));

  const Size threshold_of_parallelism = 20000;

  if(n < threshold_of_parallelism)
  {
    const Size groupsize =
      sizeof(intermediate_type) <= 2 * sizeof(int) ? 512 :
      sizeof(intermediate_type) <= 4 * sizeof(int) ? 256 :
      128;

    typedef bulk_::detail::scan_detail::scan_buffer<groupsize,3,InputIterator,OutputIterator,AssociativeOperator> heap_type;
    Size heap_size = sizeof(heap_type);
    bulk_::async(bulk_::grid<groupsize,3>(1, heap_size, s), scan_detail::inclusive_scan_n(), bulk_::root.this_exec, first, n, result, binary_op);


    (void) groupsize;
  }
  else
  {
    const Size groupsize = scan_detail::accumulate_tiles_tuning<intermediate_type>::groupsize;
    const Size grainsize = scan_detail::accumulate_tiles_tuning<intermediate_type>::grainsize;

    const Size tile_size = groupsize * grainsize;
    Size num_tiles = (n + tile_size - 1) / tile_size;


    Size subscription = 20;
    Size num_groups = thrust::min<Size>(subscription * bulk_::concurrent_group<>::hardware_concurrency(), num_tiles);

    aligned_decomposition<Size> decomp(n, num_groups, tile_size);

    thrust::detail::temporary_array<intermediate_type,DerivedPolicy> carries(exec, num_groups);



    Size heap_size = groupsize * sizeof(intermediate_type);
    bulk_::async(bulk_::grid<groupsize,grainsize>(num_groups,heap_size,s), scan_detail::accumulate_tiles(), bulk_::root.this_exec, first, decomp, carries.begin(), binary_op);



    const Size groupsize2 = sizeof(intermediate_type) <= 2 * sizeof(int) ? 256 : 128;
    const Size grainsize2 = 3;
    typedef bulk_::detail::scan_detail::scan_buffer<groupsize2,grainsize2,InputIterator,OutputIterator,AssociativeOperator> heap_type2;
    heap_size = sizeof(heap_type2);
    bulk_::async(bulk_::grid<groupsize2,grainsize2>(1,heap_size,s), scan_detail::inclusive_scan_n(), bulk_::root.this_exec, carries.begin(), num_groups, carries.begin(), binary_op);


    typedef bulk_::detail::scan_detail::scan_buffer<
      groupsize,
      grainsize,
      InputIterator,OutputIterator,AssociativeOperator
    > heap_type3;
    heap_size = sizeof(heap_type3);
    bulk_::async(bulk_::grid<groupsize,grainsize>(num_groups,heap_size,s), scan_detail::inclusive_downsweep(), bulk_::root.this_exec, first, decomp, carries.begin(), result, binary_op);


    (void) groupsize2;
    (void) grainsize2;
  }

  return result + n;
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
OutputIterator exclusive_scan(execution_policy<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              OutputIterator result,
                              T init,
                              AssociativeOperator binary_op)
{
  typedef typename bulk_::detail::scan_detail::scan_intermediate<
    InputIterator,
    OutputIterator,
    AssociativeOperator
  >::type intermediate_type;

  typedef typename thrust::iterator_difference<InputIterator>::type Size;

  Size n = last - first;

  cudaStream_t s = stream(thrust::detail::derived_cast(exec));

  const Size threshold_of_parallelism = 20000;

  if(n < threshold_of_parallelism)
  {
    const Size groupsize =
      sizeof(intermediate_type) <= 2 * sizeof(int) ? 512 :
      sizeof(intermediate_type) <= 4 * sizeof(int) ? 256 :
      128;

    typedef bulk_::detail::scan_detail::scan_buffer<groupsize,3,InputIterator,OutputIterator,AssociativeOperator> heap_type;
    Size heap_size = sizeof(heap_type);
    bulk_::async(bulk_::grid<groupsize,3>(1, heap_size, s), scan_detail::exclusive_scan_n(), bulk_::root.this_exec, first, n, result, init, binary_op);


    (void) groupsize;
  }
  else
  {
    const Size groupsize = scan_detail::accumulate_tiles_tuning<intermediate_type>::groupsize;
    const Size grainsize = scan_detail::accumulate_tiles_tuning<intermediate_type>::grainsize;

    const Size tile_size = groupsize * grainsize;
    Size num_tiles = (n + tile_size - 1) / tile_size;


    Size subscription = 20;
    Size num_groups = thrust::min<Size>(subscription * bulk_::concurrent_group<>::hardware_concurrency(), num_tiles);

    aligned_decomposition<Size> decomp(n, num_groups, tile_size);

    thrust::detail::temporary_array<intermediate_type,DerivedPolicy> carries(exec, num_groups);



    Size heap_size = groupsize * sizeof(intermediate_type);
    bulk_::async(bulk_::grid<groupsize,grainsize>(num_groups,heap_size,s), scan_detail::accumulate_tiles(), bulk_::root.this_exec, first, decomp, carries.begin(), binary_op);



    const Size groupsize2 = sizeof(intermediate_type) <= 2 * sizeof(int) ? 256 : 128;
    const Size grainsize2 = 3;

    typedef bulk_::detail::scan_detail::scan_buffer<groupsize2,grainsize2,InputIterator,OutputIterator,AssociativeOperator> heap_type2;
    heap_size = sizeof(heap_type2);
    bulk_::async(bulk_::grid<groupsize2,grainsize2>(1,heap_size,s), scan_detail::exclusive_scan_n(), bulk_::root.this_exec, carries.begin(), num_groups, carries.begin(), init, binary_op);


    typedef bulk_::detail::scan_detail::scan_buffer<
      groupsize,
      grainsize,
      InputIterator,OutputIterator,AssociativeOperator
    > heap_type3;
    heap_size = sizeof(heap_type3);
    bulk_::async(bulk_::grid<groupsize,grainsize>(num_groups,heap_size,s), scan_detail::exclusive_downsweep(), bulk_::root.this_exec, first, decomp, carries.begin(), result, binary_op);


    (void) groupsize2;
    (void) grainsize2;
  }

  return result + n;
}


}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
OutputIterator inclusive_scan(execution_policy<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              OutputIterator result,
                              AssociativeOperator binary_op)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator, 3 == 3>::value) ) >)> thrust_static_assert_typedef_395 __attribute__((unused));

  struct workaround
  {
    __attribute__((host)) __attribute__((device))
    static OutputIterator parallel_path(execution_policy<DerivedPolicy> &exec,
                                        InputIterator first,
                                        InputIterator last,
                                        OutputIterator result,
                                        AssociativeOperator binary_op)
    {
      return thrust::system::cuda::detail::scan_detail::inclusive_scan(exec, first, last, result, binary_op);
    }

    __attribute__((host)) __attribute__((device))
    static OutputIterator sequential_path(execution_policy<DerivedPolicy> &,
                                          InputIterator first,
                                          InputIterator last,
                                          OutputIterator result,
                                          AssociativeOperator binary_op)
    {
      return thrust::inclusive_scan(thrust::seq, first, last, result, binary_op);
    }
  };


  return workaround::parallel_path(exec, first, last, result, binary_op);



}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
OutputIterator exclusive_scan(execution_policy<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              OutputIterator result,
                              T init,
                              AssociativeOperator binary_op)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator, 3 == 3>::value) ) >)> thrust_static_assert_typedef_446 __attribute__((unused));

  struct workaround
  {
    __attribute__((host)) __attribute__((device))
    static OutputIterator parallel_path(execution_policy<DerivedPolicy> &exec,
                                        InputIterator first,
                                        InputIterator last,
                                        OutputIterator result,
                                        T init,
                                        AssociativeOperator binary_op)
    {
      return thrust::system::cuda::detail::scan_detail::exclusive_scan(exec, first, last, result, init, binary_op);
    }

    __attribute__((host)) __attribute__((device))
    static OutputIterator sequential_path(execution_policy<DerivedPolicy> &,
                                          InputIterator first,
                                          InputIterator last,
                                          OutputIterator result,
                                          T init,
                                          AssociativeOperator binary_op)
    {
      return thrust::exclusive_scan(thrust::seq, first, last, result, init, binary_op);
    }
  };


  return workaround::parallel_path(exec, first, last, result, init, binary_op);



}


}
}
}
}
# 69 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/scan.h" 2
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scan.h" 2
# 29 "/usr/local/cuda-8.0/include/thrust/detail/scan.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scan_by_key.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scan_by_key.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/scan_by_key.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/scan_by_key.h"
       






namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(sequential::execution_policy<DerivedPolicy> &,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred,
                                       BinaryFunction binary_op)
{
  typedef typename thrust::iterator_traits<InputIterator1>::value_type KeyType;
  typedef typename thrust::iterator_traits<OutputIterator>::value_type ValueType;


  thrust::detail::wrapped_function<
    BinaryFunction,
    ValueType
  > wrapped_binary_op(binary_op);

  if(first1 != last1)
  {
    KeyType prev_key = *first1;
    ValueType prev_value = *first2;

    *result = prev_value;

    for(++first1, ++first2, ++result;
        first1 != last1;
        ++first1, ++first2, ++result)
    {
      KeyType key = *first1;

      if(binary_pred(prev_key, key))
        *result = prev_value = wrapped_binary_op(prev_value,*first2);
      else
        *result = prev_value = *first2;

      prev_key = key;
    }
  }

  return result;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(sequential::execution_policy<DerivedPolicy> &,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred,
                                       BinaryFunction binary_op)
{
  typedef typename thrust::iterator_traits<InputIterator1>::value_type KeyType;
  typedef typename thrust::iterator_traits<OutputIterator>::value_type ValueType;

  if(first1 != last1)
  {
    KeyType temp_key = *first1;
    ValueType temp_value = *first2;

    ValueType next = init;


    *result = next;

    next = binary_op(next, temp_value);

    for(++first1, ++first2, ++result;
        first1 != last1;
        ++first1, ++first2, ++result)
    {
      KeyType key = *first1;


      temp_value = *first2;

      if (!binary_pred(temp_key, key))
        next = init;

      *result = next;
      next = binary_op(next, temp_value);

      temp_key = key;
    }
  }

  return result;
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scan_by_key.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/scan_by_key.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/scan_by_key.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/scan_by_key.h" 2
# 30 "/usr/local/cuda-8.0/include/thrust/detail/scan.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result)
{
  using thrust::system::detail::generic::inclusive_scan;
  return inclusive_scan(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                AssociativeOperator binary_op)
{
  using thrust::system::detail::generic::inclusive_scan;
  return inclusive_scan(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, binary_op);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result)
{
  using thrust::system::detail::generic::exclusive_scan;
  return exclusive_scan(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init)
{
  using thrust::system::detail::generic::exclusive_scan;
  return exclusive_scan(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, init);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init,
                                AssociativeOperator binary_op)
{
  using thrust::system::detail::generic::exclusive_scan;
  return exclusive_scan(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, init, binary_op);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result)
{
  using thrust::system::detail::generic::inclusive_scan_by_key;
  return inclusive_scan_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, result);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred)
{
  using thrust::system::detail::generic::inclusive_scan_by_key;
  return inclusive_scan_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, result, binary_pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator inclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op)
{
  using thrust::system::detail::generic::inclusive_scan_by_key;
  return inclusive_scan_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, result, binary_pred, binary_op);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result)
{
  using thrust::system::detail::generic::exclusive_scan_by_key;
  return exclusive_scan_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, result);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init)
{
  using thrust::system::detail::generic::exclusive_scan_by_key;
  return exclusive_scan_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, result, init);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred)
{
  using thrust::system::detail::generic::exclusive_scan_by_key;
  return exclusive_scan_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, result, init, binary_pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate,
         typename AssociativeOperator>
__attribute__((host)) __attribute__((device))
  OutputIterator exclusive_scan_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                       InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op)
{
  using thrust::system::detail::generic::exclusive_scan_by_key;
  return exclusive_scan_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, result, init, binary_pred, binary_op);
}


template<typename InputIterator,
         typename OutputIterator>
  OutputIterator inclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::inclusive_scan(select_system(system1,system2), first, last, result);
}


template<typename InputIterator,
         typename OutputIterator,
         typename BinaryFunction>
  OutputIterator inclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                BinaryFunction binary_op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::inclusive_scan(select_system(system1,system2), first, last, result, binary_op);
}


template<typename InputIterator,
         typename OutputIterator>
  OutputIterator exclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::exclusive_scan(select_system(system1,system2), first, last, result);
}


template<typename InputIterator,
         typename OutputIterator,
         typename T>
  OutputIterator exclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::exclusive_scan(select_system(system1,system2), first, last, result, init);
}


template<typename InputIterator,
         typename OutputIterator,
         typename T,
         typename BinaryFunction>
  OutputIterator exclusive_scan(InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                T init,
                                BinaryFunction binary_op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::exclusive_scan(select_system(system1,system2), first, last, result, init, binary_op);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
  OutputIterator inclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::inclusive_scan_by_key(select_system(system1,system2,system3), first1, last1, first2, result);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate>
  OutputIterator inclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::inclusive_scan_by_key(select_system(system1,system2,system3), first1, last1, first2, result, binary_pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename BinaryPredicate,
         typename AssociativeOperator>
  OutputIterator inclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::inclusive_scan_by_key(select_system(system1,system2,system3), first1, last1, first2, result, binary_pred, binary_op);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
  OutputIterator exclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::exclusive_scan_by_key(select_system(system1,system2,system3), first1, last1, first2, result);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T>
  OutputIterator exclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::exclusive_scan_by_key(select_system(system1,system2,system3), first1, last1, first2, result, init);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate>
  OutputIterator exclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::exclusive_scan_by_key(select_system(system1,system2,system3), first1, last1, first2, result, init, binary_pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename T,
         typename BinaryPredicate,
         typename AssociativeOperator>
  OutputIterator exclusive_scan_by_key(InputIterator1 first1,
                                       InputIterator1 last1,
                                       InputIterator2 first2,
                                       OutputIterator result,
                                       T init,
                                       BinaryPredicate binary_pred,
                                       AssociativeOperator binary_op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::exclusive_scan_by_key(select_system(system1,system2,system3), first1, last1, first2, result, init, binary_pred, binary_op);
}


}
# 1564 "/usr/local/cuda-8.0/include/thrust/scan.h" 2
# 36 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce_by_key.inl" 2


namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace detail
{


template <typename ValueType, typename TailFlagType, typename AssociativeOperator>
struct reduce_by_key_functor
{
  AssociativeOperator binary_op;

  typedef typename thrust::tuple<ValueType, TailFlagType> result_type;

  __attribute__((host)) __attribute__((device))
  reduce_by_key_functor(AssociativeOperator _binary_op) : binary_op(_binary_op) {}

  __attribute__((host)) __attribute__((device))
  result_type operator()(result_type a, result_type b)
  {
    return result_type(thrust::get<1>(b) ? thrust::get<0>(b) : binary_op(thrust::get<0>(a), thrust::get<0>(b)),
                       thrust::get<1>(a) | thrust::get<1>(b));
  }
};


}


template<typename ExecutionPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    reduce_by_key(thrust::execution_policy<ExecutionPolicy> &exec,
                  InputIterator1 keys_first,
                  InputIterator1 keys_last,
                  InputIterator2 values_first,
                  OutputIterator1 keys_output,
                  OutputIterator2 values_output,
                  BinaryPredicate binary_pred,
                  BinaryFunction binary_op)
{
    typedef typename thrust::iterator_traits<InputIterator1>::difference_type difference_type;

    typedef unsigned int FlagType;
# 106 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce_by_key.inl"
    typedef typename thrust::detail::eval_if<
      thrust::detail::has_result_type<BinaryFunction>::value,
      thrust::detail::result_type<BinaryFunction>,
      thrust::detail::eval_if<
        thrust::detail::is_output_iterator<OutputIterator2>::value,
        thrust::iterator_value<InputIterator2>,
        thrust::iterator_value<OutputIterator2>
      >
    >::type ValueType;

    if (keys_first == keys_last)
        return thrust::make_pair(keys_output, values_output);


    difference_type n = keys_last - keys_first;

    InputIterator2 values_last = values_first + n;


    thrust::detail::temporary_array<FlagType,ExecutionPolicy> head_flags(exec, n);
    thrust::transform(exec, keys_first, keys_last - 1, keys_first + 1, head_flags.begin() + 1, thrust::detail::not2(binary_pred));
    head_flags[0] = 1;


    thrust::detail::temporary_array<FlagType,ExecutionPolicy> tail_flags(exec, n);
    thrust::transform(exec, keys_first, keys_last - 1, keys_first + 1, tail_flags.begin(), thrust::detail::not2(binary_pred));
    tail_flags[n-1] = 1;


    thrust::detail::temporary_array<ValueType,ExecutionPolicy> scanned_values(exec, n);
    thrust::detail::temporary_array<FlagType,ExecutionPolicy> scanned_tail_flags(exec, n);

    thrust::inclusive_scan
        (exec,
         thrust::make_zip_iterator(thrust::make_tuple(values_first, head_flags.begin())),
         thrust::make_zip_iterator(thrust::make_tuple(values_last, head_flags.end())),
         thrust::make_zip_iterator(thrust::make_tuple(scanned_values.begin(), scanned_tail_flags.begin())),
         detail::reduce_by_key_functor<ValueType, FlagType, BinaryFunction>(binary_op));

    thrust::exclusive_scan(exec, tail_flags.begin(), tail_flags.end(), scanned_tail_flags.begin(), FlagType(0), thrust::plus<FlagType>());


    FlagType N = scanned_tail_flags[n - 1] + 1;


    thrust::scatter_if(exec, keys_first, keys_last, scanned_tail_flags.begin(), head_flags.begin(), keys_output);
    thrust::scatter_if(exec, scanned_values.begin(), scanned_values.end(), scanned_tail_flags.begin(), tail_flags.begin(), values_output);

    return thrust::make_pair(keys_output + N, values_output + N);
}


template<typename ExecutionPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    reduce_by_key(thrust::execution_policy<ExecutionPolicy> &exec,
                  InputIterator1 keys_first,
                  InputIterator1 keys_last,
                  InputIterator2 values_first,
                  OutputIterator1 keys_output,
                  OutputIterator2 values_output)
{
  typedef typename thrust::iterator_value<InputIterator1>::type KeyType;


  return thrust::reduce_by_key(exec, keys_first, keys_last, values_first, keys_output, values_output, thrust::equal_to<KeyType>());
}


template<typename ExecutionPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    reduce_by_key(thrust::execution_policy<ExecutionPolicy> &exec,
                  InputIterator1 keys_first,
                  InputIterator1 keys_last,
                  InputIterator2 values_first,
                  OutputIterator1 keys_output,
                  OutputIterator2 values_output,
                  BinaryPredicate binary_pred)
{
  typedef typename thrust::detail::eval_if<
    thrust::detail::is_output_iterator<OutputIterator2>::value,
    thrust::iterator_value<InputIterator2>,
    thrust::iterator_value<OutputIterator2>
  >::type T;


  return thrust::reduce_by_key(exec,
                               keys_first, keys_last,
                               values_first,
                               keys_output,
                               values_output,
                               binary_pred,
                               thrust::plus<T>());
}


}
}
}
}
# 89 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reduce_by_key.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/reduce.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/reduce.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/reduce.h"
       





namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputType reduce(sequential::execution_policy<DerivedPolicy> &,
                    InputIterator begin,
                    InputIterator end,
                    OutputType init,
                    BinaryFunction binary_op)
{

  thrust::detail::wrapped_function<
    BinaryFunction,
    OutputType
  > wrapped_binary_op(binary_op);


  OutputType result = init;

  while(begin != end)
  {
    result = wrapped_binary_op(result, *begin);
    ++begin;
  }

  return result;
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/reduce.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/reduce.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
OutputType reduce(execution_policy<DerivedPolicy> &exec,
                  InputIterator first,
                  InputIterator last,
                  OutputType init,
                  BinaryFunction binary_op);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce.inl" 1
# 32 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce.inl"
namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace reduce_detail
{


struct reduce_partitions
{
  template<typename ConcurrentGroup, typename Iterator1, typename Iterator2, typename T, typename BinaryOperation>
  __attribute__((device))
  void operator()(ConcurrentGroup &this_group, Iterator1 first, Iterator1 last, Iterator2 result, T init, BinaryOperation binary_op)
  {
    T sum = bulk_::reduce(this_group, first, last, init, binary_op);

    if(this_group.this_exec.index() == 0)
    {
      *result = sum;
    }
  }

  template<typename ConcurrentGroup, typename Iterator1, typename Iterator2, typename BinaryOperation>
  __attribute__((device))
  void operator()(ConcurrentGroup &this_group, Iterator1 first, Iterator1 last, Iterator2 result, BinaryOperation binary_op)
  {

    typename thrust::iterator_value<Iterator2>::type init = thrust::raw_reference_cast(last[-1]);
    (*this)(this_group, first, last - 1, result, init, binary_op);
  }


  template<typename ConcurrentGroup, typename Iterator1, typename Decomposition, typename Iterator2, typename T, typename BinaryFunction>
  __attribute__((device))
  void operator()(ConcurrentGroup &this_group, Iterator1 first, Decomposition decomp, Iterator2 result, T init, BinaryFunction binary_op)
  {
    typename Decomposition::range range = decomp[this_group.index()];

    Iterator1 last = first + range.second;
    first += range.first;

    if(this_group.index() != 0)
    {

      init = thrust::raw_reference_cast(last[-1]);
      --last;
    }

    (*this)(this_group, first, last, result + this_group.index(), init, binary_op);
  }
};


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
OutputType tuned_reduce(execution_policy<DerivedPolicy> &exec,
                        InputIterator first,
                        InputIterator last,
                        OutputType init,
                        BinaryFunction binary_op)
{
  typedef typename thrust::iterator_difference<InputIterator>::type size_type;

  const size_type n = last - first;

  if(n <= 0) return init;

  cudaStream_t s = stream(thrust::detail::derived_cast(exec));

  const size_type groupsize = 128;
  const size_type grainsize = 7;
  const size_type tile_size = groupsize * grainsize;
  const size_type num_tiles = (n + tile_size - 1) / tile_size;
  const size_type subscription = 10;

  bulk_::concurrent_group<
    bulk_::agent<grainsize>,
    groupsize
  > g;

  const size_type num_groups = thrust::min<size_type>(subscription * g.hardware_concurrency(), num_tiles);

  aligned_decomposition<size_type> decomp(n, num_groups, tile_size);

  thrust::detail::temporary_array<OutputType,DerivedPolicy> partial_sums(exec, decomp.size());


  bulk_::async(bulk_::par(s, g, decomp.size()), reduce_detail::reduce_partitions(), bulk_::root.this_exec, first, decomp, partial_sums.begin(), init, binary_op).wait();

  if(partial_sums.size() > 1)
  {

    bulk_::async(bulk_::par(s, g, 1), reduce_detail::reduce_partitions(), bulk_::root.this_exec, partial_sums.begin(), partial_sums.end(), partial_sums.begin(), binary_op);
  }

  return get_value(exec, &partial_sums[0]);
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
OutputType general_reduce(execution_policy<DerivedPolicy> &exec,
                          InputIterator first,
                          InputIterator last,
                          OutputType init,
                          BinaryFunction binary_op)
{
  typedef typename thrust::iterator_difference<InputIterator>::type size_type;

  const size_type n = last - first;

  if(n <= 0) return init;

  cudaStream_t s = stream(thrust::detail::derived_cast(exec));

  typedef thrust::detail::temporary_array<OutputType,DerivedPolicy> temporary_array;


  size_type num_groups = 0;
  size_type group_size = 0;

  thrust::tie(num_groups, group_size) = bulk_::choose_sizes(bulk_::grid(), reduce_partitions(), bulk_::root.this_exec, first, uniform_decomposition<size_type>(), typename temporary_array::iterator(), init, binary_op);

  num_groups = thrust::min<size_type>(num_groups, thrust::detail::util::divide_ri(n, group_size));

  uniform_decomposition<size_type> decomp(n, num_groups);
  temporary_array partial_sums(exec, decomp.size());


  bulk_::async(bulk_::grid(decomp.size(), group_size, bulk_::use_default, s), reduce_partitions(), bulk_::root.this_exec, first, decomp, partial_sums.begin(), init, binary_op);

  if(partial_sums.size() > 1)
  {

    thrust::tie(num_groups, group_size) = bulk_::choose_sizes(bulk_::grid(1), reduce_partitions(), bulk_::root.this_exec, partial_sums.begin(), partial_sums.end(), partial_sums.begin(), binary_op);


    bulk_::async(bulk_::grid(num_groups, group_size, bulk_::use_default, s), reduce_partitions(), bulk_::root.this_exec, partial_sums.begin(), partial_sums.end(), partial_sums.begin(), binary_op);
  }

  return get_value(exec, &partial_sums[0]);
}



template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
typename thrust::detail::enable_if<
  thrust::detail::is_arithmetic<OutputType>::value,
  OutputType
>::type
  reduce(execution_policy<DerivedPolicy> &exec,
         InputIterator first,
         InputIterator last,
         OutputType init,
         BinaryFunction binary_op)
{
  return reduce_detail::tuned_reduce(exec, first, last, init, binary_op);
}



template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
typename thrust::detail::disable_if<
  thrust::detail::is_arithmetic<OutputType>::value,
  OutputType
>::type
  reduce(execution_policy<DerivedPolicy> &exec,
         InputIterator first,
         InputIterator last,
         OutputType init,
         BinaryFunction binary_op)
{
  return reduce_detail::general_reduce(exec, first, last, init, binary_op);
}



}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
OutputType reduce(execution_policy<DerivedPolicy> &exec,
                  InputIterator first,
                  InputIterator last,
                  OutputType init,
                  BinaryFunction binary_op)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator, 3 == 3>::value) ) >)> thrust_static_assert_typedef_246 __attribute__((unused));

  struct workaround
  {
    __attribute__((host)) __attribute__((device))
    static OutputType parallel_path(execution_policy<DerivedPolicy> &exec,
                                    InputIterator first,
                                    InputIterator last,
                                    OutputType init,
                                    BinaryFunction binary_op)
    {
      return thrust::system::cuda::detail::reduce_detail::reduce(exec, first, last, init, binary_op);
    }

    __attribute__((host)) __attribute__((device))
    static OutputType sequential_path(execution_policy<DerivedPolicy> &,
                                      InputIterator first,
                                      InputIterator last,
                                      OutputType init,
                                      BinaryFunction binary_op)
    {
      return thrust::reduce(thrust::seq, first, last, init, binary_op);
    }
  };


  return workaround::parallel_path(exec, first, last, init, binary_op);



}


}
}
}
}
# 55 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce.h" 2
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/reduce.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce_by_key.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce_by_key.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/reduce_by_key.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/reduce_by_key.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/algorithm/intermediate_type_from_function_and_iterators.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/algorithm/intermediate_type_from_function_and_iterators.h"
       






namespace thrust
{

namespace detail
{
# 44 "/usr/local/cuda-8.0/include/thrust/detail/type_traits/algorithm/intermediate_type_from_function_and_iterators.h"
template<typename InputIterator, typename OutputIterator, typename Function>
  struct intermediate_type_from_function_and_iterators
    : eval_if<
        has_result_type<Function>::value,
        result_type<Function>,
        eval_if<
          is_output_iterator<OutputIterator>::value,
          thrust::iterator_value<InputIterator>,
          thrust::iterator_value<OutputIterator>
        >
      >
{
};

}

}
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/reduce_by_key.h" 2


namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    reduce_by_key(sequential::execution_policy<DerivedPolicy> &,
                  InputIterator1 keys_first,
                  InputIterator1 keys_last,
                  InputIterator2 values_first,
                  OutputIterator1 keys_output,
                  OutputIterator2 values_output,
                  BinaryPredicate binary_pred,
                  BinaryFunction binary_op)
{
  typedef typename thrust::iterator_traits<InputIterator1>::value_type InputKeyType;
  typedef typename thrust::iterator_traits<InputIterator2>::value_type InputValueType;

  typedef typename thrust::detail::intermediate_type_from_function_and_iterators<
    InputIterator2,
    OutputIterator2,
    BinaryFunction
  >::type TemporaryType;

  if(keys_first != keys_last)
  {
    InputKeyType temp_key = *keys_first;
    TemporaryType temp_value = *values_first;

    for(++keys_first, ++values_first;
        keys_first != keys_last;
        ++keys_first, ++values_first)
    {
      InputKeyType key = *keys_first;
      InputValueType value = *values_first;

      if(binary_pred(temp_key, key))
      {
        temp_value = binary_op(temp_value, value);
      }
      else
      {
        *keys_output = temp_key;
        *values_output = temp_value;

        ++keys_output;
        ++values_output;

        temp_key = key;
        temp_value = value;
      }
    }

    *keys_output = temp_key;
    *values_output = temp_value;

    ++keys_output;
    ++values_output;
  }

  return thrust::make_pair(keys_output, values_output);
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce_by_key.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/reduce_by_key.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/reduce_by_key.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce_by_key.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(execution_policy<DerivedPolicy> &exec,
                InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output,
                BinaryPredicate binary_pred,
                BinaryFunction binary_op);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/constant_iterator.h" 1
# 23 "/usr/local/cuda-8.0/include/thrust/iterator/constant_iterator.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/constant_iterator_base.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/constant_iterator_base.h"
       




namespace thrust
{


template<typename,typename,typename> class constant_iterator;

namespace detail
{

template<typename Value,
         typename Incrementable,
         typename System>
  struct constant_iterator_base
{
  typedef Value value_type;






  typedef value_type reference;


  typedef typename thrust::detail::ia_dflt_help<
    Incrementable,
    thrust::detail::identity_<int>
  >::type incrementable;

  typedef typename thrust::counting_iterator<
    incrementable,
    System,
    thrust::random_access_traversal_tag
  > base_iterator;

  typedef typename thrust::iterator_adaptor<
    constant_iterator<Value, Incrementable, System>,
    base_iterator,
    value_type,
    typename thrust::iterator_system<base_iterator>::type,
    typename thrust::iterator_traversal<base_iterator>::type,
    reference
  > type;
};

}

}
# 27 "/usr/local/cuda-8.0/include/thrust/iterator/constant_iterator.h" 2


namespace thrust
{
# 96 "/usr/local/cuda-8.0/include/thrust/iterator/constant_iterator.h"
template<typename Value,
         typename Incrementable = use_default,
         typename System = use_default>
  class constant_iterator
    : public detail::constant_iterator_base<Value, Incrementable, System>::type
{


    friend class thrust::iterator_core_access;
    typedef typename detail::constant_iterator_base<Value, Incrementable, System>::type super_t;
    typedef typename detail::constant_iterator_base<Value, Incrementable, System>::incrementable incrementable;
    typedef typename detail::constant_iterator_base<Value, Incrementable, System>::base_iterator base_iterator;

  public:
    typedef typename super_t::reference reference;
    typedef typename super_t::value_type value_type;







    __attribute__((host)) __attribute__((device))
    constant_iterator(void)
      : super_t(), m_value(){};






    __attribute__((host)) __attribute__((device))
    constant_iterator(constant_iterator const &rhs)
      : super_t(rhs.base()), m_value(rhs.m_value) {}






    template<typename OtherSystem>
    __attribute__((host)) __attribute__((device))
    constant_iterator(constant_iterator<Value,Incrementable,OtherSystem> const &rhs,
                      typename thrust::detail::enable_if_convertible<
                        typename thrust::iterator_system<constant_iterator<Value,Incrementable,OtherSystem> >::type,
                        typename thrust::iterator_system<super_t>::type
                      >::type * = 0)
      : super_t(rhs.base()), m_value(rhs.value()) {}
# 155 "/usr/local/cuda-8.0/include/thrust/iterator/constant_iterator.h"
    __attribute__((host)) __attribute__((device))
    constant_iterator(value_type const& v, incrementable const &i = incrementable())
      : super_t(base_iterator(i)), m_value(v) {}
# 167 "/usr/local/cuda-8.0/include/thrust/iterator/constant_iterator.h"
    template<typename OtherValue, typename OtherIncrementable>
    __attribute__((host)) __attribute__((device))
    constant_iterator(OtherValue const& v, OtherIncrementable const& i = incrementable())
      : super_t(base_iterator(i)), m_value(v) {}




    __attribute__((host)) __attribute__((device))
    Value const& value(void) const
    { return m_value; }




  protected:
    __attribute__((host)) __attribute__((device))
    Value const& value_reference(void) const
    { return m_value; }

    __attribute__((host)) __attribute__((device))
    Value & value_reference(void)
    { return m_value; }

  private:
    __attribute__((host)) __attribute__((device))
    reference dereference(void) const
    {
      return m_value;
    }

  private:
    Value m_value;



};
# 220 "/usr/local/cuda-8.0/include/thrust/iterator/constant_iterator.h"
template<typename V, typename I>
inline __attribute__((host)) __attribute__((device))
constant_iterator<V,I> make_constant_iterator(V x, I i = int())
{
  return constant_iterator<V,I>(x, i);
}
# 237 "/usr/local/cuda-8.0/include/thrust/iterator/constant_iterator.h"
template<typename V>
inline __attribute__((host)) __attribute__((device))
constant_iterator<V> make_constant_iterator(V x)
{
  return constant_iterator<V>(x, 0);
}







}
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/iterator/discard_iterator.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/iterator/discard_iterator.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/iterator/detail/discard_iterator_base.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/iterator/detail/discard_iterator_base.h"
       





# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 24 "/usr/local/cuda-8.0/include/thrust/iterator/detail/discard_iterator_base.h" 2

namespace thrust
{


template<typename> class discard_iterator;

namespace detail
{


template<typename System>
  struct discard_iterator_base
{


  typedef any_assign value_type;
  typedef any_assign& reference;
  typedef std::ptrdiff_t incrementable;

  typedef typename thrust::counting_iterator<
    incrementable,
    System,
    thrust::random_access_traversal_tag
  > base_iterator;

  typedef typename thrust::iterator_adaptor<
    discard_iterator<System>,
    base_iterator,
    value_type,
    typename thrust::iterator_system<base_iterator>::type,
    typename thrust::iterator_traversal<base_iterator>::type,
    reference
  > type;
};


}

}
# 26 "/usr/local/cuda-8.0/include/thrust/iterator/discard_iterator.h" 2




namespace thrust
{
# 93 "/usr/local/cuda-8.0/include/thrust/iterator/discard_iterator.h"
template<typename System = use_default>
  class discard_iterator
    : public detail::discard_iterator_base<System>::type
{


    friend class thrust::iterator_core_access;
    typedef typename detail::discard_iterator_base<System>::type super_t;
    typedef typename detail::discard_iterator_base<System>::incrementable incrementable;
    typedef typename detail::discard_iterator_base<System>::base_iterator base_iterator;

  public:
    typedef typename super_t::reference reference;
    typedef typename super_t::value_type value_type;
# 115 "/usr/local/cuda-8.0/include/thrust/iterator/discard_iterator.h"
    __attribute__((host)) __attribute__((device))
    discard_iterator(discard_iterator const &rhs)
      : super_t(rhs.base()) {}
# 126 "/usr/local/cuda-8.0/include/thrust/iterator/discard_iterator.h"
    __attribute__((host)) __attribute__((device))
    discard_iterator(incrementable const &i = incrementable())
      : super_t(base_iterator(i)) {}




  private:
    __attribute__((host)) __attribute__((device))
    reference dereference(void) const
    {
      return m_element;
    }

    mutable value_type m_element;



};
# 156 "/usr/local/cuda-8.0/include/thrust/iterator/discard_iterator.h"
inline __attribute__((host)) __attribute__((device))
discard_iterator<> make_discard_iterator(discard_iterator<>::difference_type i = discard_iterator<>::difference_type(0))
{
  return discard_iterator<>(i);
}







}


# 28 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.inl" 2

# 1 "/usr/local/cuda-8.0/include/thrust/detail/range/head_flags.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/range/head_flags.h"
       
# 27 "/usr/local/cuda-8.0/include/thrust/detail/range/head_flags.h"
namespace thrust
{
namespace detail
{


template<typename RandomAccessIterator,
         typename BinaryPredicate = thrust::equal_to<typename thrust::iterator_value<RandomAccessIterator>::type>,
         typename ValueType = bool,
         typename IndexType = typename thrust::iterator_difference<RandomAccessIterator>::type>
  class head_flags_with_init
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type init_type;



  public:
    struct head_flag_functor
    {
      BinaryPredicate binary_pred;
      init_type init;
      IndexType n;

      typedef ValueType result_type;

      __attribute__((host)) __attribute__((device))
      head_flag_functor(init_type init, IndexType n)
        : binary_pred(), init(init), n(n)
      {}

      __attribute__((host)) __attribute__((device))
      head_flag_functor(init_type init, IndexType n, BinaryPredicate binary_pred)
        : binary_pred(binary_pred), init(init), n(n)
      {}

      template<typename Tuple>
      __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
      result_type operator()(const Tuple &t)
      {
        const IndexType i = thrust::get<0>(t);

        if(i == 0)
        {
          return !binary_pred(init, thrust::get<1>(t));
        }

        return !binary_pred(thrust::get<1>(t), thrust::get<2>(t));
      }
    };

    typedef thrust::counting_iterator<IndexType> counting_iterator;

  public:
    typedef thrust::transform_iterator<
      head_flag_functor,
      thrust::zip_iterator<thrust::tuple<counting_iterator,RandomAccessIterator,RandomAccessIterator> >
    > iterator;

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    head_flags_with_init(RandomAccessIterator first, RandomAccessIterator last, init_type init)
      : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(thrust::counting_iterator<IndexType>(0), first, first - 1)),
                                                head_flag_functor(init, last - first))),
        m_end(m_begin + (last - first))
    {}

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    head_flags_with_init(RandomAccessIterator first, RandomAccessIterator last, init_type init, BinaryPredicate binary_pred)
      : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(thrust::counting_iterator<IndexType>(0), first, first - 1)),
                                                head_flag_functor(init, last - first, binary_pred))),
        m_end(m_begin + (last - first))
    {}

    __attribute__((host)) __attribute__((device))
    iterator begin() const
    {
      return m_begin;
    }

    __attribute__((host)) __attribute__((device))
    iterator end() const
    {
      return m_end;
    }

    template<typename OtherIndex>
    __attribute__((host)) __attribute__((device))
    typename iterator::reference operator[](OtherIndex i)
    {
      return *(begin() + i);
    }

  private:
    iterator m_begin, m_end;
};



template<typename RandomAccessIterator,
         typename BinaryPredicate = thrust::equal_to<typename thrust::iterator_value<RandomAccessIterator>::type>,
         typename ValueType = bool,
         typename IndexType = typename thrust::iterator_difference<RandomAccessIterator>::type>
  class head_flags
{


  public:
    struct head_flag_functor
    {
      BinaryPredicate binary_pred;
      IndexType n;

      typedef ValueType result_type;

      __attribute__((host)) __attribute__((device))
      head_flag_functor(IndexType n)
        : binary_pred(), n(n)
      {}

      __attribute__((host)) __attribute__((device))
      head_flag_functor(IndexType n, BinaryPredicate binary_pred)
        : binary_pred(binary_pred), n(n)
      {}

      template<typename Tuple>
      __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
      result_type operator()(const Tuple &t)
      {
        const IndexType i = thrust::get<0>(t);



        return (i == 0 || !binary_pred(thrust::get<1>(t), thrust::get<2>(t)));
      }
    };

    typedef thrust::counting_iterator<IndexType> counting_iterator;

  public:
    typedef thrust::transform_iterator<
      head_flag_functor,
      thrust::zip_iterator<thrust::tuple<counting_iterator,RandomAccessIterator,RandomAccessIterator> >
    > iterator;

    __attribute__((host)) __attribute__((device))
    head_flags(RandomAccessIterator first, RandomAccessIterator last)
      : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(thrust::counting_iterator<IndexType>(0), first, first - 1)),
                                                head_flag_functor(last - first))),
        m_end(m_begin + (last - first))
    {}

    __attribute__((host)) __attribute__((device))
    head_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
      : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(thrust::counting_iterator<IndexType>(0), first, first - 1)),
                                                head_flag_functor(last - first, binary_pred))),
        m_end(m_begin + (last - first))
    {}

    __attribute__((host)) __attribute__((device))
    iterator begin() const
    {
      return m_begin;
    }

    __attribute__((host)) __attribute__((device))
    iterator end() const
    {
      return m_end;
    }

    template<typename OtherIndex>
    __attribute__((host)) __attribute__((device))
    typename iterator::reference operator[](OtherIndex i)
    {
      return *(begin() + i);
    }

  private:
    iterator m_begin, m_end;
};


template<typename RandomAccessIterator, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
head_flags<RandomAccessIterator, BinaryPredicate>
  make_head_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
{
  return head_flags<RandomAccessIterator, BinaryPredicate>(first, last, binary_pred);
}


template<typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
head_flags<RandomAccessIterator>
  make_head_flags(RandomAccessIterator first, RandomAccessIterator last)
{
  return head_flags<RandomAccessIterator>(first, last);
}


}
}
# 30 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/detail/range/tail_flags.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/range/tail_flags.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/detail/range/tail_flags.h"
namespace thrust
{
namespace detail
{


template<typename RandomAccessIterator,
         typename BinaryPredicate = thrust::equal_to<typename thrust::iterator_value<RandomAccessIterator>::type>,
         typename ValueType = bool,
         typename IndexType = typename thrust::iterator_difference<RandomAccessIterator>::type>
  class tail_flags
{


  public:
    struct tail_flag_functor
    {
      BinaryPredicate binary_pred;
      RandomAccessIterator iter;
      IndexType n;

      typedef ValueType result_type;

      __attribute__((host)) __attribute__((device))
      tail_flag_functor(RandomAccessIterator first, RandomAccessIterator last)
        : binary_pred(), iter(first), n(last - first)
      {}

      __attribute__((host)) __attribute__((device))
      tail_flag_functor(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
        : binary_pred(binary_pred), iter(first), n(last - first)
      {}

      __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
      result_type operator()(const IndexType &i)
      {
        return (i == (n - 1) || !binary_pred(iter[i], iter[i+1]));
      }
    };

    typedef thrust::counting_iterator<IndexType> counting_iterator;

  public:
    typedef thrust::transform_iterator<
      tail_flag_functor,
      counting_iterator
    > iterator;

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    tail_flags(RandomAccessIterator first, RandomAccessIterator last)
      : m_begin(thrust::make_transform_iterator(thrust::counting_iterator<IndexType>(0),
                                                tail_flag_functor(first, last))),
        m_end(m_begin + (last - first))
    {}

    #pragma nv_exec_check_disable
    __attribute__((host)) __attribute__((device))
    tail_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
      : m_begin(thrust::make_transform_iterator(thrust::counting_iterator<IndexType>(0),
                                                tail_flag_functor(first, last, binary_pred))),
        m_end(m_begin + (last - first))
    {}

    __attribute__((host)) __attribute__((device))
    iterator begin() const
    {
      return m_begin;
    }

    __attribute__((host)) __attribute__((device))
    iterator end() const
    {
      return m_end;
    }

    template<typename OtherIndex>
    __attribute__((host)) __attribute__((device))
    typename iterator::reference operator[](OtherIndex i)
    {
      return *(begin() + i);
    }

  private:
    iterator m_begin, m_end;
};


template<typename RandomAccessIterator, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
tail_flags<RandomAccessIterator, BinaryPredicate>
  make_tail_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred)
{
  return tail_flags<RandomAccessIterator, BinaryPredicate>(first, last, binary_pred);
}


template<typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
tail_flags<RandomAccessIterator>
  make_tail_flags(RandomAccessIterator first, RandomAccessIterator last)
{
  return tail_flags<RandomAccessIterator>(first, last);
}


}
}
# 31 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_intervals.hpp" 1
       







namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace reduce_intervals_detail
{


struct reduce_intervals_kernel
{
  template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator1, typename Decomposition, typename RandomAccessIterator2, typename BinaryFunction>
  __attribute__((device)) void operator()(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &this_group,
                             RandomAccessIterator1 first,
                             Decomposition decomp,
                             RandomAccessIterator2 result,
                             BinaryFunction binary_op)
  {
    typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;

    typename Decomposition::range rng = decomp[this_group.index()];

    value_type init = first[rng.second-1];

    value_type sum = bulk_::reduce(this_group, first + rng.first, first + rng.second - 1, init, binary_op);

    if(this_group.this_exec.index() == 0)
    {
      result[this_group.index()] = sum;
    }
  }
};


}


template<typename DerivedPolicy, typename RandomAccessIterator1, typename Decomposition, typename RandomAccessIterator2, typename BinaryFunction>
__attribute__((host)) __attribute__((device))
RandomAccessIterator2 reduce_intervals_(execution_policy<DerivedPolicy> &exec, RandomAccessIterator1 first, Decomposition decomp, RandomAccessIterator2 result, BinaryFunction binary_op)
{
  typedef typename thrust::iterator_value<RandomAccessIterator2>::type result_type;
  const size_t groupsize = 128;
  size_t heap_size = groupsize * sizeof(result_type);
  bulk_::async(bulk_::grid<groupsize,7>(decomp.size(),heap_size,stream(thrust::detail::derived_cast(exec))), reduce_intervals_detail::reduce_intervals_kernel(), bulk_::root.this_exec, first, decomp, result, binary_op);

  return result + decomp.size();
}


template<typename DerivedPolicy, typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2, typename BinaryFunction>
__attribute__((host)) __attribute__((device))
RandomAccessIterator2 reduce_intervals_(execution_policy<DerivedPolicy> &exec, RandomAccessIterator1 first, RandomAccessIterator1 last, Size interval_size, RandomAccessIterator2 result, BinaryFunction binary_op)
{
  return thrust::system::cuda::detail::reduce_intervals_(exec, first, make_blocked_decomposition<Size>(last - first,interval_size), result, binary_op);
}


}
}
}
}
# 32 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.inl" 2


namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace reduce_by_key_detail
{


struct reduce_by_key_kernel
{
  template<typename ConcurrentGroup,
           typename RandomAccessIterator1,
           typename Decomposition,
           typename RandomAccessIterator2,
           typename RandomAccessIterator3,
           typename RandomAccessIterator4,
           typename RandomAccessIterator5,
           typename RandomAccessIterator6,
           typename RandomAccessIterator7,
           typename BinaryPredicate,
           typename BinaryFunction>
  __attribute__((device))
  thrust::pair<RandomAccessIterator3,RandomAccessIterator4>
  operator()(ConcurrentGroup &g,
             RandomAccessIterator1 keys_first,
             Decomposition decomp,
             RandomAccessIterator2 values_first,
             RandomAccessIterator3 keys_result,
             RandomAccessIterator4 values_result,
             RandomAccessIterator5 interval_output_offsets,
             RandomAccessIterator6 interval_values,
             RandomAccessIterator7 is_carry,


             thrust::tuple<BinaryPredicate,BinaryFunction> pred_and_binary_op)
  {
    typedef typename thrust::iterator_value<RandomAccessIterator1>::type key_type;
    typedef typename thrust::iterator_value<RandomAccessIterator2>::type value_type;

    BinaryPredicate pred = thrust::get<0>(pred_and_binary_op);
    BinaryFunction binary_op = thrust::get<1>(pred_and_binary_op);

    thrust::detail::tail_flags<RandomAccessIterator1,BinaryPredicate> tail_flags(keys_first, keys_first + decomp.n(), pred);

    typename Decomposition::size_type input_first, input_last;
    thrust::tie(input_first,input_last) = decomp[g.index()];

    typename Decomposition::size_type output_first = g.index() == 0 ? 0 : interval_output_offsets[g.index() - 1];

    key_type init_key = keys_first[input_first];
    value_type init_value = values_first[input_first];


    thrust::tie(keys_result, values_result, init_key, init_value) =
      bulk_::reduce_by_key(g,
                           keys_first + input_first + 1,
                           keys_first + input_last,
                           values_first + input_first + 1,
                           keys_result + output_first,
                           values_result + output_first,
                           init_key,
                           init_value,
                           pred,
                           binary_op);

    if(g.this_exec.index() == 0)
    {
      bool interval_has_carry = !tail_flags[input_last-1];

      if(interval_has_carry)
      {
        interval_values[g.index()] = init_value;
      }
      else
      {
        *keys_result = init_key;
        *values_result = init_value;

        ++keys_result;
        ++values_result;
      }

      is_carry[g.index()] = interval_has_carry;
    }

    return thrust::make_pair(keys_result, values_result);
  }


  template<typename ConcurrentGroup,
           typename RandomAccessIterator1,
           typename RandomAccessIterator2,
           typename RandomAccessIterator3,
           typename RandomAccessIterator4,
           typename BinaryPredicate,
           typename BinaryFunction,
           typename Iterator>
  __attribute__((device))
  void operator()(ConcurrentGroup &g,
                  RandomAccessIterator1 keys_first,
                  RandomAccessIterator1 keys_last,
                  RandomAccessIterator2 values_first,
                  RandomAccessIterator3 keys_result,
                  RandomAccessIterator4 values_result,
                  BinaryPredicate pred,
                  BinaryFunction binary_op,
                  Iterator result_size)
  {
    RandomAccessIterator3 old_keys_result = keys_result;

    thrust::tie(keys_result, values_result) =
      operator()(g, keys_first, make_trivial_decomposition(keys_last - keys_first), values_first, keys_result, values_result,
                 thrust::make_constant_iterator<int>(0),
                 thrust::make_discard_iterator(),
                 thrust::make_discard_iterator(),
                 thrust::make_tuple(pred,binary_op));

    if(g.this_exec.index() == 0)
    {
      *result_size = keys_result - old_keys_result;
    }
  }
};


struct tuple_and
{
  typedef bool result_type;

  template<typename Tuple>
  __attribute__((host)) __attribute__((device))
  bool operator()(Tuple t)
  {
    return thrust::get<0>(t) && thrust::get<1>(t);
  }
};


template<typename DerivedPolicy,
         typename Iterator1,
         typename Iterator2,
         typename Iterator3,
         typename Iterator4,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
void sum_tail_carries(execution_policy<DerivedPolicy> &exec,
                      Iterator1 interval_values_first,
                      Iterator1 interval_values_last,
                      Iterator2 interval_output_offsets_first,
                      Iterator2 interval_output_offsets_last,
                      Iterator3 is_carry,
                      Iterator4 values_result,
                      BinaryFunction binary_op)
{
  typedef thrust::zip_iterator<thrust::tuple<Iterator2,Iterator3> > zip_iterator;

  thrust::detail::tail_flags<zip_iterator> tail_flags(thrust::make_zip_iterator(thrust::make_tuple(interval_output_offsets_first, is_carry)),
                                                      thrust::make_zip_iterator(thrust::make_tuple(interval_output_offsets_last, is_carry)));




  thrust::transform_if(exec,
                       interval_values_first, interval_values_last,
                       thrust::make_permutation_iterator(values_result, interval_output_offsets_first),
                       thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(tail_flags.begin(), is_carry)), tuple_and()),
                       thrust::make_permutation_iterator(values_result, interval_output_offsets_first),
                       binary_op,
                       thrust::identity<bool>());
}


template<typename InputIterator, typename OutputIterator, typename BinaryFunction>
struct intermediate_type
  : thrust::detail::eval_if<
    thrust::detail::has_result_type<BinaryFunction>::value,
    thrust::detail::result_type<BinaryFunction>,
    thrust::detail::eval_if<
      thrust::detail::is_output_iterator<OutputIterator>::value,
      thrust::iterator_value<InputIterator>,
      thrust::iterator_value<OutputIterator>
    >
  >
{};


template<typename Size,
         typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
thrust::pair<OutputIterator1,OutputIterator2>
reduce_by_key(execution_policy<DerivedPolicy> &exec,
              InputIterator1 keys_first,
              InputIterator1 keys_last,
              InputIterator2 values_first,
              OutputIterator1 keys_result,
              OutputIterator2 values_result,
              BinaryPredicate binary_pred,
              BinaryFunction binary_op)
{
  typedef typename thrust::iterator_difference<InputIterator1>::type difference_type;
  typedef typename thrust::iterator_value<InputIterator2>::type value_type;
  typedef Size size_type;

  const difference_type n = keys_last - keys_first;

  if(n <= 0) return thrust::make_pair(keys_result, values_result);

  const size_type threshold_of_parallelism = 20000;

  if(n <= threshold_of_parallelism)
  {
    thrust::detail::temporary_array<size_type,DerivedPolicy> result_size_storage(exec, 1);




    const int groupsize =
      (sizeof(value_type) <= sizeof(int)) ? 512 :
      (sizeof(value_type) <= 2 * sizeof(int)) ? 256 :
      128;

    const int grainsize = (sizeof(value_type) == sizeof(int)) ? 3 : 5;

    size_type heap_size = groupsize * grainsize * (sizeof(size_type) + sizeof(value_type));
    bulk_::async(bulk_::grid<groupsize,grainsize>(1,heap_size,stream(thrust::detail::derived_cast(exec))), reduce_by_key_detail::reduce_by_key_kernel(),
      bulk_::root.this_exec, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op, result_size_storage.begin());

    size_type result_size = get_value(exec,&result_size_storage[0]);

    return thrust::make_pair(keys_result + result_size, values_result + result_size);
  }

  typedef typename reduce_by_key_detail::intermediate_type<
    InputIterator2, OutputIterator2, BinaryFunction
  >::type intermediate_type;

  const size_type groupsize = 128;
  const size_type grainsize = 5;
  size_type tile_size = groupsize * grainsize;

  const size_type interval_size = threshold_of_parallelism;

  size_type subscription = 100;
  size_type num_groups = thrust::min<size_type>(subscription * bulk_::concurrent_group<>::hardware_concurrency(), (n + interval_size - 1) / interval_size);
  aligned_decomposition<size_type> decomp(n, num_groups, tile_size);


  thrust::detail::tail_flags<
    InputIterator1,
    BinaryPredicate,
    size_type
  > tail_flags(keys_first, keys_last, binary_pred);

  thrust::detail::temporary_array<size_type,DerivedPolicy> interval_output_offsets(exec, decomp.size());

  reduce_intervals_(exec, tail_flags.begin(), decomp, interval_output_offsets.begin(), thrust::plus<size_type>());


  thrust::inclusive_scan(exec, interval_output_offsets.begin(), interval_output_offsets.end(), interval_output_offsets.begin());


  thrust::detail::temporary_array<bool,DerivedPolicy> is_carry(exec, decomp.size());
  thrust::detail::temporary_array<intermediate_type,DerivedPolicy> interval_values(exec, decomp.size());

  size_type heap_size = tile_size * (sizeof(size_type) + sizeof(value_type));
  bulk_::async(bulk_::grid<groupsize,grainsize>(decomp.size(),heap_size,stream(thrust::detail::derived_cast(exec))), reduce_by_key_detail::reduce_by_key_kernel(),
    bulk_::root.this_exec, keys_first, decomp, values_first, keys_result, values_result, interval_output_offsets.begin(), interval_values.begin(), is_carry.begin(), thrust::make_tuple(binary_pred, binary_op)
  );


  thrust::inclusive_scan_by_key(exec,
                                thrust::make_zip_iterator(thrust::make_tuple(interval_output_offsets.begin(), is_carry.begin())),
                                thrust::make_zip_iterator(thrust::make_tuple(interval_output_offsets.end(), is_carry.end())),
                                interval_values.begin(),
                                interval_values.begin(),
                                thrust::equal_to<thrust::tuple<size_type,bool> >(),
                                binary_op);


  reduce_by_key_detail::sum_tail_carries(exec,
                                         interval_values.begin(), interval_values.end(),
                                         interval_output_offsets.begin(), interval_output_offsets.end(),
                                         is_carry.begin(),
                                         values_result,
                                         binary_op);

  difference_type result_size = interval_output_offsets[interval_output_offsets.size() - 1];

  return thrust::make_pair(keys_result + result_size, values_result + result_size);
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
thrust::pair<OutputIterator1,OutputIterator2>
reduce_by_key(execution_policy<DerivedPolicy> &exec,
              InputIterator1 keys_first,
              InputIterator1 keys_last,
              InputIterator2 values_first,
              OutputIterator1 keys_result,
              OutputIterator2 values_result,
              BinaryPredicate binary_pred,
              BinaryFunction binary_op)
{
  thrust::pair<OutputIterator1,OutputIterator2> result(keys_result, values_result);

  typedef typename thrust::iterator_difference<InputIterator1>::type difference_type;



  if(keys_last - keys_first <= static_cast<difference_type>((2147483647 * 2U + 1U)))
  {
    result = reduce_by_key_detail::reduce_by_key<unsigned int>(exec,
                                                               keys_first, keys_last,
                                                               values_first,
                                                               keys_result,
                                                               values_result,
                                                               binary_pred,
                                                               binary_op);
  }
  else
  {
    result = reduce_by_key_detail::reduce_by_key<difference_type>(exec,
                                                                  keys_first, keys_last,
                                                                  values_first,
                                                                  keys_result,
                                                                  values_result,
                                                                  binary_pred,
                                                                  binary_op);
  }

  return result;
}


}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
thrust::pair<OutputIterator1,OutputIterator2>
reduce_by_key(execution_policy<DerivedPolicy> &exec,
              InputIterator1 keys_first,
              InputIterator1 keys_last,
              InputIterator2 values_first,
              OutputIterator1 keys_result,
              OutputIterator2 values_result,
              BinaryPredicate binary_pred,
              BinaryFunction binary_op)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator1, 3 == 3>::value) ) >)> thrust_static_assert_typedef_411 __attribute__((unused));

  struct workaround
  {
    static __attribute__((host)) __attribute__((device))
    thrust::pair<OutputIterator1,OutputIterator2>
    parallel_path(execution_policy<DerivedPolicy> &exec,
                  InputIterator1 keys_first,
                  InputIterator1 keys_last,
                  InputIterator2 values_first,
                  OutputIterator1 keys_result,
                  OutputIterator2 values_result,
                  BinaryPredicate binary_pred,
                  BinaryFunction binary_op)
    {
      return thrust::system::cuda::detail::reduce_by_key_detail::reduce_by_key(exec, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op);
    }

    static __attribute__((host)) __attribute__((device))
    thrust::pair<OutputIterator1,OutputIterator2>
    sequential_path(execution_policy<DerivedPolicy> &,
                    InputIterator1 keys_first,
                    InputIterator1 keys_last,
                    InputIterator2 values_first,
                    OutputIterator1 keys_result,
                    OutputIterator2 values_result,
                    BinaryPredicate binary_pred,
                    BinaryFunction binary_op)
    {
      return thrust::reduce_by_key(thrust::seq, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op);
    }
  };


  return workaround::parallel_path(exec, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op);



}


}
}
}
}
# 62 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_by_key.h" 2
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reduce_by_key.h" 2
# 29 "/usr/local/cuda-8.0/include/thrust/detail/reduce.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator>
__attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::value_type
    reduce(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, InputIterator first, InputIterator last)
{
  using thrust::system::detail::generic::reduce;
  return reduce(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename T>
__attribute__((host)) __attribute__((device))
  T reduce(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
           InputIterator first,
           InputIterator last,
           T init)
{
  using thrust::system::detail::generic::reduce;
  return reduce(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, init);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename T,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  T reduce(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
           InputIterator first,
           InputIterator last,
           T init,
           BinaryFunction binary_op)
{
  using thrust::system::detail::generic::reduce;
  return reduce(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, init, binary_op);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output)
{
  using thrust::system::detail::generic::reduce_by_key;
  return reduce_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), keys_first, keys_last, values_first, keys_output, values_output);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output,
                BinaryPredicate binary_pred)
{
  using thrust::system::detail::generic::reduce_by_key;
  return reduce_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), keys_first, keys_last, values_first, keys_output, values_output, binary_pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output,
                BinaryPredicate binary_pred,
                BinaryFunction binary_op)
{
  using thrust::system::detail::generic::reduce_by_key;
  return reduce_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), keys_first, keys_last, values_first, keys_output, values_output, binary_pred, binary_op);
}


template<typename InputIterator>
typename thrust::iterator_traits<InputIterator>::value_type
  reduce(InputIterator first,
         InputIterator last)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::reduce(select_system(system), first, last);
}


template<typename InputIterator,
         typename T>
   T reduce(InputIterator first,
            InputIterator last,
            T init)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::reduce(select_system(system), first, last, init);
}


template<typename InputIterator,
         typename T,
         typename BinaryFunction>
   T reduce(InputIterator first,
            InputIterator last,
            T init,
            BinaryFunction binary_op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::reduce(select_system(system), first, last, init, binary_op);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2>
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator1>::type System3;
  typedef typename thrust::iterator_system<OutputIterator2>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::reduce_by_key(select_system(system1,system2,system3,system4), keys_first, keys_last, values_first, keys_output, values_output);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate>
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output,
                BinaryPredicate binary_pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator1>::type System3;
  typedef typename thrust::iterator_system<OutputIterator2>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::reduce_by_key(select_system(system1,system2,system3,system4), keys_first, keys_last, values_first, keys_output, values_output, binary_pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename BinaryPredicate,
         typename BinaryFunction>
  thrust::pair<OutputIterator1,OutputIterator2>
  reduce_by_key(InputIterator1 keys_first,
                InputIterator1 keys_last,
                InputIterator2 values_first,
                OutputIterator1 keys_output,
                OutputIterator2 values_output,
                BinaryPredicate binary_pred,
                BinaryFunction binary_op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator1>::type System3;
  typedef typename thrust::iterator_system<OutputIterator2>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::reduce_by_key(select_system(system1,system2,system3,system4), keys_first, keys_last, values_first, keys_output, values_output, binary_pred, binary_op);
}


}
# 785 "/usr/local/cuda-8.0/include/thrust/reduce.h" 2
# 20 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/find.inl" 2
# 31 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/find.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename InputIterator, typename T>
__attribute__((host)) __attribute__((device))
InputIterator find(thrust::execution_policy<DerivedPolicy> &exec,
                   InputIterator first,
                   InputIterator last,
                   const T& value)
{

  return thrust::find_if(exec, first, last, thrust::detail::equal_to_value<T>(value));
}


template<typename TupleType>
struct find_if_functor
{
  __attribute__((host)) __attribute__((device))
  TupleType operator()(const TupleType& lhs, const TupleType& rhs) const
  {

    if(thrust::get<0>(lhs) && thrust::get<0>(rhs))
    {
      return TupleType(true, (thrust::min)(thrust::get<1>(lhs), thrust::get<1>(rhs)));
    }
    else if(thrust::get<0>(lhs))
    {
      return lhs;
    }
    else
    {
      return rhs;
    }
  }
};


template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
InputIterator find_if(thrust::execution_policy<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      Predicate pred)
{
  typedef typename thrust::iterator_traits<InputIterator>::difference_type difference_type;
  typedef typename thrust::tuple<bool,difference_type> result_type;


  if(first == last) return last;

  const difference_type n = thrust::distance(first, last);





  const difference_type interval_threshold = 1 << 20;
  const difference_type interval_size = (thrust::min)(interval_threshold, n);


  typedef thrust::transform_iterator<Predicate, InputIterator, bool> XfrmIterator;
  typedef thrust::tuple<XfrmIterator, thrust::counting_iterator<difference_type> > IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  IteratorTuple iter_tuple = thrust::make_tuple(XfrmIterator(first, pred),
                                                thrust::counting_iterator<difference_type>(0));

  ZipIterator begin = thrust::make_zip_iterator(iter_tuple);
  ZipIterator end = begin + n;

  for(ZipIterator interval_begin = begin; interval_begin < end; interval_begin += interval_size)
  {
    ZipIterator interval_end = interval_begin + interval_size;
    if(end < interval_end)
    {
      interval_end = end;
    }

    result_type result = thrust::reduce(exec,
                                        interval_begin, interval_end,
                                        result_type(false,interval_end - begin),
                                        find_if_functor<result_type>());


    if(thrust::get<0>(result))
    {
      return first + thrust::get<1>(result);
    }
  }


  return first + n;
}


template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
InputIterator find_if_not(thrust::execution_policy<DerivedPolicy> &exec,
                          InputIterator first,
                          InputIterator last,
                          Predicate pred)
{
  return thrust::find_if(exec, first, last, thrust::detail::not1(pred));
}


}
}
}
}
# 63 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/find.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/find.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/find.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/find.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/find.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/find.h"
       





namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
InputIterator find_if(execution_policy<DerivedPolicy> &,
                      InputIterator first,
                      InputIterator last,
                      Predicate pred)
{

  thrust::detail::wrapped_function<
    Predicate,
   
 
# 52 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/find.h"
 
# 51 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/find.h"
    bool
  > wrapped_pred(pred);

  while(first != last)
  {
    if (wrapped_pred(*first))
      return first;

    ++first;
  }


  return first;
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/find.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/find.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/find.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/find.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/find.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename T>
__attribute__((host)) __attribute__((device))
InputIterator find(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   InputIterator first,
                   InputIterator last,
                   const T& value)
{
  using thrust::system::detail::generic::find;
  return find(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
InputIterator find_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      Predicate pred)
{
  using thrust::system::detail::generic::find_if;
  return find_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
InputIterator find_if_not(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          InputIterator first,
                          InputIterator last,
                          Predicate pred)
{
  using thrust::system::detail::generic::find_if_not;
  return find_if_not(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, pred);
}


template <typename InputIterator, typename T>
InputIterator find(InputIterator first,
                   InputIterator last,
                   const T& value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::find(select_system(system), first, last, value);
}

template <typename InputIterator, typename Predicate>
InputIterator find_if(InputIterator first,
                      InputIterator last,
                      Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::find_if(select_system(system), first, last, pred);
}

template <typename InputIterator, typename Predicate>
InputIterator find_if_not(InputIterator first,
                          InputIterator last,
                          Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::find_if_not(select_system(system), first, last, pred);
}


}
# 385 "/usr/local/cuda-8.0/include/thrust/find.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/mismatch.inl" 2

namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<InputIterator1, InputIterator2>
    mismatch(thrust::execution_policy<DerivedPolicy> &exec,
             InputIterator1 first1,
             InputIterator1 last1,
             InputIterator2 first2)
{
  typedef typename thrust::iterator_value<InputIterator1>::type InputType1;


  return thrust::mismatch(exec, first1, last1, first2, thrust::detail::equal_to<InputType1>());
}


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<InputIterator1, InputIterator2>
    mismatch(thrust::execution_policy<DerivedPolicy> &exec,
             InputIterator1 first1,
             InputIterator1 last1,
             InputIterator2 first2,
             BinaryPredicate pred)
{

  typedef thrust::tuple<InputIterator1,InputIterator2> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ZipIterator zipped_first = thrust::make_zip_iterator(thrust::make_tuple(first1,first2));
  ZipIterator zipped_last = thrust::make_zip_iterator(thrust::make_tuple(last1, first2));

  ZipIterator result = thrust::find_if_not(exec, zipped_first, zipped_last, thrust::detail::tuple_binary_predicate<BinaryPredicate>(pred));

  return thrust::make_pair(thrust::get<0>(result.get_iterator_tuple()),
                           thrust::get<1>(result.get_iterator_tuple()));
}


}
}
}
}
# 58 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/mismatch.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/mismatch.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/mismatch.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/mismatch.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/mismatch.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/mismatch.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/mismatch.h" 2
# 29 "/usr/local/cuda-8.0/include/thrust/detail/mismatch.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2>
__attribute__((host)) __attribute__((device))
thrust::pair<InputIterator1, InputIterator2> mismatch(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                                      InputIterator1 first1,
                                                      InputIterator1 last1,
                                                      InputIterator2 first2)
{
  using thrust::system::detail::generic::mismatch;
  return mismatch(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
thrust::pair<InputIterator1, InputIterator2> mismatch(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                                      InputIterator1 first1,
                                                      InputIterator1 last1,
                                                      InputIterator2 first2,
                                                      BinaryPredicate pred)
{
  using thrust::system::detail::generic::mismatch;
  return mismatch(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, pred);
}


template<typename InputIterator1, typename InputIterator2>
thrust::pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,
                                                      InputIterator1 last1,
                                                      InputIterator2 first2)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;

  System1 system1;
  System2 system2;

  return thrust::mismatch(select_system(system1,system2), first1, last1, first2);
}


template<typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
thrust::pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,
                                                      InputIterator1 last1,
                                                      InputIterator2 first2,
                                                      BinaryPredicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;

  System1 system1;
  System2 system2;

  return thrust::mismatch(select_system(system1,system2), first1, last1, first2, pred);
}


}
# 260 "/usr/local/cuda-8.0/include/thrust/mismatch.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/equal.inl" 2

namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2>
__attribute__((host)) __attribute__((device))
bool equal(thrust::execution_policy<DerivedPolicy> &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  typedef typename thrust::iterator_traits<InputIterator1>::value_type InputType1;

  return thrust::equal(exec, first1, last1, first2, thrust::detail::equal_to<InputType1>());
}




 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
bool equal(thrust::execution_policy<DerivedPolicy> &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred)
{
  return thrust::mismatch(exec, first1, last1, first2, binary_pred).first == last1;
}


}
}
}
}
# 48 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/equal.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/equal.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/equal.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/equal.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/equal.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/equal.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/equal.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/equal.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename System, typename InputIterator1, typename InputIterator2>
__attribute__((host)) __attribute__((device))
bool equal(const thrust::detail::execution_policy_base<System> &system, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  using thrust::system::detail::generic::equal;
  return equal(thrust::detail::derived_cast(thrust::detail::strip_const(system)), first1, last1, first2);
}


 #pragma nv_exec_check_disable
template<typename System, typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
__attribute__((host)) __attribute__((device))
bool equal(const thrust::detail::execution_policy_base<System> &system, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred)
{
  using thrust::system::detail::generic::equal;
  return equal(thrust::detail::derived_cast(thrust::detail::strip_const(system)), first1, last1, first2, binary_pred);
}


template <typename InputIterator1, typename InputIterator2>
bool equal(InputIterator1 first1, InputIterator1 last1,
           InputIterator2 first2)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;

  System1 system1;
  System2 system2;

  return thrust::equal(select_system(system1,system2), first1, last1, first2);
}


template <typename InputIterator1, typename InputIterator2,
          typename BinaryPredicate>
bool equal(InputIterator1 first1, InputIterator1 last1,
           InputIterator2 first2, BinaryPredicate binary_pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;

  System1 system1;
  System2 system2;

  return thrust::equal(select_system(system1,system2), first1, last1, first2, binary_pred);
}


}
# 238 "/usr/local/cuda-8.0/include/thrust/equal.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.inl" 2
# 35 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.inl"
namespace thrust
{

namespace detail
{

template<typename T, typename Alloc>
  vector_base<T,Alloc>
    ::vector_base(void)
      :m_storage(),
       m_size(0)
{
  ;
}

template<typename T, typename Alloc>
  vector_base<T,Alloc>
    ::vector_base(size_type n)
      :m_storage(),
       m_size(0)
{
  default_init(n);
}

template<typename T, typename Alloc>
  vector_base<T,Alloc>
    ::vector_base(size_type n, const value_type &value)
      :m_storage(),
       m_size(0)
{
  fill_init(n,value);
}

template<typename T, typename Alloc>
  vector_base<T,Alloc>
    ::vector_base(const vector_base &v)
      :m_storage(),
       m_size(0)
{
  range_init(v.begin(), v.end());
}

template<typename T, typename Alloc>
  vector_base<T,Alloc> &
    vector_base<T,Alloc>
      ::operator=(const vector_base &v)
{
  if(this != &v)
  {
    assign(v.begin(), v.end());
  }

  return *this;
}

template<typename T, typename Alloc>
  template<typename OtherT, typename OtherAlloc>
    vector_base<T,Alloc>
      ::vector_base(const vector_base<OtherT,OtherAlloc> &v)
        :m_storage(),
         m_size(0)
{
  range_init(v.begin(), v.end());
}

template<typename T, typename Alloc>
  template<typename OtherT, typename OtherAlloc>
    vector_base<T,Alloc> &
      vector_base<T,Alloc>
        ::operator=(const vector_base<OtherT,OtherAlloc> &v)
{
  assign(v.begin(), v.end());

  return *this;
}

template<typename T, typename Alloc>
  template<typename OtherT, typename OtherAlloc>
    vector_base<T,Alloc>
      ::vector_base(const std::vector<OtherT,OtherAlloc> &v)
        :m_storage(),
         m_size(0)
{
  range_init(v.begin(), v.end());
}

template<typename T, typename Alloc>
  template<typename OtherT, typename OtherAlloc>
    vector_base<T,Alloc> &
      vector_base<T,Alloc>
        ::operator=(const std::vector<OtherT,OtherAlloc> &v)
{
  assign(v.begin(), v.end());

  return *this;
}

template<typename T, typename Alloc>
  template<typename IteratorOrIntegralType>
    void vector_base<T,Alloc>
      ::init_dispatch(IteratorOrIntegralType n,
                      IteratorOrIntegralType value,
                      true_type)
{
  fill_init(n,value);
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::default_init(size_type n)
{
  if(n > 0)
  {
    m_storage.allocate(n);
    m_size = n;

    m_storage.default_construct_n(begin(), size());
  }
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::fill_init(size_type n, const T &x)
{
  if(n > 0)
  {
    m_storage.allocate(n);
    m_size = n;

    m_storage.uninitialized_fill_n(begin(), size(), x);
  }
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    void vector_base<T,Alloc>
      ::init_dispatch(InputIterator first,
                      InputIterator last,
                      false_type)
{
  range_init(first, last);
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    void vector_base<T,Alloc>
      ::range_init(InputIterator first,
                   InputIterator last)
{
  range_init(first, last,
    typename thrust::iterator_traversal<InputIterator>::type());
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    void vector_base<T,Alloc>
      ::range_init(InputIterator first,
                   InputIterator last,
                   thrust::incrementable_traversal_tag)
{
  for(; first != last; ++first)
    push_back(*first);
}

template<typename T, typename Alloc>
  template<typename ForwardIterator>
    void vector_base<T,Alloc>
      ::range_init(ForwardIterator first,
                   ForwardIterator last,
                   thrust::random_access_traversal_tag)
{
  size_type new_size = thrust::distance(first, last);

  allocate_and_copy(new_size, first, last, m_storage);
  m_size = new_size;
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    vector_base<T,Alloc>
      ::vector_base(InputIterator first,
                    InputIterator last)
        :m_storage(),
         m_size(0)
{


  typedef thrust::detail::is_integral<InputIterator> Integer;

  init_dispatch(first, last, Integer());
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::resize(size_type new_size)
{
  if(new_size < size())
  {
    iterator new_end = begin();
    thrust::advance(new_end, new_size);
    erase(new_end, end());
  }
  else
  {
    append(new_size - size());
  }
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::resize(size_type new_size, const value_type &x)
{
  if(new_size < size())
  {
    iterator new_end = begin();
    thrust::advance(new_end, new_size);
    erase(new_end, end());
  }
  else
  {
    insert(end(), new_size - size(), x);
  }
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::size_type
    vector_base<T,Alloc>
      ::size(void) const
{
  return m_size;
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::size_type
    vector_base<T,Alloc>
      ::max_size(void) const
{
  return m_storage.max_size();
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::reserve(size_type n)
{
  if(n > capacity())
  {
    allocate_and_copy(n, begin(), end(), m_storage);
  }
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::size_type
    vector_base<T,Alloc>
      ::capacity(void) const
{
  return m_storage.size();
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::shrink_to_fit(void)
{

  vector_base(*this).swap(*this);
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::reference
    vector_base<T,Alloc>
      ::operator[](const size_type n)
{
  return m_storage[n];
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_reference
    vector_base<T,Alloc>
      ::operator[](const size_type n) const
{
  return m_storage[n];
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::iterator
    vector_base<T,Alloc>
      ::begin(void)
{
  return m_storage.begin();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_iterator
    vector_base<T,Alloc>
      ::begin(void) const
{
  return m_storage.begin();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_iterator
    vector_base<T,Alloc>
      ::cbegin(void) const
{
  return begin();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::reverse_iterator
    vector_base<T,Alloc>
      ::rbegin(void)
{
  return reverse_iterator(end());
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_reverse_iterator
    vector_base<T,Alloc>
      ::rbegin(void) const
{
  return const_reverse_iterator(end());
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_reverse_iterator
    vector_base<T,Alloc>
      ::crbegin(void) const
{
  return rbegin();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::iterator
    vector_base<T,Alloc>
      ::end(void)
{
  iterator result = begin();
  thrust::advance(result, size());
  return result;
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_iterator
    vector_base<T,Alloc>
      ::end(void) const
{
  const_iterator result = begin();
  thrust::advance(result, size());
  return result;
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_iterator
    vector_base<T,Alloc>
      ::cend(void) const
{
  return end();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::reverse_iterator
    vector_base<T,Alloc>
      ::rend(void)
{
  return reverse_iterator(begin());
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_reverse_iterator
    vector_base<T,Alloc>
      ::rend(void) const
{
  return const_reverse_iterator(begin());
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_reverse_iterator
    vector_base<T,Alloc>
      ::crend(void) const
{
  return rend();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_reference
    vector_base<T,Alloc>
      ::front(void) const
{
  return *begin();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::reference
    vector_base<T,Alloc>
      ::front(void)
{
  return *begin();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_reference
    vector_base<T,Alloc>
      ::back(void) const
{
  const_iterator ptr_to_back = end();
  --ptr_to_back;
  return *ptr_to_back;
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::reference
    vector_base<T,Alloc>
      ::back(void)
{
  iterator ptr_to_back = end();
  --ptr_to_back;
  return *ptr_to_back;
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::pointer
    vector_base<T,Alloc>
      ::data(void)
{
  return &front();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::const_pointer
    vector_base<T,Alloc>
      ::data(void) const
{
  return &front();
}

template<typename T, typename Alloc>
  vector_base<T,Alloc>
    ::~vector_base(void)
{

  m_storage.destroy(begin(),end());
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::clear(void)
{
  erase(begin(), end());
}

template<typename T, typename Alloc>
  bool vector_base<T,Alloc>
    ::empty(void) const
{
  return size() == 0;
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::push_back(const value_type &x)
{
  insert(end(), x);
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::pop_back(void)
{
  iterator e = end();
  iterator ptr_to_back = e;
  --ptr_to_back;
  m_storage.destroy(ptr_to_back, e);
  --m_size;
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::iterator vector_base<T,Alloc>
    ::erase(iterator pos)
{
  iterator end = pos;
  ++end;
  return erase(pos,end);
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::iterator vector_base<T,Alloc>
    ::erase(iterator first, iterator last)
{


  iterator i = thrust::detail::overlapped_copy(last, end(), first);


  m_storage.destroy(i, end());


  m_size -= (last - first);



  return first;
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::swap(vector_base &v)
{
  thrust::swap(m_storage, v.m_storage);
  thrust::swap(m_size, v.m_size);
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::assign(size_type n, const T &x)
{
  fill_assign(n, x);
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    void vector_base<T,Alloc>
      ::assign(InputIterator first, InputIterator last)
{


  typedef typename thrust::detail::is_integral<InputIterator> integral;

  assign_dispatch(first, last, integral());
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::allocator_type
    vector_base<T,Alloc>
      ::get_allocator(void) const
{
  return m_storage.get_allocator();
}

template<typename T, typename Alloc>
  typename vector_base<T,Alloc>::iterator
    vector_base<T,Alloc>
      ::insert(iterator position, const T &x)
{

  size_type index = thrust::distance(begin(), position);


  insert(position, 1, x);


  iterator result = begin();
  thrust::advance(result, index);
  return result;
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::insert(iterator position, size_type n, const T &x)
{
  fill_insert(position, n, x);
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    void vector_base<T,Alloc>
      ::insert(iterator position, InputIterator first, InputIterator last)
{


  typedef typename thrust::detail::is_integral<InputIterator> integral;

  insert_dispatch(position, first, last, integral());
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    void vector_base<T,Alloc>
      ::assign_dispatch(InputIterator first, InputIterator last, false_type)
{
  range_assign(first, last);
}

template<typename T, typename Alloc>
  template<typename Integral>
    void vector_base<T,Alloc>
      ::assign_dispatch(Integral n, Integral x, true_type)
{
  fill_assign(n, x);
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    void vector_base<T,Alloc>
      ::insert_dispatch(iterator position, InputIterator first, InputIterator last, false_type)
{
  copy_insert(position, first, last);
}

template<typename T, typename Alloc>
  template<typename Integral>
    void vector_base<T,Alloc>
      ::insert_dispatch(iterator position, Integral n, Integral x, true_type)
{
  fill_insert(position, n, x);
}

template<typename T, typename Alloc>
  template<typename ForwardIterator>
    void vector_base<T,Alloc>
      ::copy_insert(iterator position,
                    ForwardIterator first,
                    ForwardIterator last)
{
  if(first != last)
  {

    const size_type num_new_elements = thrust::distance(first, last);
    if(capacity() - size() >= num_new_elements)
    {


      const size_type num_displaced_elements = end() - position;
      iterator old_end = end();

      if(num_displaced_elements > num_new_elements)
      {


        m_storage.uninitialized_copy(end() - num_new_elements, end(), end());


        m_size += num_new_elements;



        const size_type copy_length = (old_end - num_new_elements) - position;
        thrust::detail::overlapped_copy(position, old_end - num_new_elements, old_end - copy_length);


        thrust::copy(first, last, position);
      }
      else
      {
        ForwardIterator mid = first;
        thrust::advance(mid, num_displaced_elements);


        m_storage.uninitialized_copy(mid, last, end());


        m_size += num_new_elements - num_displaced_elements;


        m_storage.uninitialized_copy(position, old_end, end());


        m_size += num_displaced_elements;


        thrust::copy(first, mid, position);
      }
    }
    else
    {
      const size_type old_size = size();


      size_type new_capacity = old_size + thrust::max (old_size, num_new_elements);


      new_capacity = thrust::max <size_type>(new_capacity, 2 * capacity());


      new_capacity = thrust::min <size_type>(new_capacity, max_size());

      if(new_capacity > max_size())
      {
        throw std::length_error("insert(): insertion exceeds max_size().");
      }

      storage_type new_storage(new_capacity);


      iterator new_end = new_storage.begin();

      try
      {


        new_end = m_storage.uninitialized_copy(begin(), position, new_storage.begin());


        new_end = m_storage.uninitialized_copy(first, last, new_end);



        new_end = m_storage.uninitialized_copy(position, end(), new_end);
      }
      catch(...)
      {

        m_storage.destroy(new_storage.begin(), new_end);
        new_storage.deallocate();


        throw;
      }


      m_storage.destroy(begin(), end());


      m_storage.swap(new_storage);
      m_size = old_size + num_new_elements;
    }
  }
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::append(size_type n)
{
  if(n != 0)
  {
    if(capacity() - size() >= n)
    {



      m_storage.default_construct_n(end(), n);


      m_size += n;
    }
    else
    {
      const size_type old_size = size();


      size_type new_capacity = old_size + thrust::max (old_size, n);


      new_capacity = thrust::max <size_type>(new_capacity, 2 * capacity());


      new_capacity = thrust::min <size_type>(new_capacity, max_size());


      storage_type new_storage(new_capacity);


      iterator new_end = new_storage.begin();

      try
      {

        new_end = m_storage.uninitialized_copy(begin(), end(), new_storage.begin());


        m_storage.default_construct_n(new_end, n);
        new_end += n;
      }
      catch(...)
      {

        m_storage.destroy(new_storage.begin(), new_end);
        new_storage.deallocate();


        throw;
      }


      m_storage.destroy(begin(), end());


      m_storage.swap(new_storage);
      m_size = old_size + n;
    }
  }
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::fill_insert(iterator position, size_type n, const T &x)
{
  if(n != 0)
  {
    if(capacity() - size() >= n)
    {


      const size_type num_displaced_elements = end() - position;
      iterator old_end = end();

      if(num_displaced_elements > n)
      {


        m_storage.uninitialized_copy(end() - n, end(), end());


        m_size += n;



        const size_type copy_length = (old_end - n) - position;
        thrust::detail::overlapped_copy(position, old_end - n, old_end - copy_length);


        thrust::fill_n(position, n, x);
      }
      else
      {

        m_storage.uninitialized_fill_n(end(), n - num_displaced_elements, x);


        m_size += n - num_displaced_elements;


        m_storage.uninitialized_copy(position, old_end, end());


        m_size += num_displaced_elements;


        thrust::fill(position, old_end, x);
      }
    }
    else
    {
      const size_type old_size = size();


      size_type new_capacity = old_size + thrust::max (old_size, n);


      new_capacity = thrust::max <size_type>(new_capacity, 2 * capacity());


      new_capacity = thrust::min <size_type>(new_capacity, max_size());

      if(new_capacity > max_size())
      {
        throw std::length_error("insert(): insertion exceeds max_size().");
      }

      storage_type new_storage(new_capacity);


      iterator new_end = new_storage.begin();

      try
      {


        new_end = m_storage.uninitialized_copy(begin(), position, new_storage.begin());


        m_storage.uninitialized_fill_n(new_end, n, x);
        new_end += n;



        new_end = m_storage.uninitialized_copy(position, end(), new_end);
      }
      catch(...)
      {

        m_storage.destroy(new_storage.begin(), new_end);
        new_storage.deallocate();


        throw;
      }


      m_storage.destroy(begin(), end());


      m_storage.swap(new_storage);
      m_size = old_size + n;
    }
  }
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    void vector_base<T,Alloc>
      ::range_assign(InputIterator first,
                     InputIterator last)
{

  range_assign(first, last,
    typename thrust::iterator_traversal<InputIterator>::type());
}

template<typename T, typename Alloc>
  template<typename InputIterator>
    void vector_base<T,Alloc>
      ::range_assign(InputIterator first,
                     InputIterator last,
                     thrust::incrementable_traversal_tag)
{
  iterator current(begin());


  for(; first != last && current != end(); ++current, ++first)
  {
    *current = *first;
  }



  if(first == last)
  {

    erase(current, end());
  }
  else
  {

    insert(end(), first, last);
  }
}

template<typename T, typename Alloc>
  template<typename RandomAccessIterator>
    void vector_base<T,Alloc>
      ::range_assign(RandomAccessIterator first,
                     RandomAccessIterator last,
                     thrust::random_access_traversal_tag)
{
  const size_type n = thrust::distance(first, last);

  if(n > capacity())
  {
    storage_type new_storage;
    allocate_and_copy(n, first, last, new_storage);


    m_storage.destroy(begin(), end());


    m_storage.swap(new_storage);
    m_size = n;
  }
  else if(size() >= n)
  {

    iterator new_end = thrust::copy(first, last, begin());


    m_storage.destroy(new_end, end());


    m_size = n;
  }
  else
  {







    RandomAccessIterator mid = first;
    thrust::advance(mid, size());
    thrust::copy(first, mid, begin());


    m_storage.uninitialized_copy(mid, last, end());


    m_size = n;
  }
}

template<typename T, typename Alloc>
  void vector_base<T,Alloc>
    ::fill_assign(size_type n, const T &x)
{
  if(n > capacity())
  {


    vector_base<T,Alloc> temp(n, x);
    temp.swap(*this);
  }
  else if(n > size())
  {

    thrust::fill(begin(), end(), x);


    m_storage.uninitialized_fill_n(end(), n - size(), x);


    m_size += (n - size());
  }
  else
  {

    iterator new_end = thrust::fill_n(begin(), n, x);


    erase(new_end, end());
  }
}

template<typename T, typename Alloc>
  template<typename ForwardIterator>
    void vector_base<T,Alloc>
      ::allocate_and_copy(size_type requested_size,
                          ForwardIterator first, ForwardIterator last,
                          storage_type &new_storage)
{
  if(requested_size == 0)
  {
    new_storage.deallocate();
    return;
  }


  size_type allocated_size = thrust::max<size_type>(requested_size, 2 * capacity());


  allocated_size = thrust::min<size_type>(allocated_size, max_size());

  if(requested_size > allocated_size)
  {
    throw std::length_error("assignment exceeds max_size().");
  }

  new_storage.allocate(allocated_size);

  try
  {

    m_storage.uninitialized_copy(first, last, new_storage.begin());
  }
  catch(...)
  {


    iterator new_storage_end = new_storage.begin();
    thrust::advance(new_storage_end, requested_size);
    m_storage.destroy(new_storage.begin(), new_storage_end);
    new_storage.deallocate();


    throw;
  }
}


}

template<typename T, typename Alloc>
  void swap(detail::vector_base<T,Alloc> &a,
            detail::vector_base<T,Alloc> &b)
{
  a.swap(b);
}



namespace detail
{


template <typename InputIterator1, typename InputIterator2>
bool vector_equal(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2,
                  thrust::detail::true_type)
{
  return thrust::equal(first1, last1, first2);
}


template <typename InputIterator1, typename InputIterator2>
bool vector_equal(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2,
                  thrust::detail::false_type)
{
  typename thrust::iterator_difference<InputIterator1>::type n = thrust::distance(first1,last1);

  typedef typename thrust::iterator_system<InputIterator1>::type FromSystem1;
  typedef typename thrust::iterator_system<InputIterator2>::type FromSystem2;



  FromSystem1 from_system1;
  FromSystem2 from_system2;
  thrust::host_system_tag to_system;
  thrust::detail::move_to_system<InputIterator1, FromSystem1, thrust::host_system_tag> rng1(from_system1, to_system, first1, last1);
  thrust::detail::move_to_system<InputIterator2, FromSystem2, thrust::host_system_tag> rng2(from_system2, to_system, first2, first2 + n);

  return thrust::equal(rng1.begin(), rng1.end(), rng2.begin());
}

template <typename InputIterator1, typename InputIterator2>
bool vector_equal(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2)
{
  typedef typename thrust::iterator_system<InputIterator1>::type system1;
  typedef typename thrust::iterator_system<InputIterator2>::type system2;


  return vector_equal(first1, last1, first2,
    thrust::detail::is_same<system1,system2>());
}

}




template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator==(const detail::vector_base<T1,Alloc1>& lhs,
                const detail::vector_base<T2,Alloc2>& rhs)
{
    return lhs.size() == rhs.size() && detail::vector_equal(lhs.begin(), lhs.end(), rhs.begin());
}

template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator==(const detail::vector_base<T1,Alloc1>& lhs,
                const std::vector<T2,Alloc2>& rhs)
{
    return lhs.size() == rhs.size() && detail::vector_equal(lhs.begin(), lhs.end(), rhs.begin());
}

template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator==(const std::vector<T1,Alloc1>& lhs,
                const detail::vector_base<T2,Alloc2>& rhs)
{
    return lhs.size() == rhs.size() && detail::vector_equal(lhs.begin(), lhs.end(), rhs.begin());
}

template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator!=(const detail::vector_base<T1,Alloc1>& lhs,
                const detail::vector_base<T2,Alloc2>& rhs)
{
    return !(lhs == rhs);
}

template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator!=(const detail::vector_base<T1,Alloc1>& lhs,
                const std::vector<T2,Alloc2>& rhs)
{
    return !(lhs == rhs);
}

template<typename T1, typename Alloc1,
         typename T2, typename Alloc2>
bool operator!=(const std::vector<T1,Alloc1>& lhs,
                const detail::vector_base<T2,Alloc2>& rhs)
{
    return !(lhs == rhs);
}

}
# 534 "/usr/local/cuda-8.0/include/thrust/detail/vector_base.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/host_vector.h" 2


namespace thrust
{


template<typename T, typename Alloc> class device_vector;
# 51 "/usr/local/cuda-8.0/include/thrust/host_vector.h"
template<typename T, typename Alloc = std::allocator<T> >
  class host_vector
    : public detail::vector_base<T,Alloc>
{
  private:
    typedef detail::vector_base<T,Alloc> Parent;

  public:


    typedef typename Parent::size_type size_type;
    typedef typename Parent::value_type value_type;





    __attribute__((host))
    host_vector(void)
      :Parent() {}





    __attribute__((host))
    ~host_vector(void) {}





    __attribute__((host))
    explicit host_vector(size_type n)
      :Parent(n) {}






    __attribute__((host))
    explicit host_vector(size_type n, const value_type &value)
      :Parent(n,value) {}




    __attribute__((host))
    host_vector(const host_vector &v)
      :Parent(v) {}




    __attribute__((host))
    host_vector &operator=(const host_vector &v)
    { Parent::operator=(v); return *this; }




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    host_vector(const host_vector<OtherT,OtherAlloc> &v)
      :Parent(v) {}




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    host_vector &operator=(const host_vector<OtherT,OtherAlloc> &v)
    { Parent::operator=(v); return *this; }




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    host_vector(const std::vector<OtherT,OtherAlloc> &v)
      :Parent(v) {}




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    host_vector &operator=(const std::vector<OtherT,OtherAlloc> &v)
    { Parent::operator=(v); return *this;}




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    host_vector(const device_vector<OtherT,OtherAlloc> &v);




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    host_vector &operator=(const device_vector<OtherT,OtherAlloc> &v)
    { Parent::operator=(v); return *this; }





    template<typename InputIterator>
    __attribute__((host))
    host_vector(InputIterator first, InputIterator last)
      :Parent(first, last) {}
# 425 "/usr/local/cuda-8.0/include/thrust/host_vector.h"
};




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/host_vector.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/detail/host_vector.inl"
namespace thrust
{

template<typename T, typename Alloc>
  template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    host_vector<T,Alloc>
      ::host_vector(const device_vector<OtherT,OtherAlloc> &v)
        :Parent(v)
{
  ;
}

}
# 433 "/usr/local/cuda-8.0/include/thrust/host_vector.h" 2
# 2 "./gpu_bin_shift.cu" 2
# 1 "/usr/local/cuda-8.0/include/thrust/device_vector.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/device_vector.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/device_malloc_allocator.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/device_malloc_allocator.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/device_ptr.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/device_ptr.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/memory.h" 1
# 31 "/usr/local/cuda-8.0/include/thrust/memory.h"
namespace thrust
{
# 303 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
pointer<void,DerivedPolicy> malloc(const thrust::detail::execution_policy_base<DerivedPolicy> &system, std::size_t n);
# 341 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
pointer<T,DerivedPolicy> malloc(const thrust::detail::execution_policy_base<DerivedPolicy> &system, std::size_t n);
# 394 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename T, typename DerivedPolicy>
__attribute__((host)) __attribute__((device))
thrust::pair<thrust::pointer<T,DerivedPolicy>, typename thrust::pointer<T,DerivedPolicy>::difference_type>
get_temporary_buffer(const thrust::detail::execution_policy_base<DerivedPolicy> &system, typename thrust::pointer<T,DerivedPolicy>::difference_type n);
# 437 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
void free(const thrust::detail::execution_policy_base<DerivedPolicy> &system, Pointer ptr);
# 483 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename DerivedPolicy, typename Pointer>
__attribute__((host)) __attribute__((device))
void return_temporary_buffer(const thrust::detail::execution_policy_base<DerivedPolicy> &system, Pointer p);
# 499 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename Pointer>
__attribute__((host)) __attribute__((device))
inline typename thrust::detail::pointer_traits<Pointer>::raw_pointer
  raw_pointer_cast(const Pointer &ptr);
# 516 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename T>
__attribute__((host)) __attribute__((device))
inline typename detail::raw_reference<T>::type
  raw_reference_cast(T &ref);
# 533 "/usr/local/cuda-8.0/include/thrust/memory.h"
template<typename T>
__attribute__((host)) __attribute__((device))
inline typename detail::raw_reference<const T>::type
  raw_reference_cast(const T &ref);





}
# 26 "/usr/local/cuda-8.0/include/thrust/device_ptr.h" 2

namespace thrust
{
# 37 "/usr/local/cuda-8.0/include/thrust/device_ptr.h"
template<typename T> class device_reference;
# 60 "/usr/local/cuda-8.0/include/thrust/device_ptr.h"
template<typename T>
  class device_ptr
    : public thrust::pointer<
               T,
               thrust::device_system_tag,
               thrust::device_reference<T>,
               thrust::device_ptr<T>
             >
{
  private:
    typedef thrust::pointer<
      T,
      thrust::device_system_tag,
      thrust::device_reference<T>,
      thrust::device_ptr<T>
    > super_t;

  public:


    __attribute__((host)) __attribute__((device))
    device_ptr() : super_t() {}







    template<typename OtherT>
    __attribute__((host)) __attribute__((device))
    explicit device_ptr(OtherT *ptr) : super_t(ptr) {}




    template<typename OtherT>
    __attribute__((host)) __attribute__((device))
    device_ptr(const device_ptr<OtherT> &other) : super_t(other) {}





    template<typename OtherT>
    __attribute__((host)) __attribute__((device))
    device_ptr &operator=(const device_ptr<OtherT> &other)
    {
      super_t::operator=(other);
      return *this;
    }
# 121 "/usr/local/cuda-8.0/include/thrust/device_ptr.h"
};
# 153 "/usr/local/cuda-8.0/include/thrust/device_ptr.h"
template<typename T>
__attribute__((host)) __attribute__((device))
inline device_ptr<T> device_pointer_cast(T *ptr);







template<typename T>
__attribute__((host)) __attribute__((device))
inline device_ptr<T> device_pointer_cast(const device_ptr<T> &ptr);




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/device_ptr.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/detail/device_ptr.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/device_reference.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/device_reference.h"
       






namespace thrust
{
# 185 "/usr/local/cuda-8.0/include/thrust/device_reference.h"
template<typename T>
  class device_reference
    : public thrust::reference<
               T,
               thrust::device_ptr<T>,
               thrust::device_reference<T>
             >
{
  private:
    typedef thrust::reference<
      T,
      thrust::device_ptr<T>,
      thrust::device_reference<T>
    > super_t;

  public:


    typedef typename super_t::value_type value_type;



    typedef typename super_t::pointer pointer;
# 239 "/usr/local/cuda-8.0/include/thrust/device_reference.h"
    template<typename OtherT>
    __attribute__((host)) __attribute__((device))
    device_reference(const device_reference<OtherT> &other,
                     typename thrust::detail::enable_if_convertible<
                       typename device_reference<OtherT>::pointer,
                       pointer
                     >::type * = 0)
      : super_t(other)
    {}
# 278 "/usr/local/cuda-8.0/include/thrust/device_reference.h"
    __attribute__((host)) __attribute__((device))
    explicit device_reference(const pointer &ptr)
      : super_t(ptr)
    {}
# 290 "/usr/local/cuda-8.0/include/thrust/device_reference.h"
    template<typename OtherT>
    __attribute__((host)) __attribute__((device))
    device_reference &operator=(const device_reference<OtherT> &other);







    __attribute__((host)) __attribute__((device))
    device_reference &operator=(const value_type &x);
# 953 "/usr/local/cuda-8.0/include/thrust/device_reference.h"
};





template<typename T>
__attribute__((host)) __attribute__((device))
void swap(device_reference<T> &x, device_reference<T> &y);
# 980 "/usr/local/cuda-8.0/include/thrust/device_reference.h"
}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/device_reference.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/device_reference.inl"
namespace thrust
{

template<typename T>
  template<typename OtherT>
    device_reference<T> &
      device_reference<T>
        ::operator=(const device_reference<OtherT> &other)
{
  return super_t::operator=(other);
}

template<typename T>
  device_reference<T> &
    device_reference<T>
      ::operator=(const value_type &x)
{
  return super_t::operator=(x);
}

template<typename T>
__attribute__((host)) __attribute__((device))
void swap(device_reference<T> &a, device_reference<T> &b)
{
  a.swap(b);
}

}
# 983 "/usr/local/cuda-8.0/include/thrust/device_reference.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/detail/device_ptr.inl" 2



namespace thrust
{

template<typename T>
  device_ptr<T> device_pointer_cast(T *ptr)
{
  return device_ptr<T>(ptr);
}

template<typename T>
  device_ptr<T> device_pointer_cast(const device_ptr<T> &ptr)
{
  return ptr;
}


namespace detail
{

template<typename T>
  struct is_device_ptr< thrust::device_ptr<T> >
    : public true_type
{
};
# 63 "/usr/local/cuda-8.0/include/thrust/detail/device_ptr.inl"
}
}
# 173 "/usr/local/cuda-8.0/include/thrust/device_ptr.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/device_malloc_allocator.h" 2

# 1 "/usr/local/cuda-8.0/include/thrust/device_malloc.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/device_malloc.h"
       



# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 27 "/usr/local/cuda-8.0/include/thrust/device_malloc.h" 2

namespace thrust
{
# 64 "/usr/local/cuda-8.0/include/thrust/device_malloc.h"
inline thrust::device_ptr<void> device_malloc(const std::size_t n);
# 94 "/usr/local/cuda-8.0/include/thrust/device_malloc.h"
template<typename T>
  inline thrust::device_ptr<T> device_malloc(const std::size_t n);




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/device_malloc.inl" 1
# 28 "/usr/local/cuda-8.0/include/thrust/detail/device_malloc.inl"
namespace thrust
{


thrust::device_ptr<void> device_malloc(const std::size_t n)
{
  using thrust::system::detail::generic::select_system;

  typedef thrust::iterator_system< thrust::device_ptr<void> >::type system;


  system s;

  return thrust::device_ptr<void>(thrust::malloc(s, n).get());
}


template<typename T>
  thrust::device_ptr<T> device_malloc(const std::size_t n)
{
  using thrust::system::detail::generic::select_system;

  typedef thrust::iterator_system< thrust::device_ptr<void> >::type system;


  system s;

  return thrust::device_ptr<T>(thrust::malloc<T>(s,n).get());
}


}
# 103 "/usr/local/cuda-8.0/include/thrust/device_malloc.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/device_malloc_allocator.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/device_free.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/device_free.h"
       




namespace thrust
{
# 60 "/usr/local/cuda-8.0/include/thrust/device_free.h"
inline void device_free(thrust::device_ptr<void> ptr);




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/device_free.inl" 1
# 28 "/usr/local/cuda-8.0/include/thrust/detail/device_free.inl"
namespace thrust
{

void device_free(thrust::device_ptr<void> ptr)
{
  using thrust::system::detail::generic::select_system;

  typedef thrust::iterator_system< thrust::device_ptr<void> >::type system;


  system s;

  thrust::free(s, ptr);
}

}
# 68 "/usr/local/cuda-8.0/include/thrust/device_free.h" 2
# 29 "/usr/local/cuda-8.0/include/thrust/device_malloc_allocator.h" 2



namespace thrust
{


template<typename> class device_ptr;
template<typename T> device_ptr<T> device_malloc(const std::size_t n);
# 52 "/usr/local/cuda-8.0/include/thrust/device_malloc_allocator.h"
template<typename T>
  class device_malloc_allocator
{
  public:

    typedef T value_type;


    typedef device_ptr<T> pointer;


    typedef device_ptr<const T> const_pointer;


    typedef device_reference<T> reference;


    typedef device_reference<const T> const_reference;


    typedef std::size_t size_type;


    typedef typename pointer::difference_type difference_type;






    template<typename U>
      struct rebind
    {


      typedef device_malloc_allocator<U> other;
    };


    __attribute__((host)) __attribute__((device))
    inline device_malloc_allocator() {}


    __attribute__((host)) __attribute__((device))
    inline ~device_malloc_allocator() {}


    __attribute__((host)) __attribute__((device))
    inline device_malloc_allocator(device_malloc_allocator const&) {}


    template<typename U>
    __attribute__((host)) __attribute__((device))
    inline device_malloc_allocator(device_malloc_allocator<U> const&) {}




    __attribute__((host)) __attribute__((device))
    inline pointer address(reference r) { return &r; }




    __attribute__((host)) __attribute__((device))
    inline const_pointer address(const_reference r) { return &r; }






    __attribute__((host))
    inline pointer allocate(size_type cnt,
                            const_pointer = const_pointer(static_cast<T*>(0)))
    {
      if(cnt > this->max_size())
      {
        throw std::bad_alloc();
      }

      return pointer(device_malloc<T>(cnt));
    }







    __attribute__((host))
    inline void deallocate(pointer p, size_type cnt)
    {

      (void)(cnt);

      device_free(p);
    }




    inline size_type max_size() const
    {
      return (std::numeric_limits<size_type>::max)() / sizeof(T);
    }




    __attribute__((host)) __attribute__((device))
    inline bool operator==(device_malloc_allocator const&) { return true; }




    __attribute__((host)) __attribute__((device))
    inline bool operator!=(device_malloc_allocator const &a) {return !operator==(a); }
};




}
# 26 "/usr/local/cuda-8.0/include/thrust/device_vector.h" 2



namespace thrust
{


template<typename T, typename Alloc> class host_vector;
# 51 "/usr/local/cuda-8.0/include/thrust/device_vector.h"
template<typename T, typename Alloc = thrust::device_malloc_allocator<T> >
  class device_vector
    : public detail::vector_base<T,Alloc>
{
  private:
    typedef detail::vector_base<T,Alloc> Parent;

  public:


    typedef typename Parent::size_type size_type;
    typedef typename Parent::value_type value_type;





    __attribute__((host))
    device_vector(void)
      :Parent() {}





    __attribute__((host))
    ~device_vector(void) {}





    __attribute__((host))
    explicit device_vector(size_type n)
      :Parent(n) {}






    __attribute__((host))
    explicit device_vector(size_type n, const value_type &value)
      :Parent(n,value) {}




    __attribute__((host))
    device_vector(const device_vector &v)
      :Parent(v) {}




    template<typename OtherT, typename OtherAlloc>
    __attribute__((device))
    device_vector(const device_vector<OtherT,OtherAlloc> &v)
      :Parent(v) {}




    template<typename OtherT, typename OtherAlloc>
    __attribute__((device))
    device_vector &operator=(const device_vector<OtherT,OtherAlloc> &v)
    { Parent::operator=(v); return *this; }




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    device_vector(const std::vector<OtherT,OtherAlloc> &v)
      :Parent(v) {}




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    device_vector &operator=(const std::vector<OtherT,OtherAlloc> &v)
    { Parent::operator=(v); return *this;}




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    device_vector(const host_vector<OtherT,OtherAlloc> &v);




    template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    device_vector &operator=(const host_vector<OtherT,OtherAlloc> &v)
    { Parent::operator=(v); return *this; }





    template<typename InputIterator>
    __attribute__((host))
    device_vector(InputIterator first, InputIterator last)
      :Parent(first,last) {}
# 418 "/usr/local/cuda-8.0/include/thrust/device_vector.h"
};




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/device_vector.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/detail/device_vector.inl"
namespace thrust
{

template<typename T, typename Alloc>
  template<typename OtherT, typename OtherAlloc>
    __attribute__((host))
    device_vector<T,Alloc>
      ::device_vector(const host_vector<OtherT,OtherAlloc> &v)
        :Parent(v)
{
  ;
}

}
# 426 "/usr/local/cuda-8.0/include/thrust/device_vector.h" 2
# 3 "./gpu_bin_shift.cu" 2

# 1 "/usr/local/cuda-8.0/include/thrust/sort.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/sort.h"
       




namespace thrust
{
# 77 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy, typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void sort(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
            RandomAccessIterator first,
            RandomAccessIterator last);
# 119 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename RandomAccessIterator>
  void sort(RandomAccessIterator first,
            RandomAccessIterator last);
# 167 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void sort(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
            RandomAccessIterator first,
            RandomAccessIterator last,
            StrictWeakOrdering comp);
# 215 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void sort(RandomAccessIterator first,
            RandomAccessIterator last,
            StrictWeakOrdering comp);
# 267 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy, typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void stable_sort(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   RandomAccessIterator first,
                   RandomAccessIterator last);
# 313 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename RandomAccessIterator>
  void stable_sort(RandomAccessIterator first,
                   RandomAccessIterator last);
# 365 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void stable_sort(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   RandomAccessIterator first,
                   RandomAccessIterator last,
                   StrictWeakOrdering comp);
# 417 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename RandomAccessIterator,
         typename StrictWeakOrdering>
  void stable_sort(RandomAccessIterator first,
                   RandomAccessIterator last,
                   StrictWeakOrdering comp);
# 483 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
  void sort_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first);
# 541 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  void sort_by_key(RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first);
# 604 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void sort_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first,
                   StrictWeakOrdering comp);
# 667 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
  void sort_by_key(RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first,
                   StrictWeakOrdering comp);
# 732 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
  void stable_sort_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first);
# 792 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  void stable_sort_by_key(RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first);
# 858 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void stable_sort_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first,
                          StrictWeakOrdering comp);
# 924 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
  void stable_sort_by_key(RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first,
                          StrictWeakOrdering comp);
# 999 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  bool is_sorted(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                 ForwardIterator first,
                 ForwardIterator last);
# 1055 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename ForwardIterator>
  bool is_sorted(ForwardIterator first,
                 ForwardIterator last);
# 1114 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy, typename ForwardIterator, typename Compare>
__attribute__((host)) __attribute__((device))
  bool is_sorted(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                 ForwardIterator first,
                 ForwardIterator last,
                 Compare comp);
# 1170 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename ForwardIterator, typename Compare>
  bool is_sorted(ForwardIterator first,
                 ForwardIterator last,
                 Compare comp);
# 1215 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  ForwardIterator is_sorted_until(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last);
# 1255 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename ForwardIterator>
  ForwardIterator is_sorted_until(ForwardIterator first,
                                  ForwardIterator last);
# 1303 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename DerivedPolicy, typename ForwardIterator, typename Compare>
__attribute__((host)) __attribute__((device))
  ForwardIterator is_sorted_until(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last,
                                  Compare comp);
# 1348 "/usr/local/cuda-8.0/include/thrust/sort.h"
template<typename ForwardIterator, typename Compare>
  ForwardIterator is_sorted_until(ForwardIterator first,
                                  ForwardIterator last,
                                  Compare comp);







}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/sort.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/sort.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sort.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sort.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void sort(thrust::execution_policy<DerivedPolicy> &exec,
            RandomAccessIterator first,
            RandomAccessIterator last);


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void sort(thrust::execution_policy<DerivedPolicy> &exec,
            RandomAccessIterator first,
            RandomAccessIterator last,
            StrictWeakOrdering comp);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
  void sort_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                   RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void sort_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                   RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first,
                   StrictWeakOrdering comp);


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void stable_sort(thrust::execution_policy<DerivedPolicy> &exec,
                   RandomAccessIterator first,
                   RandomAccessIterator last);



template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void stable_sort(thrust::execution_policy<DerivedPolicy> &exec,
                   RandomAccessIterator first,
                   RandomAccessIterator last,
                   StrictWeakOrdering comp);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
  void stable_sort_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                          RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first);



template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void stable_sort_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                          RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first,
                          StrictWeakOrdering comp);


template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  bool is_sorted(thrust::execution_policy<DerivedPolicy> &exec,
                 ForwardIterator first,
                 ForwardIterator last);


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Compare>
__attribute__((host)) __attribute__((device))
  bool is_sorted(thrust::execution_policy<DerivedPolicy> &exec,
                 ForwardIterator first,
                 ForwardIterator last,
                 Compare comp);


template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  ForwardIterator is_sorted_until(thrust::execution_policy<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last);


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Compare>
__attribute__((host)) __attribute__((device))
  ForwardIterator is_sorted_until(thrust::execution_policy<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last,
                                  Compare comp);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sort.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sort.inl"
       
# 31 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sort.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void sort(thrust::execution_policy<DerivedPolicy> &exec,
            RandomAccessIterator first,
            RandomAccessIterator last)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;
  thrust::sort(exec, first, last, thrust::less<value_type>());
}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void sort(thrust::execution_policy<DerivedPolicy> &exec,
            RandomAccessIterator first,
            RandomAccessIterator last,
            StrictWeakOrdering comp)
{

  thrust::stable_sort(exec, first, last, comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
  void sort_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                   RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;
  thrust::sort_by_key(exec, keys_first, keys_last, values_first, thrust::less<value_type>());
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void sort_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                   RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first,
                   StrictWeakOrdering comp)
{

  thrust::stable_sort_by_key(exec, keys_first, keys_last, values_first, comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void stable_sort(thrust::execution_policy<DerivedPolicy> &exec,
                   RandomAccessIterator first,
                   RandomAccessIterator last)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;
  thrust::stable_sort(exec, first, last, thrust::less<value_type>());
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
  void stable_sort_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                          RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first)
{
  typedef typename iterator_value<RandomAccessIterator1>::type value_type;
  thrust::stable_sort_by_key(exec, keys_first, keys_last, values_first, thrust::less<value_type>());
}


template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  bool is_sorted(thrust::execution_policy<DerivedPolicy> &exec,
                 ForwardIterator first,
                 ForwardIterator last)
{
  return thrust::is_sorted_until(exec, first, last) == last;
}


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Compare>
__attribute__((host)) __attribute__((device))
  bool is_sorted(thrust::execution_policy<DerivedPolicy> &exec,
                 ForwardIterator first,
                 ForwardIterator last,
                 Compare comp)
{
  return thrust::is_sorted_until(exec, first, last, comp) == last;
}


template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  ForwardIterator is_sorted_until(thrust::execution_policy<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last)
{
  typedef typename thrust::iterator_value<ForwardIterator>::type InputType;

  return thrust::is_sorted_until(exec, first, last, thrust::less<InputType>());
}


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Compare>
__attribute__((host)) __attribute__((device))
  ForwardIterator is_sorted_until(thrust::execution_policy<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last,
                                  Compare comp)
{
  if(thrust::distance(first,last) < 2) return last;

  typedef thrust::tuple<ForwardIterator,ForwardIterator> IteratorTuple;
  typedef thrust::zip_iterator<IteratorTuple> ZipIterator;

  ForwardIterator first_plus_one = first;
  thrust::advance(first_plus_one, 1);

  ZipIterator zipped_first = thrust::make_zip_iterator(thrust::make_tuple(first_plus_one, first));
  ZipIterator zipped_last = thrust::make_zip_iterator(thrust::make_tuple(last, first));

  return thrust::get<0>(thrust::find_if(exec, zipped_first, zipped_last, thrust::detail::tuple_binary_predicate<Compare>(comp)).get_iterator_tuple());
}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void stable_sort(thrust::execution_policy<DerivedPolicy> &,
                   RandomAccessIterator first,
                   RandomAccessIterator last,
                   StrictWeakOrdering comp)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<RandomAccessIterator, false>::value) ) >)> thrust_static_assert_typedef_192 __attribute__((unused));
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void stable_sort_by_key(thrust::execution_policy<DerivedPolicy> &,
                          RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first,
                          StrictWeakOrdering comp)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<RandomAccessIterator1, false>::value) ) >)> thrust_static_assert_typedef_208 __attribute__((unused));
}


}
}
}
}
# 154 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sort.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/sort.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/sort.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/sort.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sort.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sort.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort(sequential::execution_policy<DerivedPolicy> &exec,
                 RandomAccessIterator first,
                 RandomAccessIterator last,
                 StrictWeakOrdering comp);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                        RandomAccessIterator1 first1,
                        RandomAccessIterator1 last1,
                        RandomAccessIterator2 first2,
                        StrictWeakOrdering comp);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sort.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sort.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/reverse.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/reverse.h"
       




namespace thrust
{
# 69 "/usr/local/cuda-8.0/include/thrust/reverse.h"
template<typename DerivedPolicy, typename BidirectionalIterator>
__attribute__((host)) __attribute__((device))
  void reverse(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
               BidirectionalIterator first,
               BidirectionalIterator last);
# 103 "/usr/local/cuda-8.0/include/thrust/reverse.h"
template<typename BidirectionalIterator>
  void reverse(BidirectionalIterator first,
               BidirectionalIterator last);
# 154 "/usr/local/cuda-8.0/include/thrust/reverse.h"
template<typename DerivedPolicy, typename BidirectionalIterator, typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator reverse_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                              BidirectionalIterator first,
                              BidirectionalIterator last,
                              OutputIterator result);
# 202 "/usr/local/cuda-8.0/include/thrust/reverse.h"
template<typename BidirectionalIterator, typename OutputIterator>
  OutputIterator reverse_copy(BidirectionalIterator first,
                              BidirectionalIterator last,
                              OutputIterator result);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/reverse.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/reverse.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reverse.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reverse.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy, typename BidirectionalIterator>
__attribute__((host)) __attribute__((device))
  void reverse(thrust::execution_policy<DerivedPolicy> &exec,
               BidirectionalIterator first,
               BidirectionalIterator last);


template<typename DerivedPolicy,
         typename BidirectionalIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator reverse_copy(thrust::execution_policy<DerivedPolicy> &exec,
                              BidirectionalIterator first,
                              BidirectionalIterator last,
                              OutputIterator result);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reverse.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reverse.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename ExecutionPolicy, typename BidirectionalIterator>
__attribute__((host)) __attribute__((device))
  void reverse(thrust::execution_policy<ExecutionPolicy> &exec,
               BidirectionalIterator first,
               BidirectionalIterator last)
{
  typedef typename thrust::iterator_difference<BidirectionalIterator>::type difference_type;


  difference_type N = thrust::distance(first, last);
  BidirectionalIterator mid(first);
  thrust::advance(mid, N / 2);


  thrust::swap_ranges(exec, first, mid, thrust::make_reverse_iterator(last));
}


template<typename ExecutionPolicy,
         typename BidirectionalIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator reverse_copy(thrust::execution_policy<ExecutionPolicy> &exec,
                              BidirectionalIterator first,
                              BidirectionalIterator last,
                              OutputIterator result)
{
  return thrust::copy(exec,
                      thrust::make_reverse_iterator(last),
                      thrust::make_reverse_iterator(first),
                      result);
}


}
}
}
}
# 56 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/reverse.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/reverse.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reverse.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reverse.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/reverse.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/reverse.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/reverse.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/reverse.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename BidirectionalIterator>
__attribute__((host)) __attribute__((device))
  void reverse(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
               BidirectionalIterator first,
               BidirectionalIterator last)
{
  using thrust::system::detail::generic::reverse;
  return reverse(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename BidirectionalIterator, typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator reverse_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                              BidirectionalIterator first,
                              BidirectionalIterator last,
                              OutputIterator result)
{
  using thrust::system::detail::generic::reverse_copy;
  return reverse_copy(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result);
}


template<typename BidirectionalIterator>
  void reverse(BidirectionalIterator first,
               BidirectionalIterator last)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<BidirectionalIterator>::type System;

  System system;

  return thrust::reverse(select_system(system), first, last);
}


template<typename BidirectionalIterator,
         typename OutputIterator>
  OutputIterator reverse_copy(BidirectionalIterator first,
                              BidirectionalIterator last,
                              OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<BidirectionalIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::reverse_copy(select_system(system1,system2), first, last, result);
}


}
# 215 "/usr/local/cuda-8.0/include/thrust/reverse.h" 2
# 19 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sort.inl" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_merge_sort.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_merge_sort.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_merge_sort(sequential::execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator begin,
                       RandomAccessIterator end,
                       StrictWeakOrdering comp);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_merge_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 keys_begin,
                              RandomAccessIterator1 keys_end,
                              RandomAccessIterator2 values_begin,
                              StrictWeakOrdering comp);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_merge_sort.inl" 1
# 20 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_merge_sort.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/merge.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/merge.h"
       





namespace thrust
{
# 98 "/usr/local/cuda-8.0/include/thrust/merge.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator merge(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                       InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result);
# 163 "/usr/local/cuda-8.0/include/thrust/merge.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
  OutputIterator merge(InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result);
# 233 "/usr/local/cuda-8.0/include/thrust/merge.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename StrictWeakCompare>
__attribute__((host)) __attribute__((device))
  OutputIterator merge(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                       InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result,
                       StrictWeakCompare comp);
# 299 "/usr/local/cuda-8.0/include/thrust/merge.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename StrictWeakCompare>
  OutputIterator merge(InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result,
                       StrictWeakCompare comp);
# 396 "/usr/local/cuda-8.0/include/thrust/merge.h"
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                 InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result);
# 482 "/usr/local/cuda-8.0/include/thrust/merge.h"
template<typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2>
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result);
# 577 "/usr/local/cuda-8.0/include/thrust/merge.h"
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename Compare>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                 InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result,
                 Compare comp);
# 664 "/usr/local/cuda-8.0/include/thrust/merge.h"
template<typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare>
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result,
                 StrictWeakCompare comp);





}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/merge.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/detail/merge.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/merge.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/merge.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{



template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  OutputIterator merge(thrust::execution_policy<DerivedPolicy> &exec,
                       InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result,
                       StrictWeakOrdering comp);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator merge(thrust::execution_policy<DerivedPolicy> &exec,
                       InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result);


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename Compare>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                 InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result,
                 Compare comp);


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                 InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/merge.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/merge.inl"
       
# 28 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/merge.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  OutputIterator merge(thrust::execution_policy<DerivedPolicy> &exec,
                       InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result,
                       StrictWeakOrdering comp)
{

  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator1, false>::value) ) >)> thrust_static_assert_typedef_53 __attribute__((unused));
  return result;
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator merge(thrust::execution_policy<DerivedPolicy> &exec,
                       InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result)
{
  typedef typename thrust::iterator_value<InputIterator1>::type value_type;
  return thrust::merge(exec,first1,last1,first2,last2,result,thrust::less<value_type>());
}


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename Compare>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                 InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result,
                 Compare comp)
{
  typedef thrust::tuple<InputIterator1, InputIterator3> iterator_tuple1;
  typedef thrust::tuple<InputIterator2, InputIterator4> iterator_tuple2;
  typedef thrust::tuple<OutputIterator1, OutputIterator2> iterator_tuple3;

  typedef thrust::zip_iterator<iterator_tuple1> zip_iterator1;
  typedef thrust::zip_iterator<iterator_tuple2> zip_iterator2;
  typedef thrust::zip_iterator<iterator_tuple3> zip_iterator3;

  zip_iterator1 zipped_first1 = thrust::make_zip_iterator(thrust::make_tuple(keys_first1, values_first1));
  zip_iterator1 zipped_last1 = thrust::make_zip_iterator(thrust::make_tuple(keys_last1, values_first1));

  zip_iterator2 zipped_first2 = thrust::make_zip_iterator(thrust::make_tuple(keys_first2, values_first2));
  zip_iterator2 zipped_last2 = thrust::make_zip_iterator(thrust::make_tuple(keys_last2, values_first2));

  zip_iterator3 zipped_result = thrust::make_zip_iterator(thrust::make_tuple(keys_result, values_result));

  thrust::detail::compare_first<Compare> comp_first(comp);

  iterator_tuple3 result = thrust::merge(exec, zipped_first1, zipped_last1, zipped_first2, zipped_last2, zipped_result, comp_first).get_iterator_tuple();

  return thrust::make_pair(thrust::get<0>(result), thrust::get<1>(result));
}


template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(thrust::execution_policy<DerivedPolicy> &exec,
                 InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result)
{
  typedef typename thrust::iterator_value<InputIterator1>::type value_type;
  return thrust::merge_by_key(exec, keys_first1, keys_last1, keys_first2, keys_last2, values_first1, values_first2, keys_result, values_result, thrust::less<value_type>());
}


}
}
}
}
# 91 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/merge.h" 2
# 25 "/usr/local/cuda-8.0/include/thrust/detail/merge.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/merge.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/merge.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/merge.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/merge.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
OutputIterator merge(sequential::execution_policy<DerivedPolicy> &exec,
                     InputIterator1 first1,
                     InputIterator1 last1,
                     InputIterator2 first2,
                     InputIterator2 last2,
                     OutputIterator result,
                     StrictWeakOrdering comp);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename InputIterator4,
         typename OutputIterator1,
         typename OutputIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
thrust::pair<OutputIterator1,OutputIterator2>
  merge_by_key(sequential::execution_policy<DerivedPolicy> &exec,
               InputIterator1 keys_first1,
               InputIterator1 keys_last1,
               InputIterator2 keys_first2,
               InputIterator2 keys_last2,
               InputIterator3 values_first1,
               InputIterator4 values_first2,
               OutputIterator1 keys_result,
               OutputIterator2 values_result,
               StrictWeakOrdering comp);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/merge.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/merge.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
OutputIterator merge(sequential::execution_policy<DerivedPolicy> &exec,
                     InputIterator1 first1,
                     InputIterator1 last1,
                     InputIterator2 first2,
                     InputIterator2 last2,
                     OutputIterator result,
                     StrictWeakOrdering comp)
{

  thrust::detail::wrapped_function<
    StrictWeakOrdering,
   
 
# 52 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/merge.inl"
 
# 51 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/merge.inl"
    bool
  > wrapped_comp(comp);

  while(first1 != last1 && first2 != last2)
  {
    if(wrapped_comp(*first2, *first1))
    {
      *result = *first2;
      ++first2;
    }
    else
    {
      *result = *first1;
      ++first1;
    }

    ++result;
  }

  return thrust::copy(exec, first2, last2, thrust::copy(exec, first1, last1, result));
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename InputIterator4,
         typename OutputIterator1,
         typename OutputIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
thrust::pair<OutputIterator1,OutputIterator2>
  merge_by_key(sequential::execution_policy<DerivedPolicy> &exec,
               InputIterator1 keys_first1,
               InputIterator1 keys_last1,
               InputIterator2 keys_first2,
               InputIterator2 keys_last2,
               InputIterator3 values_first1,
               InputIterator4 values_first2,
               OutputIterator1 keys_result,
               OutputIterator2 values_result,
               StrictWeakOrdering comp)
{

  thrust::detail::wrapped_function<
    StrictWeakOrdering,
   
 
# 100 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/merge.inl"
 
# 99 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/merge.inl"
    bool
  > wrapped_comp(comp);

  while(keys_first1 != keys_last1 && keys_first2 != keys_last2)
  {
    if(!wrapped_comp(*keys_first2, *keys_first1))
    {

      *keys_result = *keys_first1;
      *values_result = *values_first1;
      ++keys_first1;
      ++values_first1;
    }
    else
    {

      *keys_result = *keys_first2;
      *values_result = *values_first2;
      ++keys_first2;
      ++values_first2;
    }

    ++keys_result;
    ++values_result;
  }

  while(keys_first1 != keys_last1)
  {
    *keys_result = *keys_first1;
    *values_result = *values_first1;
    ++keys_first1;
    ++values_first1;
    ++keys_result;
    ++values_result;
  }

  while(keys_first2 != keys_last2)
  {
    *keys_result = *keys_first2;
    *values_result = *values_first2;
    ++keys_first2;
    ++values_first2;
    ++keys_result;
    ++values_result;
  }

  return thrust::make_pair(keys_result, values_result);
}


}
}
}
}
# 80 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/merge.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/merge.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/merge.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/merge.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/merge.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/merge.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/merge.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
RandomAccessIterator3 merge(execution_policy<DerivedPolicy> &exec,
                            RandomAccessIterator1 first1,
                            RandomAccessIterator1 last1,
                            RandomAccessIterator2 first2,
                            RandomAccessIterator2 last2,
                            RandomAccessIterator3 result,
                            StrictWeakOrdering comp);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/merge.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/merge.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/tabulate.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/tabulate.h"
       




namespace thrust
{
# 75 "/usr/local/cuda-8.0/include/thrust/tabulate.h"
template<typename DerivedPolicy, typename ForwardIterator, typename UnaryOperation>
__attribute__((host)) __attribute__((device))
  void tabulate(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                UnaryOperation unary_op);
# 116 "/usr/local/cuda-8.0/include/thrust/tabulate.h"
template<typename ForwardIterator, typename UnaryOperation>
  void tabulate(ForwardIterator first,
                ForwardIterator last,
                UnaryOperation unary_op);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/tabulate.inl" 1
# 21 "/usr/local/cuda-8.0/include/thrust/detail/tabulate.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/tabulate.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/tabulate.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename UnaryOperation>
__attribute__((host)) __attribute__((device))
  void tabulate(thrust::execution_policy<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                UnaryOperation unary_op);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/tabulate.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/tabulate.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename UnaryOperation>
__attribute__((host)) __attribute__((device))
  void tabulate(thrust::execution_policy<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                UnaryOperation unary_op)
{
  typedef typename iterator_difference<ForwardIterator>::type difference_type;





  thrust::counting_iterator<difference_type, thrust::use_default, thrust::use_default, difference_type> iter(0);

  thrust::transform(exec, iter, iter + thrust::distance(first, last), first, unary_op);
}


}
}
}
}
# 49 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/tabulate.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/detail/tabulate.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/tabulate.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/tabulate.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/tabulate.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/tabulate.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/tabulate.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/detail/tabulate.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename UnaryOperation>
__attribute__((host)) __attribute__((device))
  void tabulate(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                UnaryOperation unary_op)
{
  using thrust::system::detail::generic::tabulate;
  return tabulate(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, unary_op);
}


template<typename ForwardIterator, typename UnaryOperation>
  void tabulate(ForwardIterator first,
                ForwardIterator last,
                UnaryOperation unary_op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::tabulate(select_system(system), first, last, unary_op);
}


}
# 129 "/usr/local/cuda-8.0/include/thrust/tabulate.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/merge.inl" 2




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace merge_detail
{


template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator1, typename Size,typename RandomAccessIterator2, typename RandomAccessIterator3, typename RandomAccessIterator4, typename Compare>
__attribute__((device))
RandomAccessIterator4
  staged_merge(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &exec,
               RandomAccessIterator1 first1, Size n1,
               RandomAccessIterator2 first2, Size n2,
               RandomAccessIterator3 stage,
               RandomAccessIterator4 result,
               Compare comp)
{

  bulk_::copy_n(bulk_::bound<groupsize * grainsize>(exec),
                thrust::detail::make_join_iterator(first1, n1, first2),
                n1 + n2,
                stage);


  bulk_::inplace_merge(bulk_::bound<groupsize * grainsize>(exec),
                       stage, stage + n1, stage + n1 + n2,
                       comp);



  return bulk_::copy_n(exec, stage, n1 + n2, result);
}


struct merge_kernel
{
  template<std::size_t groupsize, std::size_t grainsize, typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2, typename RandomAccessIterator3, typename RandomAccessIterator4, typename Compare>
  __attribute__((device))
  void operator()(bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> &g,
                  RandomAccessIterator1 first1, Size n1,
                  RandomAccessIterator2 first2, Size n2,
                  RandomAccessIterator3 merge_paths_first,
                  RandomAccessIterator4 result,
                  Compare comp)
  {
    typedef int size_type;

    size_type elements_per_group = g.size() * g.this_exec.grainsize();


    size_type mp0 = merge_paths_first[g.index()];
    size_type mp1 = merge_paths_first[g.index()+1];
    size_type diag = elements_per_group * g.index();

    size_type local_size1 = mp1 - mp0;
    size_type local_size2 = thrust::min<size_type>(n1 + n2, diag + elements_per_group) - mp1 - diag + mp0;

    first1 += mp0;
    first2 += diag - mp0;
    result += elements_per_group * g.index();


    typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;
# 122 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/merge.inl"
    __attribute__((shared)) bulk_::uninitialized_array<value_type, groupsize * grainsize> stage;
    staged_merge(g, first1, local_size1, first2, local_size2, stage.data(), result, comp);

  }
};


template<typename Size, typename RandomAccessIterator1,typename RandomAccessIterator2, typename Compare>
struct locate_merge_path
{
  Size partition_size;
  RandomAccessIterator1 first1, last1;
  RandomAccessIterator2 first2, last2;
  Compare comp;

  __attribute__((host)) __attribute__((device))
  locate_merge_path(Size partition_size, RandomAccessIterator1 first1, RandomAccessIterator1 last1, RandomAccessIterator2 first2, RandomAccessIterator2 last2, Compare comp)
    : partition_size(partition_size),
      first1(first1), last1(last1),
      first2(first2), last2(last2),
      comp(comp)
  {}

  template<typename Index>
  __attribute__((device))
  Size operator()(Index i)
  {
    Size n1 = last1 - first1;
    Size n2 = last2 - first2;
    Size diag = thrust::min<Size>(partition_size * i, n1 + n2);
    return bulk_::merge_path(first1, n1, first2, n2, diag, comp);
  }
};


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
  typename RandomAccessIterator3,
         typename Compare>
__attribute__((host)) __attribute__((device))
RandomAccessIterator3 merge(execution_policy<DerivedPolicy> &exec,
                            RandomAccessIterator1 first1,
                            RandomAccessIterator1 last1,
                            RandomAccessIterator2 first2,
                            RandomAccessIterator2 last2,
                            RandomAccessIterator3 result,
                            Compare comp)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;
  typedef typename thrust::iterator_difference<RandomAccessIterator1>::type difference_type;
  typedef int size_type;


  const size_type groupsize = (sizeof(value_type) == sizeof(int)) ? 256 : 256 + 32;
  const size_type grainsize = (sizeof(value_type) == sizeof(int)) ? 9 : 5;

  const size_type tile_size = groupsize * grainsize;

  difference_type n = (last1 - first1) + (last2 - first2);
  difference_type num_groups = (n + tile_size - 1) / tile_size;

  thrust::detail::temporary_array<size_type,DerivedPolicy> merge_paths(exec, num_groups + 1);

  thrust::tabulate(exec, merge_paths.begin(), merge_paths.end(), merge_detail::locate_merge_path<size_type,RandomAccessIterator1,RandomAccessIterator2,Compare>(tile_size,first1,last1,first2,last2,comp));


  size_type heap_size = tile_size * sizeof(value_type);
  bulk_::concurrent_group<bulk_::agent<grainsize>,groupsize> g(heap_size);
  bulk_::async(bulk_::par(stream(thrust::detail::derived_cast(exec)), g, num_groups), merge_detail::merge_kernel(), bulk_::root.this_exec, first1, last1 - first1, first2, last2 - first2, merge_paths.begin(), result, comp);

  return result + n;
}


}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
  typename RandomAccessIterator3,
         typename Compare>
__attribute__((host)) __attribute__((device))
RandomAccessIterator3 merge(execution_policy<DerivedPolicy> &exec,
                            RandomAccessIterator1 first1,
                            RandomAccessIterator1 last1,
                            RandomAccessIterator2 first2,
                            RandomAccessIterator2 last2,
                            RandomAccessIterator3 result,
                            Compare comp)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<RandomAccessIterator1, 3 == 3>::value) ) >)> thrust_static_assert_typedef_219 __attribute__((unused));

  struct workaround
  {
    __attribute__((host)) __attribute__((device))
    static RandomAccessIterator3 parallel_path(execution_policy<DerivedPolicy> &exec,
                                               RandomAccessIterator1 first1,
                                               RandomAccessIterator1 last1,
                                               RandomAccessIterator2 first2,
                                               RandomAccessIterator2 last2,
                                               RandomAccessIterator3 result,
                                               Compare comp)
    {
      return thrust::system::cuda::detail::merge_detail::merge(exec, first1, last1, first2, last2, result, comp);
    }

    __attribute__((host)) __attribute__((device))
    static RandomAccessIterator3 sequential_path(execution_policy<DerivedPolicy> &,
                                                 RandomAccessIterator1 first1,
                                                 RandomAccessIterator1 last1,
                                                 RandomAccessIterator2 first2,
                                                 RandomAccessIterator2 last2,
                                                 RandomAccessIterator3 result,
                                                 Compare comp)
    {
      return thrust::merge(thrust::seq, first1, last1, first2, last2, result, comp);
    }
  };


  return workaround::parallel_path(exec, first1, last1, first2, last2, result, comp);



}


}
}
}
}
# 53 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/merge.h" 2
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/merge.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/merge.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator merge(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                       InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result)
{
  using thrust::system::detail::generic::merge;
  return merge(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, last2, result);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename StrictWeakCompare>
__attribute__((host)) __attribute__((device))
  OutputIterator merge(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                       InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result,
                       StrictWeakCompare comp)
{
  using thrust::system::detail::generic::merge;
  return merge(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first1, last1, first2, last2, result, comp);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                 InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result)
{
  using thrust::system::detail::generic::merge_by_key;
  return merge_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), keys_first1, keys_last1, keys_first2, keys_last2, values_first1, values_first2, keys_result, values_result);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename Compare>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                 InputIterator1 keys_first1, InputIterator1 keys_last1,
                 InputIterator2 keys_first2, InputIterator2 keys_last2,
                 InputIterator3 values_first1, InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result,
                 Compare comp)
{
  using thrust::system::detail::generic::merge_by_key;
  return merge_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), keys_first1, keys_last1, keys_first2, keys_last2, values_first1, values_first2, keys_result, values_result, comp);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename StrictWeakOrdering>
  OutputIterator merge(InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result,
                       StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::merge(select_system(system1,system2,system3), first1, last1, first2, last2, result, comp);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator>
  OutputIterator merge(InputIterator1 first1,
                       InputIterator1 last1,
                       InputIterator2 first2,
                       InputIterator2 last2,
                       OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::merge(select_system(system1,system2,system3), first1, last1, first2, last2, result);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename InputIterator4,
         typename OutputIterator1,
         typename OutputIterator2,
         typename StrictWeakOrdering>
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(InputIterator1 keys_first1,
                 InputIterator1 keys_last1,
                 InputIterator2 keys_first2,
                 InputIterator2 keys_last2,
                 InputIterator3 values_first1,
                 InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result,
                 StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<InputIterator3>::type System3;
  typedef typename thrust::iterator_system<InputIterator4>::type System4;
  typedef typename thrust::iterator_system<OutputIterator1>::type System5;
  typedef typename thrust::iterator_system<OutputIterator2>::type System6;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;
  System5 system5;
  System6 system6;

  return thrust::merge_by_key(select_system(system1,system2,system3,system4,system5,system6), keys_first1, keys_last1, keys_first2, keys_last2, values_first1, values_first2, keys_result, values_result, comp);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename InputIterator4,
         typename OutputIterator1,
         typename OutputIterator2>
  thrust::pair<OutputIterator1,OutputIterator2>
    merge_by_key(InputIterator1 keys_first1,
                 InputIterator1 keys_last1,
                 InputIterator2 keys_first2,
                 InputIterator2 keys_last2,
                 InputIterator3 values_first1,
                 InputIterator4 values_first2,
                 OutputIterator1 keys_result,
                 OutputIterator2 values_result)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<InputIterator3>::type System3;
  typedef typename thrust::iterator_system<InputIterator4>::type System4;
  typedef typename thrust::iterator_system<OutputIterator1>::type System5;
  typedef typename thrust::iterator_system<OutputIterator2>::type System6;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;
  System5 system5;
  System6 system6;

  return thrust::merge_by_key(select_system(system1,system2,system3,system4,system5,system6), keys_first1, keys_last1, keys_first2, keys_last2, values_first1, values_first2, keys_result, values_result);
}


}
# 680 "/usr/local/cuda-8.0/include/thrust/merge.h" 2
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_merge_sort.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/insertion_sort.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/insertion_sort.h"
       





# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy_backward.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy_backward.h"
       



namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename BidirectionalIterator1,
         typename BidirectionalIterator2>
__attribute__((host)) __attribute__((device))
BidirectionalIterator2 copy_backward(BidirectionalIterator1 first,
                                     BidirectionalIterator1 last,
                                     BidirectionalIterator2 result)
{
  while (first != last)
  {
    --last;
    --result;
    *result = *last;
  }

  return result;
}


}
}
}
}
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/insertion_sort.h" 2

namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void insertion_sort(RandomAccessIterator first,
                    RandomAccessIterator last,
                    StrictWeakOrdering comp)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;

  if(first == last) return;


  thrust::detail::wrapped_function<
    StrictWeakOrdering,
   
 
# 51 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/insertion_sort.h"
 
# 50 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/insertion_sort.h"
    bool
  > wrapped_comp(comp);

  for(RandomAccessIterator i = first + 1; i != last; ++i)
  {
    value_type tmp = *i;

    if(wrapped_comp(tmp, *first))
    {

      sequential::copy_backward(first, i, i + 1);

      *first = tmp;
    }
    else
    {

      RandomAccessIterator j = i;
      RandomAccessIterator k = i - 1;

      while(wrapped_comp(tmp, *k))
      {
        *j = *k;
        j = k;
        --k;
      }

      *j = tmp;
    }
  }
}


 #pragma nv_exec_check_disable
template<typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void insertion_sort_by_key(RandomAccessIterator1 first1,
                           RandomAccessIterator1 last1,
                           RandomAccessIterator2 first2,
                           StrictWeakOrdering comp)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type1;
  typedef typename thrust::iterator_value<RandomAccessIterator2>::type value_type2;

  if(first1 == last1) return;


  thrust::detail::wrapped_function<
    StrictWeakOrdering,
   
 
# 102 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/insertion_sort.h"
 
# 101 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/insertion_sort.h"
    bool
  > wrapped_comp(comp);

  RandomAccessIterator1 i1 = first1 + 1;
  RandomAccessIterator2 i2 = first2 + 1;

  for(; i1 != last1; ++i1, ++i2)
  {
    value_type1 tmp1 = *i1;
    value_type2 tmp2 = *i2;

    if(wrapped_comp(tmp1, *first1))
    {

      sequential::copy_backward(first1, i1, i1 + 1);
      sequential::copy_backward(first2, i2, i2 + 1);

      *first1 = tmp1;
      *first2 = tmp2;
    }
    else
    {

      RandomAccessIterator1 j1 = i1;
      RandomAccessIterator1 k1 = i1 - 1;

      RandomAccessIterator2 j2 = i2;
      RandomAccessIterator2 k2 = i2 - 1;

      while(wrapped_comp(tmp1, *k1))
      {
        *j1 = *k1;
        *j2 = *k2;

        j1 = k1;
        j2 = k2;

        --k1;
        --k2;
      }

      *j1 = tmp1;
      *j2 = tmp2;
    }
  }
}


}
}
}
}
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_merge_sort.inl" 2


namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{
namespace stable_merge_sort_detail
{


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void inplace_merge(sequential::execution_policy<DerivedPolicy> &exec,
                   RandomAccessIterator first,
                   RandomAccessIterator middle,
                   RandomAccessIterator last,
                   StrictWeakOrdering comp)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;

  thrust::detail::temporary_array<value_type, DerivedPolicy> a(exec, first, middle);
  thrust::detail::temporary_array<value_type, DerivedPolicy> b(exec, middle, last);

  thrust::merge(exec, a.begin(), a.end(), b.begin(), b.end(), first, comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void inplace_merge_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                          RandomAccessIterator1 first1,
                          RandomAccessIterator1 middle1,
                          RandomAccessIterator1 last1,
                          RandomAccessIterator2 first2,
                          StrictWeakOrdering comp)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type1;
  typedef typename thrust::iterator_value<RandomAccessIterator2>::type value_type2;

  RandomAccessIterator2 middle2 = first2 + (middle1 - first1);
  RandomAccessIterator2 last2 = first2 + (last1 - first1);

  thrust::detail::temporary_array<value_type1, DerivedPolicy> lhs1(exec, first1, middle1);
  thrust::detail::temporary_array<value_type1, DerivedPolicy> rhs1(exec, middle1, last1);
  thrust::detail::temporary_array<value_type2, DerivedPolicy> lhs2(exec, first2, middle2);
  thrust::detail::temporary_array<value_type2, DerivedPolicy> rhs2(exec, middle2, last2);

  thrust::merge_by_key(exec,
                       lhs1.begin(), lhs1.end(),
                       rhs1.begin(), rhs1.end(),
                       lhs2.begin(), rhs2.begin(),
                       first1, first2,
                       comp);
}


template<typename RandomAccessIterator,
         typename Size,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void insertion_sort_each(RandomAccessIterator first,
                         RandomAccessIterator last,
                         Size partition_size,
                         StrictWeakOrdering comp)
{
  if(partition_size > 1)
  {
    for(; first < last; first += partition_size)
    {
      RandomAccessIterator partition_last = thrust::min(last, first + partition_size);

      thrust::system::detail::sequential::insertion_sort(first, partition_last, comp);
    }
  }
}


template<typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Size,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void insertion_sort_each_by_key(RandomAccessIterator1 keys_first,
                                RandomAccessIterator1 keys_last,
                                RandomAccessIterator2 values_first,
                                Size partition_size,
                                StrictWeakOrdering comp)
{
  if(partition_size > 1)
  {
    for(; keys_first < keys_last; keys_first += partition_size, values_first += partition_size)
    {
      RandomAccessIterator1 keys_partition_last = thrust::min(keys_last, keys_first + partition_size);

      thrust::system::detail::sequential::insertion_sort_by_key(keys_first, keys_partition_last, values_first, comp);
    }
  }
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void merge_adjacent_partitions(sequential::execution_policy<DerivedPolicy> &exec,
                               RandomAccessIterator1 first,
                               RandomAccessIterator1 last,
                               Size partition_size,
                               RandomAccessIterator2 result,
                               StrictWeakOrdering comp)
{
  for(; first < last; first += 2 * partition_size, result += 2 * partition_size)
  {
    RandomAccessIterator1 interval_middle = thrust::min(last, first + partition_size);
    RandomAccessIterator1 interval_last = thrust::min(last, interval_middle + partition_size);

    thrust::merge(exec,
                  first, interval_middle,
                  interval_middle, interval_last,
                  result,
                  comp);
  }
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Size,
         typename RandomAccessIterator3,
         typename RandomAccessIterator4,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void merge_adjacent_partitions_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                                      RandomAccessIterator1 keys_first,
                                      RandomAccessIterator1 keys_last,
                                      RandomAccessIterator2 values_first,
                                      Size partition_size,
                                      RandomAccessIterator3 keys_result,
                                      RandomAccessIterator4 values_result,
                                      StrictWeakOrdering comp)
{
  Size stride = 2 * partition_size;

  for(;
      keys_first < keys_last;
      keys_first += stride, values_first += stride, keys_result += stride, values_result += stride)
  {
    RandomAccessIterator1 keys_interval_middle = thrust::min(keys_last, keys_first + partition_size);
    RandomAccessIterator1 keys_interval_last = thrust::min(keys_last, keys_interval_middle + partition_size);

    RandomAccessIterator2 values_first2 = values_first + (keys_interval_middle - keys_first);

    thrust::merge_by_key(exec,
                         keys_first, keys_interval_middle,
                         keys_interval_middle, keys_interval_last,
                         values_first,
                         values_first2,
                         keys_result,
                         values_result,
                         comp);
  }
}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void iterative_stable_merge_sort(sequential::execution_policy<DerivedPolicy> &exec,
                                 RandomAccessIterator first,
                                 RandomAccessIterator last,
                                 StrictWeakOrdering comp)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;
  typedef typename thrust::iterator_difference<RandomAccessIterator>::type difference_type;

  difference_type n = last - first;

  thrust::detail::temporary_array<value_type, DerivedPolicy> temp(exec, n);


  difference_type partition_size = 32;
  insertion_sort_each(first, last, partition_size, comp);


  bool ping = true;


  for(;
      partition_size < n;
      partition_size *= 2, ping = !ping)
  {
    if(ping)
    {
      merge_adjacent_partitions(exec, first, last, partition_size, temp.begin(), comp);
    }
    else
    {
      merge_adjacent_partitions(exec, temp.begin(), temp.end(), partition_size, first, comp);
    }
  }

  if(!ping)
  {
    thrust::copy(exec, temp.begin(), temp.end(), first);
  }
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void iterative_stable_merge_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                                        RandomAccessIterator1 keys_first,
                                        RandomAccessIterator1 keys_last,
                                        RandomAccessIterator2 values_first,
                                        StrictWeakOrdering comp)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type1;
  typedef typename thrust::iterator_value<RandomAccessIterator2>::type value_type2;
  typedef typename thrust::iterator_difference<RandomAccessIterator1>::type difference_type;

  difference_type n = keys_last - keys_first;

  thrust::detail::temporary_array<value_type1, DerivedPolicy> keys_temp(exec, n);
  thrust::detail::temporary_array<value_type2, DerivedPolicy> values_temp(exec, n);


  difference_type partition_size = 32;
  insertion_sort_each_by_key(keys_first, keys_last, values_first, partition_size, comp);


  bool ping = true;


  for(;
      partition_size < n;
      partition_size *= 2, ping = !ping)
  {
    if(ping)
    {
      merge_adjacent_partitions_by_key(exec, keys_first, keys_last, values_first, partition_size, keys_temp.begin(), values_temp.begin(), comp);
    }
    else
    {
      merge_adjacent_partitions_by_key(exec, keys_temp.begin(), keys_temp.end(), values_temp.begin(), partition_size, keys_first, values_first, comp);
    }
  }

  if(!ping)
  {
    thrust::copy(exec, keys_temp.begin(), keys_temp.end(), keys_first);
    thrust::copy(exec, values_temp.begin(), values_temp.end(), values_first);
  }
}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void recursive_stable_merge_sort(sequential::execution_policy<DerivedPolicy> &exec,
                                 RandomAccessIterator first,
                                 RandomAccessIterator last,
                                 StrictWeakOrdering comp)
{
  if(last - first <= 32)
  {
    thrust::system::detail::sequential::insertion_sort(first, last, comp);
  }
  else
  {
    RandomAccessIterator middle = first + (last - first) / 2;

    stable_merge_sort_detail::recursive_stable_merge_sort(exec, first, middle, comp);
    stable_merge_sort_detail::recursive_stable_merge_sort(exec, middle, last, comp);
    stable_merge_sort_detail::inplace_merge(exec, first, middle, last, comp);
  }
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void recursive_stable_merge_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                                        RandomAccessIterator1 first1,
                                        RandomAccessIterator1 last1,
                                        RandomAccessIterator2 first2,
                                        StrictWeakOrdering comp)
{
  if(last1 - first1 <= 32)
  {
    thrust::system::detail::sequential::insertion_sort_by_key(first1, last1, first2, comp);
  }
  else
  {
    RandomAccessIterator1 middle1 = first1 + (last1 - first1) / 2;
    RandomAccessIterator2 middle2 = first2 + (last1 - first1) / 2;

    stable_merge_sort_detail::recursive_stable_merge_sort_by_key(exec, first1, middle1, first2, comp);
    stable_merge_sort_detail::recursive_stable_merge_sort_by_key(exec, middle1, last1, middle2, comp);
    stable_merge_sort_detail::inplace_merge_by_key(exec, first1, middle1, last1, first2, comp);
  }
}


}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_merge_sort(sequential::execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator first,
                       RandomAccessIterator last,
                       StrictWeakOrdering comp)
{




  stable_merge_sort_detail::recursive_stable_merge_sort(exec, first, last, comp);

}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_merge_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 first1,
                              RandomAccessIterator1 last1,
                              RandomAccessIterator2 first2,
                              StrictWeakOrdering comp)
{




  stable_merge_sort_detail::recursive_stable_merge_sort_by_key(exec, first1, last1, first2, comp);

}


}
}
}
}
# 60 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_merge_sort.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sort.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_primitive_sort.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_primitive_sort.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort(sequential::execution_policy<DerivedPolicy> &exec,
                           RandomAccessIterator first,
                           RandomAccessIterator last);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                                  RandomAccessIterator1 keys_first,
                                  RandomAccessIterator1 keys_last,
                                  RandomAccessIterator2 values_first);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_primitive_sort.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_primitive_sort.inl"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_radix_sort.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_radix_sort.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_radix_sort(sequential::execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator begin,
                       RandomAccessIterator end);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_radix_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 keys_begin,
                              RandomAccessIterator1 keys_end,
                              RandomAccessIterator2 values_begin);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_radix_sort.inl" 1
# 20 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_radix_sort.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/copy.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/copy.h"
       




namespace thrust
{
# 83 "/usr/local/cuda-8.0/include/thrust/copy.h"
template<typename DerivedPolicy, typename InputIterator, typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      OutputIterator result);
# 136 "/usr/local/cuda-8.0/include/thrust/copy.h"
template<typename DerivedPolicy, typename InputIterator, typename Size, typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_n(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                        InputIterator first,
                        Size n,
                        OutputIterator result);
# 185 "/usr/local/cuda-8.0/include/thrust/copy.h"
template<typename InputIterator, typename OutputIterator>
  OutputIterator copy(InputIterator first,
                      InputIterator last,
                      OutputIterator result);
# 230 "/usr/local/cuda-8.0/include/thrust/copy.h"
template<typename InputIterator, typename Size, typename OutputIterator>
  OutputIterator copy_n(InputIterator first,
                        Size n,
                        OutputIterator result);
# 299 "/usr/local/cuda-8.0/include/thrust/copy.h"
template<typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         InputIterator first,
                         InputIterator last,
                         OutputIterator result,
                         Predicate pred);
# 360 "/usr/local/cuda-8.0/include/thrust/copy.h"
template<typename InputIterator,
         typename OutputIterator,
         typename Predicate>
  OutputIterator copy_if(InputIterator first,
                         InputIterator last,
                         OutputIterator result,
                         Predicate pred);
# 430 "/usr/local/cuda-8.0/include/thrust/copy.h"
template<typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         InputIterator1 first,
                         InputIterator1 last,
                         InputIterator2 stencil,
                         OutputIterator result,
                         Predicate pred);
# 496 "/usr/local/cuda-8.0/include/thrust/copy.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
  OutputIterator copy_if(InputIterator1 first,
                         InputIterator1 last,
                         InputIterator2 stencil,
                         OutputIterator result,
                         Predicate pred);




}


# 1 "/usr/local/cuda-8.0/include/thrust/detail/copy_if.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/copy_if.h"
       




namespace thrust
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         InputIterator first,
                         InputIterator last,
                         OutputIterator result,
                         Predicate pred);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         InputIterator1 first,
                         InputIterator1 last,
                         InputIterator2 stencil,
                         OutputIterator result,
                         Predicate pred);


template<typename InputIterator,
         typename OutputIterator,
         typename Predicate>
  OutputIterator copy_if(InputIterator first,
                         InputIterator last,
                         OutputIterator result,
                         Predicate pred);


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
  OutputIterator copy_if(InputIterator1 first,
                         InputIterator1 last,
                         InputIterator2 stencil,
                         OutputIterator result,
                         Predicate pred);


}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/copy_if.inl" 1
# 20 "/usr/local/cuda-8.0/include/thrust/detail/copy_if.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy_if.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy_if.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                         InputIterator first,
                         InputIterator last,
                         OutputIterator result,
                         Predicate pred);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
   OutputIterator copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                          InputIterator1 first,
                          InputIterator1 last,
                          InputIterator2 stencil,
                          OutputIterator result,
                          Predicate pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy_if.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy_if.inl"
       
# 35 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy_if.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace detail
{


template<typename IndexType,
         typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
OutputIterator copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                       InputIterator1 first,
                       InputIterator1 last,
                       InputIterator2 stencil,
                       OutputIterator result,
                       Predicate pred)
{
  IndexType n = thrust::distance(first, last);;


  thrust::detail::temporary_array<IndexType, DerivedPolicy> predicates(exec, n);
  thrust::transform(exec,
                    stencil,
                    stencil + n,
                    predicates.begin(),
                    thrust::detail::predicate_to_integral<Predicate,IndexType>(pred));


  thrust::detail::temporary_array<IndexType, DerivedPolicy> scatter_indices(exec, n);
  thrust::exclusive_scan(exec,
                         predicates.begin(),
                         predicates.end(),
                         scatter_indices.begin(),
                         static_cast<IndexType>(0),
                         thrust::plus<IndexType>());


  thrust::scatter_if(exec,
                     first,
                     last,
                     scatter_indices.begin(),
                     predicates.begin(),
                     result,
                     thrust::identity<IndexType>());


  IndexType output_size = scatter_indices[n - 1] + predicates[n - 1];

  return result + output_size;
}


}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                         InputIterator first,
                         InputIterator last,
                         OutputIterator result,
                         Predicate pred)
{




  return thrust::copy_if(exec, first, last, first, result, pred);
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
   OutputIterator copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                          InputIterator1 first,
                          InputIterator1 last,
                          InputIterator2 stencil,
                          OutputIterator result,
                          Predicate pred)
{
  typedef typename thrust::iterator_traits<InputIterator1>::difference_type difference_type;


  if(first == last)
    return result;

  difference_type n = thrust::distance(first, last);



  typename thrust::detail::make_unsigned<difference_type>::type unsigned_n(n);


  if(sizeof(difference_type) > sizeof(unsigned int) && unsigned_n > thrust::detail::integer_traits<unsigned int>::const_max)
  {
    result = detail::copy_if<difference_type>(exec, first, last, stencil, result, pred);
  }
  else
  {
    result = detail::copy_if<unsigned int>(exec, first, last, stencil, result, pred);
  }

  return result;
}


}
}
}
}
# 64 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/copy_if.h" 2
# 21 "/usr/local/cuda-8.0/include/thrust/detail/copy_if.inl" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy_if.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy_if.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy_if.h" 1
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/copy_if.h"
       





namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_if(sequential::execution_policy<DerivedPolicy> &,
                         InputIterator1 first,
                         InputIterator1 last,
                         InputIterator2 stencil,
                         OutputIterator result,
                         Predicate pred)
{
  thrust::detail::wrapped_function<Predicate,bool> wrapped_pred(pred);

  while(first != last)
  {
    if(wrapped_pred(*stencil))
    {
      *result = *first;
      ++result;
    }

    ++first;
    ++stencil;
  }

  return result;
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy_if.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/copy_if.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/copy_if.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy_if.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_if.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_if.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
OutputIterator copy_if(execution_policy<DerivedPolicy> &exec,
                       InputIterator1 first,
                       InputIterator1 last,
                       InputIterator2 stencil,
                       OutputIterator result,
                       Predicate pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_if.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_if.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/internal/decompose.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/internal/decompose.h"
       



namespace thrust
{
namespace system
{
namespace detail
{
namespace internal
{

  template <typename IndexType>
    class index_range
    {
      public:
        typedef IndexType index_type;

        __attribute__((host)) __attribute__((device))
          index_range(index_type begin, index_type end) : m_begin(begin), m_end(end) {}

        __attribute__((host)) __attribute__((device))
          index_type begin(void) const { return m_begin; }

        __attribute__((host)) __attribute__((device))
          index_type end(void) const { return m_end; }

        __attribute__((host)) __attribute__((device))
          index_type size(void) const { return m_end - m_begin; }

      private:
        index_type m_begin;
        index_type m_end;
    };

  template <typename IndexType>
    class uniform_decomposition
    {
      public:
        typedef IndexType index_type;
        typedef index_range<index_type> range_type;

        __attribute__((host)) __attribute__((device))
        uniform_decomposition(index_type N, index_type granularity, index_type max_intervals)
          : m_N(N),
     m_intervals((N + granularity - 1) / granularity),
     m_threshold(0),
     m_small_interval(granularity),
     m_large_interval(0)
        {
   if(m_intervals > max_intervals)
          {
     m_small_interval = granularity * (m_intervals / max_intervals);
     m_large_interval = m_small_interval + granularity;
     m_threshold = m_intervals % max_intervals;
     m_intervals = max_intervals;
   }
        }

        __attribute__((host)) __attribute__((device))
          index_range<index_type> operator[](const index_type& i) const
          {
            if (i < m_threshold)
            {
              index_type begin = m_large_interval * i;
              index_type end = begin + m_large_interval;
              return range_type(begin, end);
            }
            else
            {
              index_type begin = m_large_interval * m_threshold + m_small_interval * (i - m_threshold);
              index_type end = (begin + m_small_interval < m_N) ? begin + m_small_interval : m_N;
              return range_type(begin, end);
            }
          }

        __attribute__((host)) __attribute__((device))
          index_type size(void) const
          {
            return m_intervals;
          }

      private:

        index_type m_N;
        index_type m_intervals;
        index_type m_threshold;
        index_type m_small_interval;
        index_type m_large_interval;
    };


}
}
}
}
# 27 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_if.inl" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/default_decomposition.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/default_decomposition.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename IndexType>
__attribute__((host)) __attribute__((device))
thrust::system::detail::internal::uniform_decomposition<IndexType> default_decomposition(IndexType n);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/default_decomposition.inl" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/default_decomposition.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/runtime_introspection.h" 1
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/runtime_introspection.h"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cuda_launch_config.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cuda_launch_config.h"
       

# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cuda_launch_config.h" 2


namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{




struct device_properties_t
{


  int major;
  int maxGridSize[3];
  int maxThreadsPerBlock;
  int maxThreadsPerMultiProcessor;
  int minor;
  int multiProcessorCount;
  int regsPerBlock;
  size_t sharedMemPerBlock;
  int warpSize;
};




struct function_attributes_t
{


  size_t constSizeBytes;
  size_t localSizeBytes;
  int maxThreadsPerBlock;
  int numRegs;
  int ptxVersion;
  size_t sharedSizeBytes;
};
# 73 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cuda_launch_config.h"
inline __attribute__((host)) __attribute__((device))
std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes,
                                                        const device_properties_t &properties);
# 88 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cuda_launch_config.h"
template<typename UnaryFunction>
inline __attribute__((host)) __attribute__((device))
std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes,
                                                        const device_properties_t &properties,
                                                        UnaryFunction block_size_to_dynamic_smem_size);
# 102 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cuda_launch_config.h"
inline __attribute__((host)) __attribute__((device))
size_t proportional_smem_allocation(const device_properties_t &properties,
                                    const function_attributes_t &attributes,
                                    size_t blocks_per_processor);


template<typename UnaryFunction>
inline __attribute__((host)) __attribute__((device))
size_t max_blocksize_subject_to_smem_usage(const device_properties_t &properties,
                                           const function_attributes_t &attributes,
                                           UnaryFunction blocksize_to_dynamic_smem_usage);



namespace cuda_launch_config_detail
{

using std::size_t;

namespace util
{


template<typename T>
inline __attribute__((host)) __attribute__((device))
T min_(const T &lhs, const T &rhs)
{
  return rhs < lhs ? rhs : lhs;
}


template <typename T>
struct zero_function
{
  inline __attribute__((host)) __attribute__((device))
  T operator()(T)
  {
    return 0;
  }
};



template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L divide_ri(const L x, const R y)
{
    return (x + (y - 1)) / y;
}


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L divide_rz(const L x, const R y)
{
    return x / y;
}


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L round_i(const L x, const R y){ return y * divide_ri(x, y); }


template<typename L, typename R>
  inline __attribute__((host)) __attribute__((device)) L round_z(const L x, const R y){ return y * divide_rz(x, y); }

}




inline __attribute__((host)) __attribute__((device))
size_t smem_allocation_unit(const device_properties_t &properties)
{
  switch(properties.major)
  {
    case 1: return 512;
    case 2: return 128;
    case 3: return 256;
    default: return 256;
  }
}



inline __attribute__((host)) __attribute__((device))
int reg_allocation_unit(const device_properties_t &properties, const size_t regsPerThread)
{
  switch(properties.major)
  {
    case 1: return (properties.minor <= 1) ? 256 : 512;
    case 2: switch(regsPerThread)
             {
               case 21:
               case 22:
               case 29:
               case 30:
               case 37:
               case 38:
               case 45:
               case 46:
                 return 128;
               default:
                 return 64;
             }
    case 3: return 256;
    default: return 256;
  }
}



inline __attribute__((host)) __attribute__((device))
size_t warp_allocation_multiple(const device_properties_t &properties)
{
  return (properties.major <= 1) ? 2 : 1;
}


inline __attribute__((host)) __attribute__((device))
size_t num_sides_per_multiprocessor(const device_properties_t &properties)
{
  switch(properties.major)
  {
    case 1: return 1;
    case 2: return 2;
    case 3: return 4;
    default: return 4;
  }
}


inline __attribute__((host)) __attribute__((device))
size_t max_blocks_per_multiprocessor(const device_properties_t &properties)
{
  return (properties.major <= 2) ? 8 : 16;
}


inline __attribute__((host)) __attribute__((device))
size_t max_active_blocks_per_multiprocessor(const device_properties_t &properties,
                                            const function_attributes_t &attributes,
                                            size_t CTA_SIZE,
                                            size_t dynamic_smem_bytes)
{






  const size_t maxThreadsPerSM = properties.maxThreadsPerMultiProcessor;
  const size_t maxBlocksPerSM = max_blocks_per_multiprocessor(properties);


  const size_t ctaLimitThreads = (CTA_SIZE <= size_t(properties.maxThreadsPerBlock)) ? maxThreadsPerSM / CTA_SIZE : 0;
  const size_t ctaLimitBlocks = maxBlocksPerSM;




  const size_t smemAllocationUnit = smem_allocation_unit(properties);
  const size_t smemBytes = attributes.sharedSizeBytes + dynamic_smem_bytes;
  const size_t smemPerCTA = util::round_i(smemBytes, smemAllocationUnit);


  const size_t ctaLimitSMem = smemPerCTA > 0 ? properties.sharedMemPerBlock / smemPerCTA : maxBlocksPerSM;




  const int regAllocationUnit = reg_allocation_unit(properties, attributes.numRegs);
  const size_t warpAllocationMultiple = warp_allocation_multiple(properties);
  const size_t numWarps = util::round_i(util::divide_ri(CTA_SIZE, properties.warpSize), warpAllocationMultiple);


  size_t ctaLimitRegs;
  if(properties.major <= 1)
  {


    const size_t regsPerCTA = util::round_i(attributes.numRegs * properties.warpSize * numWarps, regAllocationUnit);
    ctaLimitRegs = regsPerCTA > 0 ? properties.regsPerBlock / regsPerCTA : maxBlocksPerSM;
  }
  else
  {


    const size_t regsPerWarp = util::round_i(attributes.numRegs * properties.warpSize, regAllocationUnit);
    const size_t numSides = num_sides_per_multiprocessor(properties);
    const size_t numRegsPerSide = properties.regsPerBlock / numSides;
    ctaLimitRegs = regsPerWarp > 0 ? ((numRegsPerSide / regsPerWarp) * numSides) / numWarps : maxBlocksPerSM;
  }




  return util::min_(ctaLimitRegs, util::min_(ctaLimitSMem, util::min_(ctaLimitThreads, ctaLimitBlocks)));
}


}


template<typename UnaryFunction>
inline __attribute__((host)) __attribute__((device))
std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes,
                                                        const device_properties_t &properties,
                                                        UnaryFunction block_size_to_dynamic_smem_size)
{
  size_t max_occupancy = properties.maxThreadsPerMultiProcessor;
  size_t largest_blocksize = cuda_launch_config_detail::util::min_(properties.maxThreadsPerBlock, attributes.maxThreadsPerBlock);
  size_t granularity = properties.warpSize;
  size_t max_blocksize = 0;
  size_t highest_occupancy = 0;

  for(size_t blocksize = largest_blocksize; blocksize != 0; blocksize -= granularity)
  {
    size_t occupancy = blocksize * cuda_launch_config_detail::max_active_blocks_per_multiprocessor(properties, attributes, blocksize, block_size_to_dynamic_smem_size(blocksize));

    if(occupancy > highest_occupancy)
    {
      max_blocksize = blocksize;
      highest_occupancy = occupancy;
    }


    if(highest_occupancy == max_occupancy)
      break;
  }

  return max_blocksize;
}


inline __attribute__((host)) __attribute__((device))
std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes,
                                                        const device_properties_t &properties)
{
  return block_size_with_maximum_potential_occupancy(attributes, properties, cuda_launch_config_detail::util::zero_function<std::size_t>());
}


inline __attribute__((host)) __attribute__((device))
size_t proportional_smem_allocation(const device_properties_t &properties,
                                    const function_attributes_t &attributes,
                                    size_t blocks_per_processor)
{
  size_t smem_per_processor = properties.sharedMemPerBlock;
  size_t smem_allocation_unit = cuda_launch_config_detail::smem_allocation_unit(properties);

  size_t total_smem_per_block = cuda_launch_config_detail::util::round_z(smem_per_processor / blocks_per_processor, smem_allocation_unit);
  size_t static_smem_per_block = attributes.sharedSizeBytes;

  return total_smem_per_block - static_smem_per_block;
}


template<typename UnaryFunction>
inline __attribute__((host)) __attribute__((device))
size_t max_blocksize_subject_to_smem_usage(const device_properties_t &properties,
                                           const function_attributes_t &attributes,
                                           UnaryFunction blocksize_to_dynamic_smem_usage)
{
  size_t largest_blocksize = (thrust::min)(properties.maxThreadsPerBlock, attributes.maxThreadsPerBlock);
  size_t granularity = properties.warpSize;

  for(int blocksize = largest_blocksize; blocksize > 0; blocksize -= granularity)
  {
    size_t total_smem_usage = blocksize_to_dynamic_smem_usage(blocksize) + attributes.sharedSizeBytes;

    if(total_smem_usage <= properties.sharedMemPerBlock)
    {
      return blocksize;
    }
  }

  return 0;
}


}
}
}
}
# 30 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/runtime_introspection.h" 2


# 1 "/usr/include/c++/4.8.2/cstddef" 1 3
# 39 "/usr/include/c++/4.8.2/cstddef" 3
       
# 40 "/usr/include/c++/4.8.2/cstddef" 3


# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8.2/cstddef" 2 3
# 33 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/runtime_introspection.h" 2

namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{




inline __attribute__((host)) __attribute__((device))
int current_device();





inline __attribute__((host)) __attribute__((device))
device_properties_t device_properties(int device_id);





inline __attribute__((host)) __attribute__((device))
device_properties_t device_properties();





template<typename KernelFunction>
inline __attribute__((host)) __attribute__((device))
function_attributes_t function_attributes(KernelFunction kernel);






inline __attribute__((host)) __attribute__((device))
size_t compute_capability(const device_properties_t &properties);






inline __attribute__((host)) __attribute__((device))
size_t compute_capability();


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/runtime_introspection.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/runtime_introspection.inl"
# 1 "/usr/include/c++/4.8.2/cstdio" 1 3
# 39 "/usr/include/c++/4.8.2/cstdio" 3
       
# 40 "/usr/include/c++/4.8.2/cstdio" 3
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/runtime_introspection.inl" 2


namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace runtime_introspection_detail
{


__attribute__((host)) __attribute__((device))
inline void uncached_device_properties(device_properties_t &p, int device_id)
{

  cudaDeviceProp properties;

  cudaError_t error = cudaGetDeviceProperties(&properties, device_id);

  throw_on_error(error, "cudaGetDeviceProperties in get_device_properties");


  device_properties_t temp = {
    properties.major,
    {
      properties.maxGridSize[0],
      properties.maxGridSize[1],
      properties.maxGridSize[2]
    },
    properties.maxThreadsPerBlock,
    properties.maxThreadsPerMultiProcessor,
    properties.minor,
    properties.multiProcessorCount,
    properties.regsPerBlock,
    properties.sharedMemPerBlock,
    properties.warpSize
  };

  p = temp;
# 85 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/runtime_introspection.inl"
}


inline void cached_device_properties(device_properties_t &p, int device_id)
{


  static const int max_num_devices = 16;

  static bool properties_exist[max_num_devices] = {0};
  static device_properties_t device_properties[max_num_devices] = {};

  if(device_id >= max_num_devices)
  {
    uncached_device_properties(p, device_id);
  }

  if(!properties_exist[device_id])
  {
    uncached_device_properties(device_properties[device_id], device_id);



    __sync_synchronize();

    properties_exist[device_id] = true;
  }

  p = device_properties[device_id];
}


}


inline __attribute__((host)) __attribute__((device))
device_properties_t device_properties(int device_id)
{
  device_properties_t result;

  runtime_introspection_detail::cached_device_properties(result, device_id);



  return result;
}


inline __attribute__((host)) __attribute__((device))
int current_device()
{
  int result = -1;


  cudaError_t error = cudaGetDevice(&result);

  throw_on_error(error, "cudaGetDevice in current_device");

  if(result < 0)
  {
    throw_on_error(cudaErrorNoDevice, "cudaGetDevice in current_device");
  }




  return result;
}


inline __attribute__((host)) __attribute__((device))
device_properties_t device_properties()
{
  return device_properties(current_device());
}


template<typename KernelFunction>
__attribute__((host)) __attribute__((device))
inline function_attributes_t function_attributes(KernelFunction kernel)
{

  cudaFuncAttributes attributes;

  typedef void (*fun_ptr_type)();

  fun_ptr_type fun_ptr = reinterpret_cast<fun_ptr_type>(kernel);
  throw_on_error(cudaFuncGetAttributes(&attributes, reinterpret_cast<void*>(fun_ptr)), "cudaFuncGetAttributes in function_attributes");


  function_attributes_t result = {
    attributes.constSizeBytes,
    attributes.localSizeBytes,
    attributes.maxThreadsPerBlock,
    attributes.numRegs,
    attributes.ptxVersion,
    attributes.sharedSizeBytes
  };




  return result;
}


inline __attribute__((host)) __attribute__((device))
size_t compute_capability(const device_properties_t &properties)
{
  return 10 * properties.major + properties.minor;
}


inline __attribute__((host)) __attribute__((device))
size_t compute_capability(void)
{
  return compute_capability(device_properties());
}


}
}
}
}
# 94 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/runtime_introspection.h" 2
# 19 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/default_decomposition.inl" 2

namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename IndexType>
__attribute__((host)) __attribute__((device))
thrust::system::detail::internal::uniform_decomposition<IndexType> default_decomposition(IndexType n)
{

  device_properties_t properties = device_properties();
  return thrust::system::detail::internal::uniform_decomposition<IndexType>(n, properties.maxThreadsPerBlock, 10 * properties.multiProcessorCount);
}


}
}
}
}
# 48 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/default_decomposition.h" 2
# 29 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_if.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_intervals.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_intervals.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename BinaryFunction,
         typename Decomposition>
__attribute__((host)) __attribute__((device))
void reduce_intervals(execution_policy<DerivedPolicy> &exec,
                      InputIterator input,
                      OutputIterator output,
                      BinaryFunction binary_op,
                      Decomposition decomp);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_intervals.inl" 1
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_intervals.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/extern_shared_ptr.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/extern_shared_ptr.h"
       



namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{

template<typename T>
  class extern_shared_ptr
{



  public:
    __attribute__((device))
    inline operator T * (void)
    {
      extern __attribute__((shared)) int4 smem[];
      return reinterpret_cast<T*>(smem);
    }

    __attribute__((device))
    inline operator const T * (void) const
    {
      extern __attribute__((shared)) int4 smem[];
      return reinterpret_cast<const T*>(smem);
    }

};

}
}
}
}
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_intervals.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/block/reduce.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/block/reduce.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace block
{





template <typename Context, typename ValueIterator, typename BinaryFunction>
__attribute__((device)) __inline__ __attribute__((always_inline))
void reduce_n(Context context, ValueIterator data, unsigned int n, BinaryFunction binary_op)
{
  if (context.block_dimension() < n)
  {
    for (unsigned int i = context.block_dimension() + context.thread_index(); i < n; i += context.block_dimension())
      data[context.thread_index()] = binary_op(data[context.thread_index()], data[i]);

    context.barrier();
  }

  while (n > 1)
  {
    unsigned int half = n / 2;

    if (context.thread_index() < half)
      data[context.thread_index()] = binary_op(data[context.thread_index()], data[n - context.thread_index() - 1]);

    context.barrier();

    n = n - half;
  }
}

}
}
}
}
}
# 25 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_intervals.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.h"
       






namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{


template<unsigned int _ThreadsPerBlock = 0,
         unsigned int _BlocksPerMultiprocessor = 0>
struct launch_bounds
{
  typedef thrust::detail::integral_constant<unsigned int, _ThreadsPerBlock> ThreadsPerBlock;
  typedef thrust::detail::integral_constant<unsigned int, _BlocksPerMultiprocessor> BlocksPerMultiprocessor;
};


struct thread_array : public launch_bounds<>
{


  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int thread_index(void) const { return threadIdx.x; }
  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int thread_count(void) const { return blockDim.x * gridDim.x; }




};


struct blocked_thread_array : public launch_bounds<>
{


  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int thread_index(void) const { return threadIdx.x; }
  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int block_dimension(void) const { return blockDim.x; }
  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int block_index(void) const { return blockIdx.x; }
  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int grid_dimension(void) const { return gridDim.x; }
  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int linear_index(void) const { return block_dimension() * block_index() + thread_index(); }
  __attribute__((device)) __inline__ __attribute__((always_inline)) void barrier(void) { __syncthreads(); }
# 76 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.h"
};


template <unsigned int _ThreadsPerBlock>
struct statically_blocked_thread_array : public launch_bounds<_ThreadsPerBlock,1>
{


  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int thread_index(void) const { return threadIdx.x; }
  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int block_dimension(void) const { return _ThreadsPerBlock; }
  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int block_index(void) const { return blockIdx.x; }
  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int grid_dimension(void) const { return gridDim.x; }
  __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int linear_index(void) const { return block_dimension() * block_index() + thread_index(); }
  __attribute__((device)) __inline__ __attribute__((always_inline)) void barrier(void) { __syncthreads(); }
# 98 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.h"
};

template<typename DerivedPolicy, typename Closure, typename Size>
__attribute__((host)) __attribute__((device))
void launch_closure(execution_policy<DerivedPolicy> &exec, Closure f, Size num_blocks);

template<typename DerivedPolicy, typename Closure, typename Size1, typename Size2>
__attribute__((host)) __attribute__((device))
void launch_closure(execution_policy<DerivedPolicy> &exec, Closure f, Size1 num_blocks, Size2 block_size);

template<typename DerivedPolicy, typename Closure, typename Size1, typename Size2, typename Size3>
__attribute__((host)) __attribute__((device))
void launch_closure(execution_policy<DerivedPolicy> &exec, Closure f, Size1 num_blocks, Size2 block_size, Size3 smem_size);




template<typename Closure>
__attribute__((host)) __attribute__((device))
function_attributes_t closure_attributes(void);


}
}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_calculator.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_calculator.h"
       






namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{

template<typename Closure>
class launch_calculator
{
  device_properties_t properties;
  function_attributes_t attributes;

  public:

  __attribute__((host)) __attribute__((device))
  launch_calculator();

  __attribute__((host)) __attribute__((device))
  launch_calculator(const device_properties_t& properties, const function_attributes_t& attributes);

  __attribute__((host)) __attribute__((device))
  thrust::tuple<size_t,size_t,size_t> with_variable_block_size(void) const;

  template<typename UnaryFunction>
  __attribute__((host)) __attribute__((device))
  thrust::tuple<size_t,size_t,size_t> with_variable_block_size(UnaryFunction block_size_to_smem_size) const;

  __attribute__((host)) __attribute__((device))
  thrust::tuple<size_t,size_t,size_t> with_variable_block_size_available_smem(void) const;

  private:






  __attribute__((host)) __attribute__((device))
  thrust::pair<size_t, size_t> default_block_configuration() const;
# 77 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_calculator.h"
  template<typename UnaryFunction>
  __attribute__((host)) __attribute__((device))
  thrust::pair<size_t, size_t> default_block_configuration(UnaryFunction block_size_to_smem_size) const;
};

}
}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_calculator.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_calculator.inl"
namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{

template<typename Closure>
__attribute__((host)) __attribute__((device))
launch_calculator<Closure>::launch_calculator(void)
  : properties(device_properties()),
    attributes(closure_attributes<Closure>())
{}

template<typename Closure>
__attribute__((host)) __attribute__((device))
launch_calculator<Closure>::launch_calculator(const device_properties_t& properties, const function_attributes_t& attributes)
  : properties(properties),
    attributes(attributes)
{}

template<typename Closure>
  template<typename UnaryFunction>
__attribute__((host)) __attribute__((device))
thrust::pair<size_t, size_t> launch_calculator<Closure>::default_block_configuration(UnaryFunction block_size_to_smem_size) const
{

  std::size_t num_threads_per_block = block_size_with_maximum_potential_occupancy(attributes, properties, block_size_to_smem_size);


  std::size_t num_blocks_per_multiprocessor = properties.maxThreadsPerMultiProcessor / num_threads_per_block;

  return thrust::make_pair(num_threads_per_block, num_blocks_per_multiprocessor);
}


template<typename Closure>
__attribute__((host)) __attribute__((device))
thrust::pair<size_t, size_t> launch_calculator<Closure>::default_block_configuration(void) const
{

  std::size_t num_threads_per_block = block_size_with_maximum_potential_occupancy(attributes, properties);


  std::size_t num_blocks_per_multiprocessor = properties.maxThreadsPerMultiProcessor / num_threads_per_block;

  return thrust::make_pair(num_threads_per_block, num_blocks_per_multiprocessor);
}

template<typename Closure>
__attribute__((host)) __attribute__((device))
thrust::tuple<size_t,size_t,size_t> launch_calculator<Closure>::with_variable_block_size(void) const
{
  thrust::pair<size_t, size_t> config = default_block_configuration();
  return thrust::tuple<size_t,size_t,size_t>(config.second * properties.multiProcessorCount, config.first, 0);
}

template <typename Closure>
  template <typename UnaryFunction>
__attribute__((host)) __attribute__((device))
thrust::tuple<size_t,size_t,size_t> launch_calculator<Closure>::with_variable_block_size(UnaryFunction block_size_to_smem_size) const
{
  thrust::pair<size_t, size_t> config = default_block_configuration(block_size_to_smem_size);
  return thrust::tuple<size_t,size_t,size_t>(config.second * properties.multiProcessorCount, config.first, block_size_to_smem_size(config.first));
}

template<typename Closure>
__attribute__((host)) __attribute__((device))
thrust::tuple<size_t,size_t,size_t> launch_calculator<Closure>::with_variable_block_size_available_smem(void) const
{
  thrust::pair<size_t, size_t> config = default_block_configuration();
  size_t smem_per_block = proportional_smem_allocation(properties, attributes, config.second);
  return thrust::tuple<size_t,size_t,size_t>(config.second * properties.multiProcessorCount, config.first, smem_per_block);
}

}
}
}
}
}
# 89 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_calculator.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.inl" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/alignment.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/alignment.h"
       

namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{
namespace alignment_of_detail
{


template<typename T> class alignment_of_impl;

template<typename T, std::size_t size_diff>
  struct helper
{
  static const std::size_t value = size_diff;
};

template<typename T>
  class helper<T,0>
{
  public:
    static const std::size_t value = alignment_of_impl<T>::value;
};

template<typename T>
  class alignment_of_impl
{
  private:
    struct big { T x; char c; };

  public:
    static const std::size_t value = helper<big, sizeof(big) - sizeof(T)>::value;
};


}


template<typename T>
  struct alignment_of
    : alignment_of_detail::alignment_of_impl<T>
{};


template<std::size_t Align> struct aligned_type;
# 193 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/alignment.h"
template<std::size_t Align> struct aligned_type
{
  struct __attribute__((aligned(Align))) type { };
};
# 206 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/alignment.h"
template<std::size_t Len, std::size_t Align>
  struct aligned_storage
{
  union type
  {
    unsigned char data[Len];

    typename aligned_type<Align>::type align;
  };
};


}
}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.inl" 2


namespace thrust
{
namespace detail
{


template<typename, typename> class temporary_array;

}

namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{


template<typename Closure>
__attribute__((global)) __attribute__((launch_bounds(Closure::context_type::ThreadsPerBlock::value, Closure::context_type::BlocksPerMultiprocessor::value)))
void launch_closure_by_value(Closure f)
{
  f();
}

template<typename Closure>
__attribute__((global)) __attribute__((launch_bounds(Closure::context_type::ThreadsPerBlock::value, Closure::context_type::BlocksPerMultiprocessor::value)))
void launch_closure_by_pointer(const Closure *f)
{

  Closure f_reg = *f;
  f_reg();
}
# 72 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.inl"
template<typename Closure,
         bool launch_by_value = sizeof(Closure) <= 256>
  struct closure_launcher_base
{
  typedef void (*launch_function_t)(Closure);

  __attribute__((host)) __attribute__((device))
  static launch_function_t get_launch_function()
  {
    return launch_closure_by_value<Closure>;
  }

  template<typename DerivedPolicy, typename Size1, typename Size2, typename Size3>
  __attribute__((host)) __attribute__((device))
  static void launch(execution_policy<DerivedPolicy> &exec, Closure f, Size1 num_blocks, Size2 block_size, Size3 smem_size)
  {

    launch_function_t kernel = get_launch_function();



    if(num_blocks > 0)
    {

      kernel<<<(unsigned int) num_blocks, (unsigned int) block_size, (unsigned int) smem_size, stream(thrust::detail::derived_cast(exec))>>>(f);







      synchronize_if_enabled("launch_closure_by_value");
    }


  }
};


template<typename Closure>
  struct closure_launcher_base<Closure,false>
{
  typedef void (*launch_function_t)(const Closure *);

  __attribute__((host)) __attribute__((device))
  static launch_function_t get_launch_function(void)
  {
    return launch_closure_by_pointer<Closure>;
  }

  template<typename DerivedPolicy, typename Size1, typename Size2, typename Size3>
  __attribute__((host)) __attribute__((device))
  static void launch(execution_policy<DerivedPolicy> &exec, Closure f, Size1 num_blocks, Size2 block_size, Size3 smem_size)
  {

    launch_function_t kernel = get_launch_function();



    if(num_blocks > 0)
    {

      thrust::host_system_tag host_tag;
      thrust::detail::temporary_array<Closure,DerivedPolicy> closure_storage(exec, host_tag, &f, &f + 1);


      kernel<<<(unsigned int) num_blocks, (unsigned int) block_size, (unsigned int) smem_size, stream(thrust::detail::derived_cast(exec))>>>((&closure_storage[0]).get());
      synchronize_if_enabled("launch_closure_by_pointer");
    }


  }
};


template<typename Closure>
  struct closure_launcher
    : public closure_launcher_base<Closure>
{
  typedef closure_launcher_base<Closure> super_t;

  __attribute__((host)) __attribute__((device))
  static inline const device_properties_t& device_properties(void)
  {
    return device_properties();
  }

  __attribute__((host)) __attribute__((device))
  static inline function_attributes_t function_attributes(void)
  {
    return thrust::system::cuda::detail::function_attributes(super_t::get_launch_function());
  }

  template<typename DerivedPolicy, typename Size1, typename Size2, typename Size3>
  __attribute__((host)) __attribute__((device))
  static void launch(execution_policy<DerivedPolicy> &exec, Closure f, Size1 num_blocks, Size2 block_size, Size3 smem_size)
  {
    super_t::launch(exec,f,num_blocks,block_size,smem_size);
  }
};

template<typename DerivedPolicy, typename Closure, typename Size>
__attribute__((host)) __attribute__((device))
void launch_closure(execution_policy<DerivedPolicy> &exec, Closure f, Size num_blocks)
{
  launch_calculator<Closure> calculator;
  launch_closure(exec, f, num_blocks, thrust::get<1>(calculator.with_variable_block_size()));
}

template<typename DerivedPolicy, typename Closure, typename Size1, typename Size2>
__attribute__((host)) __attribute__((device))
void launch_closure(execution_policy<DerivedPolicy> &exec, Closure f, Size1 num_blocks, Size2 block_size)
{
  launch_closure(exec, f, num_blocks, block_size, 0u);
}

template<typename DerivedPolicy, typename Closure, typename Size1, typename Size2, typename Size3>
__attribute__((host)) __attribute__((device))
void launch_closure(execution_policy<DerivedPolicy> &exec, Closure f, Size1 num_blocks, Size2 block_size, Size3 smem_size)
{
  closure_launcher<Closure>::launch(exec, f, num_blocks, block_size, smem_size);
}


namespace closure_attributes_detail
{


template<typename Closure>
inline __attribute__((host)) __attribute__((device))
function_attributes_t uncached_closure_attributes()
{
  typedef closure_launcher<Closure> Launcher;
  return thrust::system::cuda::detail::function_attributes(Launcher::get_launch_function());
}


template<typename Closure>
function_attributes_t cached_closure_attributes()
{


  static const int max_num_devices = 16;

  static bool attributes_exist[max_num_devices] = {0};
  static function_attributes_t function_attributes[max_num_devices] = {};


  int device_id = current_device();

  if(device_id >= max_num_devices)
  {
    return uncached_closure_attributes<Closure>();
  }

  if(!attributes_exist[device_id])
  {
    function_attributes[device_id] = uncached_closure_attributes<Closure>();



    __sync_synchronize();

    attributes_exist[device_id] = true;
  }

  return function_attributes[device_id];
}


}


template<typename Closure>
__attribute__((host)) __attribute__((device))
function_attributes_t closure_attributes()
{

  return closure_attributes_detail::cached_closure_attributes<Closure>();



}

}
}
}
}
}
# 127 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/launch_closure.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_intervals.inl" 2



namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename InputIterator,
         typename OutputIterator,
         typename BinaryFunction,
         typename Decomposition,
         typename Context>
struct commutative_reduce_intervals_closure
{
  InputIterator input;
  OutputIterator output;
  BinaryFunction binary_op;
  Decomposition decomposition;
  unsigned int shared_array_size;

  typedef Context context_type;
  context_type context;

  __attribute__((host)) __attribute__((device))
  commutative_reduce_intervals_closure(InputIterator input, OutputIterator output, BinaryFunction binary_op, Decomposition decomposition, unsigned int shared_array_size, Context context = Context())
    : input(input), output(output), binary_op(binary_op), decomposition(decomposition), shared_array_size(shared_array_size), context(context) {}

  __attribute__((device)) __inline__ __attribute__((always_inline))
  void operator()(void)
  {
    typedef typename thrust::iterator_value<OutputIterator>::type OutputType;
    extern_shared_ptr<OutputType> shared_array;

    typedef typename Decomposition::index_type index_type;


    thrust::system::detail::internal::index_range<index_type> range = decomposition[context.block_index()];

    index_type i = range.begin() + context.thread_index();

    input += i;

    if(range.size() < context.block_dimension())
    {

      if(context.thread_index() < thrust::min<index_type>(shared_array_size,range.size()))
      {
        OutputType sum = *input;

        i += shared_array_size;
        input += shared_array_size;

        while(i < range.end())
        {
          OutputType val = *input;

          sum = binary_op(sum, val);

          i += shared_array_size;
          input += shared_array_size;
        }

        shared_array[context.thread_index()] = sum;
      }
    }
    else
    {

      OutputType sum = *input;

      i += context.block_dimension();
      input += context.block_dimension();

      while(i < range.end())
      {
        OutputType val = *input;

        sum = binary_op(sum, val);

        i += context.block_dimension();
        input += context.block_dimension();
      }


      if(context.thread_index() < shared_array_size)
      {
        shared_array[context.thread_index()] = sum;
      }


      if(context.block_dimension() > shared_array_size)
      {
        unsigned int lb = shared_array_size;
        unsigned int ub = shared_array_size + lb;

        while(lb < context.block_dimension())
        {
          context.barrier();

          if(lb <= context.thread_index() && context.thread_index() < ub)
          {
            OutputType tmp = shared_array[context.thread_index() - lb];
            shared_array[context.thread_index() - lb] = binary_op(tmp, sum);
          }

          lb += shared_array_size;
          ub += shared_array_size;
        }
      }
    }

    context.barrier();

    block::reduce_n(context, shared_array, thrust::min<index_type>(range.size(), shared_array_size), binary_op);

    if(context.thread_index() == 0)
    {
      output += context.block_index();
      *output = shared_array[0];
    }
  }
};





template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename BinaryFunction,
         typename Decomposition>
__attribute__((host)) __attribute__((device))
void reduce_intervals(execution_policy<ExecutionPolicy> &exec,
                      InputIterator input,
                      OutputIterator output,
                      BinaryFunction binary_op,
                      Decomposition decomp)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator, 3 == 3>::value) ) >)> thrust_static_assert_typedef_176 __attribute__((unused));

  if(decomp.size() == 0)
  {
    return;
  }



  typedef detail::blocked_thread_array Context;
  typedef commutative_reduce_intervals_closure<InputIterator,OutputIterator,BinaryFunction,Decomposition,Context> Closure;
  typedef typename thrust::iterator_value<OutputIterator>::type OutputType;

  detail::launch_calculator<Closure> calculator;

  thrust::tuple<size_t,size_t,size_t> config = calculator.with_variable_block_size_available_smem();


  size_t block_size = thrust::get<1>(config);
  size_t max_memory = thrust::get<2>(config);


  size_t shared_array_size = thrust::min(max_memory / sizeof(OutputType), block_size);
  size_t shared_array_bytes = sizeof(OutputType) * shared_array_size;



  Closure closure(input, output, binary_op, decomp, shared_array_size);
  detail::launch_closure(exec, closure, decomp.size(), block_size, shared_array_bytes);
}





}
}
}
}
# 56 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/reduce_intervals.h" 2
# 30 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_if.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/block/inclusive_scan.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/block/inclusive_scan.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace block
{

template<typename Context,
         typename InputIterator,
         typename BinaryFunction>
__attribute__((device)) __inline__ __attribute__((always_inline))
void inclusive_scan(Context context,
                    InputIterator first,
                    BinaryFunction binary_op)
{


  const unsigned int block_size = Context::ThreadsPerBlock::value;

  typename thrust::iterator_value<InputIterator>::type val = first[context.thread_index()];

  if(block_size > 1) { if (context.thread_index() >= 1) { val = binary_op(first[context.thread_index() - 1], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 2) { if (context.thread_index() >= 2) { val = binary_op(first[context.thread_index() - 2], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 4) { if (context.thread_index() >= 4) { val = binary_op(first[context.thread_index() - 4], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 8) { if (context.thread_index() >= 8) { val = binary_op(first[context.thread_index() - 8], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 16) { if (context.thread_index() >= 16) { val = binary_op(first[context.thread_index() - 16], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 32) { if (context.thread_index() >= 32) { val = binary_op(first[context.thread_index() - 32], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 64) { if (context.thread_index() >= 64) { val = binary_op(first[context.thread_index() - 64], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 128) { if (context.thread_index() >= 128) { val = binary_op(first[context.thread_index() - 128], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 256) { if (context.thread_index() >= 256) { val = binary_op(first[context.thread_index() - 256], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 512) { if (context.thread_index() >= 512) { val = binary_op(first[context.thread_index() - 512], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
  if(block_size > 1024) { if (context.thread_index() >= 1024) { val = binary_op(first[context.thread_index() - 1024], val); } context.barrier(); first[context.thread_index()] = val; context.barrier(); }
}


template<typename Context,
         typename InputIterator,
         typename Size,
         typename BinaryFunction>
__attribute__((device)) __inline__ __attribute__((always_inline))
void inclusive_scan_n(Context context,
                      InputIterator first,
                      Size n,
                      BinaryFunction binary_op)
{

  typename thrust::iterator_value<InputIterator>::type val = first[context.thread_index()];

  for (unsigned int i = 1; i < n; i <<= 1)
  {
    if (context.thread_index() < n && context.thread_index() >= i)
      val = binary_op(first[context.thread_index() - i], val);

    context.barrier();

    first[context.thread_index()] = val;

    context.barrier();
  }
}


template<typename Context,
         typename InputIterator1,
         typename InputIterator2,
         typename BinaryFunction>
__attribute__((device)) __inline__ __attribute__((always_inline))
void inclusive_scan_by_flag(Context context,
                            InputIterator1 first1,
                            InputIterator2 first2,
                            BinaryFunction binary_op)
{


  const unsigned int block_size = Context::ThreadsPerBlock::value;

  typename thrust::iterator_value<InputIterator1>::type flg = first1[context.thread_index()];
  typename thrust::iterator_value<InputIterator2>::type val = first2[context.thread_index()];

  if(block_size > 1) { if (context.thread_index() >= 1) { if (!flg) { flg |= first1[context.thread_index() - 1]; val = binary_op(first2[context.thread_index() - 1], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 2) { if (context.thread_index() >= 2) { if (!flg) { flg |= first1[context.thread_index() - 2]; val = binary_op(first2[context.thread_index() - 2], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 4) { if (context.thread_index() >= 4) { if (!flg) { flg |= first1[context.thread_index() - 4]; val = binary_op(first2[context.thread_index() - 4], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 8) { if (context.thread_index() >= 8) { if (!flg) { flg |= first1[context.thread_index() - 8]; val = binary_op(first2[context.thread_index() - 8], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 16) { if (context.thread_index() >= 16) { if (!flg) { flg |= first1[context.thread_index() - 16]; val = binary_op(first2[context.thread_index() - 16], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 32) { if (context.thread_index() >= 32) { if (!flg) { flg |= first1[context.thread_index() - 32]; val = binary_op(first2[context.thread_index() - 32], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 64) { if (context.thread_index() >= 64) { if (!flg) { flg |= first1[context.thread_index() - 64]; val = binary_op(first2[context.thread_index() - 64], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 128) { if (context.thread_index() >= 128) { if (!flg) { flg |= first1[context.thread_index() - 128]; val = binary_op(first2[context.thread_index() - 128], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 256) { if (context.thread_index() >= 256) { if (!flg) { flg |= first1[context.thread_index() - 256]; val = binary_op(first2[context.thread_index() - 256], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 512) { if (context.thread_index() >= 512) { if (!flg) { flg |= first1[context.thread_index() - 512]; val = binary_op(first2[context.thread_index() - 512], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
  if(block_size > 1024) { if (context.thread_index() >= 1024) { if (!flg) { flg |= first1[context.thread_index() - 1024]; val = binary_op(first2[context.thread_index() - 1024], val); } } context.barrier(); first1[context.thread_index()] = flg; first2[context.thread_index()] = val; context.barrier(); }
}


template<typename Context,
         typename InputIterator1,
         typename InputIterator2,
         typename Size,
         typename BinaryFunction>
__attribute__((device)) __inline__ __attribute__((always_inline))
void inclusive_scan_by_flag_n(Context context,
                              InputIterator1 first1,
                              InputIterator2 first2,
                              Size n,
                              BinaryFunction binary_op)
{

  typename thrust::iterator_value<InputIterator1>::type flg = first1[context.thread_index()];
  typename thrust::iterator_value<InputIterator2>::type val = first2[context.thread_index()];

  for (unsigned int i = 1; i < n; i <<= 1)
  {
    if (context.thread_index() < n && context.thread_index() >= i)
    {
      if (!flg)
      {
        flg |= first1[context.thread_index() - i];
        val = binary_op(first2[context.thread_index() - i], val);
      }
    }

    context.barrier();

    first1[context.thread_index()] = flg;
    first2[context.thread_index()] = val;

    context.barrier();
  }
}


template<typename Context, typename RandomAccessIterator, typename BinaryFunction>
__attribute__((device)) __inline__ __attribute__((always_inline))
void inplace_inclusive_scan(Context &ctx, RandomAccessIterator first, BinaryFunction op)
{
  typename thrust::iterator_value<RandomAccessIterator>::type x = first[ctx.thread_index()];

  for(unsigned int offset = 1; offset < ctx.block_dimension(); offset *= 2)
  {
    if(ctx.thread_index() >= offset)
    {
      x = op(first[ctx.thread_index() - offset], x);
    }

    ctx.barrier();

    first[ctx.thread_index()] = x;

    ctx.barrier();
  }
}


template<typename Context, typename RandomAccessIterator>
__attribute__((device)) __inline__ __attribute__((always_inline))
void inplace_inclusive_scan(Context &ctx, RandomAccessIterator first)
{
  block::inplace_inclusive_scan(ctx, first, thrust::plus<typename thrust::iterator_value<RandomAccessIterator>::type>());
}


}
}
}
}
}
# 31 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_if.inl" 2








namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace copy_if_detail
{


template<typename InputIterator1,
         typename InputIterator2,
         typename InputIterator3,
         typename Decomposition,
         typename OutputIterator,
         typename Context>
struct copy_if_intervals_closure
{
  InputIterator1 input;
  InputIterator2 stencil;
  InputIterator3 offsets;
  Decomposition decomp;
  OutputIterator output;

  typedef Context context_type;
  context_type context;

  __attribute__((host)) __attribute__((device))
  copy_if_intervals_closure(InputIterator1 input,
                            InputIterator2 stencil,
                            InputIterator3 offsets,
                            Decomposition decomp,
                            OutputIterator output,
                            Context context = Context())
    : input(input), stencil(stencil), offsets(offsets), decomp(decomp), output(output), context(context) {}

  __attribute__((device)) __inline__ __attribute__((always_inline))
  void operator()(void)
  {
    typedef unsigned int PredicateType;

    const unsigned int CTA_SIZE = context_type::ThreadsPerBlock::value;

    thrust::plus<PredicateType> binary_op;

    __attribute__((shared)) PredicateType sdata[CTA_SIZE]; context.barrier();

    typedef typename Decomposition::index_type IndexType;


    thrust::system::detail::internal::index_range<IndexType> range = decomp[context.block_index()];

    IndexType base = range.begin();

    PredicateType predicate = 0;


    input += base + context.thread_index();
    stencil += base + context.thread_index();


    if(context.block_index() != 0)
    {
      InputIterator3 temp = offsets + (context.block_index() - 1);
      output += *temp;
    }


    while(base + CTA_SIZE <= range.end())
    {

      sdata[context.thread_index()] = predicate = *stencil;

      context.barrier();


      block::inclusive_scan(context, sdata, binary_op);


      if(predicate)
      {
        OutputIterator temp2 = output + (sdata[context.thread_index()] - 1);
        *temp2 = *input;
      }


      base += CTA_SIZE;
      input += CTA_SIZE;
      stencil += CTA_SIZE;


      output += sdata[CTA_SIZE - 1];

      context.barrier();
    }


    if(base < range.end())
    {

      if(base + context.thread_index() < range.end())
      {
        sdata[context.thread_index()] = predicate = *stencil;
      }
      else
      {
        sdata[context.thread_index()] = predicate = 0;
      }

      context.barrier();


      block::inclusive_scan(context, sdata, binary_op);


      if(predicate)
      {
        OutputIterator temp2 = output + (sdata[context.thread_index()] - 1);
        *temp2 = *input;
      }
    }
  }
};


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
OutputIterator copy_if(execution_policy<DerivedPolicy> &exec,
                       InputIterator1 first,
                       InputIterator1 last,
                       InputIterator2 stencil,
                       OutputIterator output,
                       Predicate pred)
{
  typedef typename thrust::iterator_difference<InputIterator1>::type IndexType;

  if(first == last)
  {
    return output;
  }

  typedef thrust::system::detail::internal::uniform_decomposition<IndexType> Decomposition;
  typedef thrust::detail::temporary_array<IndexType, DerivedPolicy> IndexArray;

  Decomposition decomp = default_decomposition(last - first);


  IndexArray block_results(exec, decomp.size());


  typedef typename thrust::detail::predicate_to_integral<Predicate,IndexType> PredicateToIndexTransform;
  typedef thrust::transform_iterator<PredicateToIndexTransform, InputIterator2, IndexType> PredicateToIndexIterator;

  PredicateToIndexIterator predicate_stencil(stencil, PredicateToIndexTransform(pred));


  thrust::system::cuda::detail::reduce_intervals(exec, predicate_stencil, block_results.begin(), thrust::plus<IndexType>(), decomp);


  thrust::inclusive_scan(exec, block_results.begin(), block_results.end(), block_results.begin(), thrust::plus<IndexType>());


  const unsigned int ThreadsPerBlock = 256;
  typedef typename IndexArray::iterator InputIterator3;
  typedef detail::statically_blocked_thread_array<ThreadsPerBlock> Context;
  typedef copy_if_intervals_closure<InputIterator1,PredicateToIndexIterator,InputIterator3,Decomposition,OutputIterator,Context> Closure;
  Closure closure(first, predicate_stencil, block_results.begin(), decomp, output);
  detail::launch_closure(exec, closure, decomp.size(), ThreadsPerBlock);

  return output + get_value(exec,&block_results[decomp.size() - 1]);
}


}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
OutputIterator copy_if(execution_policy<DerivedPolicy> &exec,
                       InputIterator1 first,
                       InputIterator1 last,
                       InputIterator2 stencil,
                       OutputIterator output,
                       Predicate pred)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<InputIterator1, 3 == 3>::value) ) >)> thrust_static_assert_typedef_239 __attribute__((unused));

  struct workaround
  {
    __attribute__((host)) __attribute__((device))
    static OutputIterator parallel_path(execution_policy<DerivedPolicy> &exec,
                                        InputIterator1 first,
                                        InputIterator1 last,
                                        InputIterator2 stencil,
                                        OutputIterator output,
                                        Predicate pred)
    {
      return thrust::system::cuda::detail::copy_if_detail::copy_if(exec, first, last, stencil, output, pred);
    }

    __attribute__((host)) __attribute__((device))
    static OutputIterator sequential_path(execution_policy<DerivedPolicy> &,
                                          InputIterator1 first,
                                          InputIterator1 last,
                                          InputIterator2 stencil,
                                          OutputIterator output,
                                          Predicate pred)
    {
      return thrust::copy_if(thrust::seq, first, last, stencil, output, pred);
    }
  };


  return workaround::parallel_path(exec, first, last, stencil, output, pred);



}


}
}
}
}


# 52 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/copy_if.h" 2
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/copy_if.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/detail/copy_if.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         InputIterator first,
                         InputIterator last,
                         OutputIterator result,
                         Predicate pred)
{
  using thrust::system::detail::generic::copy_if;
  return copy_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         InputIterator1 first,
                         InputIterator1 last,
                         InputIterator2 stencil,
                         OutputIterator result,
                         Predicate pred)
{
  using thrust::system::detail::generic::copy_if;
  return copy_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, result, pred);
}


template<typename InputIterator,
         typename OutputIterator,
         typename Predicate>
  OutputIterator copy_if(InputIterator first,
                         InputIterator last,
                         OutputIterator result,
                         Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::copy_if(select_system(system1,system2), first, last, result, pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
  OutputIterator copy_if(InputIterator1 first,
                         InputIterator1 last,
                         InputIterator2 stencil,
                         OutputIterator result,
                         Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::copy_if(select_system(system1,system2,system3), first, last, stencil, result, pred);
}


}
# 75 "/usr/local/cuda-8.0/include/thrust/detail/copy_if.h" 2
# 513 "/usr/local/cuda-8.0/include/thrust/copy.h" 2
# 21 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_radix_sort.inl" 2
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_radix_sort.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{
namespace radix_sort_detail
{


template <typename T>
struct RadixEncoder : public thrust::identity<T>
{};


template <>
struct RadixEncoder<char> : public thrust::unary_function<char, unsigned char>
{
  __attribute__((host)) __attribute__((device))
  unsigned char operator()(char x) const
  {
    if(std::numeric_limits<char>::is_signed)
    {
      return x ^ static_cast<unsigned char>(1) << (8 * sizeof(unsigned char) - 1);
    }
    else
    {
      return x;
    }
  }
};

template <>
struct RadixEncoder<signed char> : public thrust::unary_function<signed char, unsigned char>
{
  __attribute__((host)) __attribute__((device))
  unsigned char operator()(signed char x) const
  {
    return x ^ static_cast<unsigned char>(1) << (8 * sizeof(unsigned char) - 1);
  }
};

template <>
struct RadixEncoder<short> : public thrust::unary_function<short, unsigned short>
{
  __attribute__((host)) __attribute__((device))
  unsigned short operator()(short x) const
  {
    return x ^ static_cast<unsigned short>(1) << (8 * sizeof(unsigned short) - 1);
  }
};

template <>
struct RadixEncoder<int> : public thrust::unary_function<int, unsigned int>
{
  __attribute__((host)) __attribute__((device))
  unsigned long operator()(long x) const
  {
    return x ^ static_cast<unsigned int>(1) << (8 * sizeof(unsigned int) - 1);
  }
};

template <>
struct RadixEncoder<long> : public thrust::unary_function<long, unsigned long>
{
  __attribute__((host)) __attribute__((device))
  unsigned long operator()(long x) const
  {
    return x ^ static_cast<unsigned long>(1) << (8 * sizeof(unsigned long) - 1);
  }
};

template <>
struct RadixEncoder<long long> : public thrust::unary_function<long long, unsigned long long>
{
  __attribute__((host)) __attribute__((device))
  unsigned long long operator()(long long x) const
  {
    return x ^ static_cast<unsigned long long>(1) << (8 * sizeof(unsigned long long) - 1);
  }
};


template <>
struct RadixEncoder<float> : public thrust::unary_function<float, thrust::detail::uint32_t>
{
  __attribute__((host)) __attribute__((device))
  thrust::detail::uint32_t operator()(float x) const
  {
    union { float f; thrust::detail::uint32_t i; } u;
    u.f = x;
    thrust::detail::uint32_t mask = -static_cast<thrust::detail::int32_t>(u.i >> 31) | (static_cast<thrust::detail::uint32_t>(1) << 31);
    return u.i ^ mask;
  }
};

template <>
struct RadixEncoder<double> : public thrust::unary_function<double, thrust::detail::uint64_t>
{
  __attribute__((host)) __attribute__((device))
  thrust::detail::uint64_t operator()(double x) const
  {
    union { double f; thrust::detail::uint64_t i; } u;
    u.f = x;
    thrust::detail::uint64_t mask = -static_cast<thrust::detail::int64_t>(u.i >> 63) | (static_cast<thrust::detail::uint64_t>(1) << 63);
    return u.i ^ mask;
  }
};



template<unsigned int RadixBits, typename KeyType>
  struct bucket_functor
{
  typedef RadixEncoder<KeyType> Encoder;
  typedef typename Encoder::result_type EncodedType;
  typedef size_t result_type;
  static const EncodedType BitMask = static_cast<EncodedType>((1 << RadixBits) - 1);

  Encoder encode;
  EncodedType bit_shift;
  size_t *histogram;

  __attribute__((host)) __attribute__((device))
  bucket_functor(EncodedType bit_shift, size_t *histogram)
    : encode(),
      bit_shift(bit_shift),
      histogram(histogram)
  {}

  inline __attribute__((host)) __attribute__((device))
  size_t operator()(KeyType key)
  {
    const EncodedType x = encode(key);


    return histogram[(x >> bit_shift) & BitMask]++;
  }
};


template<unsigned int RadixBits,
         typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Integer>
inline __attribute__((host)) __attribute__((device))
void radix_shuffle_n(sequential::execution_policy<DerivedPolicy> &exec,
                     RandomAccessIterator1 first,
                     const size_t n,
                     RandomAccessIterator2 result,
                     Integer bit_shift,
                     size_t *histogram)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type KeyType;


  thrust::scatter(exec,
                  first, first + n,
                  thrust::make_transform_iterator(first, bucket_functor<RadixBits,KeyType>(bit_shift, histogram)),
                  result);
}


template<unsigned int RadixBits,
         typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename RandomAccessIterator4,
         typename Integer>
__attribute__((host)) __attribute__((device))
void radix_shuffle_n(sequential::execution_policy<DerivedPolicy> &exec,
                     RandomAccessIterator1 keys_first,
                     RandomAccessIterator2 values_first,
                     const size_t n,
                     RandomAccessIterator3 keys_result,
                     RandomAccessIterator4 values_result,
                     Integer bit_shift,
                     size_t *histogram)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type KeyType;


  thrust::scatter(exec,
                  thrust::make_zip_iterator(thrust::make_tuple(keys_first, values_first)),
                  thrust::make_zip_iterator(thrust::make_tuple(keys_first + n, values_first + n)),
                  thrust::make_transform_iterator(keys_first, bucket_functor<RadixBits,KeyType>(bit_shift, histogram)),
                  thrust::make_zip_iterator(thrust::make_tuple(keys_result, values_result)));
}


template<unsigned int RadixBits,
         bool HasValues,
         typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename RandomAccessIterator4>
__attribute__((host)) __attribute__((device))
void radix_sort(sequential::execution_policy<DerivedPolicy> &exec,
                RandomAccessIterator1 keys1,
                RandomAccessIterator2 keys2,
                RandomAccessIterator3 vals1,
                RandomAccessIterator4 vals2,
                const size_t N)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type KeyType;

  typedef RadixEncoder<KeyType> Encoder;
  typedef typename Encoder::result_type EncodedType;

  const unsigned int NumHistograms = (8 * sizeof(EncodedType) + (RadixBits - 1)) / RadixBits;
  const unsigned int HistogramSize = 1 << RadixBits;

  const EncodedType BitMask = static_cast<EncodedType>((1 << RadixBits) - 1);

  Encoder encode;


  size_t histograms[NumHistograms][HistogramSize] = {{0}};


  bool skip_shuffle[NumHistograms] = {false};


  bool flip = false;


  for(size_t i = 0; i < N; i++)
  {
    const EncodedType x = encode(keys1[i]);

    for(unsigned int j = 0; j < NumHistograms; j++)
    {
      const EncodedType BitShift = RadixBits * j;
      histograms[j][(x >> BitShift) & BitMask]++;
    }
  }


  for(unsigned int i = 0; i < NumHistograms; i++)
  {
    size_t sum = 0;

    for(unsigned int j = 0; j < HistogramSize; j++)
    {
      size_t bin = histograms[i][j];

      if(bin == N)
        skip_shuffle[i] = true;

      histograms[i][j] = sum;

      sum = sum + bin;
    }
  }


  for(unsigned int i = 0; i < NumHistograms; i++)
  {
    const EncodedType BitShift = static_cast<EncodedType>(RadixBits * i);

    if(!skip_shuffle[i])
    {
      if(flip)
      {
        if(HasValues)
        {
          radix_shuffle_n<RadixBits>(exec, keys2, vals2, N, keys1, vals1, BitShift, histograms[i]);
        }
        else
        {
          radix_shuffle_n<RadixBits>(exec, keys2, N, keys1, BitShift, histograms[i]);
        }
      }
      else
      {
        if(HasValues)
        {
          radix_shuffle_n<RadixBits>(exec, keys1, vals1, N, keys2, vals2, BitShift, histograms[i]);
        }
        else
        {
          radix_shuffle_n<RadixBits>(exec, keys1, N, keys2, BitShift, histograms[i]);
        }
      }

      flip = (flip) ? false : true;
    }
  }


  if(flip)
  {
    thrust::copy(exec, keys2, keys2 + N, keys1);

    if(HasValues)
    {
      thrust::copy(exec, vals2, vals2 + N, vals1);
    }
  }
}




template <size_t KeySize>
struct radix_sort_dispatcher
{
};

template <>
struct radix_sort_dispatcher<1>
{
  template<typename DerivedPolicy,
           typename RandomAccessIterator1,
           typename RandomAccessIterator2>
  __attribute__((host)) __attribute__((device))
  void operator()(sequential::execution_policy<DerivedPolicy> &exec,
                  RandomAccessIterator1 keys1, RandomAccessIterator2 keys2,
                  const size_t N)
  {
    radix_sort_detail::radix_sort<8,false>(exec, keys1, keys2, static_cast<int *>(0), static_cast<int *>(0), N);
  }

  template<typename DerivedPolicy,
           typename RandomAccessIterator1,
           typename RandomAccessIterator2,
           typename RandomAccessIterator3,
           typename RandomAccessIterator4>
  __attribute__((host)) __attribute__((device))
  void operator()(sequential::execution_policy<DerivedPolicy> &exec,
                  RandomAccessIterator1 keys1, RandomAccessIterator2 keys2,
                  RandomAccessIterator3 vals1, RandomAccessIterator4 vals2,
                  const size_t N)
  {
    radix_sort_detail::radix_sort<8,true>(exec, keys1, keys2, vals1, vals2, N);
  }
};


template <>
struct radix_sort_dispatcher<2>
{
  template<typename DerivedPolicy,
           typename RandomAccessIterator1,
           typename RandomAccessIterator2>
  __attribute__((host)) __attribute__((device))
  void operator()(sequential::execution_policy<DerivedPolicy> &exec,
                  RandomAccessIterator1 keys1, RandomAccessIterator2 keys2,
                  const size_t N)
  {




    const bool condition = N < (1 << 16);

    if (condition)
    {
      radix_sort_detail::radix_sort<8,false>(exec, keys1, keys2, static_cast<int *>(0), static_cast<int *>(0), N);
    }
    else
    {
      radix_sort_detail::radix_sort<16,false>(exec, keys1, keys2, static_cast<int *>(0), static_cast<int *>(0), N);
    }
  }


  template<typename DerivedPolicy,
           typename RandomAccessIterator1,
           typename RandomAccessIterator2,
           typename RandomAccessIterator3,
           typename RandomAccessIterator4>
  __attribute__((host)) __attribute__((device))
  void operator()(sequential::execution_policy<DerivedPolicy> &exec,
                  RandomAccessIterator1 keys1, RandomAccessIterator2 keys2,
                  RandomAccessIterator3 vals1, RandomAccessIterator4 vals2,
                  const size_t N)
  {




    const bool condition = N < (1 << 15);

    if (condition)
    {
      radix_sort_detail::radix_sort<8,true>(exec, keys1, keys2, vals1, vals2, N);
    }
    else
    {
      radix_sort_detail::radix_sort<16,true>(exec, keys1, keys2, vals1, vals2, N);
    }
  }
};


template <>
struct radix_sort_dispatcher<4>
{
  template<typename DerivedPolicy,
           typename RandomAccessIterator1,
           typename RandomAccessIterator2>
  __attribute__((host)) __attribute__((device))
  void operator()(sequential::execution_policy<DerivedPolicy> &exec,
                  RandomAccessIterator1 keys1, RandomAccessIterator2 keys2,
                  const size_t N)
  {
    if(N < (1 << 22))
    {
      radix_sort_detail::radix_sort<8,false>(exec, keys1, keys2, static_cast<int *>(0), static_cast<int *>(0), N);
    }
    else
    {
      radix_sort_detail::radix_sort<4,false>(exec, keys1, keys2, static_cast<int *>(0), static_cast<int *>(0), N);
    }
  }

  template<typename DerivedPolicy,
           typename RandomAccessIterator1,
           typename RandomAccessIterator2,
           typename RandomAccessIterator3,
           typename RandomAccessIterator4>
  __attribute__((host)) __attribute__((device))
  void operator()(sequential::execution_policy<DerivedPolicy> &exec,
                  RandomAccessIterator1 keys1, RandomAccessIterator2 keys2,
                  RandomAccessIterator3 vals1, RandomAccessIterator4 vals2,
                  const size_t N)
  {
    if(N < (1 << 22))
    {
      radix_sort_detail::radix_sort<8,true>(exec, keys1, keys2, vals1, vals2, N);
    }
    else
    {
      radix_sort_detail::radix_sort<3,true>(exec, keys1, keys2, vals1, vals2, N);
    }
  }
};


template <>
struct radix_sort_dispatcher<8>
{
  template<typename DerivedPolicy,
           typename RandomAccessIterator1,
           typename RandomAccessIterator2>
  __attribute__((host)) __attribute__((device))
  void operator()(sequential::execution_policy<DerivedPolicy> &exec,
                  RandomAccessIterator1 keys1, RandomAccessIterator2 keys2,
                  const size_t N)
  {
    if(N < (1 << 21))
    {
      radix_sort_detail::radix_sort<8,false>(exec, keys1, keys2, static_cast<int *>(0), static_cast<int *>(0), N);
    }
    else
    {
      radix_sort_detail::radix_sort<4,false>(exec, keys1, keys2, static_cast<int *>(0), static_cast<int *>(0), N);
    }
  }

  template<typename DerivedPolicy,
           typename RandomAccessIterator1,
           typename RandomAccessIterator2,
           typename RandomAccessIterator3,
           typename RandomAccessIterator4>
  __attribute__((host)) __attribute__((device))
  void operator()(sequential::execution_policy<DerivedPolicy> &exec,
                  RandomAccessIterator1 keys1, RandomAccessIterator2 keys2,
                  RandomAccessIterator3 vals1, RandomAccessIterator4 vals2,
                  const size_t N)
  {
    if(N < (1 << 21))
    {
      radix_sort_detail::radix_sort<8,true>(exec, keys1, keys2, vals1, vals2, N);
    }
    else
    {
      radix_sort_detail::radix_sort<3,true>(exec, keys1, keys2, vals1, vals2, N);
    }
  }
};


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void radix_sort(sequential::execution_policy<DerivedPolicy> &exec,
                RandomAccessIterator1 keys1,
                RandomAccessIterator2 keys2,
                const size_t N)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type KeyType;
  radix_sort_dispatcher<sizeof(KeyType)>()(exec, keys1, keys2, N);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename RandomAccessIterator3,
         typename RandomAccessIterator4>
__attribute__((host)) __attribute__((device))
void radix_sort(sequential::execution_policy<DerivedPolicy> &exec,
                RandomAccessIterator1 keys1,
                RandomAccessIterator2 keys2,
                RandomAccessIterator3 vals1,
                RandomAccessIterator4 vals2,
                const size_t N)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type KeyType;
  radix_sort_dispatcher<sizeof(KeyType)>()(exec, keys1, keys2, vals1, vals2, N);
}


}


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_radix_sort(sequential::execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator first,
                       RandomAccessIterator last)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type KeyType;

  size_t N = last - first;

  thrust::detail::temporary_array<KeyType, DerivedPolicy> temp(exec, N);

  radix_sort_detail::radix_sort(exec, first, temp.begin(), N);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_radix_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 first1,
                              RandomAccessIterator1 last1,
                              RandomAccessIterator2 first2)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type KeyType;
  typedef typename thrust::iterator_value<RandomAccessIterator2>::type ValueType;

  size_t N = last1 - first1;

  thrust::detail::temporary_array<KeyType, DerivedPolicy> temp1(exec, N);
  thrust::detail::temporary_array<ValueType, DerivedPolicy> temp2(exec, N);

  radix_sort_detail::radix_sort(exec, first1, temp1.begin(), first2, temp2.begin(), N);
}


}
}
}
}
# 56 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_radix_sort.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_primitive_sort.inl" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
       







namespace thrust
{
namespace detail
{



template<typename,typename> class temporary_array;


}

namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename ForwardIterator1,
         typename ForwardIterator2>
__attribute__((host)) __attribute__((device))
void iter_swap(ForwardIterator1 iter1, ForwardIterator2 iter2)
{

  using namespace thrust::detail;

  typedef typename thrust::iterator_value<ForwardIterator1>::type T;

  T temp = *iter1;
  *iter1 = *iter2;
  *iter2 = temp;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(sequential::execution_policy<DerivedPolicy> &,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred)
{
  if(first == last)
    return first;


  thrust::detail::wrapped_function<
    Predicate,
   
 
# 84 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
 
# 83 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
    bool
  > wrapped_pred(pred);

  while(wrapped_pred(*first))
  {
    if(++first == last)
      return first;
  }

  ForwardIterator next = first;

  while(++next != last)
  {
    if(wrapped_pred(*next))
    {
      iter_swap(first, next);
      ++first;
    }
  }

  return first;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(sequential::execution_policy<DerivedPolicy> &,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil_first,
                            Predicate pred)
{
  if(first == last)
    return first;


  thrust::detail::wrapped_function<
    Predicate,
   
 
# 126 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
 
# 125 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
    bool
  > wrapped_pred(pred);

  while(wrapped_pred(*stencil_first))
  {
    ++stencil_first;
    if(++first == last)
    {
      return first;
    }
  }

  ForwardIterator next = first;


  ++stencil_first;

  while(++next != last)
  {
    if(wrapped_pred(*stencil_first))
    {
      iter_swap(first, next);
      ++first;
    }

    ++stencil_first;
  }

  return first;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(sequential::execution_policy<DerivedPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   Predicate pred)
{

  thrust::detail::wrapped_function<
    Predicate,
   
 
# 171 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
 
# 170 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
    bool
  > wrapped_pred(pred);

  typedef typename thrust::iterator_value<ForwardIterator>::type T;

  typedef thrust::detail::temporary_array<T,DerivedPolicy> TempRange;
  typedef typename TempRange::iterator TempIterator;

  TempRange temp(exec, first, last);

  for(TempIterator iter = temp.begin(); iter != temp.end(); ++iter)
  {
    if(wrapped_pred(*iter))
    {
      *first = *iter;
      ++first;
    }
  }

  ForwardIterator middle = first;

  for(TempIterator iter = temp.begin(); iter != temp.end(); ++iter)
  {
    if(!wrapped_pred(*iter))
    {
      *first = *iter;
      ++first;
    }
  }

  return middle;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(sequential::execution_policy<DerivedPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   InputIterator stencil,
                                   Predicate pred)
{

  thrust::detail::wrapped_function<
    Predicate,
   
 
# 220 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
 
# 219 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
    bool
  > wrapped_pred(pred);

  typedef typename thrust::iterator_value<ForwardIterator>::type T;

  typedef thrust::detail::temporary_array<T,DerivedPolicy> TempRange;
  typedef typename TempRange::iterator TempIterator;

  TempRange temp(exec, first, last);

  InputIterator stencil_iter = stencil;
  for(TempIterator iter = temp.begin(); iter != temp.end(); ++iter, ++stencil_iter)
  {
    if(wrapped_pred(*stencil_iter))
    {
      *first = *iter;
      ++first;
    }
  }

  ForwardIterator middle = first;
  stencil_iter = stencil;

  for(TempIterator iter = temp.begin(); iter != temp.end(); ++iter, ++stencil_iter)
  {
    if(!wrapped_pred(*stencil_iter))
    {
      *first = *iter;
      ++first;
    }
  }

  return middle;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(sequential::execution_policy<DerivedPolicy> &,
                          InputIterator first,
                          InputIterator last,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred)
{

  thrust::detail::wrapped_function<
    Predicate,
   
 
# 274 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
 
# 273 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
    bool
  > wrapped_pred(pred);

  for(; first != last; ++first)
  {
    if(wrapped_pred(*first))
    {
      *out_true = *first;
      ++out_true;
    }
    else
    {
      *out_false = *first;
      ++out_false;
    }
  }

  return thrust::make_pair(out_true, out_false);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(sequential::execution_policy<DerivedPolicy> &,
                          InputIterator1 first,
                          InputIterator1 last,
                          InputIterator2 stencil,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred)
{

  thrust::detail::wrapped_function<
    Predicate,
   
 
# 315 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
 
# 314 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/partition.h"
    bool
  > wrapped_pred(pred);

  for(; first != last; ++first, ++stencil)
  {
    if(wrapped_pred(*stencil))
    {
      *out_true = *first;
      ++out_true;
    }
    else
    {
      *out_false = *first;
      ++out_false;
    }
  }

  return thrust::make_pair(out_true, out_false);
}


}
}
}
}
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_primitive_sort.inl" 2



namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{
namespace stable_primitive_sort_detail
{


template<typename Iterator>
  struct enable_if_bool_sort
    : thrust::detail::enable_if<
        thrust::detail::is_same<
          bool,
          typename thrust::iterator_value<Iterator>::type
        >::value
      >
{};


template<typename Iterator>
  struct disable_if_bool_sort
    : thrust::detail::disable_if<
        thrust::detail::is_same<
          bool,
          typename thrust::iterator_value<Iterator>::type
        >::value
      >
{};



template<typename DerivedPolicy,
         typename RandomAccessIterator>
  typename enable_if_bool_sort<RandomAccessIterator>::type
__attribute__((host)) __attribute__((device))
    stable_primitive_sort(sequential::execution_policy<DerivedPolicy> &exec,
                          RandomAccessIterator first, RandomAccessIterator last)
{


  sequential::stable_partition(exec, first, last, thrust::logical_not<bool>());
}


template<typename DerivedPolicy,
         typename RandomAccessIterator>
  typename disable_if_bool_sort<RandomAccessIterator>::type
__attribute__((host)) __attribute__((device))
    stable_primitive_sort(sequential::execution_policy<DerivedPolicy> &exec,
                          RandomAccessIterator first, RandomAccessIterator last)
{

  sequential::stable_radix_sort(exec,first,last);
}


struct logical_not_first
{
  template<typename Tuple>
  __attribute__((host)) __attribute__((device))
  bool operator()(Tuple t)
  {
    return !thrust::get<0>(t);
  }
};


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  typename enable_if_bool_sort<RandomAccessIterator1>::type
__attribute__((host)) __attribute__((device))
    stable_primitive_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                                 RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last,
                                 RandomAccessIterator2 values_first)
{


  sequential::stable_partition(exec,
                               thrust::make_zip_iterator(thrust::make_tuple(keys_first, values_first)),
                               thrust::make_zip_iterator(thrust::make_tuple(keys_last, values_first)),
                               logical_not_first());
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  typename disable_if_bool_sort<RandomAccessIterator1>::type
__attribute__((host)) __attribute__((device))
    stable_primitive_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                                 RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last,
                                 RandomAccessIterator2 values_first)
{

  sequential::stable_radix_sort_by_key(exec, keys_first, keys_last, values_first);
}


}


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort(sequential::execution_policy<DerivedPolicy> &exec,
                           RandomAccessIterator first,
                           RandomAccessIterator last)
{
  stable_primitive_sort_detail::stable_primitive_sort(exec, first,last);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                                  RandomAccessIterator1 keys_first,
                                  RandomAccessIterator1 keys_last,
                                  RandomAccessIterator2 values_first)
{
  stable_primitive_sort_detail::stable_primitive_sort_by_key(exec, keys_first, keys_last, values_first);
}


}
}
}
}
# 56 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/stable_primitive_sort.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sort.inl" 2

namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{
namespace sort_detail
{







template<typename KeyType, typename Compare>
struct needs_reverse
  : thrust::detail::integral_constant<
      bool,
      thrust::detail::is_same<Compare, typename thrust::greater<KeyType> >::value
    >
{};


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort(sequential::execution_policy<DerivedPolicy> &exec,
                 RandomAccessIterator first,
                 RandomAccessIterator last,
                 StrictWeakOrdering comp,
                 thrust::detail::true_type)
{
  thrust::system::detail::sequential::stable_primitive_sort(exec, first, last);


  typedef typename thrust::iterator_traits<RandomAccessIterator>::value_type KeyType;

  if(needs_reverse<KeyType,StrictWeakOrdering>::value)
  {
    thrust::reverse(exec, first, last);
  }
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                        RandomAccessIterator1 first1,
                        RandomAccessIterator1 last1,
                        RandomAccessIterator2 first2,
                        StrictWeakOrdering comp,
                        thrust::detail::true_type)
{

  typedef typename thrust::iterator_traits<RandomAccessIterator1>::value_type KeyType;


  if(needs_reverse<KeyType,StrictWeakOrdering>::value)
  {
    thrust::reverse(exec, first1, last1);
    thrust::reverse(exec, first2, first2 + (last1 - first1));
  }

  thrust::system::detail::sequential::stable_primitive_sort_by_key(exec, first1, last1, first2);

  if(needs_reverse<KeyType,StrictWeakOrdering>::value)
  {
    thrust::reverse(exec, first1, last1);
    thrust::reverse(exec, first2, first2 + (last1 - first1));
  }
}







template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort(sequential::execution_policy<DerivedPolicy> &exec,
                 RandomAccessIterator first,
                 RandomAccessIterator last,
                 StrictWeakOrdering comp,
                 thrust::detail::false_type)
{
  thrust::system::detail::sequential::stable_merge_sort(exec, first, last, comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                        RandomAccessIterator1 first1,
                        RandomAccessIterator1 last1,
                        RandomAccessIterator2 first2,
                        StrictWeakOrdering comp,
                        thrust::detail::false_type)
{
  thrust::system::detail::sequential::stable_merge_sort_by_key(exec, first1, last1, first2, comp);
}


template<typename KeyType, typename Compare>
struct use_primitive_sort
  : thrust::detail::and_<
      thrust::detail::is_arithmetic<KeyType>,
      thrust::detail::or_<
        thrust::detail::is_same<Compare, thrust::less<KeyType> >,
        thrust::detail::is_same<Compare, thrust::greater<KeyType> >
      >
    >
{};


}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort(sequential::execution_policy<DerivedPolicy> &exec,
                 RandomAccessIterator first,
                 RandomAccessIterator last,
                 StrictWeakOrdering comp)
{
  typedef typename thrust::iterator_traits<RandomAccessIterator>::value_type KeyType;



  sort_detail::use_primitive_sort<KeyType,StrictWeakOrdering> use_primitive_sort;




  sort_detail::stable_sort(exec, first, last, comp, use_primitive_sort);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort_by_key(sequential::execution_policy<DerivedPolicy> &exec,
                        RandomAccessIterator1 first1,
                        RandomAccessIterator1 last1,
                        RandomAccessIterator2 first2,
                        StrictWeakOrdering comp)
{
  typedef typename thrust::iterator_traits<RandomAccessIterator1>::value_type KeyType;



  sort_detail::use_primitive_sort<KeyType,StrictWeakOrdering> use_primitive_sort;




  sort_detail::stable_sort_by_key(exec, first1, last1, first2, comp, use_primitive_sort);
}


}
}
}
}
# 64 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sort.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/sort.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/sort.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/sort.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/sort.h" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/sort.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/sort.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort(execution_policy<DerivedPolicy> &exec,
                 RandomAccessIterator first,
                 RandomAccessIterator last,
                 StrictWeakOrdering comp);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort_by_key(execution_policy<DerivedPolicy> &exec,
                        RandomAccessIterator1 keys_first,
                        RandomAccessIterator1 keys_last,
                        RandomAccessIterator2 values_first,
                        StrictWeakOrdering comp);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/sort.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/sort.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_merge_sort.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_merge_sort.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{

template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_merge_sort(execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator first,
                       RandomAccessIterator last,
                       StrictWeakOrdering comp);

template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_merge_sort_by_key(execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 keys_begin,
                              RandomAccessIterator1 keys_end,
                              RandomAccessIterator2 values_begin,
                              StrictWeakOrdering comp);

}
}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_merge_sort.inl" 1
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_merge_sort.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_sort_each.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_sort_each.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{


template<unsigned int work_per_thread,
         typename DerivedPolicy,
         typename Context,
         typename RandomAccessIterator1,
         typename Pointer,
         typename RandomAccessIterator2,
         typename Compare>
__attribute__((host)) __attribute__((device))
void stable_sort_each_copy(execution_policy<DerivedPolicy> &exec,
                           Context context,
                           unsigned int block_size,
                           RandomAccessIterator1 first, RandomAccessIterator1 last,
                           Pointer vitual_smem,
                           RandomAccessIterator2 result,
                           Compare comp);


}
}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_sort_each.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_sort_each.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/block/copy.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/block/copy.h"
       
# 32 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/block/copy.h"
namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace block
{

namespace trivial_copy_detail
{


template<typename Size>
  inline __attribute__((device)) thrust::pair<Size,Size> quotient_and_remainder(Size n, Size d)
{
  Size quotient = n / d;
  Size remainder = n - d * quotient;
  return thrust::make_pair(quotient,remainder);
}



template<typename Context,
         typename T>
__attribute__((device)) __inline__ __attribute__((always_inline))
void aligned_copy(Context context, T *dst, const T *src, unsigned int num_elements)
{
  for(unsigned int i = context.thread_index();
      i < num_elements;
      i += context.block_dimension())
  {
    dst[i] = src[i];
  }
}


}


template <typename Context>
__attribute__((device)) __inline__ __attribute__((always_inline))
void trivial_copy(Context context, void* destination_, const void* source_, size_t num_bytes)
{

  char* destination = reinterpret_cast<char*>(destination_);
  const char* source = reinterpret_cast<const char*>(source_);
# 93 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/block/copy.h"
  if(reinterpret_cast<size_t>(destination) % sizeof(uint2) != 0 || reinterpret_cast<size_t>(source) % sizeof(uint2) != 0)
  {
    for(unsigned int i = context.thread_index(); i < num_bytes; i += context.block_dimension())
    {
      destination[i] = source[i];
    }
  }
  else
  {




    const thrust::pair<size_t,size_t> num_wide_elements_and_remainder_bytes = trivial_copy_detail::quotient_and_remainder(num_bytes, sizeof(int2));


    trivial_copy_detail::aligned_copy(context,
                                      reinterpret_cast<int2*>(destination),
                                      reinterpret_cast<const int2*>(source),
                                      num_wide_elements_and_remainder_bytes.first);







    const char *remainder_first = reinterpret_cast<const char*>(source + sizeof(int2) * num_wide_elements_and_remainder_bytes.first);
          char *remainder_result = reinterpret_cast<char*>(destination + sizeof(int2) * num_wide_elements_and_remainder_bytes.first);

    trivial_copy_detail::aligned_copy(context, remainder_result, remainder_first, num_wide_elements_and_remainder_bytes.second);
  }
}


namespace detail
{
namespace dispatch
{

template<typename Context,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  __inline__ __attribute__((always_inline)) __attribute__((device))
  RandomAccessIterator2 copy(Context context,
                             RandomAccessIterator1 first,
                             RandomAccessIterator1 last,
                             RandomAccessIterator2 result,
                             thrust::detail::true_type is_trivial_copy)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type T;

  const T *src = &thrust::raw_reference_cast(*first);
        T *dst = &thrust::raw_reference_cast(*result);

  size_t n = (last - first);
  thrust::system::cuda::detail::block::trivial_copy(context, dst, src, n * sizeof(T));
  return result + n;
}

template<typename Context,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  __inline__ __attribute__((always_inline)) __attribute__((device))
  RandomAccessIterator2 copy(Context context,
                             RandomAccessIterator1 first,
                             RandomAccessIterator1 last,
                             RandomAccessIterator2 result,
                             thrust::detail::false_type is_trivial_copy)
{
  RandomAccessIterator2 end_of_output = result + (last - first);


  first += context.thread_index();
  result += context.thread_index();

  for(;
      first < last;
      first += context.block_dimension(),
      result += context.block_dimension())
  {
    thrust::raw_reference_cast(*result) = thrust::raw_reference_cast(*first);
  }

  return end_of_output;
}

}
}

template<typename Context,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  __inline__ __attribute__((always_inline)) __attribute__((device))
  RandomAccessIterator2 copy(Context context,
                             RandomAccessIterator1 first,
                             RandomAccessIterator1 last,
                             RandomAccessIterator2 result)
{
  return detail::dispatch::copy(context, first, last, result,


      thrust::detail::false_type()



      );
}


template<typename Context, typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2>
inline __attribute__((device))
RandomAccessIterator2 async_copy_n(Context &ctx, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result)
{
  for(Size i = ctx.thread_index(); i < n; i += ctx.block_dimension())
  {
    thrust::raw_reference_cast(result[i]) = thrust::raw_reference_cast(first[i]);
  }

  return result + n;
}


template<typename Context, typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2>
inline __attribute__((device))
RandomAccessIterator2 copy_n(Context &ctx, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result)
{
  result = async_copy_n(ctx, first, n, result);
  ctx.barrier();

  return result;
}


template<unsigned int work_per_thread, typename Context, typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2>
inline __attribute__((device))
RandomAccessIterator2 async_copy_n_global_to_shared(Context &ctx, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result)
{
  typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;


  value_type reg[work_per_thread];


  if(n >= ctx.block_dimension() * work_per_thread)
  {
    for(unsigned int i = 0; i < work_per_thread; ++i)
    {
      unsigned int idx = ctx.block_dimension() * i + ctx.thread_index();

      reg[i] = thrust::raw_reference_cast(first[idx]);
    }
  }
  else
  {
    for(unsigned int i = 0; i < work_per_thread; ++i)
    {
      unsigned int idx = ctx.block_dimension() * i + ctx.thread_index();

      if(idx < n) reg[i] = thrust::raw_reference_cast(first[idx]);
    }
  }


  if(n >= ctx.block_dimension() * work_per_thread)
  {
    for(unsigned int i = 0; i < work_per_thread; ++i)
    {
      unsigned int idx = ctx.block_dimension() * i + ctx.thread_index();

      thrust::raw_reference_cast(result[idx]) = reg[i];
    }
  }
  else
  {
    for(unsigned int i = 0; i < work_per_thread; ++i)
    {
      unsigned int idx = ctx.block_dimension() * i + ctx.thread_index();

      if(idx < n) thrust::raw_reference_cast(result[idx]) = reg[i];
    }
  }

  return result + n;
}


template<unsigned int work_per_thread, typename Context, typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2>
__attribute__((device))
RandomAccessIterator2 copy_n_global_to_shared(Context &ctx, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result)
{
  result = async_copy_n_global_to_shared<work_per_thread>(ctx, first, n, result);

  ctx.barrier();

  return result + n;
}


}
}
}
}
}
# 20 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_sort_each.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/merge.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/merge.h"
       




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{



template<unsigned int result_size_bound, typename Iterator1, typename Iterator2, typename Iterator3, typename Compare>
__attribute__((device))
void sequential_bounded_merge(Iterator1 first1, Iterator1 last1,
                              Iterator2 first2, Iterator2 last2,
                              Iterator3 result,
                              Compare comp)
{



  for(unsigned int i = 0; i < result_size_bound; ++i, ++result)
  {
    bool p = (first2 >= last2) || ((first1 < last1) && !comp(*first2, *first1));

    *result = p ? *first1 : *first2;

    if(p)
    {
      ++first1;
    }
    else
    {
      ++first2;
    }
  }
# 82 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/merge.h"
}


template<typename Size, typename Iterator1, typename Iterator2, typename Compare>
__attribute__((device))
Size merge_path(Size pos, Iterator1 first1, Size n1, Iterator2 first2, Size n2, Compare comp)
{
  Size begin = (pos >= n2) ? (pos - n2) : Size(0);
  Size end = thrust::min<Size>(pos, n1);

  while(begin < end)
  {
    Size mid = (begin + end) >> 1;

    if(comp(first2[pos - 1 - mid], first1[mid]))
    {
      end = mid;
    }
    else
    {
      begin = mid + 1;
    }
  }
  return begin;
}


}
}
}
}
}
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_sort_each.inl" 2




# 1 "/usr/local/cuda-8.0/include/thrust/detail/integer_math.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/detail/integer_math.h"
       





namespace thrust
{
namespace detail
{


template<typename Integer>
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
Integer clz(Integer x)
{


  int num_bits = 8 * sizeof(Integer);
  int num_bits_minus_one = num_bits - 1;

  for(int i = num_bits_minus_one; i >= 0; --i)
  {
    if((Integer(1) << i) & x)
    {
      return num_bits_minus_one - i;
    }
  }

  return num_bits;
}


template<typename Integer>
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
bool is_power_of_2(Integer x)
{
  return 0 == (x & (x - 1));
}


template<typename Integer>
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
Integer log2(Integer x)
{
  Integer num_bits = 8 * sizeof(Integer);
  Integer num_bits_minus_one = num_bits - 1;

  return num_bits_minus_one - clz(x);
}


template<typename Integer>
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
Integer log2_ri(Integer x)
{
  Integer result = log2(x);


  if(!is_power_of_2(x))
  {
    ++result;
  }

  return result;
}


template<typename Integer>
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
bool is_odd(Integer x)
{
  return 1 & x;
}


}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_sort_each.inl" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/virtualized_smem_closure.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/virtualized_smem_closure.h"
       


namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{


template<typename Closure, typename RandomAccessIterator>
  struct virtualized_smem_closure
    : Closure
{
  typedef Closure super_t;

  size_t num_elements_per_block;
  RandomAccessIterator virtual_smem;

  __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
  virtualized_smem_closure(Closure closure, size_t num_elements_per_block, RandomAccessIterator virtual_smem)
    : super_t(closure),
      num_elements_per_block(num_elements_per_block),
      virtual_smem(virtual_smem)
  {}

  __attribute__((device)) __inline__ __attribute__((always_inline))
  void operator()()
  {
    typename super_t::context_type ctx;

    RandomAccessIterator smem = virtual_smem + num_elements_per_block * ctx.block_index();

    super_t::operator()(smem);
  }
};


}
}
}
}
}
# 29 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_sort_each.inl" 2


namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{
namespace stable_sort_each_detail
{
namespace static_stable_odd_even_transpose_sort_detail
{


template<int i, int n>
struct impl
{
  template<typename Iterator, typename Compare>
  static __attribute__((device))
  void do_it(Iterator keys, Compare comp)
  {
    for(int j = 1 & i; j < n - 1; j += 2)
    {
      if(comp(keys[j + 1], keys[j]))
      {
        using thrust::swap;

       swap(keys[j], keys[j + 1]);
      }
    }

    impl<i + 1, n>::do_it(keys, comp);
  }
};


template<int i>
struct impl<i,i>
{
  template<typename Iterator, typename Compare>
  static __attribute__((device))
  void do_it(Iterator, Compare) {}
};


}


template<int n, typename RandomAccessIterator, typename Compare>
__attribute__((device))
void static_stable_sort(RandomAccessIterator keys, Compare comp)
{
  static_stable_odd_even_transpose_sort_detail::impl<0,n>::do_it(keys, comp);
}



template<unsigned int bound_n, typename RandomAccessIterator1, typename Size, typename RandomAccessIterator2>
__attribute__((device))
void bounded_copy_n(RandomAccessIterator1 first, Size n, RandomAccessIterator2 result)
{
  for(unsigned int i = 0; i < bound_n; ++i)
  {
    if(i < n)
    {
      result[i] = first[i];
    }
  }
}


namespace block
{


template<unsigned int work_per_thread, typename Context, typename Iterator, typename Size, typename Compare>
__attribute__((device))
void bounded_inplace_merge_adjacent_partitions(Context &ctx,
                                               Iterator first,
                                               Size n,
                                               Compare comp)
{
  typedef typename thrust::iterator_value<Iterator>::type value_type;

  for(Size num_threads_per_merge = 2; num_threads_per_merge <= ctx.block_dimension(); num_threads_per_merge *= 2)
  {

    Size list = ~(num_threads_per_merge - 1) & ctx.thread_index();
    Size diag = thrust::min<Size>(n, work_per_thread * ((num_threads_per_merge - 1) & ctx.thread_index()));
    Size input_start = work_per_thread * list;


    Size input_size = work_per_thread * (num_threads_per_merge / 2);


    Size partition_first1 = thrust::min<Size>(n, input_start);
    Size partition_first2 = thrust::min<Size>(n, partition_first1 + input_size);
    Size partition_last2 = thrust::min<Size>(n, partition_first2 + input_size);

    Size n1 = partition_first2 - partition_first1;
    Size n2 = partition_last2 - partition_first2;

    Size mp = merge_path(diag, first + partition_first1, n1, first + partition_first2, n2, comp);


    value_type local_result[work_per_thread];
    sequential_bounded_merge<work_per_thread>(first + partition_first1 + mp, first + partition_first2,
                                              first + partition_first2 + diag - mp, first + partition_last2,
                                              local_result,
                                              comp);

    ctx.barrier();


    Size local_result_size = thrust::min<Size>(work_per_thread, n - (ctx.thread_index() * work_per_thread));


    bounded_copy_n<work_per_thread>(local_result, local_result_size, first + ctx.thread_index() * work_per_thread);

    ctx.barrier();
  }
}


template<unsigned int work_per_thread, typename Context, typename RandomAccessIterator, typename Size, typename Compare>
__attribute__((device))
void bounded_stable_sort(Context &ctx,
                         RandomAccessIterator first,
                         Size n,
                         Compare comp)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;


  Size local_tile_size = work_per_thread;
  if(work_per_thread * (ctx.thread_index() + 1) > n)
  {
    local_tile_size = thrust::max<Size>(0, n - (work_per_thread * ctx.thread_index()));
  }


  value_type local_keys[work_per_thread];
  bounded_copy_n<work_per_thread>(first + ctx.thread_index() * work_per_thread, local_tile_size, local_keys);


  if(local_tile_size < work_per_thread)
  {
    value_type max_key = local_keys[0];

    for(unsigned int i = 1; i < work_per_thread; ++i)
    {
      if(i < local_tile_size)
      {
        max_key = comp(max_key, local_keys[i]) ? local_keys[i] : max_key;
      }
    }


    for(unsigned int i = 0; i < work_per_thread; ++i)
    {
      if(i >= local_tile_size)
      {
        local_keys[i] = max_key;
      }
    }
  }


  if(work_per_thread * ctx.thread_index() < n)
  {
    static_stable_sort<work_per_thread>(local_keys, comp);
  }


  bounded_copy_n<work_per_thread>(local_keys, local_tile_size, first + ctx.thread_index() * work_per_thread);
  ctx.barrier();

  block::bounded_inplace_merge_adjacent_partitions<work_per_thread>(ctx, first, n, comp);
}


}


template<unsigned int work_per_thread,
         typename Context,
         typename RandomAccessIterator1,
         typename Size,
         typename RandomAccessIterator2,
         typename Compare>
struct stable_sort_each_copy_closure
{
  typedef Context context_type;

  RandomAccessIterator1 first;
  Size n;
  RandomAccessIterator2 result;
  thrust::detail::wrapped_function<Compare,bool> comp;

  __attribute__((host)) __attribute__((device))
  stable_sort_each_copy_closure(RandomAccessIterator1 first, Size n, RandomAccessIterator2 result, Compare comp)
    : first(first),
      n(n),
      result(result),
      comp(comp)
  {}


  template<typename RandomAccessIterator>
  __attribute__((device)) __inline__ __attribute__((always_inline))
  void operator()(RandomAccessIterator staging_buffer)
  {
    context_type ctx;

    unsigned int work_per_block = ctx.block_dimension() * work_per_thread;
    unsigned int offset = work_per_block * ctx.block_index();
    unsigned int tile_size = thrust::min<unsigned int>(work_per_block, n - offset);


    thrust::system::cuda::detail::block::copy_n_global_to_shared<work_per_thread>(ctx, first + offset, tile_size, staging_buffer);


    block::bounded_stable_sort<work_per_thread>(ctx, staging_buffer, tile_size, comp);


    thrust::system::cuda::detail::block::copy_n(ctx, staging_buffer, tile_size, result + offset);
  }


  __attribute__((device)) __inline__ __attribute__((always_inline))
  void operator()()
  {
    typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;



    value_type *s_keys = thrust::system::cuda::detail::extern_shared_ptr<value_type>();

    this->operator()(s_keys);
  }
};


}


template<unsigned int work_per_thread,
         typename DerivedPolicy,
         typename Context,
         typename RandomAccessIterator1,
         typename Pointer,
         typename RandomAccessIterator2,
         typename Compare>
__attribute__((host)) __attribute__((device))
void stable_sort_each_copy(execution_policy<DerivedPolicy> &exec,
                           Context context,
                           unsigned int block_size,
                           RandomAccessIterator1 first, RandomAccessIterator1 last,
                           Pointer virtual_smem,
                           RandomAccessIterator2 result,
                           Compare comp)
{
  typedef typename thrust::iterator_difference<RandomAccessIterator1>::type difference_type;

  difference_type n = last - first;

  int num_blocks = thrust::detail::util::divide_ri(n, block_size * work_per_thread);

  typedef stable_sort_each_detail::stable_sort_each_copy_closure<
    work_per_thread,
    Context,
    RandomAccessIterator1,
    difference_type,
    RandomAccessIterator2,
    Compare
  > closure_type;

  closure_type closure(first, n, result, comp);

  typedef typename thrust::iterator_value<RandomAccessIterator1>::type value_type;

  const size_t num_smem_elements_per_block = block_size * (work_per_thread + 1);


  if(virtual_smem)
  {
    virtualized_smem_closure<closure_type, Pointer> virtualized_closure(closure, num_smem_elements_per_block, virtual_smem);

    thrust::system::cuda::detail::detail::launch_closure(exec, virtualized_closure, num_blocks, block_size);
  }
  else
  {
    const size_t num_smem_bytes = num_smem_elements_per_block * sizeof(value_type);

    thrust::system::cuda::detail::detail::launch_closure(exec, closure, num_blocks, block_size, num_smem_bytes);
  }
}


}
}
}
}
}
# 58 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_sort_each.h" 2
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_merge_sort.inl" 2
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_merge_sort.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/temporary_indirect_permutation.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/temporary_indirect_permutation.h"
       


# 1 "/usr/local/cuda-8.0/include/thrust/sequence.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/sequence.h"
       




namespace thrust
{
# 71 "/usr/local/cuda-8.0/include/thrust/sequence.h"
template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  void sequence(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last);
# 108 "/usr/local/cuda-8.0/include/thrust/sequence.h"
template<typename ForwardIterator>
  void sequence(ForwardIterator first,
                ForwardIterator last);
# 152 "/usr/local/cuda-8.0/include/thrust/sequence.h"
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void sequence(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                T init);
# 193 "/usr/local/cuda-8.0/include/thrust/sequence.h"
template<typename ForwardIterator, typename T>
  void sequence(ForwardIterator first,
                ForwardIterator last,
                T init);
# 239 "/usr/local/cuda-8.0/include/thrust/sequence.h"
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void sequence(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                T init,
                T step);
# 282 "/usr/local/cuda-8.0/include/thrust/sequence.h"
template<typename ForwardIterator, typename T>
  void sequence(ForwardIterator first,
                ForwardIterator last,
                T init,
                T step);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/sequence.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/sequence.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sequence.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sequence.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  void sequence(thrust::execution_policy<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last);


template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void sequence(thrust::execution_policy<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                T init);


template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void sequence(thrust::execution_policy<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                T init,
                T step);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sequence.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sequence.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{
namespace sequence_detail
{


template<typename T>
struct sequence_functor
{
  T init, step;

  __attribute__((host)) __attribute__((device))
  sequence_functor(T init, T step)
    : init(init), step(step)
  {}

  template<typename Index>
  __attribute__((host)) __attribute__((device))
  T operator()(Index i) const
  {
    return init + step * i;
  }
};


}


template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  void sequence(thrust::execution_policy<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last)
{
  typedef typename thrust::iterator_traits<ForwardIterator>::value_type T;

  thrust::sequence(exec, first, last, T(0));
}


template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void sequence(thrust::execution_policy<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                T init)
{
  thrust::sequence(exec, first, last, init, T(1));
}


template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void sequence(thrust::execution_policy<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                T init,
                T step)
{

  thrust::tabulate(exec, first, last, sequence_detail::sequence_functor<T>(init, step));
}


}
}
}
}
# 64 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/sequence.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/sequence.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/sequence.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/sequence.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sequence.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/sequence.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/sequence.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/sequence.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  void sequence(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last)
{
  using thrust::system::detail::generic::sequence;
  return sequence(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void sequence(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                T init)
{
  using thrust::system::detail::generic::sequence;
  return sequence(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, init);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename T>
__attribute__((host)) __attribute__((device))
  void sequence(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                ForwardIterator first,
                ForwardIterator last,
                T init,
                T step)
{
  using thrust::system::detail::generic::sequence;
  return sequence(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, init, step);
}


template<typename ForwardIterator>
  void sequence(ForwardIterator first,
                ForwardIterator last)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::sequence(select_system(system), first, last);
}


template<typename ForwardIterator, typename T>
  void sequence(ForwardIterator first,
                ForwardIterator last,
                T init)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::sequence(select_system(system), first, last, init);
}


template<typename ForwardIterator, typename T>
  void sequence(ForwardIterator first,
                ForwardIterator last,
                T init,
                T step)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::sequence(select_system(system), first, last, init, step);
}


}
# 296 "/usr/local/cuda-8.0/include/thrust/sequence.h" 2
# 21 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/temporary_indirect_permutation.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/gather.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/gather.h"
       




namespace thrust
{
# 84 "/usr/local/cuda-8.0/include/thrust/gather.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename RandomAccessIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator gather(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                        InputIterator map_first,
                        InputIterator map_last,
                        RandomAccessIterator input_first,
                        OutputIterator result);
# 137 "/usr/local/cuda-8.0/include/thrust/gather.h"
template<typename InputIterator,
         typename RandomAccessIterator,
         typename OutputIterator>
  OutputIterator gather(InputIterator map_first,
                        InputIterator map_last,
                        RandomAccessIterator input_first,
                        OutputIterator result);
# 202 "/usr/local/cuda-8.0/include/thrust/gather.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator gather_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                           InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result);
# 266 "/usr/local/cuda-8.0/include/thrust/gather.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator>
  OutputIterator gather_if(InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result);
# 345 "/usr/local/cuda-8.0/include/thrust/gather.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator gather_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                           InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result,
                           Predicate pred);
# 423 "/usr/local/cuda-8.0/include/thrust/gather.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator,
         typename Predicate>
  OutputIterator gather_if(InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result,
                           Predicate pred);




}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/gather.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/gather.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/gather.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/gather.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename RandomAccessIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator gather(thrust::execution_policy<DerivedPolicy> &exec,
                        InputIterator map_first,
                        InputIterator map_last,
                        RandomAccessIterator input_first,
                        OutputIterator result);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator gather_if(thrust::execution_policy<DerivedPolicy> &exec,
                           InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator gather_if(thrust::execution_policy<DerivedPolicy> &exec,
                           InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result,
                           Predicate pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/gather.inl" 1
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/gather.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename RandomAccessIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator gather(thrust::execution_policy<DerivedPolicy> &exec,
                        InputIterator map_first,
                        InputIterator map_last,
                        RandomAccessIterator input_first,
                        OutputIterator result)
{
  return thrust::transform(exec,
                           thrust::make_permutation_iterator(input_first, map_first),
                           thrust::make_permutation_iterator(input_first, map_last),
                           result,
                           thrust::identity<typename thrust::iterator_value<RandomAccessIterator>::type>());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator gather_if(thrust::execution_policy<DerivedPolicy> &exec,
                           InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result)
{
  typedef typename thrust::iterator_value<InputIterator2>::type StencilType;
  return thrust::gather_if(exec,
                           map_first,
                           map_last,
                           stencil,
                           input_first,
                           result,
                           thrust::identity<StencilType>());
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator gather_if(thrust::execution_policy<DerivedPolicy> &exec,
                           InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result,
                           Predicate pred)
{
  typedef typename thrust::iterator_value<RandomAccessIterator>::type InputType;
  return thrust::transform_if(exec,
                              thrust::make_permutation_iterator(input_first, map_first),
                              thrust::make_permutation_iterator(input_first, map_last),
                              stencil,
                              result,
                              thrust::identity<InputType>(),
                              pred);
}


}
}
}
}
# 81 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/gather.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/gather.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/gather.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/gather.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/gather.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/gather.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/gather.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/gather.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename RandomAccessIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator gather(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                        InputIterator map_first,
                        InputIterator map_last,
                        RandomAccessIterator input_first,
                        OutputIterator result)
{
  using thrust::system::detail::generic::gather;
  return gather(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), map_first, map_last, input_first, result);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator>
__attribute__((host)) __attribute__((device))
  OutputIterator gather_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                           InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result)
{
  using thrust::system::detail::generic::gather_if;
  return gather_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), map_first, map_last, stencil, input_first, result);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator gather_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                           InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result,
                           Predicate pred)
{
  using thrust::system::detail::generic::gather_if;
  return gather_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), map_first, map_last, stencil, input_first, result, pred);
}


template<typename InputIterator,
         typename RandomAccessIterator,
         typename OutputIterator>
  OutputIterator gather(InputIterator map_first,
                        InputIterator map_last,
                        RandomAccessIterator input_first,
                        OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<RandomAccessIterator>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::gather(select_system(system1,system2,system3), map_first, map_last, input_first, result);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator>
  OutputIterator gather_if(InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<RandomAccessIterator>::type System3;
  typedef typename thrust::iterator_system<OutputIterator>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::gather_if(select_system(system1,system2,system3,system4), map_first, map_last, stencil, input_first, result);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename RandomAccessIterator,
         typename OutputIterator,
         typename Predicate>
  OutputIterator gather_if(InputIterator1 map_first,
                           InputIterator1 map_last,
                           InputIterator2 stencil,
                           RandomAccessIterator input_first,
                           OutputIterator result,
                           Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<RandomAccessIterator>::type System3;
  typedef typename thrust::iterator_system<OutputIterator>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::gather_if(select_system(system1,system2,system3,system4), map_first, map_last, stencil, input_first, result, pred);
}


}
# 441 "/usr/local/cuda-8.0/include/thrust/gather.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/temporary_indirect_permutation.h" 2


namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{


template<typename DerivedPolicy, typename RandomAccessIterator>
  struct temporary_indirect_permutation
{
  private:
    typedef unsigned int size_type;
    typedef thrust::detail::temporary_array<size_type, DerivedPolicy> array_type;

  public:
    __attribute__((host)) __attribute__((device))
    temporary_indirect_permutation(thrust::execution_policy<DerivedPolicy> &exec, RandomAccessIterator first, RandomAccessIterator last)
      : m_exec(derived_cast(exec)),
        m_src_first(first),
        m_src_last(last),
        m_permutation(0, m_exec, last - first)
    {

      thrust::sequence(exec, m_permutation.begin(), m_permutation.end());
    }

    __attribute__((host)) __attribute__((device))
    ~temporary_indirect_permutation()
    {

      typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;
      thrust::detail::temporary_array<value_type, DerivedPolicy> temp(m_exec, m_src_first, m_src_last);
      thrust::gather(m_exec, m_permutation.begin(), m_permutation.end(), temp.begin(), m_src_first);
    }

    typedef typename array_type::iterator iterator;

    __attribute__((host)) __attribute__((device))
    iterator begin()
    {
      return m_permutation.begin();
    }

    __attribute__((host)) __attribute__((device))
    iterator end()
    {
      return m_permutation.end();
    }

  private:
    DerivedPolicy &m_exec;
    RandomAccessIterator m_src_first, m_src_last;
    thrust::detail::temporary_array<size_type, DerivedPolicy> m_permutation;
};


template<typename DerivedPolicy, typename RandomAccessIterator>
  struct iterator_range_with_execution_policy
{
  __attribute__((host)) __attribute__((device))
  iterator_range_with_execution_policy(thrust::execution_policy<DerivedPolicy> &exec, RandomAccessIterator first, RandomAccessIterator last)
    : m_exec(derived_cast(exec)), m_first(first), m_last(last)
  {}

  typedef RandomAccessIterator iterator;

  __attribute__((host)) __attribute__((device))
  iterator begin()
  {
    return m_first;
  }

  __attribute__((host)) __attribute__((device))
  iterator end()
  {
    return m_last;
  }

  __attribute__((host)) __attribute__((device))
  DerivedPolicy &exec()
  {
    return m_exec;
  }

  DerivedPolicy &m_exec;
  RandomAccessIterator m_first, m_last;
};


template<typename Condition, typename DerivedPolicy, typename RandomAccessIterator>
  struct conditional_temporary_indirect_permutation
    : thrust::detail::eval_if<
        Condition::value,
        thrust::detail::identity_<temporary_indirect_permutation<DerivedPolicy, RandomAccessIterator> >,
        thrust::detail::identity_<iterator_range_with_execution_policy<DerivedPolicy, RandomAccessIterator> >
      >::type
{
  typedef typename thrust::detail::eval_if<
    Condition::value,
    thrust::detail::identity_<temporary_indirect_permutation<DerivedPolicy, RandomAccessIterator> >,
    thrust::detail::identity_<iterator_range_with_execution_policy<DerivedPolicy, RandomAccessIterator> >
  >::type super_t;

  __attribute__((host)) __attribute__((device))
  conditional_temporary_indirect_permutation(thrust::execution_policy<DerivedPolicy> &exec, RandomAccessIterator first, RandomAccessIterator last)
    : super_t(exec, first, last)
  {}
};


template<typename DerivedPolicy, typename RandomAccessIterator, typename Compare>
  struct temporary_indirect_ordering
    : temporary_indirect_permutation<DerivedPolicy,RandomAccessIterator>
{
  private:
    typedef temporary_indirect_permutation<DerivedPolicy,RandomAccessIterator> super_t;

  public:
    __attribute__((host)) __attribute__((device))
    temporary_indirect_ordering(thrust::execution_policy<DerivedPolicy> &exec, RandomAccessIterator first, RandomAccessIterator last, Compare comp)
      : super_t(exec, first, last),
        m_comp(first, comp)
    {}

    struct compare
    {
      RandomAccessIterator first;

      thrust::detail::wrapped_function<
        Compare,
       
     
# 158 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/temporary_indirect_permutation.h"
     
# 157 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/temporary_indirect_permutation.h"
        bool
      > comp;

      __attribute__((host)) __attribute__((device))
      compare(RandomAccessIterator first, Compare comp)
        : first(first), comp(comp)
      {}

      template<typename Integral>
      __attribute__((host)) __attribute__((device))
      bool operator()(Integral a, Integral b)
      {
        return comp(first[a], first[b]);
      }
    };

    __attribute__((host)) __attribute__((device))
    compare comp() const
    {
      return m_comp;
    }

  private:
    compare m_comp;
};


template<typename DerivedPolicy, typename RandomAccessIterator, typename Compare>
  struct iterator_range_with_execution_policy_and_compare
    : iterator_range_with_execution_policy<DerivedPolicy, RandomAccessIterator>
{
  typedef iterator_range_with_execution_policy<DerivedPolicy, RandomAccessIterator> super_t;

  __attribute__((host)) __attribute__((device))
  iterator_range_with_execution_policy_and_compare(thrust::execution_policy<DerivedPolicy> &exec, RandomAccessIterator first, RandomAccessIterator last, Compare comp)
    : super_t(exec, first, last), m_comp(comp)
  {}

  typedef Compare compare;

  __attribute__((host)) __attribute__((device))
  compare comp()
  {
    return m_comp;
  }

  Compare m_comp;
};


template<typename Condition, typename DerivedPolicy, typename RandomAccessIterator, typename Compare>
  struct conditional_temporary_indirect_ordering
    : thrust::detail::eval_if<
        Condition::value,
        thrust::detail::identity_<temporary_indirect_ordering<DerivedPolicy, RandomAccessIterator, Compare> >,
        thrust::detail::identity_<iterator_range_with_execution_policy_and_compare<DerivedPolicy, RandomAccessIterator, Compare> >
      >::type
{
  typedef typename thrust::detail::eval_if<
    Condition::value,
    thrust::detail::identity_<temporary_indirect_ordering<DerivedPolicy, RandomAccessIterator, Compare> >,
    thrust::detail::identity_<iterator_range_with_execution_policy_and_compare<DerivedPolicy, RandomAccessIterator, Compare> >
  >::type super_t;

  __attribute__((host)) __attribute__((device))
  conditional_temporary_indirect_ordering(thrust::execution_policy<DerivedPolicy> &exec, RandomAccessIterator first, RandomAccessIterator last, Compare comp)
    : super_t(exec, first, last, comp)
  {}
};


}
}
}
}
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_merge_sort.inl" 2




namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{
namespace stable_merge_sort_detail
{
namespace block
{



template<unsigned int work_per_thread,
         typename Context,
         typename Iterator,
         typename Size,
         typename Compare>
__attribute__((device))
void bounded_inplace_merge(Context &ctx, Iterator first, Size n1, Size n2, Compare comp)
{
  Iterator first2 = first + n1;


  Size diag = thrust::min<Size>(n1 + n2, work_per_thread * ctx.thread_index());

  Size mp = merge_path(diag, first, n1, first2, n2, comp);


  Size start1 = mp;
  Size start2 = diag - mp;

  Size end1 = n1;
  Size end2 = n2;


  typedef typename thrust::iterator_value<Iterator>::type value_type;
  value_type local_result[work_per_thread];
  sequential_bounded_merge<work_per_thread>(first + start1, first + end1,
                                            first2 + start2, first2 + end2,
                                            local_result, comp);

  ctx.barrier();



  thrust::copy_n(thrust::seq, local_result, work_per_thread, first + work_per_thread * ctx.thread_index());
  ctx.barrier();
}



template<unsigned int work_per_thread,
         typename Context,
         typename Iterator1, typename Size1,
         typename Iterator2, typename Size2,
         typename Iterator3,
         typename Iterator4,
  typename Compare>
__attribute__((device))
void staged_bounded_merge(Context &ctx,
                          Iterator1 first1, Size1 n1,
                          Iterator2 first2, Size2 n2,
                          Iterator3 staging_buffer,
                          Iterator4 result,
                          Compare comp)
{

  cuda::detail::block::async_copy_n_global_to_shared<work_per_thread>(ctx, first1, n1, staging_buffer);
  cuda::detail::block::async_copy_n_global_to_shared<work_per_thread>(ctx, first2, n2, staging_buffer + n1);
  ctx.barrier();


  block::bounded_inplace_merge<work_per_thread>(ctx, staging_buffer, n1, n2, comp);


  cuda::detail::block::copy_n(ctx, staging_buffer, n1 + n2, result);
}


}



inline __attribute__((host)) __attribute__((device))
thrust::tuple<int,int,int,int> find_mergesort_interval(int partition_first1, int partition_size, int num_blocks_per_merge, int block_idx, int num_elements_per_block, int n, int mp, int right_mp)
{
  int partition_first2 = partition_first1 + partition_size;


  int diag = num_elements_per_block * block_idx - partition_first1;
  int start1 = partition_first1 + mp;
  int end1 = thrust::min<int>(n, partition_first1 + right_mp);
  int start2 = thrust::min<int>(n, partition_first2 + diag - mp);
  int end2 = thrust::min<int>(n, partition_first2 + diag + num_elements_per_block - right_mp);






  if(num_blocks_per_merge - 1 == ((num_blocks_per_merge - 1) & block_idx))
  {
    end1 = thrust::min<int>(n, partition_first1 + partition_size);
    end2 = thrust::min<int>(n, partition_first2 + partition_size);
  }

  return thrust::make_tuple(start1, end1, start2, end2);
}


inline __attribute__((host)) __attribute__((device))
thrust::tuple<int,int,int,int> locate_merge_partitions(int n, int block_idx, int num_blocks_per_merge, int num_elements_per_block, int mp, int right_mp)
{
  int first_block_in_partition = ~(num_blocks_per_merge - 1) & block_idx;
  int partition_size = num_elements_per_block * (num_blocks_per_merge >> 1);

  int partition_first1 = num_elements_per_block * first_block_in_partition;

  return find_mergesort_interval(partition_first1, partition_size, num_blocks_per_merge, block_idx, num_elements_per_block, n, mp, right_mp);
}


template<unsigned int work_per_thread,
         typename Context,
         typename Size,
         typename Iterator1,
         typename Iterator2,
         typename Iterator3,
         typename Compare>
struct merge_adjacent_partitions_closure
{
  typedef Context context_type;

  Size num_blocks_per_merge;
  Iterator1 first;
  Size n;
  Iterator2 merge_paths;
  Iterator3 result;
  thrust::detail::wrapped_function<Compare,bool> comp;


  __attribute__((host)) __attribute__((device))
  merge_adjacent_partitions_closure(Size num_blocks_per_merge, Iterator1 first, Size n, Iterator2 merge_paths, Iterator3 result, Compare comp)
    : num_blocks_per_merge(num_blocks_per_merge),
      first(first),
      n(n),
      merge_paths(merge_paths),
      result(result),
      comp(comp)
  {}


  template<typename RandomAccessIterator>
  __inline__ __attribute__((always_inline)) __attribute__((device))
  void operator()(RandomAccessIterator staging_buffer)
  {
    context_type ctx;

    Size work_per_block = ctx.block_dimension() * work_per_thread;

    Size start1 = 0, end1 = 0, start2 = 0, end2 = 0;

    thrust::tie(start1,end1,start2,end2) =
      locate_merge_partitions(n, ctx.block_index(), num_blocks_per_merge, work_per_block, thrust::raw_reference_cast(merge_paths[ctx.block_index()]), thrust::raw_reference_cast(merge_paths[ctx.block_index() + 1]));

    block::staged_bounded_merge<work_per_thread>(ctx,
                                                 first + start1, end1 - start1,
                                                 first + start2, end2 - start2,
                                                 staging_buffer,
                                                 result + ctx.block_index() * work_per_block,
                                                 comp);
  }


  __inline__ __attribute__((always_inline)) __attribute__((device))
  void operator()()
  {
    typedef typename thrust::iterator_value<Iterator1>::type value_type;



    value_type *s_keys = thrust::system::cuda::detail::extern_shared_ptr<value_type>();

    this->operator()(s_keys);
  }
};


template<unsigned int work_per_thread,
         typename DerivedPolicy,
         typename Context,
         typename Size,
         typename Iterator1,
         typename Iterator2,
         typename Pointer,
         typename Iterator3,
         typename Compare>
__attribute__((host)) __attribute__((device))
void merge_adjacent_partitions(thrust::system::cuda::execution_policy<DerivedPolicy> &exec,
                               Context context,
                               unsigned int block_size,
                               Size num_blocks_per_merge,
                               Iterator1 first,
                               Size n,
                               Iterator2 merge_paths,
                               Pointer virtual_smem,
                               Iterator3 result,
                               Compare comp)
{
  typedef merge_adjacent_partitions_closure<
    work_per_thread,
    Context,
    Size,
    Iterator1,
    Iterator2,
    Iterator3,
    Compare
  > closure_type;

  closure_type closure(num_blocks_per_merge, first, n, merge_paths, result, comp);

  Size num_blocks = thrust::detail::util::divide_ri(n, block_size * work_per_thread);

  typedef typename thrust::iterator_value<Iterator1>::type value_type;

  const size_t num_smem_elements_per_block = block_size * (work_per_thread + 1);


  if(virtual_smem)
  {
    virtualized_smem_closure<closure_type, Pointer> virtualized_closure(closure, num_smem_elements_per_block, virtual_smem);

    thrust::system::cuda::detail::detail::launch_closure(exec, virtualized_closure, num_blocks, block_size);
  }
  else
  {
    const size_t num_smem_bytes = num_smem_elements_per_block * sizeof(value_type);

    thrust::system::cuda::detail::detail::launch_closure(exec, closure, num_blocks, block_size, num_smem_bytes);
  }
}


template<typename Iterator, typename Size, typename Compare>
struct locate_merge_path
{
  Iterator haystack_first;
  Size haystack_size;
  Size num_elements_per_block;
  Size num_blocks_per_merge;
  thrust::detail::wrapped_function<Compare,bool> comp;

  __attribute__((host)) __attribute__((device))
  locate_merge_path(Iterator haystack_first, Size haystack_size, Size num_elements_per_block, Size num_blocks_per_merge, Compare comp)
    : haystack_first(haystack_first),
      haystack_size(haystack_size),
      num_elements_per_block(num_elements_per_block),
      num_blocks_per_merge(num_blocks_per_merge),
      comp(comp)
  {}

  template<typename Index>
  __attribute__((host)) __attribute__((device))
  Index operator()(Index merge_path_idx)
  {

    Size first_block_in_partition = ~(num_blocks_per_merge - 1) & merge_path_idx;


    Size size = num_elements_per_block * (num_blocks_per_merge / 2);


    Size start1 = num_elements_per_block * first_block_in_partition;
    Size start2 = thrust::min<Size>(haystack_size, start1 + size);



    Size n1 = thrust::min<Size>(size, haystack_size - start1);
    Size n2 = thrust::min<Size>(size, haystack_size - start2);


    Size diag = thrust::min<Size>(n1 + n2, num_elements_per_block * merge_path_idx - start1);

    return merge_path(diag, haystack_first + start1, n1, haystack_first + start2, n2, comp);
  }
};


template<typename DerivedPolicy, typename Iterator1, typename Size1, typename Iterator2, typename Size2, typename Compare>
__attribute__((host)) __attribute__((device))
void locate_merge_paths(thrust::system::cuda::execution_policy<DerivedPolicy> &exec,
                        Iterator1 result,
                        Size1 n,
                        Iterator2 haystack_first,
                        Size2 haystack_size,
                        Size2 num_elements_per_block,
                        Size2 num_blocks_per_merge,
                        Compare comp)
{
  locate_merge_path<Iterator2,Size2,Compare> f(haystack_first, haystack_size, num_elements_per_block, num_blocks_per_merge, comp);

  thrust::tabulate(exec, result, result + n, f);
}


template<typename T>
__attribute__((host)) __attribute__((device))
bool virtualize_smem(size_t num_elements_per_block)
{

  size_t num_smem_bytes_required = num_elements_per_block * sizeof(T);

  thrust::system::cuda::detail::device_properties_t props = thrust::system::cuda::detail::device_properties();

  size_t num_smem_bytes_available = props.sharedMemPerBlock;
  if(props.major == 1)
  {

    num_smem_bytes_available -= 256;
  }

  return num_smem_bytes_required > num_smem_bytes_available;





}


template<typename DerivedPolicy, typename RandomAccessIterator, typename Size, typename Compare>
__attribute__((host)) __attribute__((device))
void stable_merge_sort_n(thrust::system::cuda::execution_policy<DerivedPolicy> &exec,
                         RandomAccessIterator first,
                         Size n,
                         Compare comp)
{
  if(n <= 0) return;

  typedef typename thrust::iterator_value<RandomAccessIterator>::type T;

  const Size block_size = 256;

  typedef thrust::system::cuda::detail::detail::statically_blocked_thread_array<block_size> context_type;

  context_type context;

  const Size work_per_thread = (sizeof(T) < 8) ? 11 : 7;
  const Size work_per_block = block_size * work_per_thread;

  Size num_blocks = thrust::detail::util::divide_ri(n, work_per_block);

  const unsigned int num_smem_elements_per_block = block_size * (work_per_thread + 1);

  thrust::detail::temporary_array<T,DerivedPolicy> virtual_smem(exec, virtualize_smem<T>(num_smem_elements_per_block) ? (num_blocks * num_smem_elements_per_block) : 0);




  bool ping = false;
  thrust::detail::temporary_array<T,DerivedPolicy> pong_buffer(exec, n);

  Size num_passes = thrust::detail::log2_ri(num_blocks);

  if(thrust::detail::is_odd(num_passes))
  {
    stable_sort_each_copy<work_per_thread>(exec, context, block_size, first, first + n, thrust::raw_pointer_cast(&*virtual_smem.begin()), pong_buffer.begin(), comp);
  }
  else
  {
    stable_sort_each_copy<work_per_thread>(exec, context, block_size, first, first + n, thrust::raw_pointer_cast(&*virtual_smem.begin()), first, comp);
    ping = true;
  }

  thrust::detail::temporary_array<Size,DerivedPolicy> merge_paths(exec, num_blocks + 1);

  for(Size pass = 0; pass < num_passes; ++pass, ping = !ping)
  {
    Size num_blocks_per_merge = 2 << pass;

    if(ping)
    {
      locate_merge_paths(exec, merge_paths.begin(), merge_paths.size(), first, n, work_per_block, num_blocks_per_merge, comp);

      merge_adjacent_partitions<work_per_thread>(exec, context, block_size, num_blocks_per_merge, first, n, merge_paths.begin(), thrust::raw_pointer_cast(&*virtual_smem.begin()), pong_buffer.begin(), comp);
    }
    else
    {
      locate_merge_paths(exec, merge_paths.begin(), merge_paths.size(), pong_buffer.begin(), n, work_per_block, num_blocks_per_merge, comp);

      merge_adjacent_partitions<work_per_thread>(exec, context, block_size, num_blocks_per_merge, pong_buffer.begin(), n, merge_paths.begin(), thrust::raw_pointer_cast(&*virtual_smem.begin()), first, comp);
    }
  }
}


template<typename DerivedPolicy, typename RandomAccessIterator, typename Compare>
__attribute__((host)) __attribute__((device))
void stable_merge_sort(thrust::system::cuda::execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator first,
                       RandomAccessIterator last,
                       Compare comp)
{
  typedef typename thrust::iterator_difference<RandomAccessIterator>::type difference_type;

  difference_type n = last - first;


  thrust::detail::uint32_t threshold = thrust::detail::integer_traits<thrust::detail::uint32_t>::const_max;
  if(sizeof(difference_type) > sizeof(thrust::detail::uint32_t) && n <= difference_type(threshold))
  {
    stable_merge_sort_n(exec, first, static_cast<thrust::detail::uint32_t>(n), comp);
  }
  else
  {
    stable_merge_sort_n(exec, first, n, comp);
  }
}


}


template<typename DerivedPolicy, typename RandomAccessIterator, typename Compare>
__attribute__((host)) __attribute__((device))
void stable_merge_sort(thrust::system::cuda::execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator first,
                       RandomAccessIterator last,
                       Compare comp)
{

  typedef typename thrust::iterator_value<RandomAccessIterator>::type value_type;

  typedef thrust::detail::integral_constant<bool, (sizeof(value_type) > 16)> use_indirection;

  conditional_temporary_indirect_ordering<
    use_indirection,
    DerivedPolicy,
    RandomAccessIterator,
    Compare
  > potentially_indirect_range(exec, first, last, comp);

  stable_merge_sort_detail::stable_merge_sort(exec,
                                              potentially_indirect_range.begin(),
                                              potentially_indirect_range.end(),
                                              potentially_indirect_range.comp());
}


template<typename DerivedPolicy, typename RandomAccessIterator1, typename RandomAccessIterator2, typename Compare>
__attribute__((host)) __attribute__((device))
void stable_merge_sort_by_key(thrust::system::cuda::execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 keys_first,
                              RandomAccessIterator1 keys_last,
                              RandomAccessIterator2 values_first,
                              Compare comp)
{
  typedef thrust::tuple<RandomAccessIterator1,RandomAccessIterator2> iterator_tuple;
  typedef thrust::zip_iterator<iterator_tuple> zip_iterator;

  zip_iterator zipped_first = thrust::make_zip_iterator(thrust::make_tuple(keys_first, values_first));
  zip_iterator zipped_last = thrust::make_zip_iterator(thrust::make_tuple(keys_last, values_first));

  thrust::detail::compare_first<Compare> comp_first(comp);

  stable_merge_sort(exec, zipped_first, zipped_last, comp_first);
}


}
}
}
}
}
# 65 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_merge_sort.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/sort.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_primitive_sort.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_primitive_sort.h"
       





namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort(execution_policy<DerivedPolicy> &exec,
                           RandomAccessIterator first,
                           RandomAccessIterator last,
                           thrust::less<typename thrust::iterator_value<RandomAccessIterator>::type>);


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort(execution_policy<DerivedPolicy> &exec,
                           RandomAccessIterator first,
                           RandomAccessIterator last,
                           thrust::greater<typename thrust::iterator_value<RandomAccessIterator>::type>);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort_by_key(execution_policy<DerivedPolicy> &exec,
                                  RandomAccessIterator1 keys_first,
                                  RandomAccessIterator1 keys_last,
                                  RandomAccessIterator2 values_first,
                                  thrust::less<typename thrust::iterator_value<RandomAccessIterator1>::type>);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort_by_key(execution_policy<DerivedPolicy> &exec,
                                  RandomAccessIterator1 keys_first,
                                  RandomAccessIterator1 keys_last,
                                  RandomAccessIterator2 values_first,
                                  thrust::greater<typename thrust::iterator_value<RandomAccessIterator1>::type>);


}
}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_primitive_sort.inl" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_primitive_sort.inl"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_radix_sort.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_radix_sort.h"
       





namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_radix_sort(execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator first,
                       RandomAccessIterator last,
                       thrust::less<typename thrust::iterator_value<RandomAccessIterator>::type>);


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_radix_sort(execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator first,
                       RandomAccessIterator last,
                       thrust::greater<typename thrust::iterator_value<RandomAccessIterator>::type>);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_radix_sort_by_key(execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 keys_first,
                              RandomAccessIterator1 keys_last,
                              RandomAccessIterator2 values_first,
                              thrust::less<typename thrust::iterator_value<RandomAccessIterator1>::type>);


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_radix_sort_by_key(execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 keys_first,
                              RandomAccessIterator1 keys_last,
                              RandomAccessIterator2 values_first,
                              thrust::greater<typename thrust::iterator_value<RandomAccessIterator1>::type>);


}
}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_radix_sort.inl" 1
# 28 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_radix_sort.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub.h"
       
# 62 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub.h"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_namespace.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_namespace.cuh"
       
# 63 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub.h" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_histogram_sort.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_histogram_sort.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_macro.cuh" 1
# 33 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_macro.cuh"
       




namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 106 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_macro.cuh"
}
} } } }
# 40 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_arch.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_arch.cuh"
       




namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 197 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_arch.cuh"
}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 64 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <bool IF, typename ThenType, typename ElseType>
struct If
{

    typedef ThenType Type;
};



template <typename ThenType, typename ElseType>
struct If<false, ThenType, ElseType>
{
    typedef ElseType Type;
};
# 90 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <typename A, typename B>
struct Equals
{
    enum {
        VALUE = 0,
        NEGATE = 1
    };
};



template <typename A>
struct Equals <A, A>
{
    enum {
        VALUE = 1,
        NEGATE = 0
    };
};
# 120 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
struct NullType
{


    template <typename T>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) NullType& operator =(const T& b) { return *this; }

    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator ==(const NullType& b) { return true; }

    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator !=(const NullType& b) { return false; }


};





template <int A>
struct Int2Type
{
   enum {VALUE = A};
};
# 153 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <typename T>
struct AlignBytes
{
    struct Pad
    {
        T val;
        char byte;
    };

    enum
    {

        ALIGN_BYTES = sizeof(Pad) - sizeof(T)
    };
};



template <> struct AlignBytes<short4> { enum { ALIGN_BYTES = 8 }; };
template <> struct AlignBytes<ushort4> { enum { ALIGN_BYTES = 8 }; };
template <> struct AlignBytes<int2> { enum { ALIGN_BYTES = 8 }; };
template <> struct AlignBytes<uint2> { enum { ALIGN_BYTES = 8 }; };




template <> struct AlignBytes<long long> { enum { ALIGN_BYTES = 8 }; };
template <> struct AlignBytes<unsigned long long> { enum { ALIGN_BYTES = 8 }; };
template <> struct AlignBytes<float2> { enum { ALIGN_BYTES = 8 }; };
template <> struct AlignBytes<double> { enum { ALIGN_BYTES = 8 }; };

template <> struct AlignBytes<int4> { enum { ALIGN_BYTES = 16 }; };
template <> struct AlignBytes<uint4> { enum { ALIGN_BYTES = 16 }; };
template <> struct AlignBytes<float4> { enum { ALIGN_BYTES = 16 }; };

    template <> struct AlignBytes<long2> { enum { ALIGN_BYTES = 16 }; };
    template <> struct AlignBytes<ulong2> { enum { ALIGN_BYTES = 16 }; };

template <> struct AlignBytes<long4> { enum { ALIGN_BYTES = 16 }; };
template <> struct AlignBytes<ulong4> { enum { ALIGN_BYTES = 16 }; };
template <> struct AlignBytes<longlong2> { enum { ALIGN_BYTES = 16 }; };
template <> struct AlignBytes<ulonglong2> { enum { ALIGN_BYTES = 16 }; };
template <> struct AlignBytes<double2> { enum { ALIGN_BYTES = 16 }; };
template <> struct AlignBytes<longlong4> { enum { ALIGN_BYTES = 16 }; };
template <> struct AlignBytes<ulonglong4> { enum { ALIGN_BYTES = 16 }; };
template <> struct AlignBytes<double4> { enum { ALIGN_BYTES = 16 }; };



template <typename T>
struct UnitWord
{
    enum {
        ALIGN_BYTES = AlignBytes<T>::ALIGN_BYTES
    };

    template <typename Unit>
    struct IsMultiple
    {
        enum {
            UNIT_ALIGN_BYTES = AlignBytes<Unit>::ALIGN_BYTES,
            IS_MULTIPLE = (sizeof(T) % sizeof(Unit) == 0) && (ALIGN_BYTES % UNIT_ALIGN_BYTES == 0)
        };
    };


    typedef typename If<IsMultiple<int>::IS_MULTIPLE,
        unsigned int,
        typename If<IsMultiple<short>::IS_MULTIPLE,
            unsigned short,
            unsigned char>::Type>::Type ShuffleWord;


    typedef typename If<IsMultiple<long long>::IS_MULTIPLE,
        unsigned long long,
        ShuffleWord>::Type VolatileWord;


    typedef typename If<IsMultiple<longlong2>::IS_MULTIPLE,
        ulonglong2,
        VolatileWord>::Type DeviceWord;


    typedef typename If<IsMultiple<int4>::IS_MULTIPLE,
        uint4,
        typename If<IsMultiple<int2>::IS_MULTIPLE,
            uint2,
            ShuffleWord>::Type>::Type TextureWord;
};



template <>
struct UnitWord <float2>
{
    typedef int ShuffleWord;




    typedef unsigned long long VolatileWord;
    typedef unsigned long long DeviceWord;

    typedef float2 TextureWord;
};


template <>
struct UnitWord <float4>
{
    typedef int ShuffleWord;




    typedef unsigned long long VolatileWord;
    typedef ulonglong2 DeviceWord;

    typedef float4 TextureWord;
};



template <>
struct UnitWord <char2>
{
    typedef unsigned short ShuffleWord;




    typedef unsigned short VolatileWord;
    typedef unsigned short DeviceWord;

    typedef unsigned short TextureWord;
};
# 301 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <typename T, int vec_elements> struct CubVector;



enum
{

    MAX_VEC_ELEMENTS = 4,
};





template <typename T>
struct CubVector<T, 1>
{
    T x;

    typedef T BaseType;
    typedef CubVector<T, 1> Type;
};




template <typename T>
struct CubVector<T, 2>
{
    T x;
    T y;

    typedef T BaseType;
    typedef CubVector<T, 2> Type;
};




template <typename T>
struct CubVector<T, 3>
{
    T x;
    T y;
    T z;

    typedef T BaseType;
    typedef CubVector<T, 3> Type;
};




template <typename T>
struct CubVector<T, 4>
{
    T x;
    T y;
    T z;
    T w;

    typedef T BaseType;
    typedef CubVector<T, 4> Type;
};
# 451 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template<> struct CubVector<char, 1> : char1 { typedef char BaseType; typedef char1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<char, 2> : char2 { typedef char BaseType; typedef char2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<char, 3> : char3 { typedef char BaseType; typedef char3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<char, 4> : char4 { typedef char BaseType; typedef char4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<signed char, 1> : char1 { typedef signed char BaseType; typedef char1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<signed char, 2> : char2 { typedef signed char BaseType; typedef char2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<signed char, 3> : char3 { typedef signed char BaseType; typedef char3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<signed char, 4> : char4 { typedef signed char BaseType; typedef char4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<short, 1> : short1 { typedef short BaseType; typedef short1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<short, 2> : short2 { typedef short BaseType; typedef short2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<short, 3> : short3 { typedef short BaseType; typedef short3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<short, 4> : short4 { typedef short BaseType; typedef short4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<int, 1> : int1 { typedef int BaseType; typedef int1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<int, 2> : int2 { typedef int BaseType; typedef int2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<int, 3> : int3 { typedef int BaseType; typedef int3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<int, 4> : int4 { typedef int BaseType; typedef int4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<long, 1> : long1 { typedef long BaseType; typedef long1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<long, 2> : long2 { typedef long BaseType; typedef long2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<long, 3> : long3 { typedef long BaseType; typedef long3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<long, 4> : long4 { typedef long BaseType; typedef long4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<long long, 1> : longlong1 { typedef long long BaseType; typedef longlong1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<long long, 2> : longlong2 { typedef long long BaseType; typedef longlong2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<long long, 3> : longlong3 { typedef long long BaseType; typedef longlong3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<long long, 4> : longlong4 { typedef long long BaseType; typedef longlong4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<unsigned char, 1> : uchar1 { typedef unsigned char BaseType; typedef uchar1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<unsigned char, 2> : uchar2 { typedef unsigned char BaseType; typedef uchar2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<unsigned char, 3> : uchar3 { typedef unsigned char BaseType; typedef uchar3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<unsigned char, 4> : uchar4 { typedef unsigned char BaseType; typedef uchar4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<unsigned short, 1> : ushort1 { typedef unsigned short BaseType; typedef ushort1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<unsigned short, 2> : ushort2 { typedef unsigned short BaseType; typedef ushort2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<unsigned short, 3> : ushort3 { typedef unsigned short BaseType; typedef ushort3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<unsigned short, 4> : ushort4 { typedef unsigned short BaseType; typedef ushort4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<unsigned int, 1> : uint1 { typedef unsigned int BaseType; typedef uint1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<unsigned int, 2> : uint2 { typedef unsigned int BaseType; typedef uint2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<unsigned int, 3> : uint3 { typedef unsigned int BaseType; typedef uint3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<unsigned int, 4> : uint4 { typedef unsigned int BaseType; typedef uint4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<unsigned long, 1> : ulong1 { typedef unsigned long BaseType; typedef ulong1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<unsigned long, 2> : ulong2 { typedef unsigned long BaseType; typedef ulong2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<unsigned long, 3> : ulong3 { typedef unsigned long BaseType; typedef ulong3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<unsigned long, 4> : ulong4 { typedef unsigned long BaseType; typedef ulong4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<unsigned long long, 1> : ulonglong1 { typedef unsigned long long BaseType; typedef ulonglong1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<unsigned long long, 2> : ulonglong2 { typedef unsigned long long BaseType; typedef ulonglong2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<unsigned long long, 3> : ulonglong3 { typedef unsigned long long BaseType; typedef ulonglong3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<unsigned long long, 4> : ulonglong4 { typedef unsigned long long BaseType; typedef ulonglong4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<float, 1> : float1 { typedef float BaseType; typedef float1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<float, 2> : float2 { typedef float BaseType; typedef float2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<float, 3> : float3 { typedef float BaseType; typedef float3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<float, 4> : float4 { typedef float BaseType; typedef float4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<double, 1> : double1 { typedef double BaseType; typedef double1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<double, 2> : double2 { typedef double BaseType; typedef double2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<double, 3> : double3 { typedef double BaseType; typedef double3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<double, 4> : double4 { typedef double BaseType; typedef double4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
template<> struct CubVector<bool, 1> : uchar1 { typedef bool BaseType; typedef uchar1 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; return retval; } }; template<> struct CubVector<bool, 2> : uchar2 { typedef bool BaseType; typedef uchar2 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; return retval; } }; template<> struct CubVector<bool, 3> : uchar3 { typedef bool BaseType; typedef uchar3 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; return retval; } }; template<> struct CubVector<bool, 4> : uchar4 { typedef bool BaseType; typedef uchar4 Type; __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator+(const CubVector &other) const { CubVector retval; retval.x = x + other.x; retval.y = y + other.y; retval.z = z + other.z; retval.w = w + other.w; return retval; } __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CubVector operator-(const CubVector &other) const { CubVector retval; retval.x = x - other.x; retval.y = y - other.y; retval.z = z - other.z; retval.w = w - other.w; return retval; } };
# 480 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <typename T>
struct Uninitialized
{

    typedef typename UnitWord<T>::DeviceWord DeviceWord;

    enum
    {
        WORDS = sizeof(T) / sizeof(DeviceWord)
    };


    DeviceWord storage[WORDS];


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) T& Alias()
    {
        return reinterpret_cast<T&>(*this);
    }
};





template <typename _T, typename _Offset>
struct ItemOffsetPair
{
    typedef _T T;
    typedef _Offset Offset;


    union
    {
        Offset offset;
        typename UnitWord<T>::DeviceWord align0;
    };




    T value;


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator !=(const ItemOffsetPair &b)
    {
        return (value != b.value) || (offset != b.offset);
    }
};





template <typename _Key, typename _Value>
struct KeyValuePair
{
    typedef _Key Key;
    typedef _Value Value;

    Value value;
    Key key;


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator !=(const KeyValuePair &b)
    {
        return (value != b.value) || (key != b.key);
    }

};







template <typename T>
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) T ZeroInitialize()
{
# 572 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
    return T();


}





template <typename T, int COUNT>
struct ArrayWrapper
{

    T array[COUNT];
};
# 598 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <typename T>
struct DoubleBuffer
{

    T *d_buffers[2];


    int selector;


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) DoubleBuffer()
    {
        selector = 0;
        d_buffers[0] = __null;
        d_buffers[1] = __null;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) DoubleBuffer(
        T *d_current,
        T *d_alternate)
    {
        selector = 0;
        d_buffers[0] = d_current;
        d_buffers[1] = d_alternate;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) T* Current() { return d_buffers[selector]; }
};
# 642 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <int N, int CURRENT_VAL = N, int COUNT = 0>
struct Log2
{

    enum { VALUE = Log2<N, (CURRENT_VAL >> 1), COUNT + 1>::VALUE };
};


template <int N, int COUNT>
struct Log2<N, 0, COUNT>
{
    enum {VALUE = (1 << (COUNT - 1) < N) ?
        COUNT :
        COUNT - 1 };
};






template <int N>
struct PowerOfTwo
{
    enum { VALUE = ((N & (N - 1)) == 0) };
};
# 680 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <typename Tp>
struct IsPointer
{
    enum { VALUE = 0 };
};



template <typename Tp>
struct IsPointer<Tp*>
{
    enum { VALUE = 1 };
};
# 705 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <typename Tp>
struct IsVolatile
{
    enum { VALUE = 0 };
};



template <typename Tp>
struct IsVolatile<Tp volatile>
{
    enum { VALUE = 1 };
};
# 732 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <typename Tp, typename Up = Tp>
struct RemoveQualifiers
{

    typedef Up Type;
};



template <typename Tp, typename Up>
struct RemoveQualifiers<Tp, volatile Up>
{
    typedef Up Type;
};

template <typename Tp, typename Up>
struct RemoveQualifiers<Tp, const Up>
{
    typedef Up Type;
};

template <typename Tp, typename Up>
struct RemoveQualifiers<Tp, const volatile Up>
{
    typedef Up Type;
};
# 794 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <bool Condition, class T = void>
struct EnableIf
{

    typedef T Type;
};



template <class T>
struct EnableIf<false, T> {};
# 816 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
template <typename T, typename BinaryOp>
struct BinaryOpHasIdxParam
{
private:






    template <typename BinaryOpT, bool (BinaryOpT::*)(const T &a, const T &b, int idx) const> struct SFINAE5 {};
    template <typename BinaryOpT, bool (BinaryOpT::*)(const T &a, const T &b, int idx)> struct SFINAE6 {};
    template <typename BinaryOpT, bool (BinaryOpT::*)(T a, T b, int idx) const> struct SFINAE7 {};
    template <typename BinaryOpT, bool (BinaryOpT::*)(T a, T b, int idx)> struct SFINAE8 {};






    template <typename BinaryOpT> static char Test(SFINAE5<BinaryOpT, &BinaryOpT::operator()> *);
    template <typename BinaryOpT> static char Test(SFINAE6<BinaryOpT, &BinaryOpT::operator()> *);
    template <typename BinaryOpT> static char Test(SFINAE7<BinaryOpT, &BinaryOpT::operator()> *);
    template <typename BinaryOpT> static char Test(SFINAE8<BinaryOpT, &BinaryOpT::operator()> *);

    template <typename BinaryOpT> static int Test(...);

public:


    static const bool HAS_PARAM = sizeof(Test<BinaryOp>(__null)) == sizeof(char);
};
# 865 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_type.cuh"
enum Category
{
    NOT_A_NUMBER,
    SIGNED_INTEGER,
    UNSIGNED_INTEGER,
    FLOATING_POINT
};





template <Category _CATEGORY, bool _PRIMITIVE, bool _NULL_TYPE, typename _UnsignedBits>
struct BaseTraits
{

    static const Category CATEGORY = _CATEGORY;
    enum
    {
        PRIMITIVE = _PRIMITIVE,
        NULL_TYPE = _NULL_TYPE,
    };
};






template <typename _UnsignedBits>
struct BaseTraits<UNSIGNED_INTEGER, true, false, _UnsignedBits>
{
    typedef _UnsignedBits UnsignedBits;

    static const Category CATEGORY = UNSIGNED_INTEGER;
    static const UnsignedBits MIN_KEY = UnsignedBits(0);
    static const UnsignedBits MAX_KEY = UnsignedBits(-1);

    enum
    {
        PRIMITIVE = true,
        NULL_TYPE = false,
    };


    static __attribute__((device)) __inline__ __attribute__((always_inline)) UnsignedBits TwiddleIn(UnsignedBits key)
    {
        return key;
    }

    static __attribute__((device)) __inline__ __attribute__((always_inline)) UnsignedBits TwiddleOut(UnsignedBits key)
    {
        return key;
    }
};





template <typename _UnsignedBits>
struct BaseTraits<SIGNED_INTEGER, true, false, _UnsignedBits>
{
    typedef _UnsignedBits UnsignedBits;

    static const Category CATEGORY = SIGNED_INTEGER;
    static const UnsignedBits HIGH_BIT = UnsignedBits(1) << ((sizeof(UnsignedBits) * 8) - 1);
    static const UnsignedBits MIN_KEY = HIGH_BIT;
    static const UnsignedBits MAX_KEY = UnsignedBits(-1) ^ HIGH_BIT;

    enum
    {
        PRIMITIVE = true,
        NULL_TYPE = false,
    };

    static __attribute__((device)) __inline__ __attribute__((always_inline)) UnsignedBits TwiddleIn(UnsignedBits key)
    {
        return key ^ HIGH_BIT;
    };

    static __attribute__((device)) __inline__ __attribute__((always_inline)) UnsignedBits TwiddleOut(UnsignedBits key)
    {
        return key ^ HIGH_BIT;
    };

};





template <typename _UnsignedBits>
struct BaseTraits<FLOATING_POINT, true, false, _UnsignedBits>
{
    typedef _UnsignedBits UnsignedBits;

    static const Category CATEGORY = FLOATING_POINT;
    static const UnsignedBits HIGH_BIT = UnsignedBits(1) << ((sizeof(UnsignedBits) * 8) - 1);
    static const UnsignedBits MIN_KEY = UnsignedBits(-1);
    static const UnsignedBits MAX_KEY = UnsignedBits(-1) ^ HIGH_BIT;

    static __attribute__((device)) __inline__ __attribute__((always_inline)) UnsignedBits TwiddleIn(UnsignedBits key)
    {
        UnsignedBits mask = (key & HIGH_BIT) ? UnsignedBits(-1) : HIGH_BIT;
        return key ^ mask;
    };

    static __attribute__((device)) __inline__ __attribute__((always_inline)) UnsignedBits TwiddleOut(UnsignedBits key)
    {
        UnsignedBits mask = (key & HIGH_BIT) ? HIGH_BIT : UnsignedBits(-1);
        return key ^ mask;
    };

    enum
    {
        PRIMITIVE = true,
        NULL_TYPE = false,
    };
};







template <typename T> struct NumericTraits : BaseTraits<NOT_A_NUMBER, false, false, T> {};



template <> struct NumericTraits<NullType> : BaseTraits<NOT_A_NUMBER, false, true, NullType> {};

template <> struct NumericTraits<char> : BaseTraits<(std::numeric_limits<char>::is_signed) ? SIGNED_INTEGER : UNSIGNED_INTEGER, true, false, unsigned char> {};
template <> struct NumericTraits<signed char> : BaseTraits<SIGNED_INTEGER, true, false, unsigned char> {};
template <> struct NumericTraits<short> : BaseTraits<SIGNED_INTEGER, true, false, unsigned short> {};
template <> struct NumericTraits<int> : BaseTraits<SIGNED_INTEGER, true, false, unsigned int> {};
template <> struct NumericTraits<long> : BaseTraits<SIGNED_INTEGER, true, false, unsigned long> {};
template <> struct NumericTraits<long long> : BaseTraits<SIGNED_INTEGER, true, false, unsigned long long> {};

template <> struct NumericTraits<unsigned char> : BaseTraits<UNSIGNED_INTEGER, true, false, unsigned char> {};
template <> struct NumericTraits<unsigned short> : BaseTraits<UNSIGNED_INTEGER, true, false, unsigned short> {};
template <> struct NumericTraits<unsigned int> : BaseTraits<UNSIGNED_INTEGER, true, false, unsigned int> {};
template <> struct NumericTraits<unsigned long> : BaseTraits<UNSIGNED_INTEGER, true, false, unsigned long> {};
template <> struct NumericTraits<unsigned long long> : BaseTraits<UNSIGNED_INTEGER, true, false, unsigned long long> {};

template <> struct NumericTraits<float> : BaseTraits<FLOATING_POINT, true, false, unsigned int> {};
template <> struct NumericTraits<double> : BaseTraits<FLOATING_POINT, true, false, unsigned long long> {};







template <typename T>
struct Traits : NumericTraits<typename RemoveQualifiers<T>::Type> {};





}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh" 2




namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 85 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh"
__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int SHR_ADD(
    unsigned int x,
    unsigned int shift,
    unsigned int addend)
{
    unsigned int ret;




    ret = (x >> shift) + addend;

    return ret;
}





__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int SHL_ADD(
    unsigned int x,
    unsigned int shift,
    unsigned int addend)
{
    unsigned int ret;




    ret = (x << shift) + addend;

    return ret;
}






template <typename UnsignedBits, int BYTE_LEN>
__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int BFE(
    UnsignedBits source,
    unsigned int bit_start,
    unsigned int num_bits,
    Int2Type<BYTE_LEN> byte_len)
{
    unsigned int bits;



    const unsigned int MASK = (1 << num_bits) - 1;
    bits = (source >> bit_start) & MASK;

    return bits;
}





template <typename UnsignedBits>
__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int BFE(
    UnsignedBits source,
    unsigned int bit_start,
    unsigned int num_bits,
    Int2Type<8> byte_len)
{
    const unsigned long long MASK = (1ull << num_bits) - 1;
    return (source >> bit_start) & MASK;
}






template <typename UnsignedBits>
__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int BFE(
    UnsignedBits source,
    unsigned int bit_start,
    unsigned int num_bits)
{
    return BFE(source, bit_start, num_bits, Int2Type<sizeof(UnsignedBits)>());
}





__attribute__((device)) __inline__ __attribute__((always_inline)) void BFI(
    unsigned int &ret,
    unsigned int x,
    unsigned int y,
    unsigned int bit_start,
    unsigned int num_bits)
{




    x <<= bit_start;
    unsigned int MASK_X = ((1 << num_bits) - 1) << bit_start;
    unsigned int MASK_Y = ~MASK_X;
    ret = (y & MASK_Y) | (x & MASK_X);

}





__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int IADD3(unsigned int x, unsigned int y, unsigned int z)
{



    x = x + y + z;

    return x;
}
# 233 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh"
__attribute__((device)) __inline__ __attribute__((always_inline)) int PRMT(unsigned int a, unsigned int b, unsigned int index)
{
    int ret;
    asm("prmt.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(a), "r"(b), "r"(index));
    return ret;
}






__attribute__((device)) __inline__ __attribute__((always_inline)) void BAR(int count)
{
    asm volatile("bar.sync 1, %0;" : : "r"(count));
}





__attribute__((device)) __inline__ __attribute__((always_inline)) float FMUL_RZ(float a, float b)
{
    float d;
    asm("mul.rz.f32 %0, %1, %2;" : "=f"(d) : "f"(a), "f"(b));
    return d;
}





__attribute__((device)) __inline__ __attribute__((always_inline)) float FFMA_RZ(float a, float b, float c)
{
    float d;
    asm("fma.rz.f32 %0, %1, %2, %3;" : "=f"(d) : "f"(a), "f"(b), "f"(c));
    return d;
}






__attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadExit() {
    asm("exit;");
}





__attribute__((device)) __inline__ __attribute__((always_inline)) int RowMajorTid(int block_dim_x, int block_dim_y, int block_dim_z)
{
    return ((block_dim_z == 1) ? 0 : (threadIdx.z * block_dim_x * block_dim_y)) +
            ((block_dim_y == 1) ? 0 : (threadIdx.y * block_dim_x)) +
            threadIdx.x;
}





__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int LaneId()
{
    unsigned int ret;
    asm("mov.u32 %0, %laneid;" : "=r"(ret) );
    return ret;
}





__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int WarpId()
{
    unsigned int ret;
    asm("mov.u32 %0, %warpid;" : "=r"(ret) );
    return ret;
}




__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int LaneMaskLt()
{
    unsigned int ret;
    asm("mov.u32 %0, %lanemask_lt;" : "=r"(ret) );
    return ret;
}




__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int LaneMaskLe()
{
    unsigned int ret;
    asm("mov.u32 %0, %lanemask_le;" : "=r"(ret) );
    return ret;
}




__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int LaneMaskGt()
{
    unsigned int ret;
    asm("mov.u32 %0, %lanemask_gt;" : "=r"(ret) );
    return ret;
}




__attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int LaneMaskGe()
{
    unsigned int ret;
    asm("mov.u32 %0, %lanemask_ge;" : "=r"(ret) );
    return ret;
}
# 387 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh"
template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ShuffleUp(
    T input,
    int src_offset)
{
    enum
    {
        SHFL_C = 0,
    };

    typedef typename UnitWord<T>::ShuffleWord ShuffleWord;

    const int WORDS = (sizeof(T) + sizeof(ShuffleWord) - 1) / sizeof(ShuffleWord);
    T output;
    ShuffleWord *output_alias = reinterpret_cast<ShuffleWord *>(&output);
    ShuffleWord *input_alias = reinterpret_cast<ShuffleWord *>(&input);

#pragma unroll
    for (int WORD = 0; WORD < WORDS; ++WORD)
    {
        unsigned int shuffle_word = input_alias[WORD];
        asm(
            "  shfl.up.b32 %0, %1, %2, %3;"
            : "=r"(shuffle_word) : "r"(shuffle_word), "r"(src_offset), "r"(SHFL_C));
        output_alias[WORD] = (ShuffleWord) shuffle_word;
    }

    return output;
}
# 446 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh"
template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ShuffleDown(
    T input,
    int src_offset)
{
    enum
    {
        SHFL_C = (1 << (5)) - 1,
    };

    typedef typename UnitWord<T>::ShuffleWord ShuffleWord;

    const int WORDS = (sizeof(T) + sizeof(ShuffleWord) - 1) / sizeof(ShuffleWord);
    T output;
    ShuffleWord *output_alias = reinterpret_cast<ShuffleWord *>(&output);
    ShuffleWord *input_alias = reinterpret_cast<ShuffleWord *>(&input);

#pragma unroll
    for (int WORD = 0; WORD < WORDS; ++WORD)
    {
        unsigned int shuffle_word = input_alias[WORD];
        asm(
            "  shfl.down.b32 %0, %1, %2, %3;"
            : "=r"(shuffle_word) : "r"(shuffle_word), "r"(src_offset), "r"(SHFL_C));
        output_alias[WORD] = (ShuffleWord) shuffle_word;
    }

    return output;
}
# 485 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh"
template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ShuffleBroadcast(
    T input,
    int src_lane,
    int logical_warp_threads)
{
    typedef typename UnitWord<T>::ShuffleWord ShuffleWord;

    const int WORDS = (sizeof(T) + sizeof(ShuffleWord) - 1) / sizeof(ShuffleWord);
    T output;
    ShuffleWord *output_alias = reinterpret_cast<ShuffleWord *>(&output);
    ShuffleWord *input_alias = reinterpret_cast<ShuffleWord *>(&input);

#pragma unroll
    for (int WORD = 0; WORD < WORDS; ++WORD)
    {
        unsigned int shuffle_word = input_alias[WORD];
        asm("shfl.idx.b32 %0, %1, %2, %3;"
            : "=r"(shuffle_word) : "r"(shuffle_word), "r"(src_lane), "r"(logical_warp_threads - 1));
        output_alias[WORD] = (ShuffleWord) shuffle_word;
    }

    return output;
}
# 541 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh"
template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ShuffleBroadcast(
    T input,
    int src_lane)
{
    return ShuffleBroadcast(input, src_lane, (1 << (5)));
}
# 557 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../util_ptx.cuh"
__attribute__((device)) __inline__ __attribute__((always_inline)) int WarpAll(int cond)
{


    __attribute__((shared)) volatile int warp_signals[((0 >= 300) ? (2048) : ((0 >= 200) ? (1536) : ((0 >= 120) ? (1024) : (768)))) / (1 << (5))];

    if (LaneId() == 0)
        warp_signals[WarpId()] = 1;

    if (cond == 0)
        warp_signals[WarpId()] = 0;

    return warp_signals[WarpId()];






}






__attribute__((device)) __inline__ __attribute__((always_inline)) int WarpAny(int cond)
{


    __attribute__((shared)) volatile int warp_signals[((0 >= 300) ? (2048) : ((0 >= 200) ? (1536) : ((0 >= 120) ? (1024) : (768)))) / (1 << (5))];

    if (LaneId() == 0)
        warp_signals[WarpId()] = 0;

    if (cond)
        warp_signals[WarpId()] = 1;

    return warp_signals[WarpId()];






}


}
} } } }
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh" 2






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 108 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
template <
    typename T,
    int BLOCK_DIM_X,
    int ITEMS_PER_THREAD,
    bool WARP_TIME_SLICING = false,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockExchange
{
private:






    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,

        LOG_WARP_THREADS = (5),
        WARP_THREADS = 1 << LOG_WARP_THREADS,
        WARPS = (BLOCK_THREADS + WARP_THREADS - 1) / WARP_THREADS,

        LOG_SMEM_BANKS = ((PTX_ARCH >= 200) ? (5) : (4)),
        SMEM_BANKS = 1 << LOG_SMEM_BANKS,

        TILE_ITEMS = BLOCK_THREADS * ITEMS_PER_THREAD,

        TIME_SLICES = (WARP_TIME_SLICING) ? WARPS : 1,

        TIME_SLICED_THREADS = (WARP_TIME_SLICING) ? (((WARP_THREADS) < (BLOCK_THREADS)) ? (WARP_THREADS) : (BLOCK_THREADS)) : BLOCK_THREADS,
        TIME_SLICED_ITEMS = TIME_SLICED_THREADS * ITEMS_PER_THREAD,

        WARP_TIME_SLICED_THREADS = (((WARP_THREADS) < (BLOCK_THREADS)) ? (WARP_THREADS) : (BLOCK_THREADS)),
        WARP_TIME_SLICED_ITEMS = WARP_TIME_SLICED_THREADS * ITEMS_PER_THREAD,


        INSERT_PADDING = 0,
        PADDING_ITEMS = (INSERT_PADDING) ? (TIME_SLICED_ITEMS >> LOG_SMEM_BANKS) : 0,
    };






    typedef T _TempStorage[TIME_SLICED_ITEMS + PADDING_ITEMS];

public:


    struct TempStorage : Uninitialized<_TempStorage> {};

private:







    _TempStorage &temp_storage;


    int linear_tid;
    int lane_id;
    int warp_id;
    int warp_offset;







    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void BlockedToStriped(
        T items[ITEMS_PER_THREAD],
        Int2Type<false> time_slicing)
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = (linear_tid * ITEMS_PER_THREAD) + ITEM;
            if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
            temp_storage[item_offset] = items[ITEM];
        }

        __syncthreads();

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = int(ITEM * BLOCK_THREADS) + linear_tid;
            if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
            items[ITEM] = temp_storage[item_offset];
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void BlockedToStriped(
        T items[ITEMS_PER_THREAD],
        Int2Type<true> time_slicing)
    {
        T temp_items[ITEMS_PER_THREAD];

#pragma unroll
        for (int SLICE = 0; SLICE < TIME_SLICES; SLICE++)
        {
            const int SLICE_OFFSET = SLICE * TIME_SLICED_ITEMS;
            const int SLICE_OOB = SLICE_OFFSET + TIME_SLICED_ITEMS;

            __syncthreads();

            if (warp_id == SLICE)
            {
#pragma unroll
                for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
                {
                    int item_offset = (lane_id * ITEMS_PER_THREAD) + ITEM;
                    if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                    temp_storage[item_offset] = items[ITEM];
                }
            }

            __syncthreads();

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {

                const int STRIP_OFFSET = ITEM * BLOCK_THREADS;
                const int STRIP_OOB = STRIP_OFFSET + BLOCK_THREADS;

                if ((SLICE_OFFSET < STRIP_OOB) && (SLICE_OOB > STRIP_OFFSET))
                {
                    int item_offset = STRIP_OFFSET + linear_tid - SLICE_OFFSET;
                    if ((item_offset >= 0) && (item_offset < TIME_SLICED_ITEMS))
                    {
                        if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                        temp_items[ITEM] = temp_storage[item_offset];
                    }
                }
            }
        }


#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            items[ITEM] = temp_items[ITEM];
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void BlockedToWarpStriped(
        T items[ITEMS_PER_THREAD],
        Int2Type<false> time_slicing)
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = warp_offset + ITEM + (lane_id * ITEMS_PER_THREAD);
            if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
            temp_storage[item_offset] = items[ITEM];
        }

        __threadfence_block();

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = warp_offset + (ITEM * WARP_TIME_SLICED_THREADS) + lane_id;
            if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
            items[ITEM] = temp_storage[item_offset];
        }
    }




    __attribute__((device)) __inline__ __attribute__((always_inline)) void BlockedToWarpStriped(
        T items[ITEMS_PER_THREAD],
        Int2Type<true> time_slicing)
    {
        if (warp_id == 0)
        {
#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
                int item_offset = ITEM + (lane_id * ITEMS_PER_THREAD);
                if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                temp_storage[item_offset] = items[ITEM];
            }

            __threadfence_block();

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
                int item_offset = (ITEM * WARP_TIME_SLICED_THREADS) + lane_id;
                if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                items[ITEM] = temp_storage[item_offset];
            }
        }

#pragma unroll
        for (int SLICE = 1; SLICE < TIME_SLICES; ++SLICE)
        {
            __syncthreads();

            if (warp_id == SLICE)
            {
#pragma unroll
                for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
                {
                    int item_offset = ITEM + (lane_id * ITEMS_PER_THREAD);
                    if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                    temp_storage[item_offset] = items[ITEM];
                }

                __threadfence_block();

#pragma unroll
                for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
                {
                    int item_offset = (ITEM * WARP_TIME_SLICED_THREADS) + lane_id;
                    if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                    items[ITEM] = temp_storage[item_offset];
                }
            }
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void StripedToBlocked(
        T items[ITEMS_PER_THREAD],
        Int2Type<false> time_slicing)
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = int(ITEM * BLOCK_THREADS) + linear_tid;
            if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
            temp_storage[item_offset] = items[ITEM];
        }

        __syncthreads();


#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = (linear_tid * ITEMS_PER_THREAD) + ITEM;
            if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
            items[ITEM] = temp_storage[item_offset];
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void StripedToBlocked(
        T items[ITEMS_PER_THREAD],
        Int2Type<true> time_slicing)
    {

        T temp_items[ITEMS_PER_THREAD];

#pragma unroll
        for (int SLICE = 0; SLICE < TIME_SLICES; SLICE++)
        {
            const int SLICE_OFFSET = SLICE * TIME_SLICED_ITEMS;
            const int SLICE_OOB = SLICE_OFFSET + TIME_SLICED_ITEMS;

            __syncthreads();

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {

                const int STRIP_OFFSET = ITEM * BLOCK_THREADS;
                const int STRIP_OOB = STRIP_OFFSET + BLOCK_THREADS;

                if ((SLICE_OFFSET < STRIP_OOB) && (SLICE_OOB > STRIP_OFFSET))
                {
                    int item_offset = STRIP_OFFSET + linear_tid - SLICE_OFFSET;
                    if ((item_offset >= 0) && (item_offset < TIME_SLICED_ITEMS))
                    {
                        if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                        temp_storage[item_offset] = items[ITEM];
                    }
                }
            }

            __syncthreads();

            if (warp_id == SLICE)
            {
#pragma unroll
                for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
                {
                    int item_offset = (lane_id * ITEMS_PER_THREAD) + ITEM;
                    if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                    temp_items[ITEM] = temp_storage[item_offset];
                }
            }
        }


#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            items[ITEM] = temp_items[ITEM];
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void WarpStripedToBlocked(
        T items[ITEMS_PER_THREAD],
        Int2Type<false> time_slicing)
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = warp_offset + (ITEM * WARP_TIME_SLICED_THREADS) + lane_id;
            if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
            temp_storage[item_offset] = items[ITEM];
        }

        __threadfence_block();

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = warp_offset + ITEM + (lane_id * ITEMS_PER_THREAD);
            if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
            items[ITEM] = temp_storage[item_offset];
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void WarpStripedToBlocked(
        T items[ITEMS_PER_THREAD],
        Int2Type<true> time_slicing)
    {
#pragma unroll
        for (int SLICE = 0; SLICE < TIME_SLICES; ++SLICE)
        {
            __syncthreads();

            if (warp_id == SLICE)
            {
#pragma unroll
                for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
                {
                    int item_offset = (ITEM * WARP_TIME_SLICED_THREADS) + lane_id;
                    if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                    temp_storage[item_offset] = items[ITEM];
                }

                __threadfence_block();

#pragma unroll
                for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
                {
                    int item_offset = ITEM + (lane_id * ITEMS_PER_THREAD);
                    if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                    items[ITEM] = temp_storage[item_offset];
                }
            }
        }
    }





    template <typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterToBlocked(
        T items[ITEMS_PER_THREAD],
        Offset ranks[ITEMS_PER_THREAD],
        Int2Type<false> time_slicing)
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = ranks[ITEM];
            if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
            temp_storage[item_offset] = items[ITEM];
        }

        __syncthreads();

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = (linear_tid * ITEMS_PER_THREAD) + ITEM;
            if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
            items[ITEM] = temp_storage[item_offset];
        }
    }




    template <typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterToBlocked(
        T items[ITEMS_PER_THREAD],
        Offset ranks[ITEMS_PER_THREAD],
        Int2Type<true> time_slicing)
    {
        T temp_items[ITEMS_PER_THREAD];

#pragma unroll
        for (int SLICE = 0; SLICE < TIME_SLICES; SLICE++)
        {
            __syncthreads();

            const int SLICE_OFFSET = TIME_SLICED_ITEMS * SLICE;

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
                int item_offset = ranks[ITEM] - SLICE_OFFSET;
                if ((item_offset >= 0) && (item_offset < WARP_TIME_SLICED_ITEMS))
                {
                    if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
                    temp_storage[item_offset] = items[ITEM];
                }
            }

            __syncthreads();

            if (warp_id == SLICE)
            {
#pragma unroll
                for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
                {
                    int item_offset = (lane_id * ITEMS_PER_THREAD) + ITEM;
                    if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
                    temp_items[ITEM] = temp_storage[item_offset];
                }
            }
        }


#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            items[ITEM] = temp_items[ITEM];
        }
    }





    template <typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterToStriped(
        T items[ITEMS_PER_THREAD],
        Offset ranks[ITEMS_PER_THREAD],
        Int2Type<false> time_slicing)
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = ranks[ITEM];
            if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
            temp_storage[item_offset] = items[ITEM];
        }

        __syncthreads();

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = int(ITEM * BLOCK_THREADS) + linear_tid;
            if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
            items[ITEM] = temp_storage[item_offset];
        }
    }





    template <typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterToStriped(
        T items[ITEMS_PER_THREAD],
        Offset ranks[ITEMS_PER_THREAD],
        Int2Type<true> time_slicing)
    {
        T temp_items[ITEMS_PER_THREAD];

#pragma unroll
        for (int SLICE = 0; SLICE < TIME_SLICES; SLICE++)
        {
            const int SLICE_OFFSET = SLICE * TIME_SLICED_ITEMS;
            const int SLICE_OOB = SLICE_OFFSET + TIME_SLICED_ITEMS;

            __syncthreads();

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
                int item_offset = ranks[ITEM] - SLICE_OFFSET;
                if ((item_offset >= 0) && (item_offset < WARP_TIME_SLICED_ITEMS))
                {
                    if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
                    temp_storage[item_offset] = items[ITEM];
                }
            }

            __syncthreads();

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {

                const int STRIP_OFFSET = ITEM * BLOCK_THREADS;
                const int STRIP_OOB = STRIP_OFFSET + BLOCK_THREADS;

                if ((SLICE_OFFSET < STRIP_OOB) && (SLICE_OOB > STRIP_OFFSET))
                {
                    int item_offset = STRIP_OFFSET + linear_tid - SLICE_OFFSET;
                    if ((item_offset >= 0) && (item_offset < TIME_SLICED_ITEMS))
                    {
                        if (INSERT_PADDING) item_offset += item_offset >> LOG_SMEM_BANKS;
                        temp_items[ITEM] = temp_storage[item_offset];
                    }
                }
            }
        }


#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            items[ITEM] = temp_items[ITEM];
        }
    }


public:
# 690 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockExchange()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)),
        warp_id((WARPS == 1) ? 0 : linear_tid / WARP_THREADS),
        lane_id(LaneId()),
        warp_offset(warp_id * WARP_TIME_SLICED_ITEMS)
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockExchange(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)),
        warp_id((WARPS == 1) ? 0 : linear_tid / WARP_THREADS),
        lane_id(LaneId()),
        warp_offset(warp_id * WARP_TIME_SLICED_ITEMS)
    {}
# 756 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void StripedToBlocked(
        T items[ITEMS_PER_THREAD])
    {
        StripedToBlocked(items, Int2Type<WARP_TIME_SLICING>());
    }
# 802 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void BlockedToStriped(
        T items[ITEMS_PER_THREAD])
    {
        BlockedToStriped(items, Int2Type<WARP_TIME_SLICING>());
    }
# 847 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void WarpStripedToBlocked(
        T items[ITEMS_PER_THREAD])
    {
        WarpStripedToBlocked(items, Int2Type<WARP_TIME_SLICING>());
    }
# 894 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void BlockedToWarpStriped(
        T items[ITEMS_PER_THREAD])
    {
        BlockedToWarpStriped(items, Int2Type<WARP_TIME_SLICING>());
    }
# 916 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    template <typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterToBlocked(
        T items[ITEMS_PER_THREAD],
        Offset ranks[ITEMS_PER_THREAD])
    {
        ScatterToBlocked(items, ranks, Int2Type<WARP_TIME_SLICING>());
    }
# 933 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    template <typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterToStriped(
        T items[ITEMS_PER_THREAD],
        Offset ranks[ITEMS_PER_THREAD])
    {
        ScatterToStriped(items, ranks, Int2Type<WARP_TIME_SLICING>());
    }
# 950 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    template <typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterToStripedGuarded(
        T items[ITEMS_PER_THREAD],
        Offset ranks[ITEMS_PER_THREAD])
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = ranks[ITEM];
            if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
            if (ranks[ITEM] >= 0)
                temp_storage[item_offset] = items[ITEM];
        }

        __syncthreads();

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = int(ITEM * BLOCK_THREADS) + linear_tid;
            if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
            items[ITEM] = temp_storage[item_offset];
        }
    }
# 984 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    template <typename Offset, typename ValidFlag>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterToStriped(
        T items[ITEMS_PER_THREAD],
        Offset ranks[ITEMS_PER_THREAD],
        ValidFlag is_valid[ITEMS_PER_THREAD])
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = ranks[ITEM];
            if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
            if (is_valid[ITEM])
                temp_storage[item_offset] = items[ITEM];
        }

        __syncthreads();

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = int(ITEM * BLOCK_THREADS) + linear_tid;
            if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
            items[ITEM] = temp_storage[item_offset];
        }
    }



};





template <
    typename T,
    int ITEMS_PER_THREAD,
    int LOGICAL_WARP_THREADS = (1 << (5)),
    int PTX_ARCH = 0>
class WarpExchange
{





    enum
    {

        IS_ARCH_WARP = (LOGICAL_WARP_THREADS == (1 << (5))),

        WARP_ITEMS = (ITEMS_PER_THREAD * LOGICAL_WARP_THREADS) + 1,

        LOG_SMEM_BANKS = ((PTX_ARCH >= 200) ? (5) : (4)),
        SMEM_BANKS = 1 << LOG_SMEM_BANKS,


        INSERT_PADDING = 0,
        PADDING_ITEMS = (INSERT_PADDING) ? (WARP_ITEMS >> LOG_SMEM_BANKS) : 0,
    };






    typedef T _TempStorage[WARP_ITEMS + PADDING_ITEMS];

public:


    struct TempStorage : Uninitialized<_TempStorage> {};

private:






    _TempStorage &temp_storage;
    int lane_id;

public:






    __attribute__((device)) __inline__ __attribute__((always_inline)) WarpExchange(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        lane_id(IS_ARCH_WARP ?
            LaneId() :
            LaneId() % LOGICAL_WARP_THREADS)
    {}
# 1096 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
    template <typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterToStriped(
        T items[ITEMS_PER_THREAD],
        Offset ranks[ITEMS_PER_THREAD])
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            if (INSERT_PADDING) ranks[ITEM] = SHR_ADD(ranks[ITEM], LOG_SMEM_BANKS, ranks[ITEM]);
            temp_storage[ranks[ITEM]] = items[ITEM];
        }

        __threadfence_block();

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            int item_offset = (ITEM * LOGICAL_WARP_THREADS) + lane_id;
            if (INSERT_PADDING) item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset);
            items[ITEM] = temp_storage[item_offset];
        }
    }

};
# 1130 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_exchange.cuh"
}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_reduce.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_reduce.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/../thread/thread_operators.cuh" 1
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/../thread/thread_operators.cuh"
       






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 59 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/../thread/thread_operators.cuh"
struct Equality
{

    template <typename T>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator()(const T &a, const T &b) const
    {
        return a == b;
    }
};





struct Inequality
{

    template <typename T>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator()(const T &a, const T &b) const
    {
        return a != b;
    }
};





template <typename EqualityOp>
struct InequalityWrapper
{

    EqualityOp op;


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    InequalityWrapper(EqualityOp op) : op(op) {}


    template <typename T>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator()(const T &a, const T &b) const
    {
        return !op(a, b);
    }
};





struct Sum
{

    template <typename T>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) T operator()(const T &a, const T &b) const
    {
        return a + b;
    }
};





struct Max
{

    template <typename T>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) T operator()(const T &a, const T &b) const
    {
        return (((b) > (a)) ? (b) : (a));
    }
};





struct ArgMax
{

    template <typename T, typename Offset>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) ItemOffsetPair<T, Offset> operator()(
        const ItemOffsetPair<T, Offset> &a,
        const ItemOffsetPair<T, Offset> &b) const
    {
        if (a.value == b.value)
            return (b.offset < a.offset) ? b : a;

        return (b.value > a.value) ? b : a;
    }
};





struct Min
{

    template <typename T>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) T operator()(const T &a, const T &b) const
    {
        return (((b) < (a)) ? (b) : (a));
    }
};





struct ArgMin
{

    template <typename T, typename Offset>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) ItemOffsetPair<T, Offset> operator()(
        const ItemOffsetPair<T, Offset> &a,
        const ItemOffsetPair<T, Offset> &b) const
    {
        if (a.value == b.value)
            return (b.offset < a.offset) ? b : a;

        return (b.value < a.value) ? b : a;
    }
};





template <typename B>
struct Cast
{

    template <typename A>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) B operator()(const A &a) const
    {
        return (B) a;
    }
};
# 217 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/../thread/thread_operators.cuh"
template <
    typename ReductionOp,
    typename ItemOffsetPair>
class ReduceBySegmentOp
{
private:


    ReductionOp op;

public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) ReduceBySegmentOp(ReductionOp op) : op(op) {}


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) ItemOffsetPair operator()(
        const ItemOffsetPair &first,
        const ItemOffsetPair &second)
    {

        ItemOffsetPair retval;
        retval.offset = first.offset + second.offset;
        retval.value = (second.offset) ?
                second.value :
                op(first.value, second.value);
        return retval;
    }
};





}
} } } }
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_reduce.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 56 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_reduce.cuh"
template <
    int LENGTH,
    typename T,
    typename ReductionOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadReduce(
    T* input,
    ReductionOp reduction_op,
    T prefix,
    Int2Type<LENGTH> length)
{
    T addend = *input;
    prefix = reduction_op(prefix, addend);

    return ThreadReduce(input + 1, reduction_op, prefix, Int2Type<LENGTH - 1>());
}

template <
    typename T,
    typename ReductionOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadReduce(
    T* input,
    ReductionOp reduction_op,
    T prefix,
    Int2Type<0> length)
{
    return prefix;
}
# 92 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_reduce.cuh"
template <
    int LENGTH,
    typename T,
    typename ReductionOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadReduce(
    T* input,
    ReductionOp reduction_op,
    T prefix)
{
    return ThreadReduce(input, reduction_op, prefix, Int2Type<LENGTH>());
}
# 112 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_reduce.cuh"
template <
    int LENGTH,
    typename T,
    typename ReductionOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadReduce(
    T* input,
    ReductionOp reduction_op)
{
    T prefix = input[0];
    return ThreadReduce<LENGTH - 1>(input + 1, reduction_op, prefix);
}
# 132 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_reduce.cuh"
template <
    int LENGTH,
    typename T,
    typename ReductionOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadReduce(
    T (&input)[LENGTH],
    ReductionOp reduction_op,
    T prefix)
{
    return ThreadReduce<LENGTH>(input, reduction_op, prefix);
}
# 152 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_reduce.cuh"
template <
    int LENGTH,
    typename T,
    typename ReductionOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadReduce(
    T (&input)[LENGTH],
    ReductionOp reduction_op)
{
    return ThreadReduce<LENGTH>((T*) input, reduction_op);
}






}
} } } }
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh"
       





namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 55 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh"
template <
    int LENGTH,
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanExclusive(
    T inclusive,
    T exclusive,
    T *input,
    T *output,
    ScanOp scan_op,
    Int2Type<LENGTH> length)
{
    T addend = *input;
    inclusive = scan_op(exclusive, addend);
    *output = exclusive;
    exclusive = inclusive;

    return ThreadScanExclusive(inclusive, exclusive, input + 1, output + 1, scan_op, Int2Type<LENGTH - 1>());
}

template <
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanExclusive(
    T inclusive,
    T exclusive,
    T *input,
    T *output,
    ScanOp scan_op,
    Int2Type<0> length)
{
    return inclusive;
}
# 97 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh"
template <
    int LENGTH,
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanExclusive(
    T *input,
    T *output,
    ScanOp scan_op,
    T prefix,
    bool apply_prefix = true)
{
    T inclusive = input[0];
    if (apply_prefix)
    {
        inclusive = scan_op(prefix, inclusive);
    }
    output[0] = prefix;
    T exclusive = inclusive;

    return ThreadScanExclusive(inclusive, exclusive, input + 1, output + 1, scan_op, Int2Type<LENGTH - 1>());
}
# 127 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh"
template <
    int LENGTH,
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanExclusive(
    T (&input)[LENGTH],
    T (&output)[LENGTH],
    ScanOp scan_op,
    T prefix,
    bool apply_prefix = true)
{
    return ThreadScanExclusive<LENGTH>((T*) input, (T*) output, scan_op, prefix, apply_prefix);
}
# 149 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh"
template <
    int LENGTH,
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanInclusive(
    T inclusive,
    T *input,
    T *output,
    ScanOp scan_op,
    Int2Type<LENGTH> length)
{
    T addend = *input;
    inclusive = scan_op(inclusive, addend);
    output[0] = inclusive;

    return ThreadScanInclusive(inclusive, input + 1, output + 1, scan_op, Int2Type<LENGTH - 1>());
}

template <
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanInclusive(
    T inclusive,
    T *input,
    T *output,
    ScanOp scan_op,
    Int2Type<0> length)
{
    return inclusive;
}
# 188 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh"
template <
    int LENGTH,
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanInclusive(
    T *input,
    T *output,
    ScanOp scan_op)
{
    T inclusive = input[0];
    output[0] = inclusive;


    return ThreadScanInclusive(inclusive, input + 1, output + 1, scan_op, Int2Type<LENGTH - 1>());
}
# 212 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh"
template <
    int LENGTH,
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanInclusive(
    T (&input)[LENGTH],
    T (&output)[LENGTH],
    ScanOp scan_op)
{
    return ThreadScanInclusive<LENGTH>((T*) input, (T*) output, scan_op);
}
# 232 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh"
template <
    int LENGTH,
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanInclusive(
    T *input,
    T *output,
    ScanOp scan_op,
    T prefix,
    bool apply_prefix = true)
{
    T inclusive = input[0];
    if (apply_prefix)
    {
        inclusive = scan_op(prefix, inclusive);
    }
    output[0] = inclusive;


    return ThreadScanInclusive(inclusive, input + 1, output + 1, scan_op, Int2Type<LENGTH - 1>());
}
# 262 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../thread/thread_scan.cuh"
template <
    int LENGTH,
    typename T,
    typename ScanOp>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadScanInclusive(
    T (&input)[LENGTH],
    T (&output)[LENGTH],
    ScanOp scan_op,
    T prefix,
    bool apply_prefix = true)
{
    return ThreadScanInclusive<LENGTH>((T*) input, (T*) output, scan_op, prefix, apply_prefix);
}







}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/block_scan_raking.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/block_scan_raking.cuh"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../block/block_raking_layout.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../block/block_raking_layout.cuh"
       






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 62 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../block/block_raking_layout.cuh"
template <
    typename T,
    int BLOCK_THREADS,
    int PTX_ARCH = 0>
struct BlockRakingLayout
{




    enum
    {

        SHARED_ELEMENTS = BLOCK_THREADS,


        MAX_RAKING_THREADS = ((((1 << (5))) < (BLOCK_THREADS)) ? ((1 << (5))) : (BLOCK_THREADS)),


        SEGMENT_LENGTH = (SHARED_ELEMENTS + MAX_RAKING_THREADS - 1) / MAX_RAKING_THREADS,


        RAKING_THREADS = (SHARED_ELEMENTS + SEGMENT_LENGTH - 1) / SEGMENT_LENGTH,


        HAS_CONFLICTS = ((1 << ((PTX_ARCH >= 200) ? (5) : (4))) % SEGMENT_LENGTH == 0),


        CONFLICT_DEGREE = (HAS_CONFLICTS) ?
            (MAX_RAKING_THREADS * SEGMENT_LENGTH) / (1 << ((PTX_ARCH >= 200) ? (5) : (4))) :
            1,


        SEGMENT_PADDING = (CONFLICT_DEGREE > ((PTX_ARCH >= 300) ? (1) : (4))) ? 1 : 0,



        GRID_ELEMENTS = RAKING_THREADS * (SEGMENT_LENGTH + SEGMENT_PADDING),


        UNGUARDED = (SHARED_ELEMENTS % RAKING_THREADS == 0),
    };





    typedef T _TempStorage[BlockRakingLayout::GRID_ELEMENTS];


    struct TempStorage : Uninitialized<_TempStorage> {};





    static __attribute__((device)) __inline__ __attribute__((always_inline)) T* PlacementPtr(
        TempStorage &temp_storage,
        int linear_tid)
    {

        unsigned int offset = linear_tid;


        if (SEGMENT_PADDING > 0)
        {
            offset += offset / SEGMENT_LENGTH;
        }


        return temp_storage.Alias() + offset;
    }





    static __attribute__((device)) __inline__ __attribute__((always_inline)) T* RakingPtr(
        TempStorage &temp_storage,
        int linear_tid)
    {
        return temp_storage.Alias() + (linear_tid * (SEGMENT_LENGTH + SEGMENT_PADDING));
    }
};

}
} } } }
# 40 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/block_scan_raking.cuh" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
       







namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {




template <
    typename T,
    int LOGICAL_WARP_THREADS,
    int PTX_ARCH>
struct WarpScanShfl
{





    enum
    {

        IS_ARCH_WARP = (LOGICAL_WARP_THREADS == (1 << (5))),


        STEPS = Log2<LOGICAL_WARP_THREADS>::VALUE,


        SHFL_C = ((-1 << STEPS) & 31) << 8,
    };

    template <typename S>
    struct IsInteger
    {
        enum {

            IS_INTEGER = (Traits<S>::CATEGORY == UNSIGNED_INTEGER) || (Traits<S>::CATEGORY == SIGNED_INTEGER),


            IS_SMALL_INTEGER = IS_INTEGER && (sizeof(S) <= sizeof(unsigned int))
        };
    };


    typedef NullType TempStorage;






    int lane_id;






    __attribute__((device)) __inline__ __attribute__((always_inline)) WarpScanShfl(
        TempStorage &temp_storage)
    :
        lane_id(IS_ARCH_WARP ?
            LaneId() :
            LaneId() % LOGICAL_WARP_THREADS)
    {}







    __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int InclusiveScanStep(
        unsigned int input,
        cub_::Sum scan_op,
        int first_lane,
        int offset)
    {
        unsigned int output;


        asm(
            "{"
            "  .reg .u32 r0;"
            "  .reg .pred p;"
            "  shfl.up.b32 r0|p, %1, %2, %3;"
            "  @p add.u32 r0, r0, %4;"
            "  mov.u32 %0, r0;"
            "}"
            : "=r"(output) : "r"(input), "r"(offset), "r"(first_lane), "r"(input));

        return output;
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) float InclusiveScanStep(
        float input,
        cub_::Sum scan_op,
        int first_lane,
        int offset)
    {
        float output;


        asm(
            "{"
            "  .reg .f32 r0;"
            "  .reg .pred p;"
            "  shfl.up.b32 r0|p, %1, %2, %3;"
            "  @p add.f32 r0, r0, %4;"
            "  mov.f32 %0, r0;"
            "}"
            : "=f"(output) : "f"(input), "r"(offset), "r"(first_lane), "f"(input));

        return output;
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned long long InclusiveScanStep(
        unsigned long long input,
        cub_::Sum scan_op,
        int first_lane,
        int offset)
    {
        unsigned long long output;


        asm(
            "{"
            "  .reg .u32 lo;"
            "  .reg .u32 hi;"
            "  .reg .pred p;"
            "  mov.b64 {lo, hi}, %1;"
            "  shfl.up.b32 lo|p, lo, %2, %3;"
            "  shfl.up.b32 hi|p, hi, %2, %3;"
            "  mov.b64 %0, {lo, hi};"
            "  @p add.u64 %0, %0, %1;"
            "}"
            : "=l"(output) : "l"(input), "r"(offset), "r"(first_lane));

        return output;
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) long long InclusiveScanStep(
        long long input,
        cub_::Sum scan_op,
        int first_lane,
        int offset)
    {
        long long output;


        asm(
            "{"
            "  .reg .u32 lo;"
            "  .reg .u32 hi;"
            "  .reg .pred p;"
            "  mov.b64 {lo, hi}, %1;"
            "  shfl.up.b32 lo|p, lo, %2, %3;"
            "  shfl.up.b32 hi|p, hi, %2, %3;"
            "  mov.b64 %0, {lo, hi};"
            "  @p add.s64 %0, %0, %1;"
            "}"
            : "=l"(output) : "l"(input), "r"(offset), "r"(first_lane));

        return output;
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) double InclusiveScanStep(
        double input,
        cub_::Sum scan_op,
        int first_lane,
        int offset)
    {
        double output;


        asm(
            "{"
            "  .reg .u32 lo;"
            "  .reg .u32 hi;"
            "  .reg .pred p;"
            "  mov.b64 {lo, hi}, %1;"
            "  shfl.up.b32 lo|p, lo, %2, %3;"
            "  shfl.up.b32 hi|p, hi, %2, %3;"
            "  mov.b64 %0, {lo, hi};"
            "  @p add.f64 %0, %0, %1;"
            "}"
            : "=d"(output) : "d"(input), "r"(offset), "r"(first_lane));

        return output;
    }



    template <typename Value, typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) ItemOffsetPair<Value, Offset> InclusiveScanStep(
        ItemOffsetPair<Value, Offset> input,
        ReduceBySegmentOp<cub_::Sum, ItemOffsetPair<Value, Offset> > scan_op,
        int first_lane,
        int offset)
    {
        ItemOffsetPair<Value, Offset> output;

        output.value = InclusiveScanStep(input.value, cub_::Sum(), first_lane, offset, Int2Type<IsInteger<Value>::IS_SMALL_INTEGER>());
        output.offset = InclusiveScanStep(input.offset, cub_::Sum(), first_lane, offset, Int2Type<IsInteger<Offset>::IS_SMALL_INTEGER>());

        if (input.offset > 0)
            output.value = input.value;





        return output;
    }



    template <typename _T, typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) _T InclusiveScanStep(
        _T input,
        ScanOp scan_op,
        int first_lane,
        int offset)
    {
        T output = input;

        T temp = ShuffleUp(output, offset);


        if (lane_id >= offset)
            output = scan_op(temp, output);

        return output;
    }



    template <typename _T, typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) _T InclusiveScanStep(
        _T input,
        ScanOp scan_op,
        int first_lane,
        int offset,
        Int2Type<true> is_small_integer)
    {
        unsigned int temp = reinterpret_cast<unsigned int &>(input);

        temp = InclusiveScanStep(temp, scan_op, first_lane, offset);

        return reinterpret_cast<_T&>(temp);
    }



    template <typename _T, typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) _T InclusiveScanStep(
        _T input,
        ScanOp scan_op,
        int first_lane,
        int offset,
        Int2Type<false> is_small_integer)
    {
        return InclusiveScanStep(input, scan_op, first_lane, offset);
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) T GetExclusive(
        T input,
        T inclusive,
        cub_::Sum scan_op,
        Int2Type<true> is_integer)
    {
        return inclusive - input;
    }



    template <typename ScanOp, int _IS_INTEGER>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T GetExclusive(
        T input,
        T inclusive,
        ScanOp scan_op,
        Int2Type<_IS_INTEGER> is_integer)
    {
        return ShuffleUp(inclusive, 1);
    }


    __attribute__((device)) __inline__ __attribute__((always_inline)) T GetExclusive(
        T input,
        T inclusive,
        T identity,
        cub_::Sum scan_op,
        Int2Type<true> is_integer)
    {
        return inclusive - input;
    }



    template <typename ScanOp, int _IS_INTEGER>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T GetExclusive(
        T input,
        T inclusive,
        T identity,
        ScanOp scan_op,
        Int2Type<_IS_INTEGER> is_integer)
    {
        T exclusive = ShuffleUp(inclusive, 1);
        return (lane_id == 0) ? identity : exclusive;
    }
# 370 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Broadcast(
        T input,
        int src_lane)
    {
        return ShuffleBroadcast(input, src_lane, LOGICAL_WARP_THREADS);
    }







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        output = input;


#pragma unroll
        for (int STEP = 0; STEP < STEPS; STEP++)
        {
            output = InclusiveScanStep(output, scan_op, SHFL_C, 1 << STEP, Int2Type<IsInteger<T>::IS_SMALL_INTEGER>());
        }
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &warp_aggregate)
    {
        InclusiveScan(input, output, scan_op);


        warp_aggregate = Broadcast(output, LOGICAL_WARP_THREADS - 1);
    }







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Scan(
        T input,
        T &inclusive_output,
        T &exclusive_output,
        ScanOp scan_op)
    {

        InclusiveScan(input, inclusive_output, scan_op);


        exclusive_output = GetExclusive(input, inclusive_output, scan_op, Int2Type<IsInteger<T>::IS_INTEGER>());
    }


    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Scan(
        T input,
        T &inclusive_output,
        T &exclusive_output,
        T identity,
        ScanOp scan_op)
    {

        InclusiveScan(input, inclusive_output, scan_op);


        exclusive_output = GetExclusive(input, inclusive_output, identity, scan_op, Int2Type<IsInteger<T>::IS_INTEGER>());
    }







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op)
    {
        T inclusive_output;
        Scan(input, inclusive_output, output, identity, scan_op);
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        T inclusive_output;
        Scan(input, inclusive_output, output, scan_op);
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op,
        T &warp_aggregate)
    {
        T inclusive_output;
        Scan(input, inclusive_output, output, identity, scan_op);


        warp_aggregate = Broadcast(inclusive_output, LOGICAL_WARP_THREADS - 1);
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &warp_aggregate)
    {
        T inclusive_output;
        Scan(input, inclusive_output, output, scan_op);


        warp_aggregate = Broadcast(inclusive_output, LOGICAL_WARP_THREADS - 1);
    }

};


}
} } } }
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/warp_scan_smem.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_load.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_load.cuh"
       
# 45 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_load.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 62 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_load.cuh"
enum CacheLoadModifier
{
    LOAD_DEFAULT,
    LOAD_CA,
    LOAD_CG,
    LOAD_CS,
    LOAD_CV,
    LOAD_LDG,
    LOAD_VOLATILE,
};
# 107 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_load.cuh"
template <
    CacheLoadModifier MODIFIER,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) typename std::iterator_traits<InputIterator>::value_type ThreadLoad(InputIterator itr);
# 120 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_load.cuh"
template <int COUNT, int MAX>
struct IterateThreadLoad
{
    template <CacheLoadModifier MODIFIER, typename T>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(T *ptr, T *vals)
    {
        vals[COUNT] = ThreadLoad<MODIFIER>(ptr + COUNT);
        IterateThreadLoad<COUNT + 1, MAX>::template Load<MODIFIER>(ptr, vals);
    }

    template <typename InputIterator, typename T>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) void Dereference(InputIterator ptr, T *vals)
    {
        vals[COUNT] = ptr[COUNT];
        IterateThreadLoad<COUNT + 1, MAX>::Dereference(ptr, vals);
    }
};



template <int MAX>
struct IterateThreadLoad<MAX, MAX>
{
    template <CacheLoadModifier MODIFIER, typename T>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(T *ptr, T *vals) {}

    template <typename InputIterator, typename T>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) void Dereference(InputIterator ptr, T *vals) {}
};
# 284 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_load.cuh"
    template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint4 ThreadLoad<LOAD_CA, uint4*>(uint4* ptr) { uint4 retval; asm volatile ("ld.""global"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ulonglong2 ThreadLoad<LOAD_CA, ulonglong2*>(ulonglong2* ptr) { ulonglong2 retval; asm volatile ("ld.""global"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ushort4 ThreadLoad<LOAD_CA, ushort4*>(ushort4* ptr) { ushort4 retval; asm volatile ("ld.""global"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint2 ThreadLoad<LOAD_CA, uint2*>(uint2* ptr) { uint2 retval; asm volatile ("ld.""global"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned long long ThreadLoad<LOAD_CA, unsigned long long*>(unsigned long long* ptr) { unsigned long long retval; asm volatile ("ld.""global"".u64 %0, [%1];" : "=l"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int ThreadLoad<LOAD_CA, unsigned int*>(unsigned int* ptr) { unsigned int retval; asm volatile ("ld.""global"".u32 %0, [%1];" : "=r"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned short ThreadLoad<LOAD_CA, unsigned short*>(unsigned short* ptr) { unsigned short retval; asm volatile ("ld.""global"".u16 %0, [%1];" : "=h"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned char ThreadLoad<LOAD_CA, unsigned char*>(unsigned char* ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "l"(ptr)); return (unsigned char) retval; }

    template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint4 ThreadLoad<LOAD_CG, uint4*>(uint4* ptr) { uint4 retval; asm volatile ("ld.""volatile.global"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ulonglong2 ThreadLoad<LOAD_CG, ulonglong2*>(ulonglong2* ptr) { ulonglong2 retval; asm volatile ("ld.""volatile.global"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ushort4 ThreadLoad<LOAD_CG, ushort4*>(ushort4* ptr) { ushort4 retval; asm volatile ("ld.""volatile.global"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint2 ThreadLoad<LOAD_CG, uint2*>(uint2* ptr) { uint2 retval; asm volatile ("ld.""volatile.global"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned long long ThreadLoad<LOAD_CG, unsigned long long*>(unsigned long long* ptr) { unsigned long long retval; asm volatile ("ld.""volatile.global"".u64 %0, [%1];" : "=l"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int ThreadLoad<LOAD_CG, unsigned int*>(unsigned int* ptr) { unsigned int retval; asm volatile ("ld.""volatile.global"".u32 %0, [%1];" : "=r"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned short ThreadLoad<LOAD_CG, unsigned short*>(unsigned short* ptr) { unsigned short retval; asm volatile ("ld.""volatile.global"".u16 %0, [%1];" : "=h"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned char ThreadLoad<LOAD_CG, unsigned char*>(unsigned char* ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""volatile.global"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "l"(ptr)); return (unsigned char) retval; }
    template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint4 ThreadLoad<LOAD_CS, uint4*>(uint4* ptr) { uint4 retval; asm volatile ("ld.""global"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ulonglong2 ThreadLoad<LOAD_CS, ulonglong2*>(ulonglong2* ptr) { ulonglong2 retval; asm volatile ("ld.""global"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ushort4 ThreadLoad<LOAD_CS, ushort4*>(ushort4* ptr) { ushort4 retval; asm volatile ("ld.""global"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint2 ThreadLoad<LOAD_CS, uint2*>(uint2* ptr) { uint2 retval; asm volatile ("ld.""global"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned long long ThreadLoad<LOAD_CS, unsigned long long*>(unsigned long long* ptr) { unsigned long long retval; asm volatile ("ld.""global"".u64 %0, [%1];" : "=l"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int ThreadLoad<LOAD_CS, unsigned int*>(unsigned int* ptr) { unsigned int retval; asm volatile ("ld.""global"".u32 %0, [%1];" : "=r"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned short ThreadLoad<LOAD_CS, unsigned short*>(unsigned short* ptr) { unsigned short retval; asm volatile ("ld.""global"".u16 %0, [%1];" : "=h"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned char ThreadLoad<LOAD_CS, unsigned char*>(unsigned char* ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "l"(ptr)); return (unsigned char) retval; }
    template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint4 ThreadLoad<LOAD_CV, uint4*>(uint4* ptr) { uint4 retval; asm volatile ("ld.""volatile.global"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ulonglong2 ThreadLoad<LOAD_CV, ulonglong2*>(ulonglong2* ptr) { ulonglong2 retval; asm volatile ("ld.""volatile.global"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ushort4 ThreadLoad<LOAD_CV, ushort4*>(ushort4* ptr) { ushort4 retval; asm volatile ("ld.""volatile.global"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint2 ThreadLoad<LOAD_CV, uint2*>(uint2* ptr) { uint2 retval; asm volatile ("ld.""volatile.global"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned long long ThreadLoad<LOAD_CV, unsigned long long*>(unsigned long long* ptr) { unsigned long long retval; asm volatile ("ld.""volatile.global"".u64 %0, [%1];" : "=l"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int ThreadLoad<LOAD_CV, unsigned int*>(unsigned int* ptr) { unsigned int retval; asm volatile ("ld.""volatile.global"".u32 %0, [%1];" : "=r"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned short ThreadLoad<LOAD_CV, unsigned short*>(unsigned short* ptr) { unsigned short retval; asm volatile ("ld.""volatile.global"".u16 %0, [%1];" : "=h"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned char ThreadLoad<LOAD_CV, unsigned char*>(unsigned char* ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""volatile.global"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "l"(ptr)); return (unsigned char) retval; }





    template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint4 ThreadLoad<LOAD_LDG, uint4*>(uint4* ptr) { uint4 retval; asm volatile ("ld.""global"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ulonglong2 ThreadLoad<LOAD_LDG, ulonglong2*>(ulonglong2* ptr) { ulonglong2 retval; asm volatile ("ld.""global"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) ushort4 ThreadLoad<LOAD_LDG, ushort4*>(ushort4* ptr) { ushort4 retval; asm volatile ("ld.""global"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) uint2 ThreadLoad<LOAD_LDG, uint2*>(uint2* ptr) { uint2 retval; asm volatile ("ld.""global"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned long long ThreadLoad<LOAD_LDG, unsigned long long*>(unsigned long long* ptr) { unsigned long long retval; asm volatile ("ld.""global"".u64 %0, [%1];" : "=l"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int ThreadLoad<LOAD_LDG, unsigned int*>(unsigned int* ptr) { unsigned int retval; asm volatile ("ld.""global"".u32 %0, [%1];" : "=r"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned short ThreadLoad<LOAD_LDG, unsigned short*>(unsigned short* ptr) { unsigned short retval; asm volatile ("ld.""global"".u16 %0, [%1];" : "=h"(retval) : "l"(ptr)); return retval; } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned char ThreadLoad<LOAD_LDG, unsigned char*>(unsigned char* ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "l"(ptr)); return (unsigned char) retval; }






template <typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) typename std::iterator_traits<InputIterator>::value_type ThreadLoad(
    InputIterator itr,
    Int2Type<LOAD_DEFAULT> modifier,
    Int2Type<false> is_pointer)
{
    return *itr;
}





template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadLoad(
    T *ptr,
    Int2Type<LOAD_DEFAULT> modifier,
    Int2Type<true> is_pointer)
{
    return *ptr;
}





template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadLoadVolatilePointer(
    T *ptr,
    Int2Type<true> is_primitive)
{
    T retval = *reinterpret_cast<volatile T*>(ptr);


    if (sizeof(T) == 1) __threadfence_block();


    return retval;
}





template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadLoadVolatilePointer(
    T *ptr,
    Int2Type<false> is_primitive)
{



    T retval = *ptr;
    __threadfence_block();
    return retval;
# 380 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_load.cuh"
}





template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadLoad(
    T *ptr,
    Int2Type<LOAD_VOLATILE> modifier,
    Int2Type<true> is_pointer)
{

    return ThreadLoadVolatilePointer(ptr, Int2Type<Traits<T>::PRIMITIVE>());
}





template <typename T, int MODIFIER>
__attribute__((device)) __inline__ __attribute__((always_inline)) T ThreadLoad(
    T *ptr,
    Int2Type<MODIFIER> modifier,
    Int2Type<true> is_pointer)
{
    typedef typename UnitWord<T>::DeviceWord DeviceWord;

    const int DEVICE_MULTIPLE = sizeof(T) / sizeof(DeviceWord);

    DeviceWord words[DEVICE_MULTIPLE];

    IterateThreadLoad<0, DEVICE_MULTIPLE>::template Load<CacheLoadModifier(MODIFIER)>(
        reinterpret_cast<DeviceWord*>(ptr),
        words);

    return *reinterpret_cast<T*>(words);
}





template <
    CacheLoadModifier MODIFIER,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) typename std::iterator_traits<InputIterator>::value_type ThreadLoad(InputIterator itr)
{

    return ThreadLoad(
        itr,
        Int2Type<MODIFIER>(),
        Int2Type<IsPointer<InputIterator>::VALUE>());
}
# 443 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_load.cuh"
}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/warp_scan_smem.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_store.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_store.cuh"
       
# 43 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_store.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 61 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_store.cuh"
enum CacheStoreModifier
{
    STORE_DEFAULT,
    STORE_WB,
    STORE_CG,
    STORE_CS,
    STORE_WT,
    STORE_VOLATILE,
};
# 110 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_store.cuh"
template <
    CacheStoreModifier MODIFIER,
    typename OutputIterator,
    typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore(OutputIterator itr, T val);
# 124 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_store.cuh"
template <int COUNT, int MAX>
struct IterateThreadStore
{
    template <CacheStoreModifier MODIFIER, typename T>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(T *ptr, T *vals)
    {
        ThreadStore<MODIFIER>(ptr + COUNT, vals[COUNT]);
        IterateThreadStore<COUNT + 1, MAX>::template Store<MODIFIER>(ptr, vals);
    }

    template <typename OutputIterator, typename T>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) void Dereference(OutputIterator ptr, T *vals)
    {
        ptr[COUNT] = vals[COUNT];
        IterateThreadStore<COUNT + 1, MAX>::Dereference(ptr, vals);
    }

};


template <int MAX>
struct IterateThreadStore<MAX, MAX>
{
    template <CacheStoreModifier MODIFIER, typename T>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(T *ptr, T *vals) {}

    template <typename OutputIterator, typename T>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) void Dereference(OutputIterator ptr, T *vals) {}
};
# 272 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_store.cuh"
    template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WB, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""global"".v4.u32 [%0], {%1, %2, %3, %4};" : : "l"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WB, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""global"".v2.u64 [%0], {%1, %2};" : : "l"(ptr), "l"(val.x), "l"(val.y)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WB, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""global"".v4.u16 [%0], {%1, %2, %3, %4};" : : "l"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WB, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""global"".v2.u32 [%0], {%1, %2};" : : "l"(ptr), "r"(val.x), "r"(val.y)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WB, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""global"".u64 [%0], %1;" : : "l"(ptr), "l"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WB, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""global"".u32 [%0], %1;" : : "l"(ptr), "r"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WB, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""global"".u16 [%0], %1;" : : "l"(ptr), "h"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WB, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""global"".u8 [%0], datum;" "}" : : "l"(ptr), "h"((unsigned short) val)); }
    template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CG, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""global"".v4.u32 [%0], {%1, %2, %3, %4};" : : "l"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CG, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""global"".v2.u64 [%0], {%1, %2};" : : "l"(ptr), "l"(val.x), "l"(val.y)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CG, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""global"".v4.u16 [%0], {%1, %2, %3, %4};" : : "l"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CG, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""global"".v2.u32 [%0], {%1, %2};" : : "l"(ptr), "r"(val.x), "r"(val.y)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CG, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""global"".u64 [%0], %1;" : : "l"(ptr), "l"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CG, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""global"".u32 [%0], %1;" : : "l"(ptr), "r"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CG, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""global"".u16 [%0], %1;" : : "l"(ptr), "h"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CG, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""global"".u8 [%0], datum;" "}" : : "l"(ptr), "h"((unsigned short) val)); }
    template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CS, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""global"".v4.u32 [%0], {%1, %2, %3, %4};" : : "l"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CS, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""global"".v2.u64 [%0], {%1, %2};" : : "l"(ptr), "l"(val.x), "l"(val.y)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CS, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""global"".v4.u16 [%0], {%1, %2, %3, %4};" : : "l"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CS, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""global"".v2.u32 [%0], {%1, %2};" : : "l"(ptr), "r"(val.x), "r"(val.y)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CS, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""global"".u64 [%0], %1;" : : "l"(ptr), "l"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CS, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""global"".u32 [%0], %1;" : : "l"(ptr), "r"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CS, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""global"".u16 [%0], %1;" : : "l"(ptr), "h"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_CS, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""global"".u8 [%0], datum;" "}" : : "l"(ptr), "h"((unsigned short) val)); }
    template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WT, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""volatile.global"".v4.u32 [%0], {%1, %2, %3, %4};" : : "l"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WT, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""volatile.global"".v2.u64 [%0], {%1, %2};" : : "l"(ptr), "l"(val.x), "l"(val.y)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WT, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""volatile.global"".v4.u16 [%0], {%1, %2, %3, %4};" : : "l"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WT, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""volatile.global"".v2.u32 [%0], {%1, %2};" : : "l"(ptr), "r"(val.x), "r"(val.y)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WT, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""volatile.global"".u64 [%0], %1;" : : "l"(ptr), "l"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WT, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""volatile.global"".u32 [%0], %1;" : : "l"(ptr), "r"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WT, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""volatile.global"".u16 [%0], %1;" : : "l"(ptr), "h"(val)); } template<> __attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore<STORE_WT, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""volatile.global"".u8 [%0], datum;" "}" : : "l"(ptr), "h"((unsigned short) val)); }






template <typename OutputIterator, typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore(
    OutputIterator itr,
    T val,
    Int2Type<STORE_DEFAULT> modifier,
    Int2Type<false> is_pointer)
{
    *itr = val;
}





template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore(
    T *ptr,
    T val,
    Int2Type<STORE_DEFAULT> modifier,
    Int2Type<true> is_pointer)
{
    *ptr = val;
}





template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStoreVolatilePtr(
    T *ptr,
    T val,
    Int2Type<true> is_primitive)
{
    *reinterpret_cast<volatile T*>(ptr) = val;
}





template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStoreVolatilePtr(
    T *ptr,
    T val,
    Int2Type<false> is_primitive)
{


    *ptr = val;
    __threadfence_block();
# 351 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_store.cuh"
}





template <typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore(
    T *ptr,
    T val,
    Int2Type<STORE_VOLATILE> modifier,
    Int2Type<true> is_pointer)
{
    ThreadStoreVolatilePtr(ptr, val, Int2Type<Traits<T>::PRIMITIVE>());
}





template <typename T, int MODIFIER>
__attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore(
    T *ptr,
    T val,
    Int2Type<MODIFIER> modifier,
    Int2Type<true> is_pointer)
{
    typedef typename UnitWord<T>::DeviceWord DeviceWord;

    const int DEVICE_MULTIPLE = sizeof(T) / sizeof(DeviceWord);

    DeviceWord words[DEVICE_MULTIPLE];

    *reinterpret_cast<T*>(words) = val;

    IterateThreadStore<0, DEVICE_MULTIPLE>::template Store<CacheStoreModifier(MODIFIER)>(
        reinterpret_cast<DeviceWord*>(ptr),
        words);
}





template <CacheStoreModifier MODIFIER, typename OutputIterator, typename T>
__attribute__((device)) __inline__ __attribute__((always_inline)) void ThreadStore(OutputIterator itr, T val)
{
    ThreadStore(
        itr,
        val,
        Int2Type<MODIFIER>(),
        Int2Type<IsPointer<OutputIterator>::VALUE>());
}
# 413 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/../../thread/thread_store.cuh"
}
} } } }
# 39 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/specializations/warp_scan_smem.cuh" 2




namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {




template <
    typename T,
    int LOGICAL_WARP_THREADS,
    int PTX_ARCH>
struct WarpScanSmem
{




    enum
    {

        IS_ARCH_WARP = (LOGICAL_WARP_THREADS == (1 << (5))),


        STEPS = Log2<LOGICAL_WARP_THREADS>::VALUE,


        HALF_WARP_THREADS = 1 << (STEPS - 1),


        WARP_SMEM_ELEMENTS = LOGICAL_WARP_THREADS + HALF_WARP_THREADS,


        IS_INTEGER = (Traits<T>::CATEGORY == UNSIGNED_INTEGER) || (Traits<T>::CATEGORY == SIGNED_INTEGER),

    };


    typedef typename If<((Equals<T, char>::VALUE || Equals<T, signed char>::VALUE) && (PTX_ARCH < 200)), int, T>::Type CellT;


    typedef CellT _TempStorage[WARP_SMEM_ELEMENTS];


    struct TempStorage : Uninitialized<_TempStorage> {};






    _TempStorage &temp_storage;
    unsigned int lane_id;







    __attribute__((device)) __inline__ __attribute__((always_inline)) WarpScanSmem(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        lane_id(IS_ARCH_WARP ?
            LaneId() :
            LaneId() % LOGICAL_WARP_THREADS)
    {}







    template <
        bool HAS_IDENTITY,
        int STEP,
        typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScanStep(
        T &partial,
        ScanOp scan_op,
        Int2Type<STEP> step)
    {
        const int OFFSET = 1 << STEP;


        ThreadStore<STORE_VOLATILE>(&temp_storage[HALF_WARP_THREADS + lane_id], (CellT) partial);


        if (HAS_IDENTITY || (lane_id >= OFFSET))
        {
            T addend = (T) ThreadLoad<LOAD_VOLATILE>(&temp_storage[HALF_WARP_THREADS + lane_id - OFFSET]);
            partial = scan_op(addend, partial);
        }

        ScanStep<HAS_IDENTITY>(partial, scan_op, Int2Type<STEP + 1>());
    }



    template <
        bool HAS_IDENTITY,
        typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScanStep(
        T &partial,
        ScanOp scan_op,
        Int2Type<STEPS> step)
    {}



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op)
    {
        ThreadStore<STORE_VOLATILE>(&temp_storage[lane_id], (CellT) identity);


        output = input;
        ScanStep<true>(output, scan_op, Int2Type<0>());
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        Sum scan_op,
        Int2Type<true> is_primitive)
    {
        T identity = ZeroInitialize<T>();
        InclusiveScan(input, output, identity, scan_op);
    }



    template <typename ScanOp, int IS_PRIMITIVE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        Int2Type<IS_PRIMITIVE> is_primitive)
    {

        output = input;
        ScanStep<false>(output, scan_op, Int2Type<0>());
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) T GetExclusive(
        T input,
        T inclusive,
        Sum scan_op,
        Int2Type<true> is_integer)
    {
        return inclusive - input;
    }



    template <typename ScanOp, int _IS_INTEGER>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T GetExclusive(
        T input,
        T inclusive,
        ScanOp scan_op,
        Int2Type<_IS_INTEGER> is_integer)
    {
        ThreadStore<STORE_VOLATILE>(&temp_storage[HALF_WARP_THREADS + lane_id], (CellT) inclusive);
        return (T) ThreadLoad<LOAD_VOLATILE>(&temp_storage[HALF_WARP_THREADS + lane_id - 1]);
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) T GetExclusive(
        T input,
        T inclusive,
        Sum scan_op,
        T &warp_aggregate,
        Int2Type<true> is_integer)
    {
        ThreadStore<STORE_VOLATILE>(&temp_storage[HALF_WARP_THREADS + lane_id], (CellT) inclusive);
        warp_aggregate = (T) ThreadLoad<LOAD_VOLATILE>(&temp_storage[WARP_SMEM_ELEMENTS - 1]);

        return inclusive - input;
    }



    template <typename ScanOp, int _IS_INTEGER>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T GetExclusive(
        T input,
        T inclusive,
        ScanOp scan_op,
        T &warp_aggregate,
        Int2Type<_IS_INTEGER> is_integer)
    {
        ThreadStore<STORE_VOLATILE>(&temp_storage[HALF_WARP_THREADS + lane_id], (CellT) inclusive);
        warp_aggregate = (T) ThreadLoad<LOAD_VOLATILE>(&temp_storage[WARP_SMEM_ELEMENTS - 1]);

        return (T) ThreadLoad<LOAD_VOLATILE>(&temp_storage[HALF_WARP_THREADS + lane_id - 1]);
    }







    __attribute__((device)) __inline__ __attribute__((always_inline)) T Broadcast(
        T input,
        unsigned int src_lane)
    {
        if (lane_id == src_lane)
        {
            ThreadStore<STORE_VOLATILE>(temp_storage, (CellT) input);
        }

        return (T) ThreadLoad<LOAD_VOLATILE>(temp_storage);
    }







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        InclusiveScan(input, output, scan_op, Int2Type<Traits<T>::PRIMITIVE>()); }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &warp_aggregate)
    {
        InclusiveScan(input, output, scan_op);


        ThreadStore<STORE_VOLATILE>(&temp_storage[HALF_WARP_THREADS + lane_id], (CellT) output);
        warp_aggregate = (T) ThreadLoad<LOAD_VOLATILE>(&temp_storage[WARP_SMEM_ELEMENTS - 1]);
    }







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Scan(
        T input,
        T &inclusive_output,
        T &exclusive_output,
        ScanOp scan_op)
    {

        InclusiveScan(input, inclusive_output, scan_op);


        exclusive_output = GetExclusive(input, inclusive_output, scan_op, Int2Type<IS_INTEGER>());
    }


    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Scan(
        T input,
        T &inclusive_output,
        T &exclusive_output,
        T identity,
        ScanOp scan_op)
    {

        InclusiveScan(input, inclusive_output, identity, scan_op);


        exclusive_output = GetExclusive(input, inclusive_output, scan_op, Int2Type<IS_INTEGER>());
    }







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op)
    {
        T inclusive_output;
        Scan(input, inclusive_output, output, identity, scan_op);
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        T inclusive_output;
        Scan(input, inclusive_output, output, scan_op);
    }


    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op,
        T &warp_aggregate)
    {

        T inclusive_output;
        InclusiveScan(input, inclusive_output, identity, scan_op);


        output = GetExclusive(input, inclusive_output, scan_op, warp_aggregate, Int2Type<IS_INTEGER>());
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &warp_aggregate)
    {

        T inclusive_output;
        InclusiveScan(input, inclusive_output, scan_op);


        output = GetExclusive(input, inclusive_output, scan_op, warp_aggregate, Int2Type<IS_INTEGER>());
    }


};


}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh" 2






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 142 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
template <
    typename T,
    int LOGICAL_WARP_THREADS = (1 << (5)),
    int PTX_ARCH = 0>
class WarpScan
{
private:





    enum
    {

        IS_ARCH_WARP = (LOGICAL_WARP_THREADS == (1 << (5))),


        IS_POW_OF_TWO = ((LOGICAL_WARP_THREADS & (LOGICAL_WARP_THREADS - 1)) == 0),


        IS_INTEGER = ((Traits<T>::CATEGORY == SIGNED_INTEGER) || (Traits<T>::CATEGORY == UNSIGNED_INTEGER))
    };


    typedef typename If<(PTX_ARCH >= 300) && (IS_POW_OF_TWO),
        WarpScanShfl<T, LOGICAL_WARP_THREADS, PTX_ARCH>,
        WarpScanSmem<T, LOGICAL_WARP_THREADS, PTX_ARCH> >::Type InternalWarpScan;


    typedef typename InternalWarpScan::TempStorage _TempStorage;







    _TempStorage &temp_storage;
    int lane_id;







public:


    struct TempStorage : Uninitialized<_TempStorage> {};
# 203 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) WarpScan(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        lane_id(IS_ARCH_WARP ?
            LaneId() :
            LaneId() % LOGICAL_WARP_THREADS)
    {}
# 254 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveSum(
        T input,
        T &output)
    {
        InternalWarpScan(temp_storage).InclusiveScan(input, output, cub_::Sum());
    }
# 297 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveSum(
        T input,
        T &output,
        T &warp_aggregate)
    {
        InternalWarpScan(temp_storage).InclusiveScan(input, output, cub_::Sum(), warp_aggregate);
    }
# 349 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveSum(
        T input,
        T &output)
    {
        InternalWarpScan(temp_storage).ExclusiveScan(input, output, ZeroInitialize<T>(), cub_::Sum());
    }
# 393 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveSum(
        T input,
        T &output,
        T &warp_aggregate)
    {
        InternalWarpScan(temp_storage).ExclusiveScan(input, output, ZeroInitialize<T>(), cub_::Sum(), warp_aggregate);
    }
# 444 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        InternalWarpScan(temp_storage).InclusiveScan(input, output, scan_op);
    }
# 494 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &warp_aggregate)
    {
        InternalWarpScan(temp_storage).InclusiveScan(input, output, scan_op, warp_aggregate);
    }
# 547 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op)
    {
        InternalWarpScan(temp_storage).ExclusiveScan(input, output, identity, scan_op);
    }
# 597 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op,
        T &warp_aggregate)
    {
        InternalWarpScan(temp_storage).ExclusiveScan(input, output, identity, scan_op, warp_aggregate);
    }
# 653 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        InternalWarpScan(temp_storage).ExclusiveScan(input, output, scan_op);
    }
# 702 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &warp_aggregate)
    {
        InternalWarpScan(temp_storage).ExclusiveScan(input, output, scan_op, warp_aggregate);
    }
# 759 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Sum(
        T input,
        T &inclusive_output,
        T &exclusive_output)
    {
        InternalWarpScan(temp_storage).Scan(input, inclusive_output, exclusive_output, ZeroInitialize<T>(), cub_::Sum());
    }
# 807 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Scan(
        T input,
        T &inclusive_output,
        T &exclusive_output,
        T identity,
        ScanOp scan_op)
    {
        InternalWarpScan(temp_storage).Scan(input, inclusive_output, exclusive_output, identity, scan_op);
    }
# 858 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Scan(
        T input,
        T &inclusive_output,
        T &exclusive_output,
        ScanOp scan_op)
    {
        InternalWarpScan(temp_storage).Scan(input, inclusive_output, exclusive_output, scan_op);
    }
# 910 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/../../warp/warp_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Broadcast(
        T input,
        unsigned int src_lane)
    {
        return InternalWarpScan(temp_storage).Broadcast(input, src_lane);
    }



};



}
} } } }
# 43 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/block_scan_raking.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {





template <
    typename T,
    int BLOCK_DIM_X,
    int BLOCK_DIM_Y,
    int BLOCK_DIM_Z,
    bool MEMOIZE,
    int PTX_ARCH>
struct BlockScanRaking
{





    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };


    typedef BlockRakingLayout<T, BLOCK_THREADS, PTX_ARCH> BlockRakingLayout;


    enum
    {

        RAKING_THREADS = BlockRakingLayout::RAKING_THREADS,


        SEGMENT_LENGTH = BlockRakingLayout::SEGMENT_LENGTH,


        WARP_SYNCHRONOUS = (BLOCK_THREADS == RAKING_THREADS),
    };


    typedef WarpScan<T, RAKING_THREADS, PTX_ARCH> WarpScan;


    struct _TempStorage
    {
        typename WarpScan::TempStorage warp_scan;
        typename BlockRakingLayout::TempStorage raking_grid;
        T block_aggregate;
    };



    struct TempStorage : Uninitialized<_TempStorage> {};







    _TempStorage &temp_storage;
    int linear_tid;
    T cached_segment[SEGMENT_LENGTH];







    template <int ITERATION, typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T GuardedReduce(
        T* raking_ptr,
        ScanOp scan_op,
        T raking_partial,
        Int2Type<ITERATION> iteration)
    {
        if ((BlockRakingLayout::UNGUARDED) || (((linear_tid * SEGMENT_LENGTH) + ITERATION) < BLOCK_THREADS))
        {
            T addend = raking_ptr[ITERATION];
            raking_partial = scan_op(raking_partial, addend);
        }

        return GuardedReduce(raking_ptr, scan_op, raking_partial, Int2Type<ITERATION + 1>());
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T GuardedReduce(
        T* raking_ptr,
        ScanOp scan_op,
        T raking_partial,
        Int2Type<SEGMENT_LENGTH> iteration)
    {
        return raking_partial;
    }



    template <int ITERATION>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void CopySegment(
        T* out,
        T* in,
        Int2Type<ITERATION> iteration)
    {
        out[ITERATION] = in[ITERATION];
        CopySegment(out, in, Int2Type<ITERATION + 1>());
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) void CopySegment(
        T* out,
        T* in,
        Int2Type<SEGMENT_LENGTH> iteration)
    {}



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Upsweep(
        ScanOp scan_op)
    {
        T *smem_raking_ptr = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);


        CopySegment(cached_segment, smem_raking_ptr, Int2Type<0>());

        T raking_partial = cached_segment[0];

        return GuardedReduce(cached_segment, scan_op, raking_partial, Int2Type<1>());
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveDownsweep(
        ScanOp scan_op,
        T raking_partial,
        bool apply_prefix = true)
    {
        T *smem_raking_ptr = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);


        if (!MEMOIZE)
        {
            CopySegment(cached_segment, smem_raking_ptr, Int2Type<0>());
        }

        ThreadScanExclusive(cached_segment, cached_segment, scan_op, raking_partial, apply_prefix);


        CopySegment(smem_raking_ptr, cached_segment, Int2Type<0>());
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveDownsweep(
        ScanOp scan_op,
        T raking_partial,
        bool apply_prefix = true)
    {
        T *smem_raking_ptr = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);


        if (!MEMOIZE)
        {
            CopySegment(cached_segment, smem_raking_ptr, Int2Type<0>());
        }

        ThreadScanInclusive(cached_segment, cached_segment, scan_op, raking_partial, apply_prefix);


        CopySegment(smem_raking_ptr, cached_segment, Int2Type<0>());
    }







    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockScanRaking(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        const T &identity,
        ScanOp scan_op)
    {
        if (WARP_SYNCHRONOUS)
        {

            WarpScan(temp_storage.warp_scan).ExclusiveScan(input, output, identity, scan_op);
        }
        else
        {

            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
            *placement_ptr = input;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T upsweep_partial = Upsweep(scan_op);


                T exclusive_partial;
                WarpScan(temp_storage.warp_scan).ExclusiveScan(upsweep_partial, exclusive_partial, identity, scan_op);


                ExclusiveDownsweep(scan_op, exclusive_partial);
            }

            __syncthreads();


            output = *placement_ptr;
        }
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        const T &identity,
        ScanOp scan_op,
        T &block_aggregate)
    {
        if (WARP_SYNCHRONOUS)
        {

            WarpScan(temp_storage.warp_scan).ExclusiveScan(input, output, identity, scan_op, block_aggregate);
        }
        else
        {

            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
            *placement_ptr = input;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T upsweep_partial = Upsweep(scan_op);


                T inclusive_partial;
                T exclusive_partial;
                WarpScan(temp_storage.warp_scan).Scan(upsweep_partial, inclusive_partial, exclusive_partial, identity, scan_op);


                if (threadIdx.x == RAKING_THREADS - 1)
                    temp_storage.block_aggregate = inclusive_partial;


                ExclusiveDownsweep(scan_op, exclusive_partial);
            }

            __syncthreads();


            output = *placement_ptr;


            block_aggregate = temp_storage.block_aggregate;
        }
    }



    template <
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        if (WARP_SYNCHRONOUS)
        {

            T exclusive_partial;
            WarpScan(temp_storage.warp_scan).ExclusiveScan(input, exclusive_partial, identity, scan_op, block_aggregate);


            output = block_prefix_callback_op(block_aggregate);
            output = WarpScan(temp_storage.warp_scan).Broadcast(output, 0);


            if (linear_tid > 0)
                output = scan_op(output, exclusive_partial);
        }
        else
        {

            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
            *placement_ptr = input;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T upsweep_partial = Upsweep(scan_op);


                T inclusive_partial;
                T exclusive_partial;
                WarpScan(temp_storage.warp_scan).Scan(upsweep_partial, inclusive_partial, exclusive_partial, identity, scan_op);


                if (threadIdx.x == RAKING_THREADS - 1)
                    ThreadStore<STORE_VOLATILE>(&temp_storage.block_aggregate, inclusive_partial);
                block_aggregate = ThreadLoad<LOAD_VOLATILE>(&temp_storage.block_aggregate);


                T prefix = block_prefix_callback_op(block_aggregate);
                prefix = WarpScan(temp_storage.warp_scan).Broadcast(prefix, 0);


                if (linear_tid > 0)
                    prefix = scan_op(prefix, exclusive_partial);


                ExclusiveDownsweep(scan_op, prefix);
            }

            __syncthreads();


            output = *placement_ptr;


            block_aggregate = temp_storage.block_aggregate;
        }
    }






    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        if (WARP_SYNCHRONOUS)
        {

            WarpScan(temp_storage.warp_scan).ExclusiveScan(input, output, scan_op);
        }
        else
        {

            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
            *placement_ptr = input;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T upsweep_partial = Upsweep(scan_op);


                T exclusive_partial;
                WarpScan(temp_storage.warp_scan).ExclusiveScan(upsweep_partial, exclusive_partial, scan_op);


                ExclusiveDownsweep(scan_op, exclusive_partial, (linear_tid != 0));
            }

            __syncthreads();


            output = *placement_ptr;
        }
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate)
    {
        if (WARP_SYNCHRONOUS)
        {

            WarpScan(temp_storage.warp_scan).ExclusiveScan(input, output, scan_op, block_aggregate);
        }
        else
        {

            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
            *placement_ptr = input;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T upsweep_partial= Upsweep(scan_op);


                T inclusive_partial;
                T exclusive_partial;
                WarpScan(temp_storage.warp_scan).Scan(upsweep_partial, inclusive_partial, exclusive_partial, scan_op);


                if (threadIdx.x == RAKING_THREADS - 1)
                    temp_storage.block_aggregate = inclusive_partial;


                ExclusiveDownsweep(scan_op, exclusive_partial, (linear_tid != 0));
            }

            __syncthreads();


            output = *placement_ptr;


            block_aggregate = temp_storage.block_aggregate;
        }
    }



    template <
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        if (WARP_SYNCHRONOUS)
        {

            T exclusive_partial;
            WarpScan(temp_storage.warp_scan).ExclusiveScan(input, exclusive_partial, scan_op, block_aggregate);


            output = block_prefix_callback_op(block_aggregate);
            output = WarpScan(temp_storage.warp_scan).Broadcast(output, 0);


            if (linear_tid > 0)
                output = scan_op(output, exclusive_partial);
        }
        else
        {

            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
            *placement_ptr = input;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T upsweep_partial = Upsweep(scan_op);


                T inclusive_partial;
                T exclusive_partial;
                WarpScan(temp_storage.warp_scan).Scan(upsweep_partial, inclusive_partial, exclusive_partial, scan_op);


                if (threadIdx.x == RAKING_THREADS - 1)
                    ThreadStore<STORE_VOLATILE>(&temp_storage.block_aggregate, inclusive_partial);
                block_aggregate = ThreadLoad<LOAD_VOLATILE>(&temp_storage.block_aggregate);


                T prefix = block_prefix_callback_op(block_aggregate);
                prefix = WarpScan(temp_storage.warp_scan).Broadcast(prefix, 0);


                if (linear_tid > 0)
                    prefix = scan_op(prefix, exclusive_partial);


                ExclusiveDownsweep(scan_op, prefix);
            }

            __syncthreads();


            output = *placement_ptr;


            block_aggregate = temp_storage.block_aggregate;
        }
    }







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        if (WARP_SYNCHRONOUS)
        {

            WarpScan(temp_storage.warp_scan).InclusiveScan(input, output, scan_op);
        }
        else
        {

            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
            *placement_ptr = input;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T upsweep_partial = Upsweep(scan_op);


                T exclusive_partial;
                WarpScan(temp_storage.warp_scan).ExclusiveScan(upsweep_partial, exclusive_partial, scan_op);


                InclusiveDownsweep(scan_op, exclusive_partial, (linear_tid != 0));
            }

            __syncthreads();


            output = *placement_ptr;
        }
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate)
    {
        if (WARP_SYNCHRONOUS)
        {

            WarpScan(temp_storage.warp_scan).InclusiveScan(input, output, scan_op, block_aggregate);
        }
        else
        {

            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
            *placement_ptr = input;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T upsweep_partial = Upsweep(scan_op);


                T inclusive_partial;
                T exclusive_partial;
                WarpScan(temp_storage.warp_scan).Scan(upsweep_partial, inclusive_partial, exclusive_partial, scan_op);


                if (threadIdx.x == RAKING_THREADS - 1)
                    temp_storage.block_aggregate = inclusive_partial;


                InclusiveDownsweep(scan_op, exclusive_partial, (linear_tid != 0));
            }

            __syncthreads();


            output = *placement_ptr;


            block_aggregate = temp_storage.block_aggregate;
        }
    }



    template <
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        if (WARP_SYNCHRONOUS)
        {

            T inclusive_partial;
            WarpScan(temp_storage.warp_scan).InclusiveScan(input, inclusive_partial, scan_op, block_aggregate);


            output = block_prefix_callback_op(block_aggregate);
            output = WarpScan(temp_storage.warp_scan).Broadcast(output, 0);


            output = scan_op(output, inclusive_partial);
        }
        else
        {

            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
            *placement_ptr = input;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T upsweep_partial = Upsweep(scan_op);


                T inclusive_partial;
                T exclusive_partial;
                WarpScan(temp_storage.warp_scan).Scan(upsweep_partial, inclusive_partial, exclusive_partial, scan_op);


                if (threadIdx.x == RAKING_THREADS - 1)
                    ThreadStore<STORE_VOLATILE>(&temp_storage.block_aggregate, inclusive_partial);
                block_aggregate = ThreadLoad<LOAD_VOLATILE>(&temp_storage.block_aggregate);


                T prefix = block_prefix_callback_op(block_aggregate);
                prefix = WarpScan(temp_storage.warp_scan).Broadcast(prefix, 0);


                if (linear_tid > 0)
                    prefix = scan_op(prefix, exclusive_partial);


                InclusiveDownsweep(scan_op, prefix);
            }

            __syncthreads();


            output = *placement_ptr;


            block_aggregate = temp_storage.block_aggregate;
        }
    }

};


}
} } } }
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/block_scan_warp_scans.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/specializations/block_scan_warp_scans.cuh"
       







namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {




template <
    typename T,
    int BLOCK_DIM_X,
    int BLOCK_DIM_Y,
    int BLOCK_DIM_Z,
    int PTX_ARCH>
struct BlockScanWarpScans
{





    enum
    {

        WARP_THREADS = (1 << (5)),


        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,


        WARPS = (BLOCK_THREADS + WARP_THREADS - 1) / WARP_THREADS,
    };


    typedef WarpScan<T, WARP_THREADS, PTX_ARCH> WarpScanT;


    typedef WarpScan<T, WARPS, PTX_ARCH> WarpAggregateScan;


    struct _TempStorage
    {
        typename WarpScanT::TempStorage warp_scan[WARPS];
        T warp_aggregates[WARPS];
        T block_prefix;
    };



    struct TempStorage : Uninitialized<_TempStorage> {};







    _TempStorage &temp_storage;
    int linear_tid;
    int warp_id;
    int lane_id;







    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockScanWarpScans(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)),
        warp_id((WARPS == 1) ? 0 : linear_tid / WARP_THREADS),
        lane_id(LaneId())
    {}






    template <typename ScanOp, int WARP>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ApplyWarpAggregates(
        T &partial,
        ScanOp scan_op,
        T &block_aggregate,
        bool lane_valid,
        Int2Type<WARP> addend_warp)
    {
        T inclusive = scan_op(block_aggregate, partial);
        if (warp_id == WARP)
        {
            partial = (lane_valid) ?
                inclusive :
                block_aggregate;
        }

        T addend = temp_storage.warp_aggregates[WARP];
        block_aggregate = scan_op(block_aggregate, addend);

        ApplyWarpAggregates(partial, scan_op, block_aggregate, lane_valid, Int2Type<WARP + 1>());
    }

    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ApplyWarpAggregates(
        T &partial,
        ScanOp scan_op,
        T &block_aggregate,
        bool lane_valid,
        Int2Type<WARPS> addend_warp)
    {}



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ApplyWarpAggregates(
        T &partial,
        ScanOp scan_op,
        T warp_aggregate,
        T &block_aggregate,
        bool lane_valid = true)
    {

        if (lane_id == WARP_THREADS - 1)
            temp_storage.warp_aggregates[warp_id] = warp_aggregate;

        __syncthreads();

        block_aggregate = temp_storage.warp_aggregates[0];


        ApplyWarpAggregates(partial, scan_op, block_aggregate, lane_valid, Int2Type<1>());
    }






    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        const T &identity,
        ScanOp scan_op)
    {
        T block_aggregate;
        ExclusiveScan(input, output, identity, scan_op, block_aggregate);
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        const T &identity,
        ScanOp scan_op,
        T &block_aggregate)
    {
        T inclusive_output;
        WarpScanT(temp_storage.warp_scan[warp_id]).Scan(input, inclusive_output, output, identity, scan_op);


        ApplyWarpAggregates(output, scan_op, inclusive_output, block_aggregate);
    }



    template <
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        ExclusiveScan(input, output, identity, scan_op, block_aggregate);


        if (warp_id == 0)
        {
            T block_prefix = block_prefix_callback_op(block_aggregate);
            if (lane_id == 0)
            {

                temp_storage.block_prefix = block_prefix;
            }
        }

        __syncthreads();


        T block_prefix = temp_storage.block_prefix;
        output = scan_op(block_prefix, output);
    }







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        T block_aggregate;
        ExclusiveScan(input, output, scan_op, block_aggregate);
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate)
    {
        T inclusive_output;
        WarpScanT(temp_storage.warp_scan[warp_id]).Scan(input, inclusive_output, output, scan_op);


        ApplyWarpAggregates(output, scan_op, inclusive_output, block_aggregate, (lane_id > 0));
    }



    template <
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        ExclusiveScan(input, output, scan_op, block_aggregate);


        if (warp_id == 0)
        {
            T block_prefix = block_prefix_callback_op(block_aggregate);
            if (lane_id == 0)
            {

                temp_storage.block_prefix = block_prefix;
            }
        }

        __syncthreads();


        T block_prefix = temp_storage.block_prefix;
        output = (linear_tid == 0) ?
            block_prefix :
            scan_op(block_prefix, output);
    }







    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        T block_aggregate;
        InclusiveScan(input, output, scan_op, block_aggregate);
    }



    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate)
    {
        WarpScanT(temp_storage.warp_scan[warp_id]).InclusiveScan(input, output, scan_op);


        ApplyWarpAggregates(output, scan_op, output, block_aggregate);

    }



    template <
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        InclusiveScan(input, output, scan_op, block_aggregate);


        if (warp_id == 0)
        {
            T block_prefix = block_prefix_callback_op(block_aggregate);
            if (lane_id == 0)
            {

                temp_storage.block_prefix = block_prefix;
            }
        }

        __syncthreads();


        T block_prefix = temp_storage.block_prefix;
        output = scan_op(block_prefix, output);
    }


};


}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh" 2






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 60 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
template <typename ReductionOp>
struct ReduceByKeyOp
{
    ReductionOp op;


    __attribute__((device)) __inline__ __attribute__((always_inline)) ReduceByKeyOp(ReductionOp op) : op(op) {}


    template <typename KeyValuePair>
    __attribute__((device)) __inline__ __attribute__((always_inline)) KeyValuePair operator()(
        const KeyValuePair &first,
        const KeyValuePair &second)
    {
        KeyValuePair retval;

        retval.value = (second.key != first.key) ?
                second.value :
                op(first.value, second.value);

        retval.key = second.key;
        return retval;
    }
};






template <typename ReductionOp>
struct SegmentedOp
{
    ReductionOp op;


    __attribute__((device)) __inline__ __attribute__((always_inline)) SegmentedOp(ReductionOp op) : op(op) {}


    template <typename KeyValuePair>
    __attribute__((device)) __inline__ __attribute__((always_inline)) KeyValuePair operator()(
        const KeyValuePair &first,
        const KeyValuePair &second)
    {
        if (second.key) {
            KeyValuePair retval;
            retval.value = second.value;
            retval.key = first.key + second.key;
            return retval;
        } else {
            KeyValuePair retval;
            retval.value = op(first.value, second.value);
            retval.key = first.key + second.key;
            return ;
        }
    }
};
# 129 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
enum BlockScanAlgorithm
{
# 150 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    BLOCK_SCAN_RAKING,
# 160 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    BLOCK_SCAN_RAKING_MEMOIZE,
# 180 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    BLOCK_SCAN_WARP_SCANS,
};
# 258 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
template <
    typename T,
    int BLOCK_DIM_X,
    BlockScanAlgorithm ALGORITHM = BLOCK_SCAN_RAKING,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockScan
{
private:






    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };







    static const BlockScanAlgorithm SAFE_ALGORITHM =
        ((ALGORITHM == BLOCK_SCAN_WARP_SCANS) && (BLOCK_THREADS % (1 << (5)) != 0)) ?
            BLOCK_SCAN_RAKING :
            ALGORITHM;

    typedef BlockScanWarpScans<T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> WarpScans;
    typedef BlockScanRaking<T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, (SAFE_ALGORITHM == BLOCK_SCAN_RAKING_MEMOIZE), PTX_ARCH> Raking;


    typedef typename If<(SAFE_ALGORITHM == BLOCK_SCAN_WARP_SCANS),
        WarpScans,
        Raking>::Type InternalBlockScan;


    typedef typename InternalBlockScan::TempStorage _TempStorage;







    _TempStorage &temp_storage;


    int linear_tid;







    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }





public:


    struct TempStorage : Uninitialized<_TempStorage> {};
# 343 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockScan()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockScan(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}
# 408 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveSum(
        T input,
        T &output)
    {
        ExclusiveScan(input, output, ZeroInitialize<T>(), cub_::Sum());
    }
# 454 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveSum(
        T input,
        T &output,
        T &block_aggregate)
    {
        ExclusiveScan(input, output, ZeroInitialize<T>(), cub_::Sum(), block_aggregate);
    }
# 539 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveSum(
        T input,
        T &output,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        ExclusiveScan(input, output, ZeroInitialize<T>(), cub_::Sum(), block_aggregate, block_prefix_callback_op);
    }
# 596 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <int ITEMS_PER_THREAD>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveSum(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD])
    {

        Sum scan_op;
        T thread_partial = ThreadReduce(input, scan_op);


        ExclusiveSum(thread_partial, thread_partial);


        ThreadScanExclusive(input, output, scan_op, thread_partial);
    }
# 654 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <int ITEMS_PER_THREAD>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveSum(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        T &block_aggregate)
    {

        Sum scan_op;
        T thread_partial = ThreadReduce(input, scan_op);


        ExclusiveSum(thread_partial, thread_partial, block_aggregate);


        ThreadScanExclusive(input, output, scan_op, thread_partial);
    }
# 760 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveSum(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {

        Sum scan_op;
        T thread_partial = ThreadReduce(input, scan_op);


        ExclusiveSum(thread_partial, thread_partial, block_aggregate, block_prefix_callback_op);


        ThreadScanExclusive(input, output, scan_op, thread_partial);
    }
# 826 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op)
    {
        InternalBlockScan(temp_storage).ExclusiveScan(input, output, identity, scan_op);
    }
# 876 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op,
        T &block_aggregate)
    {
        InternalBlockScan(temp_storage).ExclusiveScan(input, output, identity, scan_op, block_aggregate);
    }
# 966 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T input,
        T &output,
        T identity,
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        InternalBlockScan(temp_storage).ExclusiveScan(input, output, identity, scan_op, block_aggregate, block_prefix_callback_op);
    }
# 1030 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        T identity,
        ScanOp scan_op)
    {

        T thread_partial = ThreadReduce(input, scan_op);


        ExclusiveScan(thread_partial, thread_partial, identity, scan_op);


        ThreadScanExclusive(input, output, scan_op, thread_partial);
    }
# 1092 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        T identity,
        ScanOp scan_op,
        T &block_aggregate)
    {

        T thread_partial = ThreadReduce(input, scan_op);


        ExclusiveScan(thread_partial, thread_partial, identity, scan_op, block_aggregate);


        ThreadScanExclusive(input, output, scan_op, thread_partial);
    }
# 1202 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        T identity,
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {

        T thread_partial = ThreadReduce(input, scan_op);


        ExclusiveScan(thread_partial, thread_partial, identity, scan_op, block_aggregate, block_prefix_callback_op);


        ThreadScanExclusive(input, output, scan_op, thread_partial);
    }
# 1330 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        ScanOp scan_op)
    {

        T thread_partial = ThreadReduce(input, scan_op);


        ExclusiveScan(thread_partial, thread_partial, scan_op);


        ThreadScanExclusive(input, output, scan_op, thread_partial, (linear_tid != 0));
    }
# 1361 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        ScanOp scan_op,
        T &block_aggregate)
    {

        T thread_partial = ThreadReduce(input, scan_op);


        ExclusiveScan(thread_partial, thread_partial, scan_op, block_aggregate);


        ThreadScanExclusive(input, output, scan_op, thread_partial, (linear_tid != 0));
    }
# 1399 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveScan(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {

        T thread_partial = ThreadReduce(input, scan_op);


        ExclusiveScan(thread_partial, thread_partial, scan_op, block_aggregate, block_prefix_callback_op);


        ThreadScanExclusive(input, output, scan_op, thread_partial);
    }
# 1466 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveSum(
        T input,
        T &output)
    {
        InclusiveScan(input, output, cub_::Sum());
    }
# 1511 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveSum(
        T input,
        T &output,
        T &block_aggregate)
    {
        InclusiveScan(input, output, cub_::Sum(), block_aggregate);
    }
# 1596 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveSum(
        T input,
        T &output,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        InclusiveScan(input, output, cub_::Sum(), block_aggregate, block_prefix_callback_op);
    }
# 1652 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <int ITEMS_PER_THREAD>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveSum(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD])
    {
        if (ITEMS_PER_THREAD == 1)
        {
            InclusiveSum(input[0], output[0]);
        }
        else
        {

            Sum scan_op;
            T thread_partial = ThreadReduce(input, scan_op);


            ExclusiveSum(thread_partial, thread_partial);


            ThreadScanInclusive(input, output, scan_op, thread_partial, (linear_tid != 0));
        }
    }
# 1719 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <int ITEMS_PER_THREAD>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveSum(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        T &block_aggregate)
    {
        if (ITEMS_PER_THREAD == 1)
        {
            InclusiveSum(input[0], output[0], block_aggregate);
        }
        else
        {

            Sum scan_op;
            T thread_partial = ThreadReduce(input, scan_op);


            ExclusiveSum(thread_partial, thread_partial, block_aggregate);


            ThreadScanInclusive(input, output, scan_op, thread_partial, (linear_tid != 0));
        }
    }
# 1831 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveSum(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        if (ITEMS_PER_THREAD == 1)
        {
            InclusiveSum(input[0], output[0], block_aggregate, block_prefix_callback_op);
        }
        else
        {

            Sum scan_op;
            T thread_partial = ThreadReduce(input, scan_op);


            ExclusiveSum(thread_partial, thread_partial, block_aggregate, block_prefix_callback_op);


            ThreadScanInclusive(input, output, scan_op, thread_partial);
        }
    }
# 1903 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op)
    {
        InternalBlockScan(temp_storage).InclusiveScan(input, output, scan_op);
    }
# 1952 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate)
    {
        InternalBlockScan(temp_storage).InclusiveScan(input, output, scan_op, block_aggregate);
    }
# 2041 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T input,
        T &output,
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        InternalBlockScan(temp_storage).InclusiveScan(input, output, scan_op, block_aggregate, block_prefix_callback_op);
    }
# 2102 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        ScanOp scan_op)
    {
        if (ITEMS_PER_THREAD == 1)
        {
            InclusiveScan(input[0], output[0], scan_op);
        }
        else
        {

            T thread_partial = ThreadReduce(input, scan_op);


            ExclusiveScan(thread_partial, thread_partial, scan_op);


            ThreadScanInclusive(input, output, scan_op, thread_partial, (linear_tid != 0));
        }
    }
# 2172 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        ScanOp scan_op,
        T &block_aggregate)
    {
        if (ITEMS_PER_THREAD == 1)
        {
            InclusiveScan(input[0], output[0], scan_op, block_aggregate);
        }
        else
        {

            T thread_partial = ThreadReduce(input, scan_op);


            ExclusiveScan(thread_partial, thread_partial, scan_op, block_aggregate);


            ThreadScanInclusive(input, output, scan_op, thread_partial, (linear_tid != 0));
        }
    }
# 2288 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/../block/block_scan.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ScanOp,
        typename BlockPrefixCallbackOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InclusiveScan(
        T (&input)[ITEMS_PER_THREAD],
        T (&output)[ITEMS_PER_THREAD],
        ScanOp scan_op,
        T &block_aggregate,
        BlockPrefixCallbackOp &block_prefix_callback_op)
    {
        if (ITEMS_PER_THREAD == 1)
        {
            InclusiveScan(input[0], output[0], scan_op, block_aggregate, block_prefix_callback_op);
        }
        else
        {

            T thread_partial = ThreadReduce(input, scan_op);


            ExclusiveScan(thread_partial, thread_partial, scan_op, block_aggregate, block_prefix_callback_op);


            ThreadScanInclusive(input, output, scan_op, thread_partial);
        }
    }




};





}
} } } }
# 39 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh" 2







namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 85 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh"
template <
    int BLOCK_DIM_X,
    int RADIX_BITS,
    bool DESCENDING,
    bool MEMOIZE_OUTER_SCAN = (0 >= 350) ? true : false,
    BlockScanAlgorithm INNER_SCAN_ALGORITHM = BLOCK_SCAN_WARP_SCANS,
    cudaSharedMemConfig SMEM_CONFIG = cudaSharedMemBankSizeFourByte,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockRadixRank
{
private:






    typedef unsigned short DigitCounter;


    typedef typename If<(SMEM_CONFIG == cudaSharedMemBankSizeEightByte),
        unsigned long long,
        unsigned int>::Type PackedCounter;

    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,

        RADIX_DIGITS = 1 << RADIX_BITS,

        LOG_WARP_THREADS = (5),
        WARP_THREADS = 1 << LOG_WARP_THREADS,
        WARPS = (BLOCK_THREADS + WARP_THREADS - 1) / WARP_THREADS,

        BYTES_PER_COUNTER = sizeof(DigitCounter),
        LOG_BYTES_PER_COUNTER = Log2<BYTES_PER_COUNTER>::VALUE,

        PACKING_RATIO = sizeof(PackedCounter) / sizeof(DigitCounter),
        LOG_PACKING_RATIO = Log2<PACKING_RATIO>::VALUE,

        LOG_COUNTER_LANES = (((0) > ((RADIX_BITS - LOG_PACKING_RATIO))) ? (0) : ((RADIX_BITS - LOG_PACKING_RATIO))),
        COUNTER_LANES = 1 << LOG_COUNTER_LANES,


        RAKING_SEGMENT = COUNTER_LANES + 1,

        LOG_SMEM_BANKS = ((PTX_ARCH >= 200) ? (5) : (4)),
        SMEM_BANKS = 1 << LOG_SMEM_BANKS,
    };



    typedef BlockScan<
            PackedCounter,
            BLOCK_DIM_X,
            INNER_SCAN_ALGORITHM,
            BLOCK_DIM_Y,
            BLOCK_DIM_Z,
            PTX_ARCH>
        BlockScan;



    struct _TempStorage
    {

        typename BlockScan::TempStorage block_scan;

        union
        {
            DigitCounter digit_counters[COUNTER_LANES + 1][BLOCK_THREADS][PACKING_RATIO];
            PackedCounter raking_grid[BLOCK_THREADS][RAKING_SEGMENT];
        };
    };







    _TempStorage &temp_storage;


    int linear_tid;


    PackedCounter cached_segment[RAKING_SEGMENT];







    template <int COUNT, int MAX>
    struct Iterate
    {
# 195 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh"
        template <typename UnsignedBits, int KEYS_PER_THREAD>
        static __attribute__((device)) __inline__ __attribute__((always_inline)) void DecodeKeys(
            BlockRadixRank &cta,
            UnsignedBits (&keys)[KEYS_PER_THREAD],
            DigitCounter (&thread_prefixes)[KEYS_PER_THREAD],
            DigitCounter* (&digit_counters)[KEYS_PER_THREAD],
            int current_bit,
            int num_bits)
        {

            UnsignedBits digit = BFE(keys[COUNT], current_bit, num_bits);


            UnsignedBits sub_counter = digit >> LOG_COUNTER_LANES;


            UnsignedBits counter_lane = digit & (COUNTER_LANES - 1);

            if (DESCENDING)
            {
                sub_counter = PACKING_RATIO - 1 - sub_counter;
                counter_lane = COUNTER_LANES - 1 - counter_lane;
            }


            digit_counters[COUNT] = &cta.temp_storage.digit_counters[counter_lane][cta.linear_tid][sub_counter];


            thread_prefixes[COUNT] = *digit_counters[COUNT];


            *digit_counters[COUNT] = thread_prefixes[COUNT] + 1;


            Iterate<COUNT + 1, MAX>::DecodeKeys(cta, keys, thread_prefixes, digit_counters, current_bit, num_bits);
        }



        template <int KEYS_PER_THREAD>
        static __attribute__((device)) __inline__ __attribute__((always_inline)) void UpdateRanks(
            int (&ranks)[KEYS_PER_THREAD],
            DigitCounter (&thread_prefixes)[KEYS_PER_THREAD],
            DigitCounter* (&digit_counters)[KEYS_PER_THREAD])
        {

            ranks[COUNT] = thread_prefixes[COUNT] + *digit_counters[COUNT];


            Iterate<COUNT + 1, MAX>::UpdateRanks(ranks, thread_prefixes, digit_counters);
        }
    };



    template <int MAX>
    struct Iterate<MAX, MAX>
    {

        template <typename UnsignedBits, int KEYS_PER_THREAD>
        static __attribute__((device)) __inline__ __attribute__((always_inline)) void DecodeKeys(
            BlockRadixRank &cta,
            UnsignedBits (&keys)[KEYS_PER_THREAD],
            DigitCounter (&thread_prefixes)[KEYS_PER_THREAD],
            DigitCounter* (&digit_counters)[KEYS_PER_THREAD],
            int current_bit,
            int num_bits)
        {}



        template <int KEYS_PER_THREAD>
        static __attribute__((device)) __inline__ __attribute__((always_inline)) void UpdateRanks(
            int (&ranks)[KEYS_PER_THREAD],
            DigitCounter (&thread_prefixes)[KEYS_PER_THREAD],
            DigitCounter *(&digit_counters)[KEYS_PER_THREAD])
        {}
    };
# 282 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) PackedCounter Upsweep()
    {
        PackedCounter *smem_raking_ptr = temp_storage.raking_grid[linear_tid];
        PackedCounter *raking_ptr;

        if (MEMOIZE_OUTER_SCAN)
        {

#pragma unroll
            for (int i = 0; i < RAKING_SEGMENT; i++)
            {
                cached_segment[i] = smem_raking_ptr[i];
            }
            raking_ptr = cached_segment;
        }
        else
        {
            raking_ptr = smem_raking_ptr;
        }

        return ThreadReduce<RAKING_SEGMENT>(raking_ptr, Sum());
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExclusiveDownsweep(
        PackedCounter raking_partial)
    {
        PackedCounter *smem_raking_ptr = temp_storage.raking_grid[linear_tid];

        PackedCounter *raking_ptr = (MEMOIZE_OUTER_SCAN) ?
            cached_segment :
            smem_raking_ptr;


        ThreadScanExclusive<RAKING_SEGMENT>(raking_ptr, raking_ptr, Sum(), raking_partial);

        if (MEMOIZE_OUTER_SCAN)
        {

#pragma unroll
            for (int i = 0; i < RAKING_SEGMENT; i++)
            {
                smem_raking_ptr[i] = cached_segment[i];
            }
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ResetCounters()
    {

#pragma unroll
        for (int LANE = 0; LANE < COUNTER_LANES + 1; LANE++)
        {
            *((PackedCounter*) temp_storage.digit_counters[LANE][linear_tid]) = 0;
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScanCounters()
    {

        PackedCounter raking_partial = Upsweep();


        PackedCounter exclusive_partial;
        PackedCounter packed_aggregate;
        BlockScan(temp_storage.block_scan).ExclusiveSum(raking_partial, exclusive_partial, packed_aggregate);


#pragma unroll
        for (int PACKED = 1; PACKED < PACKING_RATIO; PACKED++)
        {
            exclusive_partial += packed_aggregate << (sizeof(DigitCounter) * 8 * PACKED);
        }


        ExclusiveDownsweep(exclusive_partial);
    }

public:


    struct TempStorage : Uninitialized<_TempStorage> {};
# 393 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockRadixRank()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockRadixRank(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}
# 420 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_rank.cuh"
    template <
        typename UnsignedBits,
        int KEYS_PER_THREAD>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void RankKeys(
        UnsignedBits (&keys)[KEYS_PER_THREAD],
        int (&ranks)[KEYS_PER_THREAD],
        int current_bit,
        int num_bits)
    {
        DigitCounter thread_prefixes[KEYS_PER_THREAD];
        DigitCounter* digit_counters[KEYS_PER_THREAD];


        ResetCounters();


        Iterate<0, KEYS_PER_THREAD>::DecodeKeys(*this, keys, thread_prefixes, digit_counters, current_bit, num_bits);

        __syncthreads();


        ScanCounters();

        __syncthreads();


        Iterate<0, KEYS_PER_THREAD>::UpdateRanks(ranks, thread_prefixes, digit_counters);
    }





    template <
        typename UnsignedBits,
        int KEYS_PER_THREAD>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void RankKeys(
        UnsignedBits (&keys)[KEYS_PER_THREAD],
        int (&ranks)[KEYS_PER_THREAD],
        int current_bit,
        int num_bits,
        int &inclusive_digit_prefix)
    {

        RankKeys(keys, ranks, current_bit, num_bits);


        if ((BLOCK_THREADS == RADIX_DIGITS) || (linear_tid < RADIX_DIGITS))
        {
            int bin_idx = (DESCENDING) ?
                RADIX_DIGITS - linear_tid - 1 :
                linear_tid;



            int counter_lane = (bin_idx & (COUNTER_LANES - 1));
            int sub_counter = bin_idx >> (LOG_COUNTER_LANES);
            inclusive_digit_prefix = temp_storage.digit_counters[counter_lane + 1][0][sub_counter];
        }
    }
};

}
} } } }
# 39 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh" 2






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 119 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
template <
    typename Key,
    int BLOCK_DIM_X,
    int ITEMS_PER_THREAD,
    typename Value = NullType,
    int RADIX_BITS = 4,
    bool MEMOIZE_OUTER_SCAN = (0 >= 350) ? true : false,
    BlockScanAlgorithm INNER_SCAN_ALGORITHM = BLOCK_SCAN_WARP_SCANS,
    cudaSharedMemConfig SMEM_CONFIG = cudaSharedMemBankSizeFourByte,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockRadixSort
{
private:





    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,


        KEYS_ONLY = Equals<Value, NullType>::VALUE,
    };


    typedef NumericTraits<Key> KeyTraits;
    typedef typename KeyTraits::UnsignedBits UnsignedBits;


    typedef BlockRadixRank<
            BLOCK_DIM_X,
            RADIX_BITS,
            false,
            MEMOIZE_OUTER_SCAN,
            INNER_SCAN_ALGORITHM,
            SMEM_CONFIG,
            BLOCK_DIM_Y,
            BLOCK_DIM_Z,
            PTX_ARCH>
        AscendingBlockRadixRank;


    typedef BlockRadixRank<
            BLOCK_DIM_X,
            RADIX_BITS,
            true,
            MEMOIZE_OUTER_SCAN,
            INNER_SCAN_ALGORITHM,
            SMEM_CONFIG,
            BLOCK_DIM_Y,
            BLOCK_DIM_Z,
            PTX_ARCH>
        DescendingBlockRadixRank;


    typedef BlockExchange<Key, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> BlockExchangeKeys;


    typedef BlockExchange<Value, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> BlockExchangeValues;


    struct _TempStorage
    {
        union
        {
            typename AscendingBlockRadixRank::TempStorage asending_ranking_storage;
            typename DescendingBlockRadixRank::TempStorage descending_ranking_storage;
            typename BlockExchangeKeys::TempStorage exchange_keys;
            typename BlockExchangeValues::TempStorage exchange_values;
        };
    };







    _TempStorage &temp_storage;


    int linear_tid;






    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }


    __attribute__((device)) __inline__ __attribute__((always_inline)) void RankKeys(
        UnsignedBits (&unsigned_keys)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        int begin_bit,
        int pass_bits,
        Int2Type<false> is_descending)
    {
        AscendingBlockRadixRank(temp_storage.asending_ranking_storage).RankKeys(
            unsigned_keys,
            ranks,
            begin_bit,
            pass_bits);
    }


    __attribute__((device)) __inline__ __attribute__((always_inline)) void RankKeys(
        UnsignedBits (&unsigned_keys)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        int begin_bit,
        int pass_bits,
        Int2Type<true> is_descending)
    {
        DescendingBlockRadixRank(temp_storage.descending_ranking_storage).RankKeys(
            unsigned_keys,
            ranks,
            begin_bit,
            pass_bits);
    }


    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExchangeValues(
        Value (&values)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        Int2Type<false> is_keys_only,
        Int2Type<true> is_blocked)
    {
        __syncthreads();


        BlockExchangeValues(temp_storage.exchange_values).ScatterToBlocked(values, ranks);
    }


    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExchangeValues(
        Value (&values)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        Int2Type<false> is_keys_only,
        Int2Type<false> is_blocked)
    {
        __syncthreads();


        BlockExchangeValues(temp_storage.exchange_values).ScatterToStriped(values, ranks);
    }


    template <int IS_BLOCKED>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ExchangeValues(
        Value (&values)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        Int2Type<true> is_keys_only,
        Int2Type<IS_BLOCKED> is_blocked)
    {}


    template <int DESCENDING, int KEYS_ONLY>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void SortBlocked(
        Key (&keys)[ITEMS_PER_THREAD],
        Value (&values)[ITEMS_PER_THREAD],
        int begin_bit,
        int end_bit,
        Int2Type<DESCENDING> is_descending,
        Int2Type<KEYS_ONLY> is_keys_only)
    {
        UnsignedBits (&unsigned_keys)[ITEMS_PER_THREAD] =
            reinterpret_cast<UnsignedBits (&)[ITEMS_PER_THREAD]>(keys);


#pragma unroll
        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
        {
            unsigned_keys[KEY] = KeyTraits::TwiddleIn(unsigned_keys[KEY]);
        }


        while (true)
        {
            int pass_bits = (((end_bit - begin_bit) < (RADIX_BITS)) ? (end_bit - begin_bit) : (RADIX_BITS));


            int ranks[ITEMS_PER_THREAD];
            RankKeys(unsigned_keys, ranks, begin_bit, pass_bits, is_descending);
            begin_bit += RADIX_BITS;

            __syncthreads();


            BlockExchangeKeys(temp_storage.exchange_keys).ScatterToBlocked(keys, ranks);


            ExchangeValues(values, ranks, is_keys_only, Int2Type<true>());


            if (begin_bit >= end_bit) break;

            __syncthreads();
        }


#pragma unroll
        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
        {
            unsigned_keys[KEY] = KeyTraits::TwiddleOut(unsigned_keys[KEY]);
        }
    }


    template <int DESCENDING, int KEYS_ONLY>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void SortBlockedToStriped(
        Key (&keys)[ITEMS_PER_THREAD],
        Value (&values)[ITEMS_PER_THREAD],
        int begin_bit,
        int end_bit,
        Int2Type<DESCENDING> is_descending,
        Int2Type<KEYS_ONLY> is_keys_only)
    {
        UnsignedBits (&unsigned_keys)[ITEMS_PER_THREAD] =
            reinterpret_cast<UnsignedBits (&)[ITEMS_PER_THREAD]>(keys);


#pragma unroll
        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
        {
            unsigned_keys[KEY] = KeyTraits::TwiddleIn(unsigned_keys[KEY]);
        }


        while (true)
        {
            int pass_bits = (((end_bit - begin_bit) < (RADIX_BITS)) ? (end_bit - begin_bit) : (RADIX_BITS));


            int ranks[ITEMS_PER_THREAD];
            RankKeys(unsigned_keys, ranks, begin_bit, pass_bits, is_descending);
            begin_bit += RADIX_BITS;

            __syncthreads();


            if (begin_bit >= end_bit)
            {

                BlockExchangeKeys(temp_storage.exchange_keys).ScatterToStriped(keys, ranks);


                ExchangeValues(values, ranks, is_keys_only, Int2Type<false>());


                break;
            }


            BlockExchangeKeys(temp_storage.exchange_keys).ScatterToBlocked(keys, ranks);


            ExchangeValues(values, ranks, is_keys_only, Int2Type<true>());

            __syncthreads();
        }


#pragma unroll
        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
        {
            unsigned_keys[KEY] = KeyTraits::TwiddleOut(unsigned_keys[KEY]);
        }
    }



public:


    struct TempStorage : Uninitialized<_TempStorage> {};
# 413 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockRadixSort()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockRadixSort(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}
# 474 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Sort(
        Key (&keys)[ITEMS_PER_THREAD],
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8)
    {
        NullType values[ITEMS_PER_THREAD];

        SortBlocked(keys, values, begin_bit, end_bit, Int2Type<false>(), Int2Type<KEYS_ONLY>());
    }
# 529 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Sort(
        Key (&keys)[ITEMS_PER_THREAD],
        Value (&values)[ITEMS_PER_THREAD],
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8)
    {
        SortBlocked(keys, values, begin_bit, end_bit, Int2Type<false>(), Int2Type<KEYS_ONLY>());
    }
# 575 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void SortDescending(
        Key (&keys)[ITEMS_PER_THREAD],
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8)
    {
        NullType values[ITEMS_PER_THREAD];

        SortBlocked(keys, values, begin_bit, end_bit, Int2Type<true>(), Int2Type<KEYS_ONLY>());
    }
# 630 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void SortDescending(
        Key (&keys)[ITEMS_PER_THREAD],
        Value (&values)[ITEMS_PER_THREAD],
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8)
    {
        SortBlocked(keys, values, begin_bit, end_bit, Int2Type<true>(), Int2Type<KEYS_ONLY>());
    }
# 685 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void SortBlockedToStriped(
        Key (&keys)[ITEMS_PER_THREAD],
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8)
    {
        NullType values[ITEMS_PER_THREAD];

        SortBlockedToStriped(keys, values, begin_bit, end_bit, Int2Type<false>(), Int2Type<KEYS_ONLY>());
    }
# 740 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void SortBlockedToStriped(
        Key (&keys)[ITEMS_PER_THREAD],
        Value (&values)[ITEMS_PER_THREAD],
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8)
    {
        SortBlockedToStriped(keys, values, begin_bit, end_bit, Int2Type<false>(), Int2Type<KEYS_ONLY>());
    }
# 788 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void SortDescendingBlockedToStriped(
        Key (&keys)[ITEMS_PER_THREAD],
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8)
    {
        NullType values[ITEMS_PER_THREAD];

        SortBlockedToStriped(keys, values, begin_bit, end_bit, Int2Type<true>(), Int2Type<KEYS_ONLY>());
    }
# 843 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_radix_sort.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void SortDescendingBlockedToStriped(
        Key (&keys)[ITEMS_PER_THREAD],
        Value (&values)[ITEMS_PER_THREAD],
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8)
    {
        SortBlockedToStriped(keys, values, begin_bit, end_bit, Int2Type<true>(), Int2Type<KEYS_ONLY>());
    }




};





}
} } } }
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_histogram_sort.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
       






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 102 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
template <
    typename T,
    int BLOCK_DIM_X,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockDiscontinuity
{
private:






    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };



    struct _TempStorage
    {
        T first_items[BLOCK_THREADS];
        T last_items[BLOCK_THREADS];
    };







    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }



    template <typename FlagOp, bool HAS_PARAM = BinaryOpHasIdxParam<T, FlagOp>::HAS_PARAM>
    struct ApplyOp
    {

        static __attribute__((device)) __inline__ __attribute__((always_inline)) bool Flag(FlagOp flag_op, const T &a, const T &b, int idx)
        {
            return flag_op(a, b, idx);
        }
    };


    template <typename FlagOp>
    struct ApplyOp<FlagOp, false>
    {

        static __attribute__((device)) __inline__ __attribute__((always_inline)) bool Flag(FlagOp flag_op, const T &a, const T &b, int idx)
        {
            return flag_op(a, b);
        }
    };


    template <int ITERATION, int MAX_ITERATIONS>
    struct Iterate
    {

        template <
            int ITEMS_PER_THREAD,
            typename FlagT,
            typename FlagOp>
        static __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagHeads(
            int linear_tid,
            FlagT (&flags)[ITEMS_PER_THREAD],
            T (&input)[ITEMS_PER_THREAD],
            FlagOp flag_op)
        {
            flags[ITERATION] = ApplyOp<FlagOp>::Flag(
                flag_op,
                input[ITERATION - 1],
                input[ITERATION],
                (linear_tid * ITEMS_PER_THREAD) + ITERATION);

            Iterate<ITERATION + 1, MAX_ITERATIONS>::FlagHeads(linear_tid, flags, input, flag_op);
        }


        template <
            int ITEMS_PER_THREAD,
            typename FlagT,
            typename FlagOp>
        static __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagTails(
            int linear_tid,
            FlagT (&flags)[ITEMS_PER_THREAD],
            T (&input)[ITEMS_PER_THREAD],
            FlagOp flag_op)
        {
            flags[ITERATION] = ApplyOp<FlagOp>::Flag(
                flag_op,
                input[ITERATION],
                input[ITERATION + 1],
                (linear_tid * ITEMS_PER_THREAD) + ITERATION);

            Iterate<ITERATION + 1, MAX_ITERATIONS>::FlagTails(linear_tid, flags, input, flag_op);
        }

    };


    template <int MAX_ITERATIONS>
    struct Iterate<MAX_ITERATIONS, MAX_ITERATIONS>
    {

        template <
            int ITEMS_PER_THREAD,
            typename FlagT,
            typename FlagOp>
        static __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagHeads(
            int linear_tid,
            FlagT (&flags)[ITEMS_PER_THREAD],
            T (&input)[ITEMS_PER_THREAD],
            FlagOp flag_op)
        {}


        template <
            int ITEMS_PER_THREAD,
            typename FlagT,
            typename FlagOp>
        static __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagTails(
            int linear_tid,
            FlagT (&flags)[ITEMS_PER_THREAD],
            T (&input)[ITEMS_PER_THREAD],
            FlagOp flag_op)
        {}
    };







    _TempStorage &temp_storage;


    int linear_tid;


public:


    struct TempStorage : Uninitialized<_TempStorage> {};
# 267 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockDiscontinuity()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockDiscontinuity(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}
# 341 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename FlagT,
        typename FlagOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagHeads(
        FlagT (&head_flags)[ITEMS_PER_THREAD],
        T (&input)[ITEMS_PER_THREAD],
        FlagOp flag_op)
    {

        temp_storage.last_items[linear_tid] = input[ITEMS_PER_THREAD - 1];

        __syncthreads();


        head_flags[0] = (linear_tid == 0) ?
            1 :
            ApplyOp<FlagOp>::Flag(
                flag_op,
                temp_storage.last_items[linear_tid - 1],
                input[0],
                linear_tid * ITEMS_PER_THREAD);


        Iterate<1, ITEMS_PER_THREAD>::FlagHeads(linear_tid, head_flags, input, flag_op);
    }
# 424 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename FlagT,
        typename FlagOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagHeads(
        FlagT (&head_flags)[ITEMS_PER_THREAD],
        T (&input)[ITEMS_PER_THREAD],
        FlagOp flag_op,
        T tile_predecessor_item)
    {

        temp_storage.last_items[linear_tid] = input[ITEMS_PER_THREAD - 1];

        __syncthreads();


        T predecessor_item = (linear_tid == 0) ?
            tile_predecessor_item :
            temp_storage.last_items[linear_tid - 1];

        head_flags[0] = ApplyOp<FlagOp>::Flag(
            flag_op,
            predecessor_item,
            input[0],
            linear_tid * ITEMS_PER_THREAD);


        Iterate<1, ITEMS_PER_THREAD>::FlagHeads(linear_tid, head_flags, input, flag_op);
    }
# 512 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename FlagT,
        typename FlagOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagTails(
        FlagT (&tail_flags)[ITEMS_PER_THREAD],
        T (&input)[ITEMS_PER_THREAD],
        FlagOp flag_op)
    {

        temp_storage.first_items[linear_tid] = input[0];

        __syncthreads();


        tail_flags[ITEMS_PER_THREAD - 1] = (linear_tid == BLOCK_THREADS - 1) ?
            1 :
            ApplyOp<FlagOp>::Flag(
                flag_op,
                input[ITEMS_PER_THREAD - 1],
                temp_storage.first_items[linear_tid + 1],
                (linear_tid * ITEMS_PER_THREAD) + (ITEMS_PER_THREAD - 1));


        Iterate<0, ITEMS_PER_THREAD - 1>::FlagTails(linear_tid, tail_flags, input, flag_op);
    }
# 596 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename FlagT,
        typename FlagOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagTails(
        FlagT (&tail_flags)[ITEMS_PER_THREAD],
        T (&input)[ITEMS_PER_THREAD],
        FlagOp flag_op,
        T tile_successor_item)
    {

        temp_storage.first_items[linear_tid] = input[0];

        __syncthreads();


        T successor_item = (linear_tid == BLOCK_THREADS - 1) ?
            tile_successor_item :
            temp_storage.first_items[linear_tid + 1];

        tail_flags[ITEMS_PER_THREAD - 1] = ApplyOp<FlagOp>::Flag(
            flag_op,
            input[ITEMS_PER_THREAD - 1],
            successor_item,
            (linear_tid * ITEMS_PER_THREAD) + (ITEMS_PER_THREAD - 1));


        Iterate<0, ITEMS_PER_THREAD - 1>::FlagTails(linear_tid, tail_flags, input, flag_op);
    }
# 694 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename FlagT,
        typename FlagOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagHeadsAndTails(
        FlagT (&head_flags)[ITEMS_PER_THREAD],
        FlagT (&tail_flags)[ITEMS_PER_THREAD],
        T (&input)[ITEMS_PER_THREAD],
        FlagOp flag_op)
    {

        temp_storage.first_items[linear_tid] = input[0];
        temp_storage.last_items[linear_tid] = input[ITEMS_PER_THREAD - 1];

        __syncthreads();


        head_flags[0] = (linear_tid == 0) ?
            1 :
            ApplyOp<FlagOp>::Flag(
                flag_op,
                temp_storage.last_items[linear_tid - 1],
                input[0],
                linear_tid * ITEMS_PER_THREAD);


        tail_flags[ITEMS_PER_THREAD - 1] = (linear_tid == BLOCK_THREADS - 1) ?
            1 :
            ApplyOp<FlagOp>::Flag(
                flag_op,
                input[ITEMS_PER_THREAD - 1],
                temp_storage.first_items[linear_tid + 1],
                (linear_tid * ITEMS_PER_THREAD) + (ITEMS_PER_THREAD - 1));


        Iterate<1, ITEMS_PER_THREAD>::FlagHeads(linear_tid, head_flags, input, flag_op);


        Iterate<0, ITEMS_PER_THREAD - 1>::FlagTails(linear_tid, tail_flags, input, flag_op);
    }
# 801 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename FlagT,
        typename FlagOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagHeadsAndTails(
        FlagT (&head_flags)[ITEMS_PER_THREAD],
        FlagT (&tail_flags)[ITEMS_PER_THREAD],
        T tile_successor_item,
        T (&input)[ITEMS_PER_THREAD],
        FlagOp flag_op)
    {

        temp_storage.first_items[linear_tid] = input[0];
        temp_storage.last_items[linear_tid] = input[ITEMS_PER_THREAD - 1];

        __syncthreads();


        head_flags[0] = (linear_tid == 0) ?
            1 :
            ApplyOp<FlagOp>::Flag(
                flag_op,
                temp_storage.last_items[linear_tid - 1],
                input[0],
                linear_tid * ITEMS_PER_THREAD);


        T successor_item = (linear_tid == BLOCK_THREADS - 1) ?
            tile_successor_item :
            temp_storage.first_items[linear_tid + 1];

        tail_flags[ITEMS_PER_THREAD - 1] = ApplyOp<FlagOp>::Flag(
            flag_op,
            input[ITEMS_PER_THREAD - 1],
            successor_item,
            (linear_tid * ITEMS_PER_THREAD) + (ITEMS_PER_THREAD - 1));


        Iterate<1, ITEMS_PER_THREAD>::FlagHeads(linear_tid, head_flags, input, flag_op);


        Iterate<0, ITEMS_PER_THREAD - 1>::FlagTails(linear_tid, tail_flags, input, flag_op);
    }
# 917 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename FlagT,
        typename FlagOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagHeadsAndTails(
        FlagT (&head_flags)[ITEMS_PER_THREAD],
        T tile_predecessor_item,
        FlagT (&tail_flags)[ITEMS_PER_THREAD],
        T (&input)[ITEMS_PER_THREAD],
        FlagOp flag_op)
    {

        temp_storage.first_items[linear_tid] = input[0];
        temp_storage.last_items[linear_tid] = input[ITEMS_PER_THREAD - 1];

        __syncthreads();


        T predecessor_item = (linear_tid == 0) ?
            tile_predecessor_item :
            temp_storage.last_items[linear_tid - 1];

        head_flags[0] = ApplyOp<FlagOp>::Flag(
            flag_op,
            predecessor_item,
            input[0],
            linear_tid * ITEMS_PER_THREAD);


        tail_flags[ITEMS_PER_THREAD - 1] = (linear_tid == BLOCK_THREADS - 1) ?
            1 :
            ApplyOp<FlagOp>::Flag(
                flag_op,
                input[ITEMS_PER_THREAD - 1],
                temp_storage.first_items[linear_tid + 1],
                (linear_tid * ITEMS_PER_THREAD) + (ITEMS_PER_THREAD - 1));


        Iterate<1, ITEMS_PER_THREAD>::FlagHeads(linear_tid, head_flags, input, flag_op);


        Iterate<0, ITEMS_PER_THREAD - 1>::FlagTails(linear_tid, tail_flags, input, flag_op);
    }
# 1034 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../block/block_discontinuity.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename FlagT,
        typename FlagOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void FlagHeadsAndTails(
        FlagT (&head_flags)[ITEMS_PER_THREAD],
        T tile_predecessor_item,
        FlagT (&tail_flags)[ITEMS_PER_THREAD],
        T tile_successor_item,
        T (&input)[ITEMS_PER_THREAD],
        FlagOp flag_op)
    {

        temp_storage.first_items[linear_tid] = input[0];
        temp_storage.last_items[linear_tid] = input[ITEMS_PER_THREAD - 1];

        __syncthreads();


        T predecessor_item = (linear_tid == 0) ?
            tile_predecessor_item :
            temp_storage.last_items[linear_tid - 1];

        head_flags[0] = ApplyOp<FlagOp>::Flag(
            flag_op,
            predecessor_item,
            input[0],
            linear_tid * ITEMS_PER_THREAD);


        T successor_item = (linear_tid == BLOCK_THREADS - 1) ?
            tile_successor_item :
            temp_storage.first_items[linear_tid + 1];

        tail_flags[ITEMS_PER_THREAD - 1] = ApplyOp<FlagOp>::Flag(
            flag_op,
            input[ITEMS_PER_THREAD - 1],
            successor_item,
            (linear_tid * ITEMS_PER_THREAD) + (ITEMS_PER_THREAD - 1));


        Iterate<1, ITEMS_PER_THREAD>::FlagHeads(linear_tid, head_flags, input, flag_op);


        Iterate<0, ITEMS_PER_THREAD - 1>::FlagTails(linear_tid, tail_flags, input, flag_op);
    }






};


}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_histogram_sort.cuh" 2




namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {






template <
    typename T,
    int BLOCK_DIM_X,
    int ITEMS_PER_THREAD,
    int BINS,
    int BLOCK_DIM_Y,
    int BLOCK_DIM_Z,
    int PTX_ARCH>
struct BlockHistogramSort
{

    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };


    typedef BlockRadixSort<
            T,
            BLOCK_DIM_X,
            ITEMS_PER_THREAD,
            NullType,
            4,
            (PTX_ARCH >= 350) ? true : false,
            BLOCK_SCAN_WARP_SCANS,
            (PTX_ARCH >= 350) ? cudaSharedMemBankSizeEightByte : cudaSharedMemBankSizeFourByte,
            BLOCK_DIM_Y,
            BLOCK_DIM_Z,
            PTX_ARCH>
        BlockRadixSortT;


    typedef BlockDiscontinuity<
            T,
            BLOCK_DIM_X,
            BLOCK_DIM_Y,
            BLOCK_DIM_Z,
            PTX_ARCH>
        BlockDiscontinuityT;


    union _TempStorage
    {

        typename BlockRadixSortT::TempStorage sort;

        struct
        {

            typename BlockDiscontinuityT::TempStorage flag;


            unsigned int run_begin[BINS];
            unsigned int run_end[BINS];
        };
    };



    struct TempStorage : Uninitialized<_TempStorage> {};



    _TempStorage &temp_storage;
    int linear_tid;



    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockHistogramSort(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}



    struct DiscontinuityOp
    {

        _TempStorage &temp_storage;


        __attribute__((device)) __inline__ __attribute__((always_inline)) DiscontinuityOp(_TempStorage &temp_storage) :
            temp_storage(temp_storage)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator()(const T &a, const T &b, unsigned int b_index)
        {
            if (a != b)
            {

                temp_storage.run_begin[b] = b_index;
                temp_storage.run_end[a] = b_index;

                return true;
            }
            else
            {
                return false;
            }
        }
    };



    template <
        typename HistoCounter>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Composite(
        T (&items)[ITEMS_PER_THREAD],
        HistoCounter histogram[BINS])
    {
        enum { TILE_SIZE = BLOCK_THREADS * ITEMS_PER_THREAD };


        BlockRadixSortT(temp_storage.sort).Sort(items);

        __syncthreads();


        int histo_offset = 0;

#pragma unroll
        for(; histo_offset + BLOCK_THREADS <= BINS; histo_offset += BLOCK_THREADS)
        {
            temp_storage.run_begin[histo_offset + linear_tid] = TILE_SIZE;
            temp_storage.run_end[histo_offset + linear_tid] = TILE_SIZE;
        }

        if ((BINS % BLOCK_THREADS != 0) && (histo_offset + linear_tid < BINS))
        {
            temp_storage.run_begin[histo_offset + linear_tid] = TILE_SIZE;
            temp_storage.run_end[histo_offset + linear_tid] = TILE_SIZE;
        }

        __syncthreads();

        int flags[ITEMS_PER_THREAD];


        DiscontinuityOp flag_op(temp_storage);
        BlockDiscontinuityT(temp_storage.flag).FlagHeads(flags, items, flag_op);


        if (linear_tid == 0) temp_storage.run_begin[items[0]] = 0;

        __syncthreads();


        histo_offset = 0;

#pragma unroll
        for(; histo_offset + BLOCK_THREADS <= BINS; histo_offset += BLOCK_THREADS)
        {
            int thread_offset = histo_offset + linear_tid;
            HistoCounter count = temp_storage.run_end[thread_offset] - temp_storage.run_begin[thread_offset];
            histogram[thread_offset] += count;
        }


        if ((BINS % BLOCK_THREADS != 0) && (histo_offset + linear_tid < BINS))
        {
            int thread_offset = histo_offset + linear_tid;
            HistoCounter count = temp_storage.run_end[thread_offset] - temp_storage.run_begin[thread_offset];
            histogram[thread_offset] += count;
        }
    }

};

}
} } } }
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_histogram_atomic.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_histogram_atomic.cuh"
       




namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {





template <int BINS>
struct BlockHistogramAtomic
{

    struct TempStorage {};



    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockHistogramAtomic(
        TempStorage &temp_storage)
    {}



    template <
        typename T,
        typename HistoCounter,
        int ITEMS_PER_THREAD>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Composite(
        T (&items)[ITEMS_PER_THREAD],
        HistoCounter histogram[BINS])
    {

#pragma unroll
        for (int i = 0; i < ITEMS_PER_THREAD; ++i)
        {
              atomicAdd(histogram + items[i], 1);
        }
    }

};

}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh" 2





namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 56 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh"
enum BlockHistogramAlgorithm
{
# 68 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh"
    BLOCK_HISTO_SORT,
# 81 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh"
    BLOCK_HISTO_ATOMIC,
};
# 148 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh"
template <
    typename T,
    int BLOCK_DIM_X,
    int ITEMS_PER_THREAD,
    int BINS,
    BlockHistogramAlgorithm ALGORITHM = BLOCK_HISTO_SORT,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockHistogram
{
private:






    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };







    static const BlockHistogramAlgorithm SAFE_ALGORITHM =
        ((ALGORITHM == BLOCK_HISTO_ATOMIC) && (PTX_ARCH < 120)) ?
            BLOCK_HISTO_SORT :
            ALGORITHM;


    typedef typename If<(SAFE_ALGORITHM == BLOCK_HISTO_SORT),
        BlockHistogramSort<T, BLOCK_DIM_X, ITEMS_PER_THREAD, BINS, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>,
        BlockHistogramAtomic<BINS> >::Type InternalBlockHistogram;


    typedef typename InternalBlockHistogram::TempStorage _TempStorage;







    _TempStorage &temp_storage;


    int linear_tid;







    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }


public:


    struct TempStorage : Uninitialized<_TempStorage> {};
# 229 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockHistogram()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockHistogram(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}
# 290 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh"
    template <typename HistoCounter>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InitHistogram(HistoCounter histogram[BINS])
    {

        int histo_offset = 0;

#pragma unroll
        for(; histo_offset + BLOCK_THREADS <= BINS; histo_offset += BLOCK_THREADS)
        {
            histogram[histo_offset + linear_tid] = 0;
        }

        if ((BINS % BLOCK_THREADS != 0) && (histo_offset + linear_tid < BINS))
        {
            histogram[histo_offset + linear_tid] = 0;
        }
    }
# 345 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh"
    template <
        typename HistoCounter>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Histogram(
        T (&items)[ITEMS_PER_THREAD],
        HistoCounter histogram[BINS])
    {

        InitHistogram(histogram);

        __syncthreads();


        InternalBlockHistogram(temp_storage).Composite(items, histogram);
    }
# 402 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_histogram.cuh"
    template <
        typename HistoCounter>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Composite(
        T (&items)[ITEMS_PER_THREAD],
        HistoCounter histogram[BINS])
    {
        InternalBlockHistogram(temp_storage).Composite(items, histogram);
    }

};

}
} } } }
# 39 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
       
# 45 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 71 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectBlocked(
    int linear_tid,
    InputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD])
{

#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        items[ITEM] = block_itr[(linear_tid * ITEMS_PER_THREAD) + ITEM];
    }
}
# 98 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectBlocked(
    int linear_tid,
    InputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD],
    int valid_items)
{
    int bounds = valid_items - (linear_tid * ITEMS_PER_THREAD);

#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        if (ITEM < bounds)
        {
            items[ITEM] = block_itr[(linear_tid * ITEMS_PER_THREAD) + ITEM];
        }
    }
}
# 130 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectBlocked(
    int linear_tid,
    InputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD],
    int valid_items,
    T oob_default)
{
#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        items[ITEM] = oob_default;
    }

    LoadDirectBlocked(linear_tid, block_itr, items, valid_items);
}
# 165 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectBlockedVectorized(
    int linear_tid,
    T *block_ptr,
    T (&items)[ITEMS_PER_THREAD])
{
    enum
    {

        MAX_VEC_SIZE = (((ITEMS_PER_THREAD) < (4)) ? (ITEMS_PER_THREAD) : (4)),


        VEC_SIZE = ((((MAX_VEC_SIZE - 1) & MAX_VEC_SIZE) == 0) && ((ITEMS_PER_THREAD % MAX_VEC_SIZE) == 0)) ?
            MAX_VEC_SIZE :
            1,

        VECTORS_PER_THREAD = ITEMS_PER_THREAD / VEC_SIZE,
    };


    typedef typename CubVector<T, VEC_SIZE>::Type Vector;


    Vector vec_items[VECTORS_PER_THREAD];


    Vector *ptr = reinterpret_cast<Vector*>(block_ptr + (linear_tid * VEC_SIZE * VECTORS_PER_THREAD));


#pragma unroll
    for (int ITEM = 0; ITEM < VECTORS_PER_THREAD; ITEM++)
    {
        vec_items[ITEM] = ptr[ITEM];
    }


#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        items[ITEM] = reinterpret_cast<T*>(vec_items)[ITEM];
    }
}
# 229 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    int BLOCK_THREADS,
    typename T,
    int ITEMS_PER_THREAD,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectStriped(
    int linear_tid,
    InputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD])
{
#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        items[ITEM] = block_itr[(ITEM * BLOCK_THREADS) + linear_tid];
    }
}
# 257 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    int BLOCK_THREADS,
    typename T,
    int ITEMS_PER_THREAD,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectStriped(
    int linear_tid,
    InputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD],
    int valid_items)
{
    int bounds = valid_items - linear_tid;

#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        if (ITEM * BLOCK_THREADS < bounds)
        {
            items[ITEM] = block_itr[linear_tid + (ITEM * BLOCK_THREADS)];
        }
    }
}
# 291 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    int BLOCK_THREADS,
    typename T,
    int ITEMS_PER_THREAD,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectStriped(
    int linear_tid,
    InputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD],
    int valid_items,
    T oob_default)
{
#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        items[ITEM] = oob_default;
    }

    LoadDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items, valid_items);
}
# 333 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectWarpStriped(
    int linear_tid,
    InputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD])
{
    int tid = linear_tid & ((1 << (5)) - 1);
    int wid = linear_tid >> (5);
    int warp_offset = wid * (1 << (5)) * ITEMS_PER_THREAD;


#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        items[ITEM] = block_itr[warp_offset + tid + (ITEM * (1 << (5)))];
    }
}
# 367 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectWarpStriped(
    int linear_tid,
    InputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD],
    int valid_items)
{
    int tid = linear_tid & ((1 << (5)) - 1);
    int wid = linear_tid >> (5);
    int warp_offset = wid * (1 << (5)) * ITEMS_PER_THREAD;
    int bounds = valid_items - warp_offset - tid;


#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        if ((ITEM * (1 << (5))) < bounds)
        {
            items[ITEM] = block_itr[warp_offset + tid + (ITEM * (1 << (5)))];
        }
    }
}
# 406 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename InputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void LoadDirectWarpStriped(
    int linear_tid,
    InputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD],
    int valid_items,
    T oob_default)
{
#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        items[ITEM] = oob_default;
    }

    LoadDirectWarpStriped(linear_tid, block_itr, items, valid_items);
}
# 440 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
enum BlockLoadAlgorithm
{
# 453 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
    BLOCK_LOAD_DIRECT,
# 475 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
    BLOCK_LOAD_VECTORIZE,
# 494 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
    BLOCK_LOAD_TRANSPOSE,
# 517 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
    BLOCK_LOAD_WARP_TRANSPOSE,
};
# 584 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
template <
    typename InputIterator,
    int BLOCK_DIM_X,
    int ITEMS_PER_THREAD,
    BlockLoadAlgorithm ALGORITHM = BLOCK_LOAD_DIRECT,
    bool WARP_TIME_SLICING = false,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockLoad
{
private:






    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };


    typedef typename std::iterator_traits<InputIterator>::value_type T;







    template <BlockLoadAlgorithm _POLICY, int DUMMY>
    struct LoadInternal;





    template <int DUMMY>
    struct LoadInternal<BLOCK_LOAD_DIRECT, DUMMY>
    {

        typedef NullType TempStorage;


        int linear_tid;


        __attribute__((device)) __inline__ __attribute__((always_inline)) LoadInternal(
            TempStorage &temp_storage,
            int linear_tid)
        :
            linear_tid(linear_tid)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD])
        {
            LoadDirectBlocked(linear_tid, block_itr, items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items)
        {
            LoadDirectBlocked(linear_tid, block_itr, items, valid_items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items,
            T oob_default)
        {
            LoadDirectBlocked(linear_tid, block_itr, items, valid_items, oob_default);
        }

    };





    template <int DUMMY>
    struct LoadInternal<BLOCK_LOAD_VECTORIZE, DUMMY>
    {

        typedef NullType TempStorage;


        int linear_tid;


        __attribute__((device)) __inline__ __attribute__((always_inline)) LoadInternal(
            TempStorage &temp_storage,
            int linear_tid)
        :
            linear_tid(linear_tid)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            T *block_ptr,
            T (&items)[ITEMS_PER_THREAD])
        {
            LoadDirectBlockedVectorized(linear_tid, block_ptr, items);
        }


        template <
            typename T,
            typename _InputIterator>
        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            _InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD])
        {
            LoadDirectBlocked(linear_tid, block_itr, items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items)
        {
            LoadDirectBlocked(linear_tid, block_itr, items, valid_items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items,
            T oob_default)
        {
            LoadDirectBlocked(linear_tid, block_itr, items, valid_items, oob_default);
        }

    };





    template <int DUMMY>
    struct LoadInternal<BLOCK_LOAD_TRANSPOSE, DUMMY>
    {

        typedef BlockExchange<T, BLOCK_DIM_X, ITEMS_PER_THREAD, WARP_TIME_SLICING, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> BlockExchange;


        typedef typename BlockExchange::TempStorage _TempStorage;


        struct TempStorage : Uninitialized<_TempStorage> {};


        _TempStorage &temp_storage;


        int linear_tid;


        __attribute__((device)) __inline__ __attribute__((always_inline)) LoadInternal(
            TempStorage &temp_storage,
            int linear_tid)
        :
            temp_storage(temp_storage.Alias()),
            linear_tid(linear_tid)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD])
        {
            LoadDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items);
            BlockExchange(temp_storage).StripedToBlocked(items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items)
        {
            LoadDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items, valid_items);
            BlockExchange(temp_storage).StripedToBlocked(items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items,
            T oob_default)
        {
            LoadDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items, valid_items, oob_default);
            BlockExchange(temp_storage).StripedToBlocked(items);
        }

    };





    template <int DUMMY>
    struct LoadInternal<BLOCK_LOAD_WARP_TRANSPOSE, DUMMY>
    {
        enum
        {
            WARP_THREADS = (1 << (5))
        };


        typedef int cub_static_assert807[((BLOCK_THREADS % WARP_THREADS == 0)) ? 1 : -1];


        typedef BlockExchange<T, BLOCK_DIM_X, ITEMS_PER_THREAD, WARP_TIME_SLICING, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> BlockExchange;


        typedef typename BlockExchange::TempStorage _TempStorage;


        struct TempStorage : Uninitialized<_TempStorage> {};


        _TempStorage &temp_storage;


        int linear_tid;


        __attribute__((device)) __inline__ __attribute__((always_inline)) LoadInternal(
            TempStorage &temp_storage,
            int linear_tid)
        :
            temp_storage(temp_storage.Alias()),
            linear_tid(linear_tid)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD])
        {
            LoadDirectWarpStriped(linear_tid, block_itr, items);
            BlockExchange(temp_storage).WarpStripedToBlocked(items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items)
        {
            LoadDirectWarpStriped(linear_tid, block_itr, items, valid_items);
            BlockExchange(temp_storage).WarpStripedToBlocked(items);
        }



        __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
            InputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items,
            T oob_default)
        {
            LoadDirectWarpStriped(linear_tid, block_itr, items, valid_items, oob_default);
            BlockExchange(temp_storage).WarpStripedToBlocked(items);
        }
    };







    typedef LoadInternal<ALGORITHM, 0> InternalLoad;



    typedef typename InternalLoad::TempStorage _TempStorage;







    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }







    _TempStorage &temp_storage;


    int linear_tid;

public:


    struct TempStorage : Uninitialized<_TempStorage> {};
# 914 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockLoad()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockLoad(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}
# 977 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
        InputIterator block_itr,
        T (&items)[ITEMS_PER_THREAD])
    {
        InternalLoad(temp_storage, linear_tid).Load(block_itr, items);
    }
# 1022 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
        InputIterator block_itr,
        T (&items)[ITEMS_PER_THREAD],
        int valid_items)
    {
        InternalLoad(temp_storage, linear_tid).Load(block_itr, items, valid_items);
    }
# 1069 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_load.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Load(
        InputIterator block_itr,
        T (&items)[ITEMS_PER_THREAD],
        int valid_items,
        T oob_default)
    {
        InternalLoad(temp_storage, linear_tid).Load(block_itr, items, valid_items, oob_default);
    }




};


}
} } } }
# 42 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_reduce_raking.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_reduce_raking.cuh"
       


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
       

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/warp_reduce_shfl.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
       






# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/../../util_debug.cuh" 1
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/../../util_debug.cuh"
       






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 68 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/../../util_debug.cuh"
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t Debug(
    cudaError_t error,
    const char* filename,
    int line)
{
# 84 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/../../util_debug.cuh"
    return error;
}
# 114 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/../../util_debug.cuh"
}
} } } }
# 42 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/warp_reduce_shfl.cuh" 2


namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {





template <
    typename T,
    int LOGICAL_WARP_THREADS,
    int PTX_ARCH>
struct WarpReduceShfl
{




    enum
    {

        IS_ARCH_WARP = (LOGICAL_WARP_THREADS == (1 << (5))),


        STEPS = Log2<LOGICAL_WARP_THREADS>::VALUE,


        LOGICAL_WARPS = (1 << (5)) / LOGICAL_WARP_THREADS,
    };

    template <typename S>
    struct IsInteger
    {
        enum {

            IS_INTEGER = (Traits<S>::CATEGORY == UNSIGNED_INTEGER) || (Traits<S>::CATEGORY == SIGNED_INTEGER),


            IS_SMALL_INTEGER = IS_INTEGER && (sizeof(S) <= sizeof(unsigned int))
        };
    };



    template <int WARP, int WARPS>
    struct LastLaneMask
    {
        enum {
            BASE_MASK = 1 << (LOGICAL_WARP_THREADS - 1),
            MASK = (LastLaneMask<WARP + 1, WARPS>::MASK << LOGICAL_WARP_THREADS) | BASE_MASK,
        };
    };


    template <int WARP>
    struct LastLaneMask<WARP, WARP>
    {
        enum {
            MASK = 1 << (LOGICAL_WARP_THREADS - 1),
        };
    };




    typedef NullType TempStorage;






    int lane_id;







    __attribute__((device)) __inline__ __attribute__((always_inline)) WarpReduceShfl(
        TempStorage &temp_storage)
    :
        lane_id(LaneId())
    {}







    __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned int ReduceStep(
        unsigned int input,
        cub_::Sum reduction_op,
        int last_lane,
        int offset)
    {
        unsigned int output;


        asm(
            "{"
            "  .reg .u32 r0;"
            "  .reg .pred p;"
            "  shfl.down.b32 r0|p, %1, %2, %3;"
            "  @p add.u32 r0, r0, %4;"
            "  mov.u32 %0, r0;"
            "}"
            : "=r"(output) : "r"(input), "r"(offset), "r"(last_lane), "r"(input));

        return output;
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) float ReduceStep(
        float input,
        cub_::Sum reduction_op,
        int last_lane,
        int offset)
    {
        float output;


        asm(
            "{"
            "  .reg .f32 r0;"
            "  .reg .pred p;"
            "  shfl.down.b32 r0|p, %1, %2, %3;"
            "  @p add.f32 r0, r0, %4;"
            "  mov.f32 %0, r0;"
            "}"
            : "=f"(output) : "f"(input), "r"(offset), "r"(last_lane), "f"(input));

        return output;
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) unsigned long long ReduceStep(
        unsigned long long input,
        cub_::Sum reduction_op,
        int last_lane,
        int offset)
    {
        unsigned long long output;

        asm(
            "{"
            "  .reg .u32 lo;"
            "  .reg .u32 hi;"
            "  .reg .pred p;"
            "  mov.b64 {lo, hi}, %1;"
            "  shfl.down.b32 lo|p, lo, %2, %3;"
            "  shfl.down.b32 hi|p, hi, %2, %3;"
            "  mov.b64 %0, {lo, hi};"
            "  @p add.u64 %0, %0, %1;"
            "}"
            : "=l"(output) : "l"(input), "r"(offset), "r"(last_lane));

        return output;
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) long long ReduceStep(
        long long input,
        cub_::Sum reduction_op,
        int last_lane,
        int offset)
    {
        long long output;


        asm(
            "{"
            "  .reg .u32 lo;"
            "  .reg .u32 hi;"
            "  .reg .pred p;"
            "  mov.b64 {lo, hi}, %1;"
            "  shfl.down.b32 lo|p, lo, %2, %3;"
            "  shfl.down.b32 hi|p, hi, %2, %3;"
            "  mov.b64 %0, {lo, hi};"
            "  @p add.s64 %0, %0, %1;"
            "}"
            : "=l"(output) : "l"(input), "r"(offset), "r"(last_lane));

        return output;
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) double ReduceStep(
        double input,
        cub_::Sum reduction_op,
        int last_lane,
        int offset)
    {
        double output;


        asm(
            "{"
            "  .reg .u32 lo;"
            "  .reg .u32 hi;"
            "  .reg .pred p;"
            "  mov.b64 {lo, hi}, %1;"
            "  shfl.down.b32 lo|p, lo, %2, %3;"
            "  shfl.down.b32 hi|p, hi, %2, %3;"
            "  mov.b64 %0, {lo, hi};"
            "  @p add.f64 %0, %0, %1;"
            "}"
            : "=d"(output) : "d"(input), "r"(offset), "r"(last_lane));

        return output;
    }



    template <typename Value, typename Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) ItemOffsetPair<Value, Offset> ReduceStep(
        ItemOffsetPair<Value, Offset> input,
        ReduceBySegmentOp<cub_::Sum, ItemOffsetPair<Value, Offset> > reduction_op,
        int last_lane,
        int offset)
    {
        ItemOffsetPair<Value, Offset> output;

        output.value = ReduceStep(input.value, cub_::Sum(), last_lane, offset, Int2Type<IsInteger<Value>::IS_SMALL_INTEGER>());
        output.offset = ReduceStep(input.offset, cub_::Sum(), last_lane, offset, Int2Type<IsInteger<Offset>::IS_SMALL_INTEGER>());




        if (input.offset > 0)
            output.value = input.value;

        return output;
    }



    template <typename _T, typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) _T ReduceStep(
        _T input,
        ReductionOp reduction_op,
        int last_lane,
        int offset)
    {
        T output = input;

        T temp = ShuffleDown(output, offset);


        if (offset <= last_lane - lane_id)
            output = reduction_op(temp, output);

        return output;
    }



    template <typename _T, typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) _T ReduceStep(
        _T input,
        ReductionOp reduction_op,
        int last_lane,
        int offset,
        Int2Type<true> is_small_integer)
    {
        unsigned int temp = reinterpret_cast<unsigned int &>(input);

        temp = ReduceStep(temp, reduction_op, last_lane, offset);

        return reinterpret_cast<_T&>(temp);
    }


    template <typename _T, typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) _T ReduceStep(
        _T input,
        ReductionOp reduction_op,
        int last_lane,
        int offset,
        Int2Type<false> is_small_integer)
    {
        return ReduceStep(input, reduction_op, last_lane, offset);
    }







    template <
        bool ALL_LANES_VALID,
        int FOLDED_ITEMS_PER_LANE,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T input,
        int folded_items_per_warp,
        ReductionOp reduction_op)
    {

        int first_warp_thread = 0;
        int last_warp_thread = LOGICAL_WARP_THREADS - 1;
        if (!IS_ARCH_WARP)
        {
            first_warp_thread = lane_id & (~(LOGICAL_WARP_THREADS - 1));
            last_warp_thread |= lane_id;
        }


        int lanes_with_valid_data = (folded_items_per_warp - 1) / FOLDED_ITEMS_PER_LANE;


        int last_lane = (ALL_LANES_VALID) ?
            last_warp_thread :
            (((first_warp_thread + lanes_with_valid_data) < (last_warp_thread)) ? (first_warp_thread + lanes_with_valid_data) : (last_warp_thread));

        T output = input;


#pragma unroll
        for (int STEP = 0; STEP < STEPS; STEP++)
        {
            output = ReduceStep(output, reduction_op, last_lane, 1 << STEP, Int2Type<IsInteger<T>::IS_SMALL_INTEGER>());
        }

        return output;
    }



    template <
        bool HEAD_SEGMENTED,
        typename Flag,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T SegmentedReduce(
        T input,
        Flag flag,
        ReductionOp reduction_op)
    {

        int warp_flags = __ballot(flag);

        if (HEAD_SEGMENTED)
            warp_flags >>= 1;


        warp_flags |= LastLaneMask<1, LOGICAL_WARPS>::MASK;


        warp_flags &= LaneMaskGe();


        int last_lane = __clz(__brev(warp_flags));

        T output = input;


#pragma unroll
        for (int STEP = 0; STEP < STEPS; STEP++)
        {
            output = ReduceStep(output, reduction_op, last_lane, 1 << STEP, Int2Type<IsInteger<T>::IS_SMALL_INTEGER>());
        }

        return output;
    }
};


}
} } } }
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/warp_reduce_smem.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
       
# 43 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {




template <
    typename T,
    int LOGICAL_WARP_THREADS,
    int PTX_ARCH>
struct WarpReduceSmem
{




    enum
    {

        IS_ARCH_WARP = (LOGICAL_WARP_THREADS == (1 << (5))),


        IS_POW_OF_TWO = ((LOGICAL_WARP_THREADS & (LOGICAL_WARP_THREADS - 1)) == 0),


        STEPS = Log2<LOGICAL_WARP_THREADS>::VALUE,


        HALF_WARP_THREADS = 1 << (STEPS - 1),


        WARP_SMEM_ELEMENTS = LOGICAL_WARP_THREADS + HALF_WARP_THREADS,


        UNSET = 0x0,
        SET = 0x1,
        SEEN = 0x2,
    };


    typedef unsigned char SmemFlag;


    struct _TempStorage
    {
        T reduce[WARP_SMEM_ELEMENTS];
        SmemFlag flags[WARP_SMEM_ELEMENTS];
    };


    struct TempStorage : Uninitialized<_TempStorage> {};






    _TempStorage &temp_storage;
    int lane_id;







    __attribute__((device)) __inline__ __attribute__((always_inline)) WarpReduceSmem(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        lane_id(IS_ARCH_WARP ?
            LaneId() :
            LaneId() % LOGICAL_WARP_THREADS)
    {}
# 131 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
    template <
        bool ALL_LANES_VALID,
        int FOLDED_ITEMS_PER_LANE,
        typename ReductionOp,
        int STEP>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T ReduceStep(
        T input,
        int folded_items_per_warp,
        ReductionOp reduction_op,
        Int2Type<STEP> step)
    {
        const int OFFSET = 1 << STEP;


        ThreadStore<STORE_VOLATILE>(&temp_storage.reduce[lane_id], input);


        if ((ALL_LANES_VALID && IS_POW_OF_TWO) || ((lane_id + OFFSET) * FOLDED_ITEMS_PER_LANE < folded_items_per_warp))
        {
            T peer_addend = ThreadLoad<LOAD_VOLATILE>(&temp_storage.reduce[lane_id + OFFSET]);
            input = reduction_op(input, peer_addend);
        }

        return ReduceStep<ALL_LANES_VALID, FOLDED_ITEMS_PER_LANE>(input, folded_items_per_warp, reduction_op, Int2Type<STEP + 1>());
    }





    template <
        bool ALL_LANES_VALID,
        int FOLDED_ITEMS_PER_LANE,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T ReduceStep(
        T input,
        int folded_items_per_warp,
        ReductionOp reduction_op,
        Int2Type<STEPS> step)
    {
        return input;
    }
# 183 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
    template <
        bool HEAD_SEGMENTED,
        typename Flag,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T SegmentedReduce(
        T input,
        Flag flag,
        ReductionOp reduction_op,
        Int2Type<true> has_ballot)
    {

        int warp_flags = __ballot(flag);

        if (!HEAD_SEGMENTED)
            warp_flags <<= 1;


        warp_flags &= LaneMaskGt();


        if (!IS_ARCH_WARP)
        {
            warp_flags >>= (LaneId() / LOGICAL_WARP_THREADS) * LOGICAL_WARP_THREADS;
        }


        int next_flag = __clz(__brev(warp_flags));


        if (LOGICAL_WARP_THREADS != 32)
            next_flag = (((LOGICAL_WARP_THREADS) < (next_flag)) ? (LOGICAL_WARP_THREADS) : (next_flag));

#pragma unroll
        for (int STEP = 0; STEP < STEPS; STEP++)
        {
            const int OFFSET = 1 << STEP;


            ThreadStore<STORE_VOLATILE>(&temp_storage.reduce[lane_id], input);


            if (OFFSET < next_flag - lane_id)
            {
                T peer_addend = ThreadLoad<LOAD_VOLATILE>(&temp_storage.reduce[lane_id + OFFSET]);
                input = reduction_op(input, peer_addend);
            }
        }

        return input;
    }





    template <
        bool HEAD_SEGMENTED,
        typename Flag,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T SegmentedReduce(
        T input,
        Flag flag,
        ReductionOp reduction_op,
        Int2Type<false> has_ballot)
    {
        enum
        {
            UNSET = 0x0,
            SET = 0x1,
            SEEN = 0x2,
        };


        volatile SmemFlag *flag_storage = temp_storage.flags;

        SmemFlag flag_status = (flag) ? SET : UNSET;

        for (int STEP = 0; STEP < STEPS; STEP++)
        {
            const int OFFSET = 1 << STEP;


            ThreadStore<STORE_VOLATILE>(&temp_storage.reduce[lane_id], input);


            T peer_addend = ThreadLoad<LOAD_VOLATILE>(&temp_storage.reduce[lane_id + OFFSET]);


            flag_storage[lane_id] = flag_status;


            SmemFlag peer_flag_status = flag_storage[lane_id + OFFSET];


            if (lane_id < LOGICAL_WARP_THREADS - OFFSET)
            {
                if (HEAD_SEGMENTED)
                {

                    if ((flag_status & SEEN) == 0)
                    {

                        if (peer_flag_status & SET)
                        {

                            flag_status |= SEEN;
                        }
                        else
                        {

                            input = reduction_op(input, peer_addend);
                        }


                        flag_status |= (peer_flag_status & SEEN);
                    }
                }
                else
                {

                    if (!flag_status)
                    {
                        input = reduction_op(input, peer_addend);
                        flag_status |= peer_flag_status;
                    }

                }
            }
        }

        return input;
    }
# 324 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
    template <
        bool ALL_LANES_VALID,
        int FOLDED_ITEMS_PER_LANE,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T input,
        int folded_items_per_warp,
        ReductionOp reduction_op)
    {
        return ReduceStep<ALL_LANES_VALID, FOLDED_ITEMS_PER_LANE>(input, folded_items_per_warp, reduction_op, Int2Type<0>());
    }





    template <
        bool HEAD_SEGMENTED,
        typename Flag,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T SegmentedReduce(
        T input,
        Flag flag,
        ReductionOp reduction_op)
    {
        return SegmentedReduce<HEAD_SEGMENTED>(input, flag, reduction_op, Int2Type<(PTX_ARCH >= 200)>());
    }


};


}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh" 2






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 137 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
template <
    typename T,
    int LOGICAL_WARP_THREADS = (1 << (5)),
    int PTX_ARCH = 0>
class WarpReduce
{
private:





    enum
    {

        IS_ARCH_WARP = (LOGICAL_WARP_THREADS == (1 << (5))),


        IS_POW_OF_TWO = PowerOfTwo<LOGICAL_WARP_THREADS>::VALUE,
    };

public:




    typedef typename If<(PTX_ARCH >= 300) && (IS_POW_OF_TWO),
        WarpReduceShfl<T, LOGICAL_WARP_THREADS, PTX_ARCH>,
        WarpReduceSmem<T, LOGICAL_WARP_THREADS, PTX_ARCH> >::Type InternalWarpReduce;




private:


    typedef typename InternalWarpReduce::TempStorage _TempStorage;







    _TempStorage &temp_storage;






public:


    struct TempStorage : Uninitialized<_TempStorage> {};
# 203 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) WarpReduce(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias())
    {}
# 251 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Sum(
        T input)
    {
        return InternalWarpReduce(temp_storage).Reduce<true, 1>(input, LOGICAL_WARP_THREADS, cub_::Sum());
    }
# 295 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Sum(
        T input,
        int valid_items)
    {

        return InternalWarpReduce(temp_storage).Reduce<false, 1>(input, valid_items, cub_::Sum());
    }
# 342 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
    template <
        typename Flag>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T HeadSegmentedSum(
        T input,
        Flag head_flag)
    {
        return HeadSegmentedReduce(input, head_flag, cub_::Sum());
    }
# 389 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
    template <
        typename Flag>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T TailSegmentedSum(
        T input,
        Flag tail_flag)
    {
        return TailSegmentedReduce(input, tail_flag, cub_::Sum());
    }
# 444 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
    template <typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T input,
        ReductionOp reduction_op)
    {
        return InternalWarpReduce(temp_storage).Reduce<true, 1>(input, LOGICAL_WARP_THREADS, reduction_op);
    }
# 493 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
    template <typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T input,
        ReductionOp reduction_op,
        int valid_items)
    {
        return InternalWarpReduce(temp_storage).Reduce<false, 1>(input, valid_items, reduction_op);
    }
# 542 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
    template <
        typename ReductionOp,
        typename Flag>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T HeadSegmentedReduce(
        T input,
        Flag head_flag,
        ReductionOp reduction_op)
    {
        return InternalWarpReduce(temp_storage).template SegmentedReduce<true>(input, head_flag, reduction_op);
    }
# 593 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/../../warp/warp_reduce.cuh"
    template <
        typename ReductionOp,
        typename Flag>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T TailSegmentedReduce(
        T input,
        Flag tail_flag,
        ReductionOp reduction_op)
    {
        return InternalWarpReduce(temp_storage).template SegmentedReduce<false>(input, tail_flag, reduction_op);
    }




};



}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_reduce_raking.cuh" 2





namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 62 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_reduce_raking.cuh"
template <
    typename T,
    int BLOCK_DIM_X,
    int BLOCK_DIM_Y,
    int BLOCK_DIM_Z,
    int PTX_ARCH>
struct BlockReduceRaking
{

    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };


    typedef BlockRakingLayout<T, BLOCK_THREADS, PTX_ARCH> BlockRakingLayout;


    typedef typename WarpReduce<T, BlockRakingLayout::RAKING_THREADS, PTX_ARCH>::InternalWarpReduce WarpReduce;


    enum
    {

        RAKING_THREADS = BlockRakingLayout::RAKING_THREADS,


        SEGMENT_LENGTH = BlockRakingLayout::SEGMENT_LENGTH,


        WARP_SYNCHRONOUS = (RAKING_THREADS == BLOCK_THREADS),


        WARP_SYNCHRONOUS_UNGUARDED = PowerOfTwo<RAKING_THREADS>::VALUE,


        RAKING_UNGUARDED = BlockRakingLayout::UNGUARDED,

    };



    struct _TempStorage
    {
        typename WarpReduce::TempStorage warp_storage;
        typename BlockRakingLayout::TempStorage raking_grid;
    };



    struct TempStorage : Uninitialized<_TempStorage> {};



    _TempStorage &temp_storage;
    int linear_tid;



    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockReduceRaking(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}


    template <bool FULL_TILE, typename ReductionOp, int ITERATION>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T RakingReduction(
        ReductionOp reduction_op,
        T *raking_segment,
        T partial,
        int num_valid,
        Int2Type<ITERATION> iteration)
    {

        if ((FULL_TILE && RAKING_UNGUARDED) || ((linear_tid * SEGMENT_LENGTH) + ITERATION < num_valid))
        {
            T addend = raking_segment[ITERATION];
            partial = reduction_op(partial, addend);
        }
        return RakingReduction<FULL_TILE>(reduction_op, raking_segment, partial, num_valid, Int2Type<ITERATION + 1>());
    }

    template <bool FULL_TILE, typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T RakingReduction(
        ReductionOp reduction_op,
        T *raking_segment,
        T partial,
        int num_valid,
        Int2Type<SEGMENT_LENGTH> iteration)
    {
        return partial;
    }



    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Sum(
        T partial,
        int num_valid)
    {
        cub_::Sum reduction_op;

        if (WARP_SYNCHRONOUS)
        {

            partial = WarpReduce(temp_storage.warp_storage).template Sum<FULL_TILE, SEGMENT_LENGTH>(
                partial,
                num_valid);
        }
        else
        {

            *BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid) = partial;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T *raking_segment = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);
                partial = raking_segment[0];

                partial = RakingReduction<FULL_TILE>(reduction_op, raking_segment, partial, num_valid, Int2Type<1>());

                partial = WarpReduce(temp_storage.warp_storage).template Sum<FULL_TILE && RAKING_UNGUARDED, SEGMENT_LENGTH>(
                    partial,
                    num_valid);
            }
        }

        return partial;
    }



    template <
        bool FULL_TILE,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T partial,
        int num_valid,
        ReductionOp reduction_op)
    {
        if (WARP_SYNCHRONOUS)
        {

            partial = WarpReduce(temp_storage.warp_storage).template Reduce<FULL_TILE, SEGMENT_LENGTH>(
                partial,
                num_valid,
                reduction_op);
        }
        else
        {

            *BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid) = partial;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T *raking_segment = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);
                partial = raking_segment[0];

                partial = RakingReduction<FULL_TILE>(reduction_op, raking_segment, partial, num_valid, Int2Type<1>());

                partial = WarpReduce(temp_storage.warp_storage).template Reduce<FULL_TILE && RAKING_UNGUARDED, SEGMENT_LENGTH>(
                    partial,
                    num_valid,
                    reduction_op);
            }
        }

        return partial;
    }

};

}
} } } }
# 37 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_reduce_raking_commutative_only.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_reduce_raking_commutative_only.cuh"
       
# 43 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_reduce_raking_commutative_only.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {





template <
    typename T,
    int BLOCK_DIM_X,
    int BLOCK_DIM_Y,
    int BLOCK_DIM_Z,
    int PTX_ARCH>
struct BlockReduceRakingCommutativeOnly
{

    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };


    typedef BlockReduceRaking<T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> FallBack;


    enum
    {

        WARP_THREADS = (1 << (5)),


        USE_FALLBACK = ((BLOCK_THREADS % WARP_THREADS != 0) || (BLOCK_THREADS <= WARP_THREADS)),


        RAKING_THREADS = WARP_THREADS,


        SHARING_THREADS = (((BLOCK_THREADS - RAKING_THREADS) > (1)) ? (BLOCK_THREADS - RAKING_THREADS) : (1)),


        SEGMENT_LENGTH = SHARING_THREADS / WARP_THREADS,
    };


    typedef WarpReduce<T, RAKING_THREADS, PTX_ARCH> WarpReduce;


    typedef BlockRakingLayout<T, SHARING_THREADS, PTX_ARCH> BlockRakingLayout;


    struct _TempStorage
    {
        union
        {
            struct
            {
                typename WarpReduce::TempStorage warp_storage;
                typename BlockRakingLayout::TempStorage raking_grid;
            };
            typename FallBack::TempStorage fallback_storage;
        };
    };



    struct TempStorage : Uninitialized<_TempStorage> {};



    _TempStorage &temp_storage;
    int linear_tid;



    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockReduceRakingCommutativeOnly(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}



    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Sum(
        T partial,
        int num_valid)
    {
        if (USE_FALLBACK || !FULL_TILE)
        {
            return FallBack(temp_storage.fallback_storage).template Sum<FULL_TILE>(partial, num_valid);
        }
        else
        {

            if (linear_tid >= RAKING_THREADS)
                *BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid - RAKING_THREADS) = partial;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T *raking_segment = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);
                partial = ThreadReduce<SEGMENT_LENGTH>(raking_segment, cub_::Sum(), partial);


                partial = WarpReduce(temp_storage.warp_storage).Sum(partial);
            }
        }

        return partial;
    }



    template <
        bool FULL_TILE,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T partial,
        int num_valid,
        ReductionOp reduction_op)
    {
        if (USE_FALLBACK || !FULL_TILE)
        {
            return FallBack(temp_storage.fallback_storage).template Reduce<FULL_TILE>(partial, num_valid, reduction_op);
        }
        else
        {

            if (linear_tid >= RAKING_THREADS)
                *BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid - RAKING_THREADS) = partial;

            __syncthreads();


            if (linear_tid < RAKING_THREADS)
            {

                T *raking_segment = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);
                partial = ThreadReduce<SEGMENT_LENGTH>(raking_segment, reduction_op, partial);


                partial = WarpReduce(temp_storage.warp_storage).Reduce(partial, reduction_op);
            }
        }

        return partial;
    }

};

}
} } } }
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_reduce_warp_reductions.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/specializations/block_reduce_warp_reductions.cuh"
       







namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {





template <
    typename T,
    int BLOCK_DIM_X,
    int BLOCK_DIM_Y,
    int BLOCK_DIM_Z,
    int PTX_ARCH>
struct BlockReduceWarpReductions
{

    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,


        WARP_THREADS = (1 << (5)),


        WARPS = (BLOCK_THREADS + WARP_THREADS - 1) / WARP_THREADS,


        LOGICAL_WARP_SIZE = (((WARP_THREADS) < (BLOCK_THREADS)) ? (WARP_THREADS) : (BLOCK_THREADS)),


        EVEN_WARP_MULTIPLE = (BLOCK_THREADS % LOGICAL_WARP_SIZE == 0)
    };



    typedef typename WarpReduce<T, LOGICAL_WARP_SIZE, PTX_ARCH>::InternalWarpReduce WarpReduce;



    struct _TempStorage
    {
        typename WarpReduce::TempStorage warp_reduce[WARPS];
        T warp_aggregates[WARPS];
        T block_prefix;
    };


    struct TempStorage : Uninitialized<_TempStorage> {};



    _TempStorage &temp_storage;
    int linear_tid;
    int warp_id;
    int lane_id;



    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockReduceWarpReductions(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)),
        warp_id((WARPS == 1) ? 0 : linear_tid / WARP_THREADS),
        lane_id(LaneId())
    {}


    template <bool FULL_TILE, typename ReductionOp, int SUCCESSOR_WARP>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T ApplyWarpAggregates(
        ReductionOp reduction_op,
        T warp_aggregate,
        int num_valid,
        Int2Type<SUCCESSOR_WARP> successor_warp)
    {
        if (FULL_TILE || (SUCCESSOR_WARP * LOGICAL_WARP_SIZE < num_valid))
        {
            T addend = temp_storage.warp_aggregates[SUCCESSOR_WARP];
            warp_aggregate = reduction_op(warp_aggregate, addend);
        }
        return ApplyWarpAggregates<FULL_TILE>(reduction_op, warp_aggregate, num_valid, Int2Type<SUCCESSOR_WARP + 1>());
    }

    template <bool FULL_TILE, typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T ApplyWarpAggregates(
        ReductionOp reduction_op,
        T warp_aggregate,
        int num_valid,
        Int2Type<WARPS> successor_warp)
    {
        return warp_aggregate;
    }



    template <
        bool FULL_TILE,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T ApplyWarpAggregates(
        ReductionOp reduction_op,
        T warp_aggregate,
        int num_valid)
    {

        if (lane_id == 0)
        {
            temp_storage.warp_aggregates[warp_id] = warp_aggregate;
        }

        __syncthreads();


        if (linear_tid == 0)
        {
            warp_aggregate = ApplyWarpAggregates<FULL_TILE>(reduction_op, warp_aggregate, num_valid, Int2Type<1>());
        }

        return warp_aggregate;
    }



    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Sum(
        T input,
        int num_valid)
    {
        cub_::Sum reduction_op;
        unsigned int warp_offset = warp_id * LOGICAL_WARP_SIZE;
        unsigned int warp_num_valid = (FULL_TILE && EVEN_WARP_MULTIPLE) ?
                            LOGICAL_WARP_SIZE :
                            (warp_offset < num_valid) ?
                                num_valid - warp_offset :
                                0;


        T warp_aggregate = WarpReduce(temp_storage.warp_reduce[warp_id]).template Sum<(FULL_TILE && EVEN_WARP_MULTIPLE), 1>(
            input,
            warp_num_valid);


        return ApplyWarpAggregates<FULL_TILE>(reduction_op, warp_aggregate, num_valid);
    }



    template <
        bool FULL_TILE,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T input,
        int num_valid,
        ReductionOp reduction_op)
    {
        unsigned int warp_offset = warp_id * LOGICAL_WARP_SIZE;
        unsigned int warp_num_valid = (FULL_TILE && EVEN_WARP_MULTIPLE) ?
                            LOGICAL_WARP_SIZE :
                            (warp_offset < num_valid) ?
                                num_valid - warp_offset :
                                0;


        T warp_aggregate = WarpReduce(temp_storage.warp_reduce[warp_id]).template Reduce<(FULL_TILE && EVEN_WARP_MULTIPLE), 1>(
            input,
            warp_num_valid,
            reduction_op);


        return ApplyWarpAggregates<FULL_TILE>(reduction_op, warp_aggregate, num_valid);
    }

};


}
} } } }
# 39 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh" 2






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 60 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
enum BlockReduceAlgorithm
{
# 89 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    BLOCK_REDUCE_RAKING_COMMUTATIVE_ONLY,
# 119 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    BLOCK_REDUCE_RAKING,
# 148 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    BLOCK_REDUCE_WARP_REDUCTIONS,
};
# 214 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
template <
    typename T,
    int BLOCK_DIM_X,
    BlockReduceAlgorithm ALGORITHM = BLOCK_REDUCE_WARP_REDUCTIONS,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockReduce
{
private:






    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };

    typedef BlockReduceWarpReductions<T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> WarpReductions;
    typedef BlockReduceRakingCommutativeOnly<T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> RakingCommutativeOnly;
    typedef BlockReduceRaking<T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> Raking;


    typedef typename If<(ALGORITHM == BLOCK_REDUCE_WARP_REDUCTIONS),
        WarpReductions,
        typename If<(ALGORITHM == BLOCK_REDUCE_RAKING_COMMUTATIVE_ONLY),
            RakingCommutativeOnly,
            Raking>::Type>::Type InternalBlockReduce;


    typedef typename InternalBlockReduce::TempStorage _TempStorage;







    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }







    _TempStorage &temp_storage;


    int linear_tid;


public:


    struct TempStorage : Uninitialized<_TempStorage> {};
# 288 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockReduce()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockReduce(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}
# 347 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    template <typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T input,
        ReductionOp reduction_op)
    {
        return InternalBlockReduce(temp_storage).template Reduce<true>(input, BLOCK_THREADS, reduction_op);
    }
# 392 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    template <
        int ITEMS_PER_THREAD,
        typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T (&inputs)[ITEMS_PER_THREAD],
        ReductionOp reduction_op)
    {

        T partial = ThreadReduce(inputs, reduction_op);
        return Reduce(partial, reduction_op);
    }
# 439 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    template <typename ReductionOp>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Reduce(
        T input,
        ReductionOp reduction_op,
        int num_valid)
    {

        if (num_valid >= BLOCK_THREADS)
        {
            return InternalBlockReduce(temp_storage).template Reduce<true>(input, num_valid, reduction_op);
        }
        else
        {
            return InternalBlockReduce(temp_storage).template Reduce<false>(input, num_valid, reduction_op);
        }
    }
# 497 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Sum(
        T input)
    {
        return InternalBlockReduce(temp_storage).template Sum<true>(input, BLOCK_THREADS);
    }
# 538 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    template <int ITEMS_PER_THREAD>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Sum(
        T (&inputs)[ITEMS_PER_THREAD])
    {

        T partial = ThreadReduce(inputs, cub_::Sum());
        return Sum(partial);
    }
# 582 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_reduce.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) T Sum(
        T input,
        int num_valid)
    {

        if (num_valid >= BLOCK_THREADS)
        {
            return InternalBlockReduce(temp_storage).template Sum<true>(input, num_valid);
        }
        else
        {
            return InternalBlockReduce(temp_storage).template Sum<false>(input, num_valid);
        }
    }



};





}
} } } }
# 45 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
       
# 45 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 70 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename OutputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void StoreDirectBlocked(
    int linear_tid,
    OutputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD])
{

#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        block_itr[(linear_tid * ITEMS_PER_THREAD) + ITEM] = items[ITEM];
    }
}
# 97 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename OutputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void StoreDirectBlocked(
    int linear_tid,
    OutputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD],
    int valid_items)
{

#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        if (ITEM + (linear_tid * ITEMS_PER_THREAD) < valid_items)
        {
            block_itr[(linear_tid * ITEMS_PER_THREAD) + ITEM] = items[ITEM];
        }
    }
}
# 136 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD>
__attribute__((device)) __inline__ __attribute__((always_inline)) void StoreDirectBlockedVectorized(
    int linear_tid,
    T *block_ptr,
    T (&items)[ITEMS_PER_THREAD])
{
    enum
    {

        MAX_VEC_SIZE = (((ITEMS_PER_THREAD) < (4)) ? (ITEMS_PER_THREAD) : (4)),


        VEC_SIZE = ((((MAX_VEC_SIZE - 1) & MAX_VEC_SIZE) == 0) && ((ITEMS_PER_THREAD % MAX_VEC_SIZE) == 0)) ?
            MAX_VEC_SIZE :
            1,

        VECTORS_PER_THREAD = ITEMS_PER_THREAD / VEC_SIZE,
    };


    typedef typename CubVector<T, VEC_SIZE>::Type Vector;


    Vector *block_ptr_vectors = reinterpret_cast<Vector *>(block_ptr);


    Vector raw_vector[VECTORS_PER_THREAD];
    T *raw_items = reinterpret_cast<T*>(raw_vector);


#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        raw_items[ITEM] = items[ITEM];
    }


    StoreDirectBlocked(linear_tid, block_ptr_vectors, raw_vector);
}
# 197 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
template <
    int BLOCK_THREADS,
    typename T,
    int ITEMS_PER_THREAD,
    typename OutputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void StoreDirectStriped(
    int linear_tid,
    OutputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD])
{

#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        block_itr[(ITEM * BLOCK_THREADS) + linear_tid] = items[ITEM];
    }
}
# 226 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
template <
    int BLOCK_THREADS,
    typename T,
    int ITEMS_PER_THREAD,
    typename OutputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void StoreDirectStriped(
    int linear_tid,
    OutputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD],
    int valid_items)
{

#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        if ((ITEM * BLOCK_THREADS) + linear_tid < valid_items)
        {
            block_itr[(ITEM * BLOCK_THREADS) + linear_tid] = items[ITEM];
        }
    }
}
# 269 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename OutputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void StoreDirectWarpStriped(
    int linear_tid,
    OutputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD])
{
    int tid = linear_tid & ((1 << (5)) - 1);
    int wid = linear_tid >> (5);
    int warp_offset = wid * (1 << (5)) * ITEMS_PER_THREAD;


#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        block_itr[warp_offset + tid + (ITEM * (1 << (5)))] = items[ITEM];
    }
}
# 303 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
template <
    typename T,
    int ITEMS_PER_THREAD,
    typename OutputIterator>
__attribute__((device)) __inline__ __attribute__((always_inline)) void StoreDirectWarpStriped(
    int linear_tid,
    OutputIterator block_itr,
    T (&items)[ITEMS_PER_THREAD],
    int valid_items)
{
    int tid = linear_tid & ((1 << (5)) - 1);
    int wid = linear_tid >> (5);
    int warp_offset = wid * (1 << (5)) * ITEMS_PER_THREAD;


#pragma unroll
    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
    {
        if (warp_offset + tid + (ITEM * (1 << (5))) < valid_items)
        {
            block_itr[warp_offset + tid + (ITEM * (1 << (5)))] = items[ITEM];
        }
    }
}
# 342 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
enum BlockStoreAlgorithm
{
# 355 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
    BLOCK_STORE_DIRECT,
# 377 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
    BLOCK_STORE_VECTORIZE,
# 396 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
    BLOCK_STORE_TRANSPOSE,
# 415 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
    BLOCK_STORE_WARP_TRANSPOSE,
};
# 486 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
template <
    typename OutputIterator,
    int BLOCK_DIM_X,
    int ITEMS_PER_THREAD,
    BlockStoreAlgorithm ALGORITHM = BLOCK_STORE_DIRECT,
    bool WARP_TIME_SLICING = false,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockStore
{
private:





    enum
    {

        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
    };


    typedef typename std::iterator_traits<OutputIterator>::value_type T;







    template <BlockStoreAlgorithm _POLICY, int DUMMY>
    struct StoreInternal;





    template <int DUMMY>
    struct StoreInternal<BLOCK_STORE_DIRECT, DUMMY>
    {

        typedef NullType TempStorage;


        int linear_tid;


        __attribute__((device)) __inline__ __attribute__((always_inline)) StoreInternal(
            TempStorage &temp_storage,
            int linear_tid)
        :
            linear_tid(linear_tid)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
            OutputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD])
        {
            StoreDirectBlocked(linear_tid, block_itr, items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
            OutputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items)
        {
            StoreDirectBlocked(linear_tid, block_itr, items, valid_items);
        }
    };





    template <int DUMMY>
    struct StoreInternal<BLOCK_STORE_VECTORIZE, DUMMY>
    {

        typedef NullType TempStorage;


        int linear_tid;


        __attribute__((device)) __inline__ __attribute__((always_inline)) StoreInternal(
            TempStorage &temp_storage,
            int linear_tid)
        :
            linear_tid(linear_tid)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
            T *block_ptr,
            T (&items)[ITEMS_PER_THREAD])
        {
            StoreDirectBlockedVectorized(linear_tid, block_ptr, items);
        }


        template <typename _OutputIterator>
        __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
            _OutputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD])
        {
            StoreDirectBlocked(linear_tid, block_itr, items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
            OutputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items)
        {
            StoreDirectBlocked(linear_tid, block_itr, items, valid_items);
        }
    };





    template <int DUMMY>
    struct StoreInternal<BLOCK_STORE_TRANSPOSE, DUMMY>
    {

        typedef BlockExchange<T, BLOCK_DIM_X, ITEMS_PER_THREAD, WARP_TIME_SLICING, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> BlockExchange;


        typedef typename BlockExchange::TempStorage _TempStorage;


        struct TempStorage : Uninitialized<_TempStorage> {};


        _TempStorage &temp_storage;


        int linear_tid;


        __attribute__((device)) __inline__ __attribute__((always_inline)) StoreInternal(
            TempStorage &temp_storage,
            int linear_tid)
        :
            temp_storage(temp_storage.Alias()),
            linear_tid(linear_tid)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
            OutputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD])
        {
            BlockExchange(temp_storage).BlockedToStriped(items);
            StoreDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
            OutputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items)
        {
            BlockExchange(temp_storage).BlockedToStriped(items);
            StoreDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items, valid_items);
        }
    };





    template <int DUMMY>
    struct StoreInternal<BLOCK_STORE_WARP_TRANSPOSE, DUMMY>
    {
        enum
        {
            WARP_THREADS = (1 << (5))
        };


        typedef int cub_static_assert672[((BLOCK_THREADS % WARP_THREADS == 0)) ? 1 : -1];


        typedef BlockExchange<T, BLOCK_DIM_X, ITEMS_PER_THREAD, WARP_TIME_SLICING, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> BlockExchange;


        typedef typename BlockExchange::TempStorage _TempStorage;


        struct TempStorage : Uninitialized<_TempStorage> {};


        _TempStorage &temp_storage;


        int linear_tid;


        __attribute__((device)) __inline__ __attribute__((always_inline)) StoreInternal(
            TempStorage &temp_storage,
            int linear_tid)
        :
            temp_storage(temp_storage.Alias()),
            linear_tid(linear_tid)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
            OutputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD])
        {
            BlockExchange(temp_storage).BlockedToWarpStriped(items);
            StoreDirectWarpStriped(linear_tid, block_itr, items);
        }


        __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
            OutputIterator block_itr,
            T (&items)[ITEMS_PER_THREAD],
            int valid_items)
        {
            BlockExchange(temp_storage).BlockedToWarpStriped(items);
            StoreDirectWarpStriped(linear_tid, block_itr, items, valid_items);
        }
    };






    typedef StoreInternal<ALGORITHM, 0> InternalStore;



    typedef typename InternalStore::TempStorage _TempStorage;







    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }







    _TempStorage &temp_storage;


    int linear_tid;

public:



    struct TempStorage : Uninitialized<_TempStorage> {};
# 767 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockStore()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockStore(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z))
    {}
# 832 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
        OutputIterator block_itr,
        T (&items)[ITEMS_PER_THREAD])
    {
        InternalStore(temp_storage, linear_tid).Store(block_itr, items);
    }
# 880 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_store.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Store(
        OutputIterator block_itr,
        T (&items)[ITEMS_PER_THREAD],
        int valid_items)
    {
        InternalStore(temp_storage, linear_tid).Store(block_itr, items, valid_items);
    }
};


}
} } } }
# 47 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
       
# 43 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 64 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
template <
    typename T,
    int BLOCK_DIM_X,
    int BLOCK_DIM_Y = 1,
    int BLOCK_DIM_Z = 1,
    int PTX_ARCH = 0>
class BlockShift
{
private:





    enum
    {
        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,

        LOG_WARP_THREADS = (5),
        WARP_THREADS = 1 << LOG_WARP_THREADS,
        WARPS = (BLOCK_THREADS + WARP_THREADS - 1) / WARP_THREADS,
    };






    typedef typename If<(PTX_ARCH >= 300),
        T[WARPS],
        T[BLOCK_THREADS] >::Type _TempStorage;

public:


    struct TempStorage : Uninitialized<_TempStorage> {};

private:







    _TempStorage &temp_storage;


    int linear_tid;
    int lane_id;
    int warp_id;







    __attribute__((device)) __inline__ __attribute__((always_inline)) _TempStorage& PrivateStorage()
    {
        __attribute__((shared)) _TempStorage private_storage;
        return private_storage;
    }


public:
# 139 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockShift()
    :
        temp_storage(PrivateStorage()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)),
        warp_id((WARPS == 1) ? 0 : linear_tid / WARP_THREADS),
        lane_id(LaneId())
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockShift(
        TempStorage &temp_storage)
    :
        temp_storage(temp_storage.Alias()),
        linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)),
        warp_id((WARPS == 1) ? 0 : linear_tid / WARP_THREADS),
        lane_id(LaneId())
    {}
# 174 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Up(
        T input,
        T &output,
        T block_prefix)
    {
# 193 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
        temp_storage[linear_tid] = input;

        __syncthreads();

        output = (linear_tid == 0) ?
            block_prefix :
            temp_storage[linear_tid - 1];

    }
# 210 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Up(
        T input,
        T &output,
        T block_prefix,
        T &block_suffix)
    {
# 231 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
        temp_storage[linear_tid] = input;

        __syncthreads();

        output = (linear_tid == 0) ?
            block_prefix :
            temp_storage[linear_tid - 1];

        block_suffix = temp_storage[BLOCK_THREADS - 1];

    }
# 250 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Down(
        T input,
        T &output,
        T block_suffix)
    {
# 269 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
        temp_storage[linear_tid] = input;

        __syncthreads();

        output = (linear_tid == BLOCK_THREADS - 1) ?
            block_suffix :
            temp_storage[linear_tid + 1];

    }
# 286 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Down(
        T input,
        T &output,
        T block_suffix,
        T &block_prefix)
    {
# 306 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/block/block_shift.cuh"
        temp_storage[linear_tid] = input;

        __syncthreads();

        output = (linear_tid == BLOCK_THREADS - 1) ?
            block_suffix :
            temp_storage[linear_tid + 1];


        block_prefix = temp_storage[0];
    }




};

}
} } } }
# 48 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_gatomic_sweep.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_gatomic_sweep.cuh"
       







namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {






template <
    typename BlockHistogramSweepPolicy,
    int BINS,
    int CHANNELS,
    int ACTIVE_CHANNELS,
    typename InputIterator,
    typename HistoCounter,
    typename Offset>
struct BlockHistogramSweepGlobalAtomic
{





    typedef typename std::iterator_traits<InputIterator>::value_type SampleT;


    enum
    {
        BLOCK_THREADS = BlockHistogramSweepPolicy::BLOCK_THREADS,
        ITEMS_PER_THREAD = BlockHistogramSweepPolicy::ITEMS_PER_THREAD,
        TILE_CHANNEL_ITEMS = BLOCK_THREADS * ITEMS_PER_THREAD,
        TILE_ITEMS = TILE_CHANNEL_ITEMS * CHANNELS,
    };


    typedef NullType TempStorage;







    HistoCounter* (&d_out_histograms)[ACTIVE_CHANNELS];


    InputIterator d_in;
# 100 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_gatomic_sweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockHistogramSweepGlobalAtomic(
        TempStorage &temp_storage,
        InputIterator d_in,
        HistoCounter* (&d_out_histograms)[ACTIVE_CHANNELS])
    :
        d_in(d_in),
        d_out_histograms(d_out_histograms)
    {}





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeTile(
        Offset block_offset,
        int valid_items = TILE_ITEMS)
    {
        if (FULL_TILE)
        {

            SampleT items[ITEMS_PER_THREAD][CHANNELS];

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
#pragma unroll
                for (int CHANNEL = 0; CHANNEL < CHANNELS; ++CHANNEL)
                {
                    if (CHANNEL < ACTIVE_CHANNELS)
                    {
                        items[ITEM][CHANNEL] = d_in[block_offset + (ITEM * BLOCK_THREADS * CHANNELS) + (threadIdx.x * CHANNELS) + CHANNEL];
                    }
                }
            }

            __threadfence_block();

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
#pragma unroll
                for (int CHANNEL = 0; CHANNEL < CHANNELS; ++CHANNEL)
                {
                    if (CHANNEL < ACTIVE_CHANNELS)
                    {
                        atomicAdd(d_out_histograms[CHANNEL] + items[ITEM][CHANNEL], 1);
                    }
                }
            }
        }
        else
        {

            int bounds = valid_items - (threadIdx.x * CHANNELS);

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
            {
#pragma unroll
                for (int CHANNEL = 0; CHANNEL < CHANNELS; ++CHANNEL)
                {
                    if (((ACTIVE_CHANNELS == CHANNELS) || (CHANNEL < ACTIVE_CHANNELS)) && ((ITEM * BLOCK_THREADS * CHANNELS) + CHANNEL < bounds))
                    {
                        SampleT item = d_in[block_offset + (ITEM * BLOCK_THREADS * CHANNELS) + (threadIdx.x * CHANNELS) + CHANNEL];
                        atomicAdd(d_out_histograms[CHANNEL] + item, 1);
                    }
                }
            }

        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void AggregateOutput()
    {}
};


}
} } } }
# 39 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_satomic_sweep.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_satomic_sweep.cuh"
       







namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {





template <
    typename BlockHistogramSweepPolicy,
    int BINS,
    int CHANNELS,
    int ACTIVE_CHANNELS,
    typename InputIterator,
    typename HistoCounter,
    typename Offset>
struct BlockHistogramSweepSharedAtomic
{





    typedef typename std::iterator_traits<InputIterator>::value_type SampleT;


    enum
    {
        BLOCK_THREADS = BlockHistogramSweepPolicy::BLOCK_THREADS,
        ITEMS_PER_THREAD = BlockHistogramSweepPolicy::ITEMS_PER_THREAD,
        TILE_CHANNEL_ITEMS = BLOCK_THREADS * ITEMS_PER_THREAD,
        TILE_ITEMS = TILE_CHANNEL_ITEMS * CHANNELS,
    };


    struct _TempStorage
    {
        HistoCounter histograms[ACTIVE_CHANNELS][BINS + 1];
    };



    struct TempStorage : Uninitialized<_TempStorage> {};







    _TempStorage &temp_storage;


    HistoCounter* (&d_out_histograms)[ACTIVE_CHANNELS];


    InputIterator d_in;
# 109 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_satomic_sweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockHistogramSweepSharedAtomic(
        TempStorage &temp_storage,
        InputIterator d_in,
        HistoCounter* (&d_out_histograms)[ACTIVE_CHANNELS])
    :
        temp_storage(temp_storage.Alias()),
        d_in(d_in),
        d_out_histograms(d_out_histograms)
    {

#pragma unroll
        for (int CHANNEL = 0; CHANNEL < ACTIVE_CHANNELS; ++CHANNEL)
        {
            int histo_offset = 0;

#pragma unroll
            for(; histo_offset + BLOCK_THREADS <= BINS; histo_offset += BLOCK_THREADS)
            {
                this->temp_storage.histograms[CHANNEL][histo_offset + threadIdx.x] = 0;
            }

            if ((BINS % BLOCK_THREADS != 0) && (histo_offset + threadIdx.x < BINS))
            {
                this->temp_storage.histograms[CHANNEL][histo_offset + threadIdx.x] = 0;
            }
        }

        __syncthreads();
    }





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeTile(
        Offset block_offset,
        int valid_items = TILE_ITEMS)
    {
        if (FULL_TILE)
        {

            SampleT items[ITEMS_PER_THREAD][CHANNELS];

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
#pragma unroll
                for (int CHANNEL = 0; CHANNEL < CHANNELS; ++CHANNEL)
                {
                    if (CHANNEL < ACTIVE_CHANNELS)
                    {
                        items[ITEM][CHANNEL] = d_in[block_offset + (ITEM * BLOCK_THREADS * CHANNELS) + (threadIdx.x * CHANNELS) + CHANNEL];
                    }
                }
            }

            __threadfence_block();

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
#pragma unroll
                for (int CHANNEL = 0; CHANNEL < CHANNELS; ++CHANNEL)
                {
                    if (CHANNEL < ACTIVE_CHANNELS)
                    {
                        atomicAdd(temp_storage.histograms[CHANNEL] + items[ITEM][CHANNEL], 1);
                    }
                }
            }

            __threadfence_block();
        }
        else
        {

            int bounds = valid_items - (threadIdx.x * CHANNELS);

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
            {
#pragma unroll
                for (int CHANNEL = 0; CHANNEL < CHANNELS; ++CHANNEL)
                {
                    if (((ACTIVE_CHANNELS == CHANNELS) || (CHANNEL < ACTIVE_CHANNELS)) && ((ITEM * BLOCK_THREADS * CHANNELS) + CHANNEL < bounds))
                    {
                        SampleT item = d_in[block_offset + (ITEM * BLOCK_THREADS * CHANNELS) + (threadIdx.x * CHANNELS) + CHANNEL];
                        atomicAdd(temp_storage.histograms[CHANNEL] + item, 1);
                    }
                }
            }

        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void AggregateOutput()
    {

        __syncthreads();


        int channel_offset = (blockIdx.x * BINS);

#pragma unroll
        for (int CHANNEL = 0; CHANNEL < ACTIVE_CHANNELS; ++CHANNEL)
        {
            int histo_offset = 0;

#pragma unroll
            for(; histo_offset + BLOCK_THREADS <= BINS; histo_offset += BLOCK_THREADS)
            {
                HistoCounter count = temp_storage.histograms[CHANNEL][histo_offset + threadIdx.x];

                d_out_histograms[CHANNEL][channel_offset + histo_offset + threadIdx.x] = count;
            }


            if ((BINS % BLOCK_THREADS != 0) && (histo_offset + threadIdx.x < BINS))
            {
                HistoCounter count = temp_storage.histograms[CHANNEL][histo_offset + threadIdx.x];

                d_out_histograms[CHANNEL][channel_offset + histo_offset + threadIdx.x] = count;
            }
        }
    }
};



}
} } } }
# 40 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_sort_sweep.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_sort_sweep.cuh"
       
# 43 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_sort_sweep.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {





template <
    typename BlockHistogramSweepPolicy,
    int BINS,
    int CHANNELS,
    int ACTIVE_CHANNELS,
    typename InputIterator,
    typename HistoCounter,
    typename Offset>
struct BlockHistogramSweepSort
{





    typedef typename std::iterator_traits<InputIterator>::value_type SampleT;


    enum
    {
        BLOCK_THREADS = BlockHistogramSweepPolicy::BLOCK_THREADS,
        ITEMS_PER_THREAD = BlockHistogramSweepPolicy::ITEMS_PER_THREAD,
        TILE_CHANNEL_ITEMS = BLOCK_THREADS * ITEMS_PER_THREAD,
        TILE_ITEMS = TILE_CHANNEL_ITEMS * CHANNELS,

        STRIPED_COUNTERS_PER_THREAD = (BINS + BLOCK_THREADS - 1) / BLOCK_THREADS,
    };


    typedef BlockRadixSort<SampleT, BLOCK_THREADS, ITEMS_PER_THREAD> BlockRadixSortT;


    typedef BlockDiscontinuity<SampleT, BLOCK_THREADS> BlockDiscontinuityT;


    union _TempStorage
    {

        typename BlockRadixSortT::TempStorage sort;

        struct
        {

            typename BlockDiscontinuityT::TempStorage flag;


            int run_begin[BLOCK_THREADS * STRIPED_COUNTERS_PER_THREAD];
            int run_end[BLOCK_THREADS * STRIPED_COUNTERS_PER_THREAD];
        };
    };



    struct TempStorage : Uninitialized<_TempStorage> {};



    struct DiscontinuityOp
    {

        _TempStorage &temp_storage;


        __attribute__((device)) __inline__ __attribute__((always_inline)) DiscontinuityOp(_TempStorage &temp_storage) :
            temp_storage(temp_storage)
        {}


        __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator()(const SampleT &a, const SampleT &b, int b_index)
        {
            if (a != b)
            {

                temp_storage.run_begin[b] = b_index;
                temp_storage.run_end[a] = b_index;

                return true;
            }
            else
            {
                return false;
            }
        }
    };







    _TempStorage &temp_storage;


    HistoCounter thread_counters[ACTIVE_CHANNELS][STRIPED_COUNTERS_PER_THREAD];


    HistoCounter* (&d_out_histograms)[ACTIVE_CHANNELS];


    InputIterator d_in;
# 162 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/specializations/block_histogram_sort_sweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockHistogramSweepSort(
        TempStorage &temp_storage,
        InputIterator d_in,
        HistoCounter* (&d_out_histograms)[ACTIVE_CHANNELS])
    :
        temp_storage(temp_storage.Alias()),
        d_in(d_in),
        d_out_histograms(d_out_histograms)
    {

#pragma unroll
        for (int CHANNEL = 0; CHANNEL < ACTIVE_CHANNELS; ++CHANNEL)
        {
#pragma unroll
            for (int COUNTER = 0; COUNTER < STRIPED_COUNTERS_PER_THREAD; ++COUNTER)
            {
                thread_counters[CHANNEL][COUNTER] = 0;
            }
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void Composite(
        SampleT (&items)[ITEMS_PER_THREAD],
        HistoCounter thread_counters[STRIPED_COUNTERS_PER_THREAD])
    {

        BlockRadixSortT(temp_storage.sort).Sort(items);

        __syncthreads();


#pragma unroll
        for (int COUNTER = 0; COUNTER < STRIPED_COUNTERS_PER_THREAD; ++COUNTER)
        {
            temp_storage.run_begin[(COUNTER * BLOCK_THREADS) + threadIdx.x] = TILE_CHANNEL_ITEMS;
            temp_storage.run_end[(COUNTER * BLOCK_THREADS) + threadIdx.x] = TILE_CHANNEL_ITEMS;
        }

        __syncthreads();


        int flags[ITEMS_PER_THREAD];
        DiscontinuityOp flag_op(temp_storage);
        BlockDiscontinuityT(temp_storage.flag).FlagHeads(flags, items, flag_op);


        if (threadIdx.x == 0) temp_storage.run_begin[items[0]] = 0;

        __syncthreads();



#pragma unroll
        for (int COUNTER = 0; COUNTER < STRIPED_COUNTERS_PER_THREAD; ++COUNTER)
        {
            int bin = (COUNTER * BLOCK_THREADS) + threadIdx.x;
            HistoCounter run_length = temp_storage.run_end[bin] - temp_storage.run_begin[bin];

            thread_counters[COUNTER] += run_length;
        }
    }





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeTileChannel(
        int channel,
        Offset block_offset,
        int valid_items)
    {

        if (FULL_TILE)
        {

            SampleT items[ITEMS_PER_THREAD];


#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
                items[ITEM] = d_in[channel + block_offset + (ITEM * BLOCK_THREADS * CHANNELS) + (threadIdx.x * CHANNELS)];
            }


            Composite(items, thread_counters[channel]);
        }
        else
        {

            SampleT items[ITEMS_PER_THREAD];


            int bounds = (valid_items - (threadIdx.x * CHANNELS));

#pragma unroll
            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
            {
                items[ITEM] = ((ITEM * BLOCK_THREADS * CHANNELS) < bounds) ?
                    d_in[channel + block_offset + (ITEM * BLOCK_THREADS * CHANNELS) + (threadIdx.x * CHANNELS)] :
                    0;
            }


            Composite(items, thread_counters[channel]);

            __syncthreads();


            if (threadIdx.x == 0)
            {
                int extra = (TILE_ITEMS - valid_items) / CHANNELS;
                thread_counters[channel][0] -= extra;
            }
        }
    }





    template <bool FULL_TILE, int CHANNEL, int END>
    struct IterateChannels
    {



        static __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeTileChannel(
            BlockHistogramSweepSort *cta,
            Offset block_offset,
            int valid_items)
        {
            __syncthreads();

            cta->ConsumeTileChannel<FULL_TILE>(CHANNEL, block_offset, valid_items);

            IterateChannels<FULL_TILE, CHANNEL + 1, END>::ConsumeTileChannel(cta, block_offset, valid_items);
        }
    };





    template <bool FULL_TILE, int END>
    struct IterateChannels<FULL_TILE, END, END>
    {
        static __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeTileChannel(BlockHistogramSweepSort *cta, Offset block_offset, int valid_items) {}
    };





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeTile(
        Offset block_offset,
        int valid_items = TILE_ITEMS)
    {

        ConsumeTileChannel<FULL_TILE>(0, block_offset, valid_items);


        IterateChannels<FULL_TILE, 1, ACTIVE_CHANNELS>::ConsumeTileChannel(this, block_offset, valid_items);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void AggregateOutput()
    {

#pragma unroll
        for (int CHANNEL = 0; CHANNEL < ACTIVE_CHANNELS; ++CHANNEL)
        {
            int channel_offset = (blockIdx.x * BINS);

#pragma unroll
            for (int COUNTER = 0; COUNTER < STRIPED_COUNTERS_PER_THREAD; ++COUNTER)
            {
                int bin = (COUNTER * BLOCK_THREADS) + threadIdx.x;

                if ((STRIPED_COUNTERS_PER_THREAD * BLOCK_THREADS == BINS) || (bin < BINS))
                {
                    d_out_histograms[CHANNEL][channel_offset + bin] = thread_counters[CHANNEL][COUNTER];
                }
            }
        }
    }
};




}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_mapping.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_mapping.cuh"
       




namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 59 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_mapping.cuh"
enum GridMappingStrategy
{
# 74 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_mapping.cuh"
    GRID_MAPPING_EVEN_SHARE,
# 87 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_mapping.cuh"
    GRID_MAPPING_DYNAMIC,
};




}
} } } }
# 43 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_even_share.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_even_share.cuh"
       





namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 70 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_even_share.cuh"
template <typename Offset>
struct GridEvenShare
{
    Offset total_grains;
    int big_blocks;
    Offset big_share;
    Offset normal_share;
    Offset normal_base_offset;


    Offset num_items;


    int grid_size;


    Offset block_offset;


    Offset block_end;




    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) GridEvenShare() :
        num_items(0),
        grid_size(0),
        block_offset(0),
        block_end(0) {}




    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) GridEvenShare(
        Offset num_items,
        int max_grid_size,
        int schedule_granularity)
    {
        this->num_items = num_items;
        this->block_offset = num_items;
        this->block_end = num_items;
        this->total_grains = (num_items + schedule_granularity - 1) / schedule_granularity;
        this->grid_size = (((max_grid_size) < (total_grains)) ? (max_grid_size) : (total_grains));
        Offset grains_per_block = total_grains / grid_size;
        this->big_blocks = total_grains - (grains_per_block * grid_size);
        this->normal_share = grains_per_block * schedule_granularity;
        this->normal_base_offset = big_blocks * schedule_granularity;
        this->big_share = normal_share + schedule_granularity;
    }






    __attribute__((device)) __inline__ __attribute__((always_inline)) void Init(int partition_id)
    {
        if (partition_id < big_blocks)
        {

            block_offset = (partition_id * big_share);
            block_end = block_offset + big_share;
        }
        else if (partition_id < total_grains)
        {

            block_offset = normal_base_offset + (partition_id * normal_share);
            block_end = (((block_offset + normal_share) < (num_items)) ? (block_offset + normal_share) : (num_items));
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void BlockInit()
    {
        Init(blockIdx.x);
    }





    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) void Print()
    {
        printf(





            "num_items(%lu)  "
            "total_grains(%lu)  "
            "big_blocks(%lu)  "
            "big_share(%lu)  "
            "normal_share(%lu)\n",





                (unsigned long) num_items,
                (unsigned long) total_grains,
                (unsigned long) big_blocks,
                (unsigned long) big_share,
                (unsigned long) normal_share);
    }
};





}
} } } }
# 44 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_queue.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_queue.cuh"
       





namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 81 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_queue.cuh"
template <typename Offset>
class GridQueue
{
private:


    enum
    {
        FILL = 0,
        DRAIN = 1,
    };


    Offset *d_counters;

public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static size_t AllocationSize()
    {
        return sizeof(Offset) * 2;
    }



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) GridQueue()
    :
        d_counters(__null)
    {}



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) GridQueue(
        void *d_storage)
    :
        d_counters((Offset*) d_storage)
    {}



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t FillAndResetDrain(
        Offset fill_size,
        cudaStream_t stream = 0)
    {





        Offset counters[2];
        counters[FILL] = fill_size;
        counters[DRAIN] = 0;
        return cub_::Debug((cudaMemcpyAsync(d_counters, counters, sizeof(Offset) * 2, cudaMemcpyHostToDevice, stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_queue.cuh", 134);

    }



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t ResetDrain(cudaStream_t stream = 0)
    {




        return FillAndResetDrain(0, stream);

    }



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t ResetFill()
    {




        return cub_::Debug((cudaMemset(d_counters + FILL, 0, sizeof(Offset))), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_queue.cuh", 158);

    }



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t FillSize(
        Offset &fill_size,
        cudaStream_t stream = 0)
    {




        return cub_::Debug((cudaMemcpyAsync(&fill_size, d_counters + FILL, sizeof(Offset), cudaMemcpyDeviceToHost, stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_queue.cuh", 172);

    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) Offset Drain(Offset num_items)
    {
        return atomicAdd(d_counters + DRAIN, num_items);
    }



    __attribute__((device)) __inline__ __attribute__((always_inline)) Offset Fill(Offset num_items)
    {
        return atomicAdd(d_counters + FILL, num_items);
    }
};
# 198 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_queue.cuh"
template <typename Offset>
__attribute__((global)) void FillAndResetDrainKernel(
    GridQueue<Offset> grid_queue,
    Offset num_items)
{
    grid_queue.FillAndResetDrain(num_items);
}
# 213 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../grid/grid_queue.cuh"
}
} } } }
# 45 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 62 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh"
enum DeviceHistogramAlgorithm
{
# 79 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh"
    DEVICE_HISTO_SORT,
# 100 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh"
    DEVICE_HISTO_SHARED_ATOMIC,
# 117 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh"
    DEVICE_HISTO_GLOBAL_ATOMIC,

};
# 129 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh"
template <
    int _BLOCK_THREADS,
    int _ITEMS_PER_THREAD,
    DeviceHistogramAlgorithm _HISTO_ALGORITHM,
    GridMappingStrategy _GRID_MAPPING>
struct BlockHistogramSweepPolicy
{
    enum
    {
        BLOCK_THREADS = _BLOCK_THREADS,
        ITEMS_PER_THREAD = _ITEMS_PER_THREAD,
    };

    static const DeviceHistogramAlgorithm HISTO_ALGORITHM = _HISTO_ALGORITHM;
    static const GridMappingStrategy GRID_MAPPING = _GRID_MAPPING;
};
# 155 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh"
template <
    typename BlockHistogramSweepPolicy,
    int BINS,
    int CHANNELS,
    int ACTIVE_CHANNELS,
    typename InputIterator,
    typename HistoCounter,
    typename Offset>
struct BlockHistogramSweep
{





    static const DeviceHistogramAlgorithm HISTO_ALGORITHM = BlockHistogramSweepPolicy::HISTO_ALGORITHM;


    typedef BlockHistogramSweepSort< BlockHistogramSweepPolicy, BINS, CHANNELS, ACTIVE_CHANNELS, InputIterator, HistoCounter, Offset> BlockHistogramSweepSortT;
    typedef BlockHistogramSweepSharedAtomic< BlockHistogramSweepPolicy, BINS, CHANNELS, ACTIVE_CHANNELS, InputIterator, HistoCounter, Offset> BlockHistogramSweepSharedAtomicT;
    typedef BlockHistogramSweepGlobalAtomic< BlockHistogramSweepPolicy, BINS, CHANNELS, ACTIVE_CHANNELS, InputIterator, HistoCounter, Offset> BlockHistogramSweepGlobalAtomicT;


    typedef typename If<(HISTO_ALGORITHM == DEVICE_HISTO_SORT),
        BlockHistogramSweepSortT,
        typename If<(HISTO_ALGORITHM == DEVICE_HISTO_SHARED_ATOMIC),
            BlockHistogramSweepSharedAtomicT,
            BlockHistogramSweepGlobalAtomicT>::Type>::Type InternalBlockDelegate;

    enum
    {
        TILE_ITEMS = InternalBlockDelegate::TILE_ITEMS,
    };



    typedef typename InternalBlockDelegate::TempStorage TempStorage;






    InternalBlockDelegate internal_delegate;
# 208 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_histogram_sweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockHistogramSweep(
        TempStorage &temp_storage,
        InputIterator d_in,
        HistoCounter* (&d_out_histograms)[ACTIVE_CHANNELS])
    :
        internal_delegate(temp_storage, d_in, d_out_histograms)
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        Offset block_offset,
        Offset block_end)
    {

        while (block_offset + TILE_ITEMS <= block_end)
        {
            internal_delegate.ConsumeTile<true>(block_offset);
            block_offset += TILE_ITEMS;
        }


        if (block_offset < block_end)
        {
            int valid_items = block_end - block_offset;
            internal_delegate.ConsumeTile<false>(block_offset, valid_items);
        }


        internal_delegate.AggregateOutput();
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        Offset num_items,
        GridEvenShare<Offset> &even_share,
        GridQueue<Offset> &queue,
        Int2Type<GRID_MAPPING_EVEN_SHARE> is_even_share)
    {
        even_share.BlockInit();
        ConsumeRange(even_share.block_offset, even_share.block_end);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        int num_items,
        GridQueue<Offset> queue)
    {

        __attribute__((shared)) Offset shared_block_offset;


        Offset block_offset = blockIdx.x * TILE_ITEMS;
        Offset even_share_base = gridDim.x * TILE_ITEMS;


        while (block_offset + TILE_ITEMS <= num_items)
        {
            internal_delegate.ConsumeTile<true>(block_offset);


            if (threadIdx.x == 0)
                shared_block_offset = queue.Drain(TILE_ITEMS) + even_share_base;

            __syncthreads();

            block_offset = shared_block_offset;

            __syncthreads();
        }


        if (block_offset < num_items)
        {
            int valid_items = num_items - block_offset;
            internal_delegate.ConsumeTile<false>(block_offset, valid_items);
        }


        internal_delegate.AggregateOutput();
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        Offset num_items,
        GridEvenShare<Offset> &even_share,
        GridQueue<Offset> &queue,
        Int2Type<GRID_MAPPING_DYNAMIC> is_dynamic)
    {
        ConsumeRange(num_items, queue);
    }


};




}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh"
       







namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 59 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh"
template <typename T>
__attribute__((global)) void EmptyKernel(void) { }





template <int ALLOCATIONS>
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
cudaError_t AliasTemporaries(
    void *d_temp_storage,
    size_t &temp_storage_bytes,
    void* (&allocations)[ALLOCATIONS],
    size_t (&allocation_sizes)[ALLOCATIONS])
{
    const int ALIGN_BYTES = 256;
    const int ALIGN_MASK = ~(ALIGN_BYTES - 1);


    size_t allocation_offsets[ALLOCATIONS];
    size_t bytes_needed = 0;
    for (int i = 0; i < ALLOCATIONS; ++i)
    {
        size_t allocation_bytes = (allocation_sizes[i] + ALIGN_BYTES - 1) & ALIGN_MASK;
        allocation_offsets[i] = bytes_needed;
        bytes_needed += allocation_bytes;
    }


    if (!d_temp_storage)
    {
        temp_storage_bytes = bytes_needed;
        return cudaSuccess;
    }


    if (temp_storage_bytes < bytes_needed)
    {
        return cub_::Debug((cudaErrorInvalidValue), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh", 97);
    }


    for (int i = 0; i < ALLOCATIONS; ++i)
    {
        allocations[i] = static_cast<char*>(d_temp_storage) + allocation_offsets[i];
    }

    return cudaSuccess;
}
# 118 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh"
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t PtxVersion(int &ptx_version)
{
    struct Dummy
    {

        typedef void (*EmptyKernelPtr)();


        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        EmptyKernelPtr Empty()
        {
            return EmptyKernel<void>;
        }
    };
# 146 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh"
    cudaError_t error = cudaSuccess;
    do
    {
        cudaFuncAttributes empty_kernel_attrs;
        if (cub_::Debug((error = cudaFuncGetAttributes(&empty_kernel_attrs, EmptyKernel<void>)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh", 150)) break;
        ptx_version = empty_kernel_attrs.ptxVersion * 10;
    }
    while (0);

    return error;


}





__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t SmVersion(int &sm_version, int device_ordinal)
{







    cudaError_t error = cudaSuccess;
    do
    {

        int major, minor;
        if (cub_::Debug((error = cudaDeviceGetAttribute(&major, cudaDevAttrComputeCapabilityMajor, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh", 178)) break;
        if (cub_::Debug((error = cudaDeviceGetAttribute(&minor, cudaDevAttrComputeCapabilityMinor, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh", 179)) break;
        sm_version = major * 100 + minor * 10;
    }
    while (0);

    return error;


}







__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
static cudaError_t SyncStream(cudaStream_t stream)
{

    return cudaStreamSynchronize(stream);




}





template <typename KernelPtr>
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
cudaError_t MaxSmOccupancy(
    int &max_sm_occupancy,
    int sm_version,
    KernelPtr kernel_ptr,
    int block_threads)
{







    cudaError_t error = cudaSuccess;
    do
    {
        int warp_threads = 1 << (5);
        int max_sm_blocks = ((sm_version >= 300) ? (16) : (8));
        int max_sm_warps = ((sm_version >= 300) ? (2048) : ((sm_version >= 200) ? (1536) : ((sm_version >= 120) ? (1024) : (768)))) / warp_threads;
        int regs_by_block = ((sm_version >= 200) ? (false) : (true));
        int max_sm_registers = ((sm_version >= 300) ? (64 * 1024) : ((sm_version >= 200) ? (32 * 1024) : ((sm_version >= 120) ? (16 * 1024) : (8 * 1024))));
        int warp_alloc_unit = ((sm_version >= 300) ? (4) : (2));
        int smem_alloc_unit = ((sm_version >= 300) ? (256) : ((sm_version >= 200) ? (128) : (512)));
        int reg_alloc_unit = ((sm_version >= 300) ? (256) : ((sm_version >= 200) ? (64) : ((sm_version >= 120) ? (512) : (256))));
        int smem_bytes = ((sm_version >= 200) ? (48 * 1024) : (16 * 1024));


        cudaFuncAttributes kernel_attrs;
        if (cub_::Debug((error = cudaFuncGetAttributes(&kernel_attrs, kernel_ptr)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh", 240)) break;


        int block_warps = (block_threads + warp_threads - 1) / warp_threads;


        int max_warp_occupancy = (block_warps > 0) ?
            max_sm_warps / block_warps :
            max_sm_blocks;


        int max_reg_occupancy;
        if ((block_threads == 0) || (kernel_attrs.numRegs == 0))
        {

            max_reg_occupancy = max_sm_blocks;
        }
        else if (regs_by_block)
        {

            int block_regs = ((((kernel_attrs.numRegs * warp_threads * block_warps) + (reg_alloc_unit) - 1) / (reg_alloc_unit)) * reg_alloc_unit);
            max_reg_occupancy = max_sm_registers / block_regs;
        }
        else
        {

            int sm_sides = warp_alloc_unit;
            int sm_registers_per_side = max_sm_registers / sm_sides;
            int regs_per_warp = ((((kernel_attrs.numRegs * warp_threads) + (reg_alloc_unit) - 1) / (reg_alloc_unit)) * reg_alloc_unit);
            int warps_per_side = sm_registers_per_side / regs_per_warp;
            int warps = warps_per_side * sm_sides;
            max_reg_occupancy = warps / block_warps;
        }


        int block_allocated_smem = (((((int) kernel_attrs.sharedSizeBytes) + (smem_alloc_unit) - 1) / (smem_alloc_unit)) * smem_alloc_unit)

                            ;


        int max_smem_occupancy = (block_allocated_smem > 0) ?
            (smem_bytes / block_allocated_smem) :
            max_sm_blocks;


        max_sm_occupancy = ((((((max_reg_occupancy) < (max_smem_occupancy)) ? (max_reg_occupancy) : (max_smem_occupancy))) < ((((max_warp_occupancy) < (max_sm_blocks)) ? (max_warp_occupancy) : (max_sm_blocks)))) ? ((((max_reg_occupancy) < (max_smem_occupancy)) ? (max_reg_occupancy) : (max_smem_occupancy))) : ((((max_warp_occupancy) < (max_sm_blocks)) ? (max_warp_occupancy) : (max_sm_blocks))))

                                                           ;



    } while (0);

    return error;


}
# 332 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh"
template <typename KernelPtr>
__attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
cudaError_t MaxSmOccupancy(
    int &max_sm_occupancy,
    KernelPtr kernel_ptr,
    int block_threads)
{







    cudaError_t error = cudaSuccess;
    do
    {

        int device_ordinal;
        if (cub_::Debug((error = cudaGetDevice(&device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh", 351)) break;


        int sm_version;
        if (cub_::Debug((error = SmVersion(sm_version, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh", 355)) break;


        if (cub_::Debug((error = MaxSmOccupancy(max_sm_occupancy, sm_version, kernel_ptr, block_threads)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../util_device.cuh", 358)) break;

    } while (0);

    return error;



}




}
} } } }
# 45 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 60 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
template <
    int BINS,
    int ACTIVE_CHANNELS,
    typename Offset,
    typename HistoCounter>
__attribute__((launch_bounds(BINS, 1)))
__attribute__((global)) void DeviceHistogramInitKernel(
    GridQueue<Offset> grid_queue,
    ArrayWrapper<HistoCounter*, ACTIVE_CHANNELS> d_out_histograms,
    Offset num_samples)
{
    d_out_histograms.array[blockIdx.x][threadIdx.x] = 0;
    if (threadIdx.x == 0) grid_queue.FillAndResetDrain(num_samples);
}





template <
    typename BlockHistogramSweepPolicy,
    int BINS,
    int CHANNELS,
    int ACTIVE_CHANNELS,
    typename InputIterator,
    typename HistoCounter,
    typename Offset>
__attribute__((launch_bounds(int(BlockHistogramSweepPolicy::BLOCK_THREADS))))
__attribute__((global)) void DeviceHistogramSweepKernel(
    InputIterator d_samples,
    ArrayWrapper<HistoCounter*, ACTIVE_CHANNELS> d_out_histograms,
    Offset num_samples,
    GridEvenShare<Offset> even_share,
    GridQueue<Offset> queue)
{

    enum
    {
        BLOCK_THREADS = BlockHistogramSweepPolicy::BLOCK_THREADS,
        ITEMS_PER_THREAD = BlockHistogramSweepPolicy::ITEMS_PER_THREAD,
        TILE_SIZE = BLOCK_THREADS * ITEMS_PER_THREAD,
    };


    typedef BlockHistogramSweep<BlockHistogramSweepPolicy, BINS, CHANNELS, ACTIVE_CHANNELS, InputIterator, HistoCounter, Offset> BlockHistogramSweepT;


    __attribute__((shared)) typename BlockHistogramSweepT::TempStorage temp_storage;


    BlockHistogramSweepT(temp_storage, d_samples, d_out_histograms.array).ConsumeRange(
        num_samples,
        even_share,
        queue,
        Int2Type<BlockHistogramSweepPolicy::GRID_MAPPING>());
}





template <
    int BINS,
    int ACTIVE_CHANNELS,
    typename HistoCounter>
__attribute__((launch_bounds(BINS, 1)))
__attribute__((global)) void DeviceHistogramAggregateKernel(
    HistoCounter* d_block_histograms,
    ArrayWrapper<HistoCounter*, ACTIVE_CHANNELS> d_out_histograms,
    int num_threadblocks)
{

    HistoCounter bin_aggregate = 0;

    int block_offset = blockIdx.x * (num_threadblocks * BINS);
    int block_end = block_offset + (num_threadblocks * BINS);




    while (block_offset < block_end)
    {
        HistoCounter block_bin_count = d_block_histograms[block_offset + threadIdx.x];

        bin_aggregate += block_bin_count;
        block_offset += BINS;
    }


    d_out_histograms.array[blockIdx.x][threadIdx.x] = bin_aggregate;
}
# 161 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
template <
    DeviceHistogramAlgorithm HISTO_ALGORITHM,
    int BINS,
    int CHANNELS,
    int ACTIVE_CHANNELS,
    typename InputIterator,
    typename HistoCounter,
    typename Offset>
struct DeviceHistogramDispatch
{





    struct Policy350
    {

        typedef BlockHistogramSweepPolicy<
                (HISTO_ALGORITHM == DEVICE_HISTO_SORT) ? 128 : 256,
                (HISTO_ALGORITHM == DEVICE_HISTO_SORT) ? 12 : (30 / ACTIVE_CHANNELS),
                HISTO_ALGORITHM,
                (HISTO_ALGORITHM == DEVICE_HISTO_SORT) ? GRID_MAPPING_DYNAMIC : GRID_MAPPING_EVEN_SHARE>
            RangeHistoPolicy;
    };


    struct Policy300
    {

        typedef BlockHistogramSweepPolicy<
                128,
                (HISTO_ALGORITHM == DEVICE_HISTO_SORT) ? 20 : (22 / ACTIVE_CHANNELS),
                HISTO_ALGORITHM,
                (HISTO_ALGORITHM == DEVICE_HISTO_SORT) ? GRID_MAPPING_DYNAMIC : GRID_MAPPING_EVEN_SHARE>
            RangeHistoPolicy;
    };


    struct Policy200
    {

        typedef BlockHistogramSweepPolicy<
                128,
                (HISTO_ALGORITHM == DEVICE_HISTO_SORT) ? 21 : (23 / ACTIVE_CHANNELS),
                HISTO_ALGORITHM,
                GRID_MAPPING_DYNAMIC>
            RangeHistoPolicy;
    };


    struct Policy100
    {

        typedef BlockHistogramSweepPolicy<
                128,
                7,
                DEVICE_HISTO_SORT,
                GRID_MAPPING_EVEN_SHARE>
            RangeHistoPolicy;
    };
# 238 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
    typedef Policy100 PtxPolicy;




    struct PtxRangeHistoPolicy : PtxPolicy::RangeHistoPolicy {};
# 253 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
    template <typename KernelConfig>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static void InitConfigs(
        int ptx_version,
        KernelConfig &device_histogram_sweep_config)
    {
# 267 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
        if (ptx_version >= 350)
        {
            device_histogram_sweep_config.template Init<typename Policy350::RangeHistoPolicy>();
        }
        else if (ptx_version >= 300)
        {
            device_histogram_sweep_config.template Init<typename Policy300::RangeHistoPolicy>();
        }
        else if (ptx_version >= 200)
        {
            device_histogram_sweep_config.template Init<typename Policy200::RangeHistoPolicy>();
        }
        else
        {
            device_histogram_sweep_config.template Init<typename Policy100::RangeHistoPolicy>();
        }


    }





    struct KernelConfig
    {
        int block_threads;
        int items_per_thread;
        DeviceHistogramAlgorithm block_algorithm;
        GridMappingStrategy grid_mapping;

        template <typename BlockPolicy>
        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Init()
        {
            block_threads = BlockPolicy::BLOCK_THREADS;
            items_per_thread = BlockPolicy::ITEMS_PER_THREAD;
            block_algorithm = BlockPolicy::HISTO_ALGORITHM;
            grid_mapping = BlockPolicy::GRID_MAPPING;
        }

        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Print()
        {
            printf("%d, %d, %d, %d", block_threads, items_per_thread, block_algorithm, grid_mapping);
        }

    };
# 325 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
    template <
        typename InitHistoKernelPtr,
        typename DeviceHistogramSweepKernelPtr,
        typename SingleHistogramPartialsKernelPtr>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_samples,
        HistoCounter *d_histograms[ACTIVE_CHANNELS],
        Offset num_samples,
        cudaStream_t stream,
        bool debug_synchronous,
        InitHistoKernelPtr init_kernel,
        DeviceHistogramSweepKernelPtr device_histogram_sweep_kernel,
        SingleHistogramPartialsKernelPtr single_histogram_partials_kernel,
        KernelConfig device_histogram_sweep_config)
    {







        cudaError error = cudaSuccess;
        do
        {

            int device_ordinal;
            if (cub_::Debug((error = cudaGetDevice(&device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 355)) break;


            int sm_version;
            if (cub_::Debug((error = SmVersion(sm_version, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 359)) break;


            int sm_count;
            if (cub_::Debug((error = cudaDeviceGetAttribute (&sm_count, cudaDevAttrMultiProcessorCount, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 363)) break;


            int histo_range_sm_occupancy;
            if (cub_::Debug((error = MaxSmOccupancy( histo_range_sm_occupancy, sm_version, device_histogram_sweep_kernel, device_histogram_sweep_config.block_threads)),



 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
# 367 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
                ,



 371
# 367 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
                )



                                                             ) break;


            int histo_range_occupancy = histo_range_sm_occupancy * sm_count;


            int channel_tile_size = device_histogram_sweep_config.block_threads * device_histogram_sweep_config.items_per_thread;
            int tile_size = channel_tile_size * CHANNELS;


            int subscription_factor = histo_range_sm_occupancy;
            GridEvenShare<Offset> even_share(
                num_samples,
                histo_range_occupancy * subscription_factor,
                tile_size);


            int histo_range_grid_size;
            switch (device_histogram_sweep_config.grid_mapping)
            {
            case GRID_MAPPING_EVEN_SHARE:


                histo_range_grid_size = even_share.grid_size;
                break;

            case GRID_MAPPING_DYNAMIC:


                int num_tiles = (num_samples + tile_size - 1) / tile_size;
                histo_range_grid_size = (num_tiles < histo_range_occupancy) ?
                    num_tiles :
                    histo_range_occupancy;
                break;
            };


            void* allocations[2];
            size_t allocation_sizes[2] =
            {
                ACTIVE_CHANNELS * histo_range_grid_size * sizeof(HistoCounter) * BINS,
                GridQueue<int>::AllocationSize()
            };


            if (cub_::Debug((error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 416)) break;
            if (d_temp_storage == __null)
            {

                return cudaSuccess;
            }


            HistoCounter *d_block_histograms = (HistoCounter*) allocations[0];


            GridQueue<Offset> queue(allocations[1]);


            ArrayWrapper<HistoCounter*, ACTIVE_CHANNELS> d_histo_wrapper;
            for (int CHANNEL = 0; CHANNEL < ACTIVE_CHANNELS; ++CHANNEL)
                d_histo_wrapper.array[CHANNEL] = d_histograms[CHANNEL];


            ArrayWrapper<HistoCounter*, ACTIVE_CHANNELS> d_temp_histo_wrapper;
            for (int CHANNEL = 0; CHANNEL < ACTIVE_CHANNELS; ++CHANNEL)
                d_temp_histo_wrapper.array[CHANNEL] = d_block_histograms + (CHANNEL * histo_range_grid_size * BINS);


            if (debug_synchronous) printf("Invoking init_kernel<<<%d, %d, 0, %lld>>>()\n",ACTIVE_CHANNELS, BINS, (long long) stream);;


            init_kernel<<<ACTIVE_CHANNELS, BINS, 0, stream>>>(queue, d_histo_wrapper, num_samples);


            if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 446)) break;


            if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 449))) break;


            bool privatized_temporaries = (histo_range_grid_size > 1) && (device_histogram_sweep_config.block_algorithm != DEVICE_HISTO_GLOBAL_ATOMIC);


            if (debug_synchronous) printf("Invoking device_histogram_sweep_kernel<<<%d, %d, 0, %lld>>>(), %d items per thread, %d SM occupancy\n",histo_range_grid_size, device_histogram_sweep_config.block_threads, (long long) stream, device_histogram_sweep_config.items_per_thread, histo_range_sm_occupancy);
                                                                                                                                                                                 ;


            device_histogram_sweep_kernel<<<histo_range_grid_size, device_histogram_sweep_config.block_threads, 0, stream>>>(
                d_samples,
                (privatized_temporaries) ?
                    d_temp_histo_wrapper :
                    d_histo_wrapper,
                num_samples,
                even_share,
                queue);


            if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 469)) break;


            if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 472))) break;


            if (privatized_temporaries)
            {

                if (debug_synchronous) printf("Invoking single_histogram_partials_kernel<<<%d, %d, 0, %lld>>>()\n",ACTIVE_CHANNELS, BINS, (long long) stream);
                                                              ;


                single_histogram_partials_kernel<<<ACTIVE_CHANNELS, BINS, 0, stream>>>(
                    d_block_histograms,
                    d_histo_wrapper,
                    histo_range_grid_size);


                if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 488)) break;


                if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 491))) break;
            }
        }
        while (0);

        return error;


    }





    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_samples,
        HistoCounter *d_histograms[ACTIVE_CHANNELS],
        int num_samples,
        cudaStream_t stream,
        bool debug_synchronous)
    {
        cudaError error = cudaSuccess;
        do
        {

            int ptx_version;

            if (cub_::Debug((error = PtxVersion(ptx_version)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh", 521)) break;





            KernelConfig device_histogram_sweep_config;
            InitConfigs(ptx_version, device_histogram_sweep_config);


            if (cub_::Debug((error = Dispatch( d_temp_storage, temp_storage_bytes, d_samples, d_histograms, num_samples, stream, debug_synchronous, DeviceHistogramInitKernel<BINS, ACTIVE_CHANNELS, Offset, HistoCounter>, DeviceHistogramSweepKernel<PtxRangeHistoPolicy, BINS, CHANNELS, ACTIVE_CHANNELS, InputIterator, HistoCounter, Offset>, DeviceHistogramAggregateKernel<BINS, ACTIVE_CHANNELS, HistoCounter>, device_histogram_sweep_config)),
# 542 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
# 531 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
                ,
# 542 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
 542
# 531 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
                )
# 542 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_histogram_dispatch.cuh"
                                               ) break;
        }
        while (0);

        return error;
    }
};


}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 66 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh"
struct DeviceHistogram
{
# 124 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh"
    template <
        int BINS,
        typename InputIterator,
        typename HistoCounter>
    __attribute__((host)) __attribute__((device))
    static cudaError_t SingleChannelSorting(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_samples,
        HistoCounter* d_histogram,
        int num_samples,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceHistogramDispatch<
                DEVICE_HISTO_SORT,
                BINS,
                1,
                1,
                InputIterator,
                HistoCounter,
                Offset>
            DeviceHistogramDispatch;

        return DeviceHistogramDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_samples,
            &d_histogram,
            num_samples,
            stream,
            debug_synchronous);
    }
# 212 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh"
    template <
        int BINS,
        typename InputIterator,
        typename HistoCounter>
    __attribute__((host)) __attribute__((device))
    static cudaError_t SingleChannelSharedAtomic(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_samples,
        HistoCounter* d_histogram,
        int num_samples,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceHistogramDispatch<
                DEVICE_HISTO_SHARED_ATOMIC,
                BINS,
                1,
                1,
                InputIterator,
                HistoCounter,
                Offset>
            DeviceHistogramDispatch;

        return DeviceHistogramDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_samples,
            &d_histogram,
            num_samples,
            stream,
            debug_synchronous);
    }
# 300 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh"
    template <
        int BINS,
        typename InputIterator,
        typename HistoCounter>
    __attribute__((host)) __attribute__((device))
    static cudaError_t SingleChannelGlobalAtomic(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_samples,
        HistoCounter* d_histogram,
        int num_samples,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceHistogramDispatch<
                DEVICE_HISTO_GLOBAL_ATOMIC,
                BINS,
                1,
                1,
                InputIterator,
                HistoCounter,
                Offset>
            DeviceHistogramDispatch;

        return DeviceHistogramDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_samples,
            &d_histogram,
            num_samples,
            stream,
            debug_synchronous);
    }
# 405 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh"
    template <
        int BINS,
        int CHANNELS,
        int ACTIVE_CHANNELS,
        typename InputIterator,
        typename HistoCounter>
    __attribute__((host)) __attribute__((device))
    static cudaError_t MultiChannelSorting(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_samples,
        HistoCounter *d_histograms[ACTIVE_CHANNELS],
        int num_samples,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceHistogramDispatch<
            DEVICE_HISTO_SORT,
            BINS,
            CHANNELS,
            ACTIVE_CHANNELS,
            InputIterator,
            HistoCounter,
            Offset> DeviceHistogramDispatch;

        return DeviceHistogramDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_samples,
            d_histograms,
            num_samples,
            stream,
            debug_synchronous);
    }
# 503 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh"
    template <
        int BINS,
        int CHANNELS,
        int ACTIVE_CHANNELS,
        typename InputIterator,
        typename HistoCounter>
    __attribute__((host)) __attribute__((device))
    static cudaError_t MultiChannelSharedAtomic(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_samples,
        HistoCounter *d_histograms[ACTIVE_CHANNELS],
        int num_samples,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceHistogramDispatch<
            DEVICE_HISTO_SHARED_ATOMIC,
            BINS,
            CHANNELS,
            ACTIVE_CHANNELS,
            InputIterator,
            HistoCounter,
            Offset> DeviceHistogramDispatch;

        return DeviceHistogramDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_samples,
            d_histograms,
            num_samples,
            stream,
            debug_synchronous);
    }
# 602 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_histogram.cuh"
    template <
        int BINS,
        int CHANNELS,
        int ACTIVE_CHANNELS,
        typename InputIterator,
        typename HistoCounter>
    __attribute__((host)) __attribute__((device))
    static cudaError_t MultiChannelGlobalAtomic(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_samples,
        HistoCounter *d_histograms[ACTIVE_CHANNELS],
        int num_samples,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceHistogramDispatch<
                DEVICE_HISTO_GLOBAL_ATOMIC,
                BINS,
                CHANNELS,
                ACTIVE_CHANNELS,
                InputIterator,
                HistoCounter,
                Offset>
            DeviceHistogramDispatch;

        return DeviceHistogramDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_samples,
            d_histograms,
            num_samples,
            stream,
            debug_synchronous);
    }



};





}
} } } }
# 51 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_partition.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_partition.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh"
       



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_prefix_operators.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_prefix_operators.cuh"
       
# 46 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_prefix_operators.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 62 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_prefix_operators.cuh"
template <
    typename T,
    typename ScanOp>
struct BlockScanRunningPrefixOp
{
    ScanOp op;
    T running_total;


    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockScanRunningPrefixOp(ScanOp op)
    :
        op(op)
    {}


    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockScanRunningPrefixOp(
        T starting_prefix,
        ScanOp op)
    :
        op(op),
        running_total(starting_prefix)
    {}




    __attribute__((device)) __inline__ __attribute__((always_inline)) T operator()(
        const T &block_aggregate)
    {
        T retval = running_total;
        running_total = op(running_total, block_aggregate);
        return retval;
    }
};
# 105 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_prefix_operators.cuh"
enum ScanTileStatus
{
    SCAN_TILE_OOB,
    SCAN_TILE_INVALID,
    SCAN_TILE_PARTIAL,
    SCAN_TILE_INCLUSIVE,
};





template <
    typename T,
    bool SINGLE_WORD = Traits<T>::PRIMITIVE>
struct ScanTileState;







template <typename T>
struct ScanTileState<T, true>
{

    typedef typename If<(sizeof(T) == 8),
        long long,
        typename If<(sizeof(T) == 4),
            int,
            typename If<(sizeof(T) == 2),
                short,
                char>::Type>::Type>::Type StatusWord;



    typedef typename If<(sizeof(T) == 8),
        longlong2,
        typename If<(sizeof(T) == 4),
            int2,
            typename If<(sizeof(T) == 2),
                int,
                uchar2>::Type>::Type>::Type TxnWord;



    struct TileDescriptor
    {
        StatusWord status;
        T value;
    };



    enum
    {
        TILE_STATUS_PADDING = (1 << (5)),
    };



    TileDescriptor *d_tile_status;



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    ScanTileState()
    :
        d_tile_status(__null)
    {}



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    cudaError_t Init(
        int num_tiles,
        void *d_temp_storage,
        size_t temp_storage_bytes)
    {
        d_tile_status = reinterpret_cast<TileDescriptor*>(d_temp_storage);
        return cudaSuccess;
    }





    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t AllocationSize(
        int num_tiles,
        size_t &temp_storage_bytes)
    {
        temp_storage_bytes = (num_tiles + TILE_STATUS_PADDING) * sizeof(TileDescriptor);
        return cudaSuccess;
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void InitializeStatus(int num_tiles)
    {
        int tile_idx = (blockIdx.x * blockDim.x) + threadIdx.x;
        if (tile_idx < num_tiles)
        {

            d_tile_status[TILE_STATUS_PADDING + tile_idx].status = StatusWord(SCAN_TILE_INVALID);
        }

        if ((blockIdx.x == 0) && (threadIdx.x < TILE_STATUS_PADDING))
        {

            d_tile_status[threadIdx.x].status = StatusWord(SCAN_TILE_OOB);
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void SetInclusive(int tile_idx, T tile_inclusive)
    {
        TileDescriptor tile_descriptor;
        tile_descriptor.status = SCAN_TILE_INCLUSIVE;
        tile_descriptor.value = tile_inclusive;

        TxnWord alias;
        *reinterpret_cast<TileDescriptor*>(&alias) = tile_descriptor;
        ThreadStore<STORE_CG>(reinterpret_cast<TxnWord*>(d_tile_status + TILE_STATUS_PADDING + tile_idx), alias);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void SetPartial(int tile_idx, T tile_partial)
    {
        TileDescriptor tile_descriptor;
        tile_descriptor.status = SCAN_TILE_PARTIAL;
        tile_descriptor.value = tile_partial;

        TxnWord alias;
        *reinterpret_cast<TileDescriptor*>(&alias) = tile_descriptor;
        ThreadStore<STORE_CG>(reinterpret_cast<TxnWord*>(d_tile_status + TILE_STATUS_PADDING + tile_idx), alias);
    }




    __attribute__((device)) __inline__ __attribute__((always_inline)) void WaitForValid(
        int tile_idx,
        StatusWord &status,
        T &value)
    {

        TxnWord alias = ThreadLoad<LOAD_CG>(reinterpret_cast<TxnWord*>(d_tile_status + TILE_STATUS_PADDING + tile_idx));
        TileDescriptor tile_descriptor = reinterpret_cast<TileDescriptor&>(alias);

        while ((tile_descriptor.status == SCAN_TILE_INVALID))
        {
            alias = ThreadLoad<LOAD_CG>(reinterpret_cast<TxnWord*>(d_tile_status + TILE_STATUS_PADDING + tile_idx));
            tile_descriptor = reinterpret_cast<TileDescriptor&>(alias);
        }

        status = tile_descriptor.status;
        value = tile_descriptor.value;
    }

};







template <typename T>
struct ScanTileState<T, false>
{

    typedef char StatusWord;


    enum
    {
        TILE_STATUS_PADDING = (1 << (5)),
    };


    StatusWord *d_tile_status;
    T *d_tile_partial;
    T *d_tile_inclusive;


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    ScanTileState()
    :
        d_tile_status(__null),
        d_tile_partial(__null),
        d_tile_inclusive(__null)
    {}



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    cudaError_t Init(
        int num_tiles,
        void *d_temp_storage,
        size_t temp_storage_bytes)
    {
        cudaError_t error = cudaSuccess;
        do
        {
            void* allocations[3];
            size_t allocation_sizes[3];

            allocation_sizes[0] = (num_tiles + TILE_STATUS_PADDING) * sizeof(StatusWord);
            allocation_sizes[1] = (num_tiles + TILE_STATUS_PADDING) * sizeof(Uninitialized<T>);
            allocation_sizes[2] = (num_tiles + TILE_STATUS_PADDING) * sizeof(Uninitialized<T>);


            if (cub_::Debug((error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_prefix_operators.cuh", 327)) break;


            d_tile_status = reinterpret_cast<StatusWord*>(allocations[0]);
            d_tile_partial = reinterpret_cast<T*>(allocations[1]);
            d_tile_inclusive = reinterpret_cast<T*>(allocations[2]);
        }
        while (0);

        return error;
    }





    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t AllocationSize(
        int num_tiles,
        size_t &temp_storage_bytes)
    {

        size_t allocation_sizes[3];
        allocation_sizes[0] = (num_tiles + TILE_STATUS_PADDING) * sizeof(StatusWord);
        allocation_sizes[1] = (num_tiles + TILE_STATUS_PADDING) * sizeof(Uninitialized<T>);
        allocation_sizes[2] = (num_tiles + TILE_STATUS_PADDING) * sizeof(Uninitialized<T>);


        void* allocations[3];
        return cub_::Debug((AliasTemporaries(__null, temp_storage_bytes, allocations, allocation_sizes)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_prefix_operators.cuh", 356);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void InitializeStatus(int num_tiles)
    {
        int tile_idx = (blockIdx.x * blockDim.x) + threadIdx.x;
        if (tile_idx < num_tiles)
        {

            d_tile_status[TILE_STATUS_PADDING + tile_idx] = StatusWord(SCAN_TILE_INVALID);
        }

        if ((blockIdx.x == 0) && (threadIdx.x < TILE_STATUS_PADDING))
        {

            d_tile_status[threadIdx.x] = StatusWord(SCAN_TILE_OOB);
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void SetInclusive(int tile_idx, T tile_inclusive)
    {

        ThreadStore<STORE_CG>(d_tile_inclusive + TILE_STATUS_PADDING + tile_idx, tile_inclusive);


        __threadfence();


        ThreadStore<STORE_CG>(d_tile_status + TILE_STATUS_PADDING + tile_idx, StatusWord(SCAN_TILE_INCLUSIVE));
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void SetPartial(int tile_idx, T tile_partial)
    {

        ThreadStore<STORE_CG>(d_tile_partial + TILE_STATUS_PADDING + tile_idx, tile_partial);


        __threadfence();


        ThreadStore<STORE_CG>(d_tile_status + TILE_STATUS_PADDING + tile_idx, StatusWord(SCAN_TILE_PARTIAL));
    }




    __attribute__((device)) __inline__ __attribute__((always_inline)) void WaitForValid(
        int tile_idx,
        StatusWord &status,
        T &value)
    {
        status = ThreadLoad<LOAD_CG>(d_tile_status + TILE_STATUS_PADDING + tile_idx);
        while (status == SCAN_TILE_INVALID)
        {
            status = ThreadLoad<LOAD_CG>(d_tile_status + TILE_STATUS_PADDING + tile_idx);
        }

        T partial = ThreadLoad<LOAD_CG>(d_tile_partial + TILE_STATUS_PADDING + tile_idx);
        T inclusive = ThreadLoad<LOAD_CG>(d_tile_inclusive + TILE_STATUS_PADDING + tile_idx);

        value = (status == StatusWord(SCAN_TILE_PARTIAL)) ?
            partial :
            inclusive;

    }
};
# 444 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_prefix_operators.cuh"
template <
    typename Value,
    typename Offset,
    bool SINGLE_WORD = (Traits<Value>::PRIMITIVE) && (sizeof(Value) + sizeof(Offset) < 16)>
struct ReduceByKeyScanTileState;






template <
    typename Value,
    typename Offset>
struct ReduceByKeyScanTileState<Value, Offset, false> :
    ScanTileState<ItemOffsetPair<Value, Offset> >
{
    typedef ScanTileState<ItemOffsetPair<Value, Offset> > SuperClass;


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    ReduceByKeyScanTileState() : SuperClass() {}
};






template <
    typename Value,
    typename Offset>
struct ReduceByKeyScanTileState<Value, Offset, true>
{
    typedef ItemOffsetPair<Value, Offset> ReductionOffsetPair;


    enum
    {
        PAIR_SIZE = sizeof(Value) + sizeof(Offset),
        TXN_WORD_SIZE = 1 << Log2<PAIR_SIZE + 1>::VALUE,
        STATUS_WORD_SIZE = TXN_WORD_SIZE - PAIR_SIZE,

        TILE_STATUS_PADDING = (1 << (5)),
    };


    typedef typename If<(STATUS_WORD_SIZE == 8),
        long long,
        typename If<(STATUS_WORD_SIZE == 4),
            int,
            typename If<(STATUS_WORD_SIZE == 2),
                short,
                char>::Type>::Type>::Type StatusWord;


    typedef typename If<(TXN_WORD_SIZE == 16),
        longlong2,
        typename If<(TXN_WORD_SIZE == 8),
            long long,
            int>::Type>::Type TxnWord;


    struct TileDescriptorBigStatus
    {
        Offset offset;
        Value value;
        StatusWord status;
    };


    struct TileDescriptorLittleStatus
    {
        Value value;
        StatusWord status;
        Offset offset;
    };


    typedef typename If<
            (sizeof(Value) == sizeof(Offset)),
            TileDescriptorBigStatus,
            TileDescriptorLittleStatus>::Type
        TileDescriptor;



    TileDescriptor *d_tile_status;



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    ReduceByKeyScanTileState()
    :
        d_tile_status(__null)
    {}



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    cudaError_t Init(
        int num_tiles,
        void *d_temp_storage,
        size_t temp_storage_bytes)
    {
        d_tile_status = reinterpret_cast<TileDescriptor*>(d_temp_storage);
        return cudaSuccess;
    }





    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t AllocationSize(
        int num_tiles,
        size_t &temp_storage_bytes)
    {
        temp_storage_bytes = (num_tiles + TILE_STATUS_PADDING) * sizeof(TileDescriptor);
        return cudaSuccess;
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void InitializeStatus(int num_tiles)
    {
        int tile_idx = (blockIdx.x * blockDim.x) + threadIdx.x;
        if (tile_idx < num_tiles)
        {

            d_tile_status[TILE_STATUS_PADDING + tile_idx].status = StatusWord(SCAN_TILE_INVALID);
        }

        if ((blockIdx.x == 0) && (threadIdx.x < TILE_STATUS_PADDING))
        {

            d_tile_status[threadIdx.x].status = StatusWord(SCAN_TILE_OOB);
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void SetInclusive(int tile_idx, ReductionOffsetPair tile_inclusive)
    {
        TileDescriptor tile_descriptor;
        tile_descriptor.status = SCAN_TILE_INCLUSIVE;
        tile_descriptor.value = tile_inclusive.value;
        tile_descriptor.offset = tile_inclusive.offset;

        TxnWord alias;
        *reinterpret_cast<TileDescriptor*>(&alias) = tile_descriptor;
        ThreadStore<STORE_CG>(reinterpret_cast<TxnWord*>(d_tile_status + TILE_STATUS_PADDING + tile_idx), alias);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void SetPartial(int tile_idx, ReductionOffsetPair tile_partial)
    {
        TileDescriptor tile_descriptor;
        tile_descriptor.status = SCAN_TILE_PARTIAL;
        tile_descriptor.value = tile_partial.value;
        tile_descriptor.offset = tile_partial.offset;

        TxnWord alias;
        *reinterpret_cast<TileDescriptor*>(&alias) = tile_descriptor;
        ThreadStore<STORE_CG>(reinterpret_cast<TxnWord*>(d_tile_status + TILE_STATUS_PADDING + tile_idx), alias);
    }




    __attribute__((device)) __inline__ __attribute__((always_inline)) void WaitForValid(
        int tile_idx,
        StatusWord &status,
        ReductionOffsetPair &value)
    {

        TxnWord alias = ThreadLoad<LOAD_CG>(reinterpret_cast<TxnWord*>(d_tile_status + TILE_STATUS_PADDING + tile_idx));
        TileDescriptor tile_descriptor = reinterpret_cast<TileDescriptor&>(alias);

        while (WarpAny(tile_descriptor.status == SCAN_TILE_INVALID))
        {
            alias = ThreadLoad<LOAD_CG>(reinterpret_cast<TxnWord*>(d_tile_status + TILE_STATUS_PADDING + tile_idx));
            tile_descriptor = reinterpret_cast<TileDescriptor&>(alias);
        }

        status = tile_descriptor.status;
        value.value = tile_descriptor.value;
        value.offset = tile_descriptor.offset;
    }

};
# 654 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_prefix_operators.cuh"
template <
    typename T,
    typename ScanOp,
    typename ScanTileState>
struct BlockScanLookbackPrefixOp
{

    typedef WarpReduce<T> WarpReduceT;


    typedef typename WarpReduceT::TempStorage _TempStorage;


    struct TempStorage : Uninitialized<_TempStorage> {};


    typedef typename ScanTileState::StatusWord StatusWord;


    ScanTileState &tile_status;
    _TempStorage &temp_storage;
    ScanOp scan_op;
    int tile_idx;
    T exclusive_prefix;
    T inclusive_prefix;


    __attribute__((device)) __inline__ __attribute__((always_inline))
    BlockScanLookbackPrefixOp(
        ScanTileState &tile_status,
        TempStorage &temp_storage,
        ScanOp scan_op,
        int tile_idx)
    :
        tile_status(tile_status),
        temp_storage(temp_storage.Alias()),
        scan_op(scan_op),
        tile_idx(tile_idx) {}



    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ProcessWindow(
        int predecessor_idx,
        StatusWord &predecessor_status,
        T &window_aggregate)
    {
        T value;
        tile_status.WaitForValid(predecessor_idx, predecessor_status, value);


        int tail_flag = (predecessor_status == StatusWord(SCAN_TILE_INCLUSIVE));

        window_aggregate = WarpReduceT(temp_storage).TailSegmentedReduce(
            value,
            tail_flag,
            scan_op);
    }



    __attribute__((device)) __inline__ __attribute__((always_inline))
    T operator()(T block_aggregate)
    {

        if (threadIdx.x == 0)
        {
            tile_status.SetPartial(tile_idx, block_aggregate);
        }

        int predecessor_idx = tile_idx - threadIdx.x - 1;
        StatusWord predecessor_status;
        T window_aggregate;


        ProcessWindow(predecessor_idx, predecessor_status, window_aggregate);


        exclusive_prefix = window_aggregate;


        while (WarpAll(predecessor_status != StatusWord(SCAN_TILE_INCLUSIVE)))
        {
            predecessor_idx -= (1 << (5));


            ProcessWindow(predecessor_idx, predecessor_status, window_aggregate);
            exclusive_prefix = scan_op(window_aggregate, exclusive_prefix);
        }


        if (threadIdx.x == 0)
        {
            inclusive_prefix = scan_op(exclusive_prefix, block_aggregate);
            tile_status.SetInclusive(tile_idx, inclusive_prefix);
        }


        return exclusive_prefix;
    }
};


}
} } } }
# 39 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh" 2




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../iterator/cache_modified_input_iterator.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../iterator/cache_modified_input_iterator.cuh"
       
# 52 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../iterator/cache_modified_input_iterator.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 103 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/../iterator/cache_modified_input_iterator.cuh"
template <
    CacheLoadModifier MODIFIER,
    typename ValueType,
    typename Offset = ptrdiff_t>
class CacheModifiedInputIterator
{
public:


    typedef CacheModifiedInputIterator self_type;
    typedef Offset difference_type;
    typedef ValueType value_type;
    typedef ValueType* pointer;
    typedef ValueType reference;



    typedef typename thrust::detail::iterator_facade_category<
        thrust::device_system_tag,
        thrust::random_access_traversal_tag,
        value_type,
        reference
      >::type iterator_category;





private:

    ValueType* ptr;

public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CacheModifiedInputIterator(
        ValueType* ptr)
    :
        ptr(ptr)
    {}


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++(int)
    {
        self_type retval = *this;
        ptr++;
        return retval;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++()
    {
        ptr++;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator*() const
    {
        return ThreadLoad<MODIFIER>(ptr);
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator+(Distance n) const
    {
        self_type retval(ptr + n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator+=(Distance n)
    {
        ptr += n;
        return *this;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator-(Distance n) const
    {
        self_type retval(ptr - n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator-=(Distance n)
    {
        ptr -= n;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) difference_type operator-(self_type other) const
    {
        return ptr - other.ptr;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator[](Distance n) const
    {
        return ThreadLoad<MODIFIER>(ptr + n);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) pointer operator->()
    {
        return &ThreadLoad<MODIFIER>(ptr);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator==(const self_type& rhs)
    {
        return (ptr == rhs.ptr);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator!=(const self_type& rhs)
    {
        return (ptr != rhs.ptr);
    }


    friend std::ostream& operator<<(std::ostream& os, const self_type& itr)
    {
        return os;
    }
};





}
} } } }
# 44 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 60 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh"
template <
    int _BLOCK_THREADS,
    int _ITEMS_PER_THREAD,
    BlockLoadAlgorithm _LOAD_ALGORITHM,
    bool _LOAD_WARP_TIME_SLICING,
    CacheLoadModifier _LOAD_MODIFIER,
    BlockStoreAlgorithm _STORE_ALGORITHM,
    bool _STORE_WARP_TIME_SLICING,
    BlockScanAlgorithm _SCAN_ALGORITHM>
struct BlockScanSweepPolicy
{
    enum
    {
        BLOCK_THREADS = _BLOCK_THREADS,
        ITEMS_PER_THREAD = _ITEMS_PER_THREAD,
        LOAD_WARP_TIME_SLICING = _LOAD_WARP_TIME_SLICING,
        STORE_WARP_TIME_SLICING = _STORE_WARP_TIME_SLICING,
    };

    static const BlockLoadAlgorithm LOAD_ALGORITHM = _LOAD_ALGORITHM;
    static const CacheLoadModifier LOAD_MODIFIER = _LOAD_MODIFIER;
    static const BlockStoreAlgorithm STORE_ALGORITHM = _STORE_ALGORITHM;
    static const BlockScanAlgorithm SCAN_ALGORITHM = _SCAN_ALGORITHM;
};
# 95 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh"
template <
    typename BlockScanSweepPolicy,
    typename InputIterator,
    typename OutputIterator,
    typename ScanOp,
    typename Identity,
    typename Offset>
struct BlockScanSweep
{





    typedef typename std::iterator_traits<InputIterator>::value_type T;


    typedef ScanTileState<T> ScanTileState;


    typedef typename If<IsPointer<InputIterator>::VALUE,
            CacheModifiedInputIterator<BlockScanSweepPolicy::LOAD_MODIFIER, T, Offset>,
            InputIterator>::Type
        WrappedInputIterator;


    enum
    {
        INCLUSIVE = Equals<Identity, NullType>::VALUE,
        BLOCK_THREADS = BlockScanSweepPolicy::BLOCK_THREADS,
        ITEMS_PER_THREAD = BlockScanSweepPolicy::ITEMS_PER_THREAD,
        TILE_ITEMS = BLOCK_THREADS * ITEMS_PER_THREAD,


        SYNC_AFTER_LOAD = (BlockScanSweepPolicy::LOAD_ALGORITHM != BLOCK_LOAD_DIRECT),

    };


    typedef BlockLoad<
            WrappedInputIterator,
            BlockScanSweepPolicy::BLOCK_THREADS,
            BlockScanSweepPolicy::ITEMS_PER_THREAD,
            BlockScanSweepPolicy::LOAD_ALGORITHM,
            BlockScanSweepPolicy::LOAD_WARP_TIME_SLICING>
        BlockLoadT;


    typedef BlockStore<
            OutputIterator,
            BlockScanSweepPolicy::BLOCK_THREADS,
            BlockScanSweepPolicy::ITEMS_PER_THREAD,
            BlockScanSweepPolicy::STORE_ALGORITHM,
            BlockScanSweepPolicy::STORE_WARP_TIME_SLICING>
        BlockStoreT;


    typedef BlockScan<
            T,
            BlockScanSweepPolicy::BLOCK_THREADS,
            BlockScanSweepPolicy::SCAN_ALGORITHM>
        BlockScanT;


    typedef BlockScanLookbackPrefixOp<
            T,
            ScanOp,
            ScanTileState>
        LookbackPrefixCallbackOp;


    typedef BlockScanRunningPrefixOp<
            T,
            ScanOp>
        RunningPrefixCallbackOp;


    struct _TempStorage
    {
        union
        {
            typename BlockLoadT::TempStorage load;
            typename BlockStoreT::TempStorage store;
            struct
            {
                typename LookbackPrefixCallbackOp::TempStorage prefix;
                typename BlockScanT::TempStorage scan;
            };
        };

        Offset tile_idx;
    };


    struct TempStorage : Uninitialized<_TempStorage> {};






    _TempStorage &temp_storage;
    WrappedInputIterator d_in;
    OutputIterator d_out;
    ScanOp scan_op;
    Identity identity;
# 211 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh"
    template <typename _ScanOp, typename _Identity>
    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(T (&items)[ITEMS_PER_THREAD], _ScanOp scan_op, _Identity identity, T& block_aggregate)
    {
        BlockScanT(temp_storage.scan).ExclusiveScan(items, items, identity, scan_op, block_aggregate);
    }




    template <typename _Identity>
    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(T (&items)[ITEMS_PER_THREAD], Sum scan_op, _Identity identity, T& block_aggregate)
    {
        BlockScanT(temp_storage.scan).ExclusiveSum(items, items, block_aggregate);
    }




    template <typename _ScanOp>
    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(T (&items)[ITEMS_PER_THREAD], _ScanOp scan_op, NullType identity, T& block_aggregate)
    {
        BlockScanT(temp_storage.scan).InclusiveScan(items, items, scan_op, block_aggregate);
    }




    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(T (&items)[ITEMS_PER_THREAD], Sum scan_op, NullType identity, T& block_aggregate)
    {
        BlockScanT(temp_storage.scan).InclusiveSum(items, items, block_aggregate);
    }
# 254 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh"
    template <typename _ScanOp, typename _Identity, typename PrefixCallback>
    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(T (&items)[ITEMS_PER_THREAD], _ScanOp scan_op, _Identity identity, T& block_aggregate, PrefixCallback &prefix_op)
    {
        BlockScanT(temp_storage.scan).ExclusiveScan(items, items, identity, scan_op, block_aggregate, prefix_op);
    }




    template <typename _Identity, typename PrefixCallback>
    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(T (&items)[ITEMS_PER_THREAD], Sum scan_op, _Identity identity, T& block_aggregate, PrefixCallback &prefix_op)
    {
        BlockScanT(temp_storage.scan).ExclusiveSum(items, items, block_aggregate, prefix_op);
    }




    template <typename _ScanOp, typename PrefixCallback>
    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(T (&items)[ITEMS_PER_THREAD], _ScanOp scan_op, NullType identity, T& block_aggregate, PrefixCallback &prefix_op)
    {
        BlockScanT(temp_storage.scan).InclusiveScan(items, items, scan_op, block_aggregate, prefix_op);
    }




    template <typename PrefixCallback>
    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(T (&items)[ITEMS_PER_THREAD], Sum scan_op, NullType identity, T& block_aggregate, PrefixCallback &prefix_op)
    {
        BlockScanT(temp_storage.scan).InclusiveSum(items, items, block_aggregate, prefix_op);
    }







    __attribute__((device)) __inline__ __attribute__((always_inline))
    BlockScanSweep(
        TempStorage &temp_storage,
        InputIterator d_in,
        OutputIterator d_out,
        ScanOp scan_op,
        Identity identity)
    :
        temp_storage(temp_storage.Alias()),
        d_in(d_in),
        d_out(d_out),
        scan_op(scan_op),
        identity(identity)
    {}
# 320 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh"
    template <bool LAST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeTile(
        Offset num_items,
        Offset num_remaining,
        int tile_idx,
        Offset block_offset,
        ScanTileState &tile_status)
    {

        T items[ITEMS_PER_THREAD];

        if (LAST_TILE)
            BlockLoadT(temp_storage.load).Load(d_in + block_offset, items, num_remaining);
        else
            BlockLoadT(temp_storage.load).Load(d_in + block_offset, items);

        if (SYNC_AFTER_LOAD)
            __syncthreads();


        if (tile_idx == 0)
        {

            T block_aggregate;
            ScanBlock(items, scan_op, identity, block_aggregate);


            if (!LAST_TILE && (threadIdx.x == 0))
                tile_status.SetInclusive(0, block_aggregate);
        }
        else
        {

            T block_aggregate;
            LookbackPrefixCallbackOp prefix_op(tile_status, temp_storage.prefix, scan_op, tile_idx);
            ScanBlock(items, scan_op, identity, block_aggregate, prefix_op);
        }

        __syncthreads();


        if (LAST_TILE)
            BlockStoreT(temp_storage.store).Store(d_out + block_offset, items, num_remaining);
        else
            BlockStoreT(temp_storage.store).Store(d_out + block_offset, items);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        int num_items,
        GridQueue<int> queue,
        ScanTileState &tile_status)
    {



        int tile_idx = (blockIdx.y * gridDim.x) + blockIdx.x;
        Offset block_offset = Offset(TILE_ITEMS) * tile_idx;
        Offset num_remaining = num_items - block_offset;

        if (num_remaining > TILE_ITEMS)
            ConsumeTile<false>(num_items, num_remaining, tile_idx, block_offset, tile_status);
        else if (num_remaining > 0)
            ConsumeTile<true>(num_items, num_remaining, tile_idx, block_offset, tile_status);
# 425 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh"
    }
# 435 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_scan_sweep.cuh"
    template <
        bool FULL_TILE,
        bool FIRST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeTile(
        Offset block_offset,
        RunningPrefixCallbackOp &prefix_op,
        int valid_items = TILE_ITEMS)
    {

        T items[ITEMS_PER_THREAD];

        if (FULL_TILE)
            BlockLoadT(temp_storage.load).Load(d_in + block_offset, items);
        else
            BlockLoadT(temp_storage.load).Load(d_in + block_offset, items, valid_items);

        __syncthreads();


        if (FIRST_TILE)
        {
            T block_aggregate;
            ScanBlock(items, scan_op, identity, block_aggregate);
            prefix_op.running_total = block_aggregate;
        }
        else
        {
            T block_aggregate;
            ScanBlock(items, scan_op, identity, block_aggregate, prefix_op);
        }

        __syncthreads();


        if (FULL_TILE)
            BlockStoreT(temp_storage.store).Store(d_out + block_offset, items);
        else
            BlockStoreT(temp_storage.store).Store(d_out + block_offset, items, valid_items);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        Offset block_offset,
        Offset block_end)
    {
        BlockScanRunningPrefixOp<T, ScanOp> prefix_op(scan_op);

        if (block_offset + TILE_ITEMS <= block_end)
        {

            ConsumeTile<true, true>(block_offset, prefix_op);
            block_offset += TILE_ITEMS;


            while (block_offset + TILE_ITEMS <= block_end)
            {
                ConsumeTile<true, false>(block_offset, prefix_op);
                block_offset += TILE_ITEMS;
            }


            if (block_offset < block_end)
            {
                int valid_items = block_end - block_offset;
                ConsumeTile<false, false>(block_offset, prefix_op, valid_items);
            }
        }
        else
        {

            int valid_items = block_end - block_offset;
            ConsumeTile<false, true>(block_offset, prefix_op, valid_items);
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        Offset block_offset,
        Offset block_end,
        T prefix)
    {
        BlockScanRunningPrefixOp<T, ScanOp> prefix_op(prefix, scan_op);


        while (block_offset + TILE_ITEMS <= block_end)
        {
            ConsumeTile<true, false>(block_offset, prefix_op);
            block_offset += TILE_ITEMS;
        }


        if (block_offset < block_end)
        {
            int valid_items = block_end - block_offset;
            ConsumeTile<false, false>(block_offset, prefix_op, valid_items);
        }
    }

};


}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh" 2







namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 61 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
template <
    typename Offset,
    typename ScanTileState>
__attribute__((global)) void DeviceScanInitKernel(
    GridQueue<Offset> grid_queue,
    ScanTileState tile_status,
    int num_tiles)
{

    if ((blockIdx.x == 0) && (threadIdx.x == 0))
        grid_queue.FillAndResetDrain(num_tiles);


    tile_status.InitializeStatus(num_tiles);
}





template <
    typename BlockScanSweepPolicy,
    typename InputIterator,
    typename OutputIterator,
    typename ScanTileState,
    typename ScanOp,
    typename Identity,
    typename Offset>
__attribute__((launch_bounds(int(BlockScanSweepPolicy::BLOCK_THREADS))))
__attribute__((global)) void DeviceScanSweepKernel(
    InputIterator d_in,
    OutputIterator d_out,
    ScanTileState tile_status,
    ScanOp scan_op,
    Identity identity,
    Offset num_items,
    GridQueue<int> queue)
{

    typedef BlockScanSweep<
        BlockScanSweepPolicy,
        InputIterator,
        OutputIterator,
        ScanOp,
        Identity,
        Offset> BlockScanSweepT;


    __attribute__((shared)) typename BlockScanSweepT::TempStorage temp_storage;


    BlockScanSweepT(temp_storage, d_in, d_out, scan_op, identity).ConsumeRange(
        num_items,
        queue,
        tile_status);
}
# 128 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
template <
    typename InputIterator,
    typename OutputIterator,
    typename ScanOp,
    typename Identity,
    typename Offset>
struct DeviceScanDispatch
{
    enum
    {
        INIT_KERNEL_THREADS = 128
    };


    typedef typename std::iterator_traits<InputIterator>::value_type T;


    typedef ScanTileState<T> ScanTileState;







    struct Policy350
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 12,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };


        typedef BlockScanSweepPolicy<
                128,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_DIRECT,
                false,
                LOAD_LDG,
                BLOCK_STORE_WARP_TRANSPOSE,
                true,
                BLOCK_SCAN_RAKING_MEMOIZE>
            RangeScanPolicy;
    };


    struct Policy300
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 9,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockScanSweepPolicy<
                256,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                false,
                LOAD_DEFAULT,
                BLOCK_STORE_WARP_TRANSPOSE,
                false,
                BLOCK_SCAN_RAKING_MEMOIZE>
            RangeScanPolicy;
    };


    struct Policy200
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 15,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };


        typedef BlockScanSweepPolicy<
                128,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                false,
                LOAD_DEFAULT,
                BLOCK_STORE_WARP_TRANSPOSE,
                false,
                BLOCK_SCAN_RAKING_MEMOIZE>
            RangeScanPolicy;
    };


    struct Policy130
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 21,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockScanSweepPolicy<
                96,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                false,
                LOAD_DEFAULT,
                BLOCK_STORE_WARP_TRANSPOSE,
                false,
                BLOCK_SCAN_RAKING_MEMOIZE>
            RangeScanPolicy;
    };


    struct Policy100
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 9,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockScanSweepPolicy<
                64,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                true,
                LOAD_DEFAULT,
                BLOCK_STORE_WARP_TRANSPOSE,
                true,
                BLOCK_SCAN_WARP_SCANS>
            RangeScanPolicy;
    };
# 272 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
    typedef Policy100 PtxPolicy;




    struct PtxRangeScanPolicy : PtxPolicy::RangeScanPolicy {};
# 287 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
    template <typename KernelConfig>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static void InitConfigs(
        int ptx_version,
        KernelConfig &device_scan_sweep_config)
    {
# 301 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
        if (ptx_version >= 350)
        {
            device_scan_sweep_config.template Init<typename Policy350::RangeScanPolicy>();
        }
        else if (ptx_version >= 300)
        {
            device_scan_sweep_config.template Init<typename Policy300::RangeScanPolicy>();
        }
        else if (ptx_version >= 200)
        {
            device_scan_sweep_config.template Init<typename Policy200::RangeScanPolicy>();
        }
        else if (ptx_version >= 130)
        {
            device_scan_sweep_config.template Init<typename Policy130::RangeScanPolicy>();
        }
        else
        {
            device_scan_sweep_config.template Init<typename Policy100::RangeScanPolicy>();
        }


    }





    struct KernelConfig
    {
        int block_threads;
        int items_per_thread;
        BlockLoadAlgorithm load_policy;
        BlockStoreAlgorithm store_policy;
        BlockScanAlgorithm scan_algorithm;

        template <typename BlockScanSweepPolicy>
        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Init()
        {
            block_threads = BlockScanSweepPolicy::BLOCK_THREADS;
            items_per_thread = BlockScanSweepPolicy::ITEMS_PER_THREAD;
            load_policy = BlockScanSweepPolicy::LOAD_ALGORITHM;
            store_policy = BlockScanSweepPolicy::STORE_ALGORITHM;
            scan_algorithm = BlockScanSweepPolicy::SCAN_ALGORITHM;
        }

        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Print()
        {
            printf("%d, %d, %d, %d, %d",
                block_threads,
                items_per_thread,
                load_policy,
                store_policy,
                scan_algorithm);
        }
    };
# 369 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
    template <
        typename DeviceScanInitKernelPtr,
        typename DeviceScanSweepKernelPtr>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        ScanOp scan_op,
        Identity identity,
        Offset num_items,
        cudaStream_t stream,
        bool debug_synchronous,
        int ptx_version,
        DeviceScanInitKernelPtr device_scan_init_kernel,
        DeviceScanSweepKernelPtr device_scan_sweep_kernel,
        KernelConfig device_scan_sweep_config)
    {







        cudaError error = cudaSuccess;
        do
        {

            int device_ordinal;
            if (cub_::Debug((error = cudaGetDevice(&device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 400)) break;


            int sm_version;
            if (cub_::Debug((error = SmVersion(sm_version, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 404)) break;


            int sm_count;
            if (cub_::Debug((error = cudaDeviceGetAttribute (&sm_count, cudaDevAttrMultiProcessorCount, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 408)) break;


            int tile_size = device_scan_sweep_config.block_threads * device_scan_sweep_config.items_per_thread;
            int num_tiles = (num_items + tile_size - 1) / tile_size;


            size_t allocation_sizes[2];
            if (cub_::Debug((error = ScanTileState::AllocationSize(num_tiles, allocation_sizes[0])), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 416)) break;
            allocation_sizes[1] = GridQueue<int>::AllocationSize();


            void* allocations[2];
            if (cub_::Debug((error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 421)) break;
            if (d_temp_storage == __null)
            {

                return cudaSuccess;
            }


            ScanTileState tile_status;
            if (cub_::Debug((error = tile_status.Init(num_tiles, allocations[0], allocation_sizes[0])), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 430)) break;


            GridQueue<int> queue(allocations[1]);


            int init_grid_size = (num_tiles + INIT_KERNEL_THREADS - 1) / INIT_KERNEL_THREADS;
            if (debug_synchronous) printf("Invoking device_scan_init_kernel<<<%d, %d, 0, %lld>>>()\n",init_grid_size, INIT_KERNEL_THREADS, (long long) stream);;


            device_scan_init_kernel<<<init_grid_size, INIT_KERNEL_THREADS, 0, stream>>>(
                queue,
                tile_status,
                num_tiles);


            if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 446)) break;


            if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 449))) break;


            int range_scan_sm_occupancy;
            if (cub_::Debug((error = MaxSmOccupancy( range_scan_sm_occupancy, sm_version, device_scan_sweep_kernel, device_scan_sweep_config.block_threads)),



 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
# 453 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
                ,



 457
# 453 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
                )



                                                        ) break;


            dim3 scan_grid_size;
            if (ptx_version <= 130)
            {

                int max_dim_x = 32 * 1024;
                scan_grid_size.z = 1;
                scan_grid_size.y = (num_tiles + max_dim_x - 1) / max_dim_x;
                scan_grid_size.x = (((max_dim_x) < (num_tiles)) ? (max_dim_x) : (num_tiles));
            }
            else
            {

                int range_scan_occupancy = range_scan_sm_occupancy * sm_count;
                scan_grid_size.z = 1;
                scan_grid_size.y = 1;
                scan_grid_size.x = (num_tiles < range_scan_occupancy) ?
                    num_tiles :
                    range_scan_occupancy;
            }


            if (debug_synchronous) printf("Invoking device_scan_sweep_kernel<<<{%d,%d,%d}, %d, 0, %lld>>>(), %d items per thread, %d SM occupancy\n",scan_grid_size.x, scan_grid_size.y, scan_grid_size.z, device_scan_sweep_config.block_threads, (long long) stream, device_scan_sweep_config.items_per_thread, range_scan_sm_occupancy);
                                                                                                                                                                                                     ;


            device_scan_sweep_kernel<<<scan_grid_size, device_scan_sweep_config.block_threads, 0, stream>>>(
                d_in,
                d_out,
                tile_status,
                scan_op,
                identity,
                num_items,
                queue);


            if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 495)) break;


            if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 498))) break;
        }
        while (0);

        return error;


    }





    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        ScanOp scan_op,
        Identity identity,
        Offset num_items,
        cudaStream_t stream,
        bool debug_synchronous)
    {
        cudaError error = cudaSuccess;
        do
        {

            int ptx_version;

            if (cub_::Debug((error = PtxVersion(ptx_version)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh", 529)) break;





            KernelConfig device_scan_sweep_config;
            InitConfigs(ptx_version, device_scan_sweep_config);


            if (cub_::Debug((error = Dispatch( d_temp_storage, temp_storage_bytes, d_in, d_out, scan_op, identity, num_items, stream, debug_synchronous, ptx_version, DeviceScanInitKernel<Offset, ScanTileState>, DeviceScanSweepKernel<PtxRangeScanPolicy, InputIterator, OutputIterator, ScanTileState, ScanOp, Identity, Offset>, device_scan_sweep_config)),
# 552 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
# 539 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
                ,
# 552 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
 552
# 539 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
                )
# 552 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_scan_dispatch.cuh"
                                          ) break;
        }
        while (0);

        return error;
    }
};



}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh"
       
# 49 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 62 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh"
template <
    int _BLOCK_THREADS,
    int _ITEMS_PER_THREAD,
    BlockLoadAlgorithm _LOAD_ALGORITHM,
    CacheLoadModifier _LOAD_MODIFIER,
    bool _STORE_WARP_TIME_SLICING,
    BlockScanAlgorithm _SCAN_ALGORITHM>
struct BlockSelectSweepPolicy
{
    enum
    {
        BLOCK_THREADS = _BLOCK_THREADS,
        ITEMS_PER_THREAD = _ITEMS_PER_THREAD,
        STORE_WARP_TIME_SLICING = _STORE_WARP_TIME_SLICING,
    };

    static const BlockLoadAlgorithm LOAD_ALGORITHM = _LOAD_ALGORITHM;
    static const CacheLoadModifier LOAD_MODIFIER = _LOAD_MODIFIER;
    static const BlockScanAlgorithm SCAN_ALGORITHM = _SCAN_ALGORITHM;
};
# 97 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh"
template <
    typename BlockSelectSweepPolicy,
    typename InputIterator,
    typename FlagsInputIterator,
    typename SelectedOutputIterator,
    typename SelectOp,
    typename EqualityOp,
    typename Offset,
    bool KEEP_REJECTS>
struct BlockSelectSweep
{





    typedef typename std::iterator_traits<InputIterator>::value_type T;


    typedef typename std::iterator_traits<FlagsInputIterator>::value_type Flag;


    typedef ScanTileState<Offset> ScanTileState;


    enum
    {
        USE_SELECT_OP,
        USE_SELECT_FLAGS,
        USE_DISCONTINUITY,

        BLOCK_THREADS = BlockSelectSweepPolicy::BLOCK_THREADS,


        WARP_THREADS = (1 << (5)),


        WARPS = (BLOCK_THREADS + WARP_THREADS - 1) / WARP_THREADS,

        ITEMS_PER_THREAD = BlockSelectSweepPolicy::ITEMS_PER_THREAD,
        TILE_ITEMS = BLOCK_THREADS * ITEMS_PER_THREAD,


        SYNC_AFTER_LOAD = (BlockSelectSweepPolicy::LOAD_ALGORITHM != BLOCK_LOAD_DIRECT),


        STORE_WARP_TIME_SLICING = BlockSelectSweepPolicy::STORE_WARP_TIME_SLICING,
        ACTIVE_EXCHANGE_WARPS = (STORE_WARP_TIME_SLICING) ? 1 : WARPS,

        SELECT_METHOD = (!Equals<SelectOp, NullType>::VALUE) ?
                                    USE_SELECT_OP :
                                    (!Equals<Flag, NullType>::VALUE) ?
                                        USE_SELECT_FLAGS :
                                        USE_DISCONTINUITY
    };


    typedef typename If<IsPointer<InputIterator>::VALUE,
            CacheModifiedInputIterator<BlockSelectSweepPolicy::LOAD_MODIFIER, T, Offset>,
            InputIterator>::Type
        WrappedInputIterator;


    typedef typename If<IsPointer<FlagsInputIterator>::VALUE,
            CacheModifiedInputIterator<BlockSelectSweepPolicy::LOAD_MODIFIER, Flag, Offset>,
            FlagsInputIterator>::Type
        WrappedFlagsInputIterator;


    typedef BlockLoad<
            WrappedInputIterator,
            BlockSelectSweepPolicy::BLOCK_THREADS,
            BlockSelectSweepPolicy::ITEMS_PER_THREAD,
            BlockSelectSweepPolicy::LOAD_ALGORITHM>
        BlockLoadT;


    typedef BlockLoad<
            WrappedFlagsInputIterator,
            BlockSelectSweepPolicy::BLOCK_THREADS,
            BlockSelectSweepPolicy::ITEMS_PER_THREAD,
            BlockSelectSweepPolicy::LOAD_ALGORITHM>
        BlockLoadFlags;


    typedef BlockDiscontinuity<T, BLOCK_THREADS> BlockDiscontinuityT;


    typedef WarpScan<Offset> WarpScanAllocations;


    typedef BlockScanLookbackPrefixOp<
            Offset,
            Sum,
            ScanTileState>
        LookbackPrefixCallbackOp;


    typedef WarpExchange<T, ITEMS_PER_THREAD> WarpExchangeT;


    struct _TempStorage
    {
        union
        {
            struct
            {
                typename BlockDiscontinuityT::TempStorage discontinuity;
                typename WarpScanAllocations::TempStorage warp_scan[WARPS];
                Offset warp_aggregates[WARPS];
                typename LookbackPrefixCallbackOp::TempStorage prefix;
            };


            typename BlockLoadT::TempStorage load_items;


            typename BlockLoadFlags::TempStorage load_flags;


            union
            {
                unsigned long long align;
                typename WarpExchangeT::TempStorage exchange[ACTIVE_EXCHANGE_WARPS];
            };
        };

        Offset tile_idx;
        Offset tile_inclusive;
        Offset tile_exclusive;
    };


    struct TempStorage : Uninitialized<_TempStorage> {};






    _TempStorage &temp_storage;
    WrappedInputIterator d_in;
    WrappedFlagsInputIterator d_flags;
    SelectedOutputIterator d_selected_out;
    SelectOp select_op;
    InequalityWrapper<EqualityOp> inequality_op;
    Offset num_items;







    __attribute__((device)) __inline__ __attribute__((always_inline))
    BlockSelectSweep(
        TempStorage &temp_storage,
        InputIterator d_in,
        FlagsInputIterator d_flags,
        SelectedOutputIterator d_selected_out,
        SelectOp select_op,
        EqualityOp equality_op,
        Offset num_items)
    :
        temp_storage(temp_storage.Alias()),
        d_in(d_in),
        d_flags(d_flags),
        d_selected_out(d_selected_out),
        select_op(select_op),
        inequality_op(equality_op),
        num_items(num_items)
    {}
# 278 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh"
    template <bool FIRST_TILE, bool LAST_TILE, int ITERATION>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ApplySelectionOp(
        Offset block_offset,
        Offset num_remaining,
        T (&items)[ITEMS_PER_THREAD],
        Offset (&selected)[ITEMS_PER_THREAD],
        Int2Type<ITERATION> iteration)
    {
        selected[ITERATION] = 0;
        if (!LAST_TILE || (Offset(threadIdx.x * ITEMS_PER_THREAD) + ITERATION < num_remaining))
            selected[ITERATION] = select_op(items[ITERATION]);

        ApplySelectionOp<FIRST_TILE, LAST_TILE>(block_offset, num_remaining, items, selected, Int2Type<ITERATION + 1>());
    }




    template <bool FIRST_TILE, bool LAST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ApplySelectionOp(
        Offset block_offset,
        Offset num_remaining,
        T (&items)[ITEMS_PER_THREAD],
        Offset (&selected)[ITEMS_PER_THREAD],
        Int2Type<ITEMS_PER_THREAD> iteration)
    {}




    template <bool FIRST_TILE, bool LAST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InitializeSelections(
        Offset block_offset,
        Offset num_remaining,
        T (&items)[ITEMS_PER_THREAD],
        Offset (&selected)[ITEMS_PER_THREAD],
        Int2Type<USE_SELECT_OP> select_method)
    {
        __syncthreads();

        ApplySelectionOp<FIRST_TILE, LAST_TILE>(block_offset, num_remaining, items, selected, Int2Type<0>());
    }





    template <bool FIRST_TILE, bool LAST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InitializeSelections(
        Offset block_offset,
        Offset num_remaining,
        T (&items)[ITEMS_PER_THREAD],
        Offset (&selected)[ITEMS_PER_THREAD],
        Int2Type<USE_SELECT_FLAGS> select_method)
    {
        Flag flags[ITEMS_PER_THREAD];

        if (LAST_TILE)
            BlockLoadFlags(temp_storage.load_flags).Load(d_flags + block_offset, flags, num_remaining, 0);
        else
            BlockLoadFlags(temp_storage.load_flags).Load(d_flags + block_offset, flags);

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
        {
            selected[ITEM] = flags[ITEM];
        }

        if (SYNC_AFTER_LOAD)
            __syncthreads();
    }





    template <bool FIRST_TILE, bool LAST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void InitializeSelections(
        Offset block_offset,
        Offset num_remaining,
        T (&items)[ITEMS_PER_THREAD],
        Offset (&selected)[ITEMS_PER_THREAD],
        Int2Type<USE_DISCONTINUITY> select_method)
    {
        if (FIRST_TILE)
        {

            BlockDiscontinuityT(temp_storage.discontinuity).FlagHeads(selected, items, inequality_op);
        }
        else
        {

            T tile_predecessor_item;
            if (threadIdx.x == 0)
                tile_predecessor_item = d_in[block_offset - 1];

            BlockDiscontinuityT(temp_storage.discontinuity).FlagHeads(selected, items, inequality_op, tile_predecessor_item);
        }
    }
# 386 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScanAllocations(
        Offset &tile_aggregate,
        int &warp_aggregate,
        int &warp_exclusive,
        int (&selected)[ITEMS_PER_THREAD],
        int (&thread_exclusives)[ITEMS_PER_THREAD])
    {

        int warp_id = ((WARPS == 1) ? 0 : threadIdx.x / WARP_THREADS);
        int lane_id = LaneId();

        int thread_aggregate = ThreadReduce(selected, cub_::Sum());
        int inclusive_partial, exclusive_partial;
        WarpScanAllocations(temp_storage.warp_scan[warp_id]).Sum(thread_aggregate, inclusive_partial, exclusive_partial);
        ThreadScanExclusive(selected, thread_exclusives, cub_::Sum(), exclusive_partial);


        if (lane_id == WARP_THREADS - 1)
            temp_storage.warp_aggregates[warp_id] = inclusive_partial;

        __syncthreads();


        warp_exclusive = 0;
        warp_aggregate = temp_storage.warp_aggregates[warp_id];
        tile_aggregate = temp_storage.warp_aggregates[0];

#pragma unroll
        for (int WARP = 1; WARP < WARPS; ++WARP)
        {
            if (warp_id == WARP)
                warp_exclusive = tile_aggregate;

            tile_aggregate += temp_storage.warp_aggregates[WARP];
        }


#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
        {
            if (!selected[ITEM])
                thread_exclusives[ITEM] = WARP_THREADS * ITEMS_PER_THREAD;
        }
    }
# 438 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterTwoPhase(
        Offset tile_exclusive,
        int warp_aggregate,
        int warp_exclusive,
        int (&thread_exclusives)[ITEMS_PER_THREAD],
        T (&items)[ITEMS_PER_THREAD],
        Int2Type<true> is_warp_time_slice)
    {
        int warp_id = ((WARPS == 1) ? 0 : threadIdx.x / WARP_THREADS);
        int lane_id = LaneId();


        if (warp_id == 0)
        {
            WarpExchangeT(temp_storage.exchange[0]).ScatterToStriped(items, thread_exclusives);
        }


#pragma unroll
        for (int SLICE = 1; SLICE < WARPS; ++SLICE)
        {
            __syncthreads();

            if (warp_id == SLICE)
            {
                WarpExchangeT(temp_storage.exchange[0]).ScatterToStriped(items, thread_exclusives);
            }
        }

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            if ((ITEM * WARP_THREADS) < warp_aggregate - lane_id)
            {
                d_selected_out[tile_exclusive + warp_exclusive + (ITEM * WARP_THREADS) + lane_id] = items[ITEM];
            }
        }
    }






    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterTwoPhase(
        Offset tile_exclusive,
        int warp_aggregate,
        int warp_exclusive,
        int (&thread_exclusives)[ITEMS_PER_THREAD],
        T (&items)[ITEMS_PER_THREAD],
        Int2Type<false> is_warp_time_slice)
    {
        int warp_id = ((WARPS == 1) ? 0 : threadIdx.x / WARP_THREADS);
        int lane_id = LaneId();

        WarpExchangeT(temp_storage.exchange[warp_id]).ScatterToStriped(items, thread_exclusives);

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
        {
            if ((ITEM * WARP_THREADS) < warp_aggregate - lane_id)
            {
                d_selected_out[tile_exclusive + warp_exclusive + (ITEM * WARP_THREADS) + lane_id] = items[ITEM];
            }
        }
    }






    __attribute__((device)) __inline__ __attribute__((always_inline)) void Scatter(
        Offset tile_aggregate,
        Offset tile_exclusive,
        int warp_aggregate,
        int warp_exclusive,
        int (&thread_exclusives)[ITEMS_PER_THREAD],
        T (&items)[ITEMS_PER_THREAD])
    {
        if ((ITEMS_PER_THREAD == 1) || (tile_aggregate < BLOCK_THREADS))
        {

            if (warp_aggregate)
            {
#pragma unroll
                for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
                {
                    if (thread_exclusives[ITEM] < warp_aggregate)
                        d_selected_out[tile_exclusive + warp_exclusive + thread_exclusives[ITEM]] = items[ITEM];
                }
            }
        }
        else
        {
            ScatterTwoPhase(
                tile_exclusive,
                warp_aggregate,
                warp_exclusive,
                thread_exclusives,
                items,
                Int2Type<STORE_WARP_TIME_SLICING>());
        }
    }
# 554 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh"
    template <bool LAST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) Offset ConsumeTile(
        Offset num_items,
        Offset num_remaining,
        int tile_idx,
        Offset block_offset,
        ScanTileState &tile_status)
    {
        if (tile_idx == 0)
        {



            T items[ITEMS_PER_THREAD];
            if (LAST_TILE)
            {
                T oob_item = (SELECT_METHOD == USE_DISCONTINUITY) ?
                    d_in[num_items - 1] :
                    ZeroInitialize<T>();

                BlockLoadT(temp_storage.load_items).Load(d_in + block_offset, items, num_remaining, oob_item);
            }
            else
            {
                BlockLoadT(temp_storage.load_items).Load(d_in + block_offset, items);
            }

            if (SYNC_AFTER_LOAD)
                __syncthreads();


            int selected[ITEMS_PER_THREAD];
            InitializeSelections<true, LAST_TILE>(block_offset, num_remaining, items, selected, Int2Type<SELECT_METHOD>());


            Offset tile_aggregate;
            int warp_aggregate, warp_exclusive;
            int thread_exclusives[ITEMS_PER_THREAD];
            ScanAllocations(tile_aggregate, warp_aggregate, warp_exclusive, selected, thread_exclusives);


            if (!LAST_TILE && (threadIdx.x == 0))
                tile_status.SetInclusive(0, tile_aggregate);

            Offset tile_exclusive = 0;


            Scatter(tile_aggregate, tile_exclusive, warp_aggregate, warp_exclusive, thread_exclusives, items);


            return tile_aggregate;
        }
        else
        {



            T items[ITEMS_PER_THREAD];
            if (LAST_TILE)
            {
                T oob_item = (SELECT_METHOD == USE_DISCONTINUITY) ?
                    d_in[num_items - 1] :
                    ZeroInitialize<T>();

                BlockLoadT(temp_storage.load_items).Load(d_in + block_offset, items, num_remaining, oob_item);
            }
            else
            {
                BlockLoadT(temp_storage.load_items).Load(d_in + block_offset, items);
            }

            if (SYNC_AFTER_LOAD)
                __syncthreads();


            int selected[ITEMS_PER_THREAD];
            InitializeSelections<false, LAST_TILE>(block_offset, num_remaining, items, selected, Int2Type<SELECT_METHOD>());


            Offset tile_aggregate;
            int warp_aggregate, warp_exclusive;
            int thread_exclusives[ITEMS_PER_THREAD];
            ScanAllocations(tile_aggregate, warp_aggregate, warp_exclusive, selected, thread_exclusives);


            LookbackPrefixCallbackOp prefix_op(tile_status, temp_storage.prefix, Sum(), tile_idx);
            int warp_id = ((WARPS == 1) ? 0 : threadIdx.x / WARP_THREADS);
            if (warp_id == 0)
            {
                prefix_op(tile_aggregate);
                if (threadIdx.x == 0)
                    temp_storage.tile_exclusive = prefix_op.exclusive_prefix;
            }

            __syncthreads();

            Offset tile_exclusive = temp_storage.tile_exclusive;


            Scatter(tile_aggregate, tile_exclusive, warp_aggregate, warp_exclusive, thread_exclusives, items);


            return prefix_op.inclusive_prefix;
        }
    }





    template <typename NumSelectedIterator>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        int num_tiles,
        GridQueue<int> queue,
        ScanTileState &tile_status,
        NumSelectedIterator d_num_selected_out)
    {
# 685 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_select_sweep.cuh"
        int tile_idx = (blockIdx.y * gridDim.x) + blockIdx.x;



        Offset block_offset = Offset(TILE_ITEMS) * tile_idx;
        Offset num_remaining = num_items - block_offset;

        if (num_remaining > 0)
        {
            if (num_remaining > TILE_ITEMS)
            {

                ConsumeTile<false>(num_items, num_remaining, tile_idx, block_offset, tile_status);
            }
            else
            {

                Offset total_selected = ConsumeTile<true>(num_items, num_remaining, tile_idx, block_offset, tile_status);


                if (threadIdx.x == 0)
                {
                    *d_num_selected_out = total_selected;
                }
            }
        }
    }

};


}
} } } }
# 42 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh" 2






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 64 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
template <
    typename BlockSelectSweepPolicy,
    typename InputIterator,
    typename FlagsInputIterator,
    typename SelectedOutputIterator,
    typename NumSelectedIterator,
    typename ScanTileState,
    typename SelectOp,
    typename EqualityOp,
    typename Offset,
    bool KEEP_REJECTS>
__attribute__((launch_bounds(int(BlockSelectSweepPolicy::BLOCK_THREADS))))
__attribute__((global)) void DeviceSelectSweepKernel(
    InputIterator d_in,
    FlagsInputIterator d_flags,
    SelectedOutputIterator d_selected_out,
    NumSelectedIterator d_num_selected_out,
    ScanTileState tile_status,
    SelectOp select_op,
    EqualityOp equality_op,
    Offset num_items,
    int num_tiles,
    GridQueue<int> queue)
{

    typedef BlockSelectSweep<
        BlockSelectSweepPolicy,
        InputIterator,
        FlagsInputIterator,
        SelectedOutputIterator,
        SelectOp,
        EqualityOp,
        Offset,
        KEEP_REJECTS> BlockSelectSweepT;


    __attribute__((shared)) typename BlockSelectSweepT::TempStorage temp_storage;


    BlockSelectSweepT(temp_storage, d_in, d_flags, d_selected_out, select_op, equality_op, num_items).ConsumeRange(
        num_tiles,
        queue,
        tile_status,
        d_num_selected_out);
}
# 120 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
template <
    typename InputIterator,
    typename FlagsInputIterator,
    typename SelectedOutputIterator,
    typename NumSelectedIterator,
    typename SelectOp,
    typename EqualityOp,
    typename Offset,
    bool KEEP_REJECTS>
struct DeviceSelectDispatch
{





    typedef typename std::iterator_traits<InputIterator>::value_type T;


    typedef typename std::iterator_traits<FlagsInputIterator>::value_type Flag;

    enum
    {
        INIT_KERNEL_THREADS = 128,
    };


    typedef ScanTileState<Offset> ScanTileState;







    struct Policy350
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 17,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockSelectSweepPolicy<
                96,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_DIRECT,
                LOAD_LDG,
                true,
                BLOCK_SCAN_WARP_SCANS>
            RangeSelectPolicy;
    };


    struct Policy300
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 5,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockSelectSweepPolicy<
                256,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                LOAD_DEFAULT,
                true,
                BLOCK_SCAN_RAKING_MEMOIZE>
            RangeSelectPolicy;
    };


    struct Policy200
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = (KEEP_REJECTS) ? 7 : 15,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockSelectSweepPolicy<
                128,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                LOAD_DEFAULT,
                false,
                BLOCK_SCAN_WARP_SCANS>
            RangeSelectPolicy;
    };


    struct Policy130
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 9,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockSelectSweepPolicy<
                64,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                LOAD_DEFAULT,
                true,
                BLOCK_SCAN_RAKING_MEMOIZE>
            RangeSelectPolicy;
    };


    struct Policy100
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 9,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockSelectSweepPolicy<
                256,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                LOAD_DEFAULT,
                true,
                BLOCK_SCAN_RAKING_MEMOIZE>
            RangeSelectPolicy;
    };
# 262 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
    typedef Policy100 PtxPolicy;




    struct PtxRangeSelectPolicy : PtxPolicy::RangeSelectPolicy {};
# 277 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
    template <typename KernelConfig>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static void InitConfigs(
        int ptx_version,
        KernelConfig &device_select_sweep_config)
    {
# 291 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
        if (ptx_version >= 350)
        {
            device_select_sweep_config.template Init<typename Policy350::RangeSelectPolicy>();
        }
        else if (ptx_version >= 300)
        {
            device_select_sweep_config.template Init<typename Policy300::RangeSelectPolicy>();
        }
        else if (ptx_version >= 200)
        {
            device_select_sweep_config.template Init<typename Policy200::RangeSelectPolicy>();
        }
        else if (ptx_version >= 130)
        {
            device_select_sweep_config.template Init<typename Policy130::RangeSelectPolicy>();
        }
        else
        {
            device_select_sweep_config.template Init<typename Policy100::RangeSelectPolicy>();
        }


    }





    struct KernelConfig
    {
        int block_threads;
        int items_per_thread;
        BlockLoadAlgorithm load_policy;
        bool store_warp_time_slicing;
        BlockScanAlgorithm scan_algorithm;

        template <typename BlockSelectSweepPolicy>
        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Init()
        {
            block_threads = BlockSelectSweepPolicy::BLOCK_THREADS;
            items_per_thread = BlockSelectSweepPolicy::ITEMS_PER_THREAD;
            load_policy = BlockSelectSweepPolicy::LOAD_ALGORITHM;
            store_warp_time_slicing = BlockSelectSweepPolicy::STORE_WARP_TIME_SLICING;
            scan_algorithm = BlockSelectSweepPolicy::SCAN_ALGORITHM;
        }

        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Print()
        {
            printf("%d, %d, %d, %d, %d",
                block_threads,
                items_per_thread,
                load_policy,
                store_warp_time_slicing,
                scan_algorithm);
        }
    };
# 359 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
    template <
        typename DeviceScanInitKernelPtr,
        typename DeviceSelectSweepKernelPtr>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        FlagsInputIterator d_flags,
        SelectedOutputIterator d_selected_out,
        NumSelectedIterator d_num_selected_out,
        SelectOp select_op,
        EqualityOp equality_op,
        Offset num_items,
        cudaStream_t stream,
        bool debug_synchronous,
        int ptx_version,
        DeviceScanInitKernelPtr device_scan_init_kernel,
        DeviceSelectSweepKernelPtr device_select_sweep_kernel,
        KernelConfig device_select_sweep_config)
    {
# 388 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
        cudaError error = cudaSuccess;
        do
        {

            int device_ordinal;
            if (cub_::Debug((error = cudaGetDevice(&device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 393)) break;


            int sm_version;
            if (cub_::Debug((error = SmVersion(sm_version, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 397)) break;


            int sm_count;
            if (cub_::Debug((error = cudaDeviceGetAttribute (&sm_count, cudaDevAttrMultiProcessorCount, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 401)) break;


            int tile_size = device_select_sweep_config.block_threads * device_select_sweep_config.items_per_thread;
            int num_tiles = (num_items + tile_size - 1) / tile_size;


            size_t allocation_sizes[2];
            if (cub_::Debug((error = ScanTileState::AllocationSize(num_tiles, allocation_sizes[0])), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 409)) break;
            allocation_sizes[1] = GridQueue<int>::AllocationSize();


            void* allocations[2];
            if (cub_::Debug((error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 414)) break;
            if (d_temp_storage == __null)
            {

                return cudaSuccess;
            }


            ScanTileState tile_status;
            if (cub_::Debug((error = tile_status.Init(num_tiles, allocations[0], allocation_sizes[0])), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 423)) break;


            GridQueue<int> queue(allocations[1]);


            int init_grid_size = (num_tiles + INIT_KERNEL_THREADS - 1) / INIT_KERNEL_THREADS;
            if (debug_synchronous) printf("Invoking device_scan_init_kernel<<<%d, %d, 0, %lld>>>()\n",init_grid_size, INIT_KERNEL_THREADS, (long long) stream);;


            device_scan_init_kernel<<<init_grid_size, INIT_KERNEL_THREADS, 0, stream>>>(
                queue,
                tile_status,
                num_tiles);


            if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 439)) break;


            if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 442))) break;


            int range_select_sm_occupancy;
            if (cub_::Debug((error = MaxSmOccupancy( range_select_sm_occupancy, sm_version, device_select_sweep_kernel, device_select_sweep_config.block_threads)),



 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
# 446 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
                ,



 450
# 446 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
                )



                                                          ) break;


            dim3 select_grid_size;
            int max_dim_x = 32 * 1024;
            select_grid_size.z = 1;
            select_grid_size.y = (num_tiles + max_dim_x - 1) / max_dim_x;
            select_grid_size.x = (((max_dim_x) < (num_tiles)) ? (max_dim_x) : (num_tiles));


            if (debug_synchronous) printf("Invoking device_select_sweep_kernel<<<{%d,%d,%d}, %d, 0, %lld>>>(), %d items per thread, %d SM occupancy\n",select_grid_size.x, select_grid_size.y, select_grid_size.z, device_select_sweep_config.block_threads, (long long) stream, device_select_sweep_config.items_per_thread, range_select_sm_occupancy);
                                                                                                                                                                                                                 ;


            device_select_sweep_kernel<<<select_grid_size, device_select_sweep_config.block_threads, 0, stream>>>(
                d_in,
                d_flags,
                d_selected_out,
                d_num_selected_out,
                tile_status,
                select_op,
                equality_op,
                num_items,
                num_tiles,
                queue);


            if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 477)) break;


            if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 480))) break;
        }
        while (0);

        return error;


    }





    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        FlagsInputIterator d_flags,
        SelectedOutputIterator d_selected_out,
        NumSelectedIterator d_num_selected_out,
        SelectOp select_op,
        EqualityOp equality_op,
        Offset num_items,
        cudaStream_t stream,
        bool debug_synchronous)
    {
        cudaError error = cudaSuccess;
        do
        {

            int ptx_version;

            if (cub_::Debug((error = PtxVersion(ptx_version)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh", 513)) break;





            KernelConfig device_select_sweep_config;
            InitConfigs(ptx_version, device_select_sweep_config);


            if (cub_::Debug((error = Dispatch( d_temp_storage, temp_storage_bytes, d_in, d_flags, d_selected_out, d_num_selected_out, select_op, equality_op, num_items, stream, debug_synchronous, ptx_version, DeviceScanInitKernel<Offset, ScanTileState>, DeviceSelectSweepKernel<PtxRangeSelectPolicy, InputIterator, FlagsInputIterator, SelectedOutputIterator, NumSelectedIterator, ScanTileState, SelectOp, EqualityOp, Offset, KEEP_REJECTS>, device_select_sweep_config)),
# 538 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
# 523 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
                ,
# 538 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
 538
# 523 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
                )
# 538 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_select_dispatch.cuh"
                                            ) break;
        }
        while (0);

        return error;
    }
};


}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_partition.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 73 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_partition.cuh"
struct DevicePartition
{
# 121 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_partition.cuh"
    template <
        typename InputIterator,
        typename FlagIterator,
        typename OutputIterator,
        typename NumSelectedIterator>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Flagged(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        FlagIterator d_flags,
        OutputIterator d_out,
        NumSelectedIterator d_num_selected_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {
        typedef int Offset;
        typedef NullType SelectOp;
        typedef NullType EqualityOp;

        return DeviceSelectDispatch<InputIterator, FlagIterator, OutputIterator, NumSelectedIterator, SelectOp, EqualityOp, Offset, true>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_flags,
            d_out,
            d_num_selected_out,
            SelectOp(),
            EqualityOp(),
            num_items,
            stream,
            debug_synchronous);
    }
# 230 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_partition.cuh"
    template <
        typename InputIterator,
        typename OutputIterator,
        typename NumSelectedIterator,
        typename SelectOp>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t If(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        NumSelectedIterator d_num_selected_out,
        int num_items,
        SelectOp select_op,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {
        typedef int Offset;
        typedef NullType* FlagIterator;
        typedef NullType EqualityOp;

        return DeviceSelectDispatch<InputIterator, FlagIterator, OutputIterator, NumSelectedIterator, SelectOp, EqualityOp, Offset, true>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            __null,
            d_out,
            d_num_selected_out,
            select_op,
            EqualityOp(),
            num_items,
            stream,
            debug_synchronous);
    }

};






}
} } } }
# 52 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_radix_sort.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_radix_sort.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_upsweep.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_upsweep.cuh"
       
# 44 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_upsweep.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 56 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_upsweep.cuh"
template <
    int _BLOCK_THREADS,
    int _ITEMS_PER_THREAD,
    CacheLoadModifier _LOAD_MODIFIER,
    int _RADIX_BITS>
struct BlockRadixSortUpsweepPolicy
{
    enum
    {
        BLOCK_THREADS = _BLOCK_THREADS,
        ITEMS_PER_THREAD = _ITEMS_PER_THREAD,
        RADIX_BITS = _RADIX_BITS,
    };

    static const CacheLoadModifier LOAD_MODIFIER = _LOAD_MODIFIER;
};
# 81 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_upsweep.cuh"
template <
    typename BlockRadixSortUpsweepPolicy,
    typename Key,
    typename Offset>
struct BlockRadixSortUpsweep
{





    typedef typename Traits<Key>::UnsignedBits UnsignedBits;


    typedef unsigned char DigitCounter;


    typedef unsigned int PackedCounter;

    static const CacheLoadModifier LOAD_MODIFIER = BlockRadixSortUpsweepPolicy::LOAD_MODIFIER;

    enum
    {
        RADIX_BITS = BlockRadixSortUpsweepPolicy::RADIX_BITS,
        BLOCK_THREADS = BlockRadixSortUpsweepPolicy::BLOCK_THREADS,
        KEYS_PER_THREAD = BlockRadixSortUpsweepPolicy::ITEMS_PER_THREAD,

        RADIX_DIGITS = 1 << RADIX_BITS,

        LOG_WARP_THREADS = (5),
        WARP_THREADS = 1 << LOG_WARP_THREADS,
        WARPS = (BLOCK_THREADS + WARP_THREADS - 1) / WARP_THREADS,

        TILE_ITEMS = BLOCK_THREADS * KEYS_PER_THREAD,

        BYTES_PER_COUNTER = sizeof(DigitCounter),
        LOG_BYTES_PER_COUNTER = Log2<BYTES_PER_COUNTER>::VALUE,

        PACKING_RATIO = sizeof(PackedCounter) / sizeof(DigitCounter),
        LOG_PACKING_RATIO = Log2<PACKING_RATIO>::VALUE,

        LOG_COUNTER_LANES = (((RADIX_BITS - LOG_PACKING_RATIO) > (0)) ? (RADIX_BITS - LOG_PACKING_RATIO) : (0)),
        COUNTER_LANES = 1 << LOG_COUNTER_LANES,





        LANES_PER_WARP = ((((COUNTER_LANES + WARPS - 1) / WARPS) > (1)) ? ((COUNTER_LANES + WARPS - 1) / WARPS) : (1)),


        UNROLL_COUNT = (((255 / KEYS_PER_THREAD) < (64)) ? (255 / KEYS_PER_THREAD) : (64)),
        UNROLLED_ELEMENTS = UNROLL_COUNT * TILE_ITEMS,
    };



    typedef CacheModifiedInputIterator<LOAD_MODIFIER, UnsignedBits, Offset> KeysItr;




    struct _TempStorage
    {
        union
        {
            DigitCounter digit_counters[COUNTER_LANES][BLOCK_THREADS][PACKING_RATIO];
            PackedCounter packed_counters[COUNTER_LANES][BLOCK_THREADS];
            Offset digit_partials[RADIX_DIGITS][WARP_THREADS + 1];
        };
    };



    struct TempStorage : Uninitialized<_TempStorage> {};







    _TempStorage &temp_storage;


    Offset local_counts[LANES_PER_WARP][PACKING_RATIO];


    KeysItr d_keys_in;


    int current_bit;


    int num_bits;
# 184 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_upsweep.cuh"
    template <int COUNT, int MAX>
    struct Iterate
    {

        static __attribute__((device)) __inline__ __attribute__((always_inline)) void BucketKeys(
            BlockRadixSortUpsweep &cta,
            UnsignedBits keys[KEYS_PER_THREAD])
        {
            cta.Bucket(keys[COUNT]);


            Iterate<COUNT + 1, MAX>::BucketKeys(cta, keys);
        }
    };


    template <int MAX>
    struct Iterate<MAX, MAX>
    {

        static __attribute__((device)) __inline__ __attribute__((always_inline)) void BucketKeys(BlockRadixSortUpsweep &cta, UnsignedBits keys[KEYS_PER_THREAD]) {}
    };
# 215 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_upsweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Bucket(UnsignedBits key)
    {

        UnsignedBits converted_key = Traits<Key>::TwiddleIn(key);


        UnsignedBits digit = BFE(converted_key, current_bit, num_bits);


        UnsignedBits sub_counter = digit & (PACKING_RATIO - 1);


        UnsignedBits row_offset = digit >> LOG_PACKING_RATIO;


        temp_storage.digit_counters[row_offset][threadIdx.x][sub_counter]++;
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ResetDigitCounters()
    {
#pragma unroll
        for (int LANE = 0; LANE < COUNTER_LANES; LANE++)
        {
            temp_storage.packed_counters[LANE][threadIdx.x] = 0;
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ResetUnpackedCounters()
    {
#pragma unroll
        for (int LANE = 0; LANE < LANES_PER_WARP; LANE++)
        {
#pragma unroll
            for (int UNPACKED_COUNTER = 0; UNPACKED_COUNTER < PACKING_RATIO; UNPACKED_COUNTER++)
            {
                local_counts[LANE][UNPACKED_COUNTER] = 0;
            }
        }
    }






    __attribute__((device)) __inline__ __attribute__((always_inline)) void UnpackDigitCounts()
    {
        unsigned int warp_id = threadIdx.x >> LOG_WARP_THREADS;
        unsigned int warp_tid = threadIdx.x & (WARP_THREADS - 1);

#pragma unroll
        for (int LANE = 0; LANE < LANES_PER_WARP; LANE++)
        {
            const int counter_lane = (LANE * WARPS) + warp_id;
            if (counter_lane < COUNTER_LANES)
            {
#pragma unroll
                for (int PACKED_COUNTER = 0; PACKED_COUNTER < BLOCK_THREADS; PACKED_COUNTER += WARP_THREADS)
                {
#pragma unroll
                    for (int UNPACKED_COUNTER = 0; UNPACKED_COUNTER < PACKING_RATIO; UNPACKED_COUNTER++)
                    {
                        Offset counter = temp_storage.digit_counters[counter_lane][warp_tid + PACKED_COUNTER][UNPACKED_COUNTER];
                        local_counts[LANE][UNPACKED_COUNTER] += counter;
                    }
                }
            }
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ReduceUnpackedCounts(Offset &bin_count)
    {
        unsigned int warp_id = threadIdx.x >> LOG_WARP_THREADS;
        unsigned int warp_tid = threadIdx.x & (WARP_THREADS - 1);


#pragma unroll
        for (int LANE = 0; LANE < LANES_PER_WARP; LANE++)
        {
            int counter_lane = (LANE * WARPS) + warp_id;
            if (counter_lane < COUNTER_LANES)
            {
                int digit_row = counter_lane << LOG_PACKING_RATIO;

#pragma unroll
                for (int UNPACKED_COUNTER = 0; UNPACKED_COUNTER < PACKING_RATIO; UNPACKED_COUNTER++)
                {
                    temp_storage.digit_partials[digit_row + UNPACKED_COUNTER][warp_tid] =
                        local_counts[LANE][UNPACKED_COUNTER];
                }
            }
        }

        __syncthreads();


        if (threadIdx.x < RADIX_DIGITS)
        {
            bin_count = ThreadReduce<WARP_THREADS>(
                temp_storage.digit_partials[threadIdx.x],
                Sum());
        }
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ProcessFullTile(Offset block_offset)
    {

        UnsignedBits keys[KEYS_PER_THREAD];

        LoadDirectStriped<BLOCK_THREADS>(threadIdx.x, d_keys_in + block_offset, keys);


        __syncthreads();


        Iterate<0, KEYS_PER_THREAD>::BucketKeys(*this, keys);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ProcessPartialTile(
        Offset block_offset,
        const Offset &block_end)
    {

        block_offset += threadIdx.x;
        while (block_offset < block_end)
        {

            UnsignedBits key = d_keys_in[block_offset];
            Bucket(key);
            block_offset += BLOCK_THREADS;
        }
    }
# 376 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_upsweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockRadixSortUpsweep(
        TempStorage &temp_storage,
        Key *d_keys_in,
        int current_bit,
        int num_bits)
    :
        temp_storage(temp_storage.Alias()),
        d_keys_in(reinterpret_cast<UnsignedBits*>(d_keys_in)),
        current_bit(current_bit),
        num_bits(num_bits)
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ProcessRegion(
        Offset block_offset,
        const Offset &block_end,
        Offset &bin_count)
    {

        ResetDigitCounters();
        ResetUnpackedCounters();


        while (block_offset + UNROLLED_ELEMENTS <= block_end)
        {
            for (int i = 0; i < UNROLL_COUNT; ++i)
            {
                ProcessFullTile(block_offset);
                block_offset += TILE_ITEMS;
            }

            __syncthreads();


            UnpackDigitCounts();

            __syncthreads();


            ResetDigitCounters();
        }


        while (block_offset + TILE_ITEMS <= block_end)
        {
            ProcessFullTile(block_offset);
            block_offset += TILE_ITEMS;
        }


        ProcessPartialTile(
            block_offset,
            block_end);

        __syncthreads();


        UnpackDigitCounts();

        __syncthreads();


        ReduceUnpackedCounts(bin_count);
    }

};


}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_downsweep.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_downsweep.cuh"
       
# 47 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_downsweep.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 60 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_downsweep.cuh"
enum RadixSortScatterAlgorithm
{
    RADIX_SORT_SCATTER_DIRECT,
    RADIX_SORT_SCATTER_TWO_PHASE,
};





template <
    int _BLOCK_THREADS,
    int _ITEMS_PER_THREAD,
    BlockLoadAlgorithm _LOAD_ALGORITHM,
    CacheLoadModifier _LOAD_MODIFIER,
    bool _EXCHANGE_TIME_SLICING,
    bool _MEMOIZE_OUTER_SCAN,
    BlockScanAlgorithm _INNER_SCAN_ALGORITHM,
    RadixSortScatterAlgorithm _SCATTER_ALGORITHM,
    cudaSharedMemConfig _SMEM_CONFIG,
    int _RADIX_BITS>
struct BlockRadixSortDownsweepPolicy
{
    enum
    {
        BLOCK_THREADS = _BLOCK_THREADS,
        ITEMS_PER_THREAD = _ITEMS_PER_THREAD,
        EXCHANGE_TIME_SLICING = _EXCHANGE_TIME_SLICING,
        RADIX_BITS = _RADIX_BITS,
        MEMOIZE_OUTER_SCAN = _MEMOIZE_OUTER_SCAN,
    };

    static const BlockLoadAlgorithm LOAD_ALGORITHM = _LOAD_ALGORITHM;
    static const CacheLoadModifier LOAD_MODIFIER = _LOAD_MODIFIER;
    static const BlockScanAlgorithm INNER_SCAN_ALGORITHM = _INNER_SCAN_ALGORITHM;
    static const RadixSortScatterAlgorithm SCATTER_ALGORITHM = _SCATTER_ALGORITHM;
    static const cudaSharedMemConfig SMEM_CONFIG = _SMEM_CONFIG;
};
# 107 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_downsweep.cuh"
template <
    typename BlockRadixSortDownsweepPolicy,
    bool DESCENDING,
    typename Key,
    typename Value,
    typename Offset>
struct BlockRadixSortDownsweep
{





    typedef typename Traits<Key>::UnsignedBits UnsignedBits;

    static const UnsignedBits MIN_KEY = Traits<Key>::MIN_KEY;
    static const UnsignedBits MAX_KEY = Traits<Key>::MAX_KEY;

    static const BlockLoadAlgorithm LOAD_ALGORITHM = BlockRadixSortDownsweepPolicy::LOAD_ALGORITHM;
    static const CacheLoadModifier LOAD_MODIFIER = BlockRadixSortDownsweepPolicy::LOAD_MODIFIER;
    static const BlockScanAlgorithm INNER_SCAN_ALGORITHM = BlockRadixSortDownsweepPolicy::INNER_SCAN_ALGORITHM;
    static const RadixSortScatterAlgorithm SCATTER_ALGORITHM = BlockRadixSortDownsweepPolicy::SCATTER_ALGORITHM;
    static const cudaSharedMemConfig SMEM_CONFIG = BlockRadixSortDownsweepPolicy::SMEM_CONFIG;

    enum
    {
        BLOCK_THREADS = BlockRadixSortDownsweepPolicy::BLOCK_THREADS,
        ITEMS_PER_THREAD = BlockRadixSortDownsweepPolicy::ITEMS_PER_THREAD,
        EXCHANGE_TIME_SLICING = BlockRadixSortDownsweepPolicy::EXCHANGE_TIME_SLICING,
        RADIX_BITS = BlockRadixSortDownsweepPolicy::RADIX_BITS,
        MEMOIZE_OUTER_SCAN = BlockRadixSortDownsweepPolicy::MEMOIZE_OUTER_SCAN,
        TILE_ITEMS = BLOCK_THREADS * ITEMS_PER_THREAD,

        RADIX_DIGITS = 1 << RADIX_BITS,
        KEYS_ONLY = Equals<Value, NullType>::VALUE,

        WARP_THREADS = (5),
        WARPS = (BLOCK_THREADS + WARP_THREADS - 1) / WARP_THREADS,

        BYTES_PER_SIZET = sizeof(Offset),
        LOG_BYTES_PER_SIZET = Log2<BYTES_PER_SIZET>::VALUE,

        LOG_SMEM_BANKS = ((0 >= 200) ? (5) : (4)),
        SMEM_BANKS = 1 << LOG_SMEM_BANKS,

        DIGITS_PER_SCATTER_PASS = BLOCK_THREADS / SMEM_BANKS,
        SCATTER_PASSES = RADIX_DIGITS / DIGITS_PER_SCATTER_PASS,

        LOG_STORE_TXN_THREADS = LOG_SMEM_BANKS,
        STORE_TXN_THREADS = 1 << LOG_STORE_TXN_THREADS,
    };


    typedef CacheModifiedInputIterator<LOAD_MODIFIER, UnsignedBits, Offset> KeysItr;
    typedef CacheModifiedInputIterator<LOAD_MODIFIER, Value, Offset> ValuesItr;


    typedef BlockRadixRank<
        BLOCK_THREADS,
        RADIX_BITS,
        DESCENDING,
        MEMOIZE_OUTER_SCAN,
        INNER_SCAN_ALGORITHM,
        SMEM_CONFIG> BlockRadixRank;


    typedef BlockLoad<
        KeysItr,
        BLOCK_THREADS,
        ITEMS_PER_THREAD,
        LOAD_ALGORITHM,
        EXCHANGE_TIME_SLICING> BlockLoadKeys;


    typedef BlockLoad<
        ValuesItr,
        BLOCK_THREADS,
        ITEMS_PER_THREAD,
        LOAD_ALGORITHM,
        EXCHANGE_TIME_SLICING> BlockLoadValues;


    typedef BlockExchange<
        UnsignedBits,
        BLOCK_THREADS,
        ITEMS_PER_THREAD,
        EXCHANGE_TIME_SLICING> BlockExchangeKeys;


    typedef BlockExchange<
        Value,
        BLOCK_THREADS,
        ITEMS_PER_THREAD,
        EXCHANGE_TIME_SLICING> BlockExchangeValues;





    struct _TempStorage
    {
        Offset relative_bin_offsets[RADIX_DIGITS + 1];
        bool short_circuit;

        union
        {
            typename BlockRadixRank::TempStorage ranking;
            typename BlockLoadKeys::TempStorage load_keys;
            typename BlockLoadValues::TempStorage load_values;
            typename BlockExchangeKeys::TempStorage exchange_keys;
            typename BlockExchangeValues::TempStorage exchange_values;
        };
    };



    struct TempStorage : Uninitialized<_TempStorage> {};







    _TempStorage &temp_storage;


    KeysItr d_keys_in;
    ValuesItr d_values_in;
    UnsignedBits *d_keys_out;
    Value *d_values_out;


    Offset bin_offset;


    int current_bit;


    int num_bits;


    bool short_circuit;
# 260 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_downsweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void DecodeRelativeBinOffsets(
        UnsignedBits (&twiddled_keys)[ITEMS_PER_THREAD],
        Offset (&relative_bin_offsets)[ITEMS_PER_THREAD])
    {
#pragma unroll
        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
        {
            UnsignedBits digit = BFE(twiddled_keys[KEY], current_bit, num_bits);


            relative_bin_offsets[KEY] = temp_storage.relative_bin_offsets[digit];
        }
    }





    template <bool FULL_TILE, typename T>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterItems(
        T (&items)[ITEMS_PER_THREAD],
        int (&local_ranks)[ITEMS_PER_THREAD],
        Offset (&relative_bin_offsets)[ITEMS_PER_THREAD],
        T *d_out,
        Offset valid_items)
    {
#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
        {

            if (FULL_TILE || (local_ranks[ITEM] < valid_items))
            {
                d_out[relative_bin_offsets[ITEM] + local_ranks[ITEM]] = items[ITEM];
            }
        }
    }





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterKeys(
        UnsignedBits (&twiddled_keys)[ITEMS_PER_THREAD],
        Offset (&relative_bin_offsets)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        Offset valid_items,
        Int2Type<RADIX_SORT_SCATTER_DIRECT> scatter_algorithm)
    {

        DecodeRelativeBinOffsets(twiddled_keys, relative_bin_offsets);


        UnsignedBits keys[ITEMS_PER_THREAD];

#pragma unroll
        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
        {
            keys[KEY] = Traits<Key>::TwiddleOut(twiddled_keys[KEY]);
        }


        ScatterItems<FULL_TILE>(keys, ranks, relative_bin_offsets, d_keys_out, valid_items);
    }





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterKeys(
        UnsignedBits (&twiddled_keys)[ITEMS_PER_THREAD],
        Offset (&relative_bin_offsets)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        Offset valid_items,
        Int2Type<RADIX_SORT_SCATTER_TWO_PHASE> scatter_algorithm)
    {

        BlockExchangeKeys(temp_storage.exchange_keys).ScatterToStriped(twiddled_keys, ranks);


        int local_ranks[ITEMS_PER_THREAD];

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
        {
            local_ranks[ITEM] = threadIdx.x + (ITEM * BLOCK_THREADS);
        }


        ScatterKeys<FULL_TILE>(
            twiddled_keys,
            relative_bin_offsets,
            local_ranks,
            valid_items,
            Int2Type<RADIX_SORT_SCATTER_DIRECT>());
    }





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterValues(
        Value (&values)[ITEMS_PER_THREAD],
        Offset (&relative_bin_offsets)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        Offset valid_items,
        Int2Type<RADIX_SORT_SCATTER_DIRECT> scatter_algorithm)
    {

        ScatterItems<FULL_TILE>(values, ranks, relative_bin_offsets, d_values_out, valid_items);
    }





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterValues(
        Value (&values)[ITEMS_PER_THREAD],
        Offset (&relative_bin_offsets)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        Offset valid_items,
        Int2Type<RADIX_SORT_SCATTER_TWO_PHASE> scatter_algorithm)
    {
        __syncthreads();


        BlockExchangeValues(temp_storage.exchange_values).ScatterToStriped(values, ranks);


        int local_ranks[ITEMS_PER_THREAD];

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
        {
            local_ranks[ITEM] = threadIdx.x + (ITEM * BLOCK_THREADS);
        }


        ScatterValues<FULL_TILE>(
            values,
            relative_bin_offsets,
            local_ranks,
            valid_items,
            Int2Type<RADIX_SORT_SCATTER_DIRECT>());
    }





    template <typename BlockLoadT, typename T, typename InputIterator>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void LoadItems(
        BlockLoadT &block_loader,
        T (&items)[ITEMS_PER_THREAD],
        InputIterator d_in,
        Offset valid_items,
        Int2Type<true> is_full_tile)
    {
        block_loader.Load(d_in, items);
    }





    template <typename BlockLoadT, typename T, typename InputIterator>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void LoadItems(
        BlockLoadT &block_loader,
        T (&items)[ITEMS_PER_THREAD],
        InputIterator d_in,
        Offset valid_items,
        Int2Type<false> is_full_tile)
    {
        block_loader.Load(d_in, items, valid_items);
    }





    template <bool FULL_TILE, typename _Value>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void GatherScatterValues(
        _Value (&values)[ITEMS_PER_THREAD],
        Offset (&relative_bin_offsets)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        Offset block_offset,
        Offset valid_items)
    {
        __syncthreads();

        BlockLoadValues loader(temp_storage.load_values);
        LoadItems(
            loader,
            values,
            d_values_in + block_offset,
            valid_items,
            Int2Type<FULL_TILE>());

        ScatterValues<FULL_TILE>(
            values,
            relative_bin_offsets,
            ranks,
            valid_items,
            Int2Type<SCATTER_ALGORITHM>());
    }





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void GatherScatterValues(
        NullType (&values)[ITEMS_PER_THREAD],
        Offset (&relative_bin_offsets)[ITEMS_PER_THREAD],
        int (&ranks)[ITEMS_PER_THREAD],
        Offset block_offset,
        Offset valid_items)
    {}





    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ProcessTile(
        Offset block_offset,
        const Offset &valid_items = TILE_ITEMS)
    {

        UnsignedBits keys[ITEMS_PER_THREAD];
        UnsignedBits twiddled_keys[ITEMS_PER_THREAD];
        int ranks[ITEMS_PER_THREAD];
        Offset relative_bin_offsets[ITEMS_PER_THREAD];


#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
        {
            keys[ITEM] = (DESCENDING) ? MIN_KEY : MAX_KEY;
        }


        BlockLoadKeys loader(temp_storage.load_keys);
        LoadItems(
            loader,
            keys,
            d_keys_in + block_offset,
            valid_items,
            Int2Type<FULL_TILE>());

        __syncthreads();


#pragma unroll
        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
        {
            twiddled_keys[KEY] = Traits<Key>::TwiddleIn(keys[KEY]);
        }


        int inclusive_digit_prefix;
        BlockRadixRank(temp_storage.ranking).RankKeys(
            twiddled_keys,
            ranks,
            current_bit,
            num_bits,
            inclusive_digit_prefix);


        if ((BLOCK_THREADS == RADIX_DIGITS) || (threadIdx.x < RADIX_DIGITS))
        {
            int exclusive_digit_prefix;


            if (DESCENDING)
            {






                volatile int* exchange = reinterpret_cast<int *>(temp_storage.relative_bin_offsets);
                exchange[threadIdx.x + 1] = 0;
                exchange[threadIdx.x] = inclusive_digit_prefix;
                exclusive_digit_prefix = exchange[threadIdx.x + 1];

            }
            else
            {






                volatile int* exchange = reinterpret_cast<int *>(temp_storage.relative_bin_offsets);
                exchange[threadIdx.x] = 0;
                exchange[threadIdx.x + 1] = inclusive_digit_prefix;
                exclusive_digit_prefix = exchange[threadIdx.x];

            }

            bin_offset -= exclusive_digit_prefix;
            temp_storage.relative_bin_offsets[threadIdx.x] = bin_offset;
            bin_offset += inclusive_digit_prefix;
        }

        __syncthreads();


        ScatterKeys<FULL_TILE>(twiddled_keys, relative_bin_offsets, ranks, valid_items, Int2Type<SCATTER_ALGORITHM>());


        Value values[ITEMS_PER_THREAD];
        GatherScatterValues<FULL_TILE>(values, relative_bin_offsets, ranks, block_offset, valid_items);
    }





    template <
        typename InputIterator,
        typename T>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Copy(
        InputIterator d_in,
        T *d_out,
        Offset block_offset,
        Offset block_end)
    {

        while (block_offset + TILE_ITEMS <= block_end)
        {
            T items[ITEMS_PER_THREAD];

            LoadDirectStriped<BLOCK_THREADS>(threadIdx.x, d_in + block_offset, items);
            __syncthreads();
            StoreDirectStriped<BLOCK_THREADS>(threadIdx.x, d_out + block_offset, items);

            block_offset += TILE_ITEMS;
        }


        if (block_offset < block_end)
        {
            Offset valid_items = block_end - block_offset;

            T items[ITEMS_PER_THREAD];

            LoadDirectStriped<BLOCK_THREADS>(threadIdx.x, d_in + block_offset, items, valid_items);
            __syncthreads();
            StoreDirectStriped<BLOCK_THREADS>(threadIdx.x, d_out + block_offset, items, valid_items);
        }
    }





    template <typename InputIterator>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Copy(
        InputIterator d_in,
        NullType *d_out,
        Offset block_offset,
        Offset block_end)
    {}
# 639 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_radix_sort_downsweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockRadixSortDownsweep(
        TempStorage &temp_storage,
        Offset bin_offset,
        Key *d_keys_in,
        Key *d_keys_out,
        Value *d_values_in,
        Value *d_values_out,
        int current_bit,
        int num_bits)
    :
        temp_storage(temp_storage.Alias()),
        bin_offset(bin_offset),
        d_keys_in(reinterpret_cast<UnsignedBits*>(d_keys_in)),
        d_keys_out(reinterpret_cast<UnsignedBits*>(d_keys_out)),
        d_values_in(d_values_in),
        d_values_out(d_values_out),
        current_bit(current_bit),
        num_bits(num_bits),
        short_circuit(false)
    {}





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockRadixSortDownsweep(
        TempStorage &temp_storage,
        Offset num_items,
        Offset *d_spine,
        Key *d_keys_in,
        Key *d_keys_out,
        Value *d_values_in,
        Value *d_values_out,
        int current_bit,
        int num_bits)
    :
        temp_storage(temp_storage.Alias()),
        d_keys_in(reinterpret_cast<UnsignedBits*>(d_keys_in)),
        d_keys_out(reinterpret_cast<UnsignedBits*>(d_keys_out)),
        d_values_in(d_values_in),
        d_values_out(d_values_out),
        current_bit(current_bit),
        num_bits(num_bits)
    {

        if (threadIdx.x < RADIX_DIGITS)
        {
            int bin_idx = (DESCENDING) ?
                RADIX_DIGITS - threadIdx.x - 1 :
                threadIdx.x;


            Offset first_block_bin_offset = d_spine[gridDim.x * bin_idx];
            int predicate = ((first_block_bin_offset == 0) || (first_block_bin_offset == num_items));
            this->temp_storage.short_circuit = WarpAll(predicate);


            bin_offset = d_spine[(gridDim.x * bin_idx) + blockIdx.x];
        }

        __syncthreads();

        short_circuit = this->temp_storage.short_circuit;
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ProcessRegion(
        Offset block_offset,
        const Offset &block_end)
    {
        if (short_circuit)
        {

            Copy(d_keys_in, d_keys_out, block_offset, block_end);


            Copy(d_values_in, d_values_out, block_offset, block_end);
        }
        else
        {

            while (block_offset + TILE_ITEMS <= block_end)
            {
                ProcessTile<true>(block_offset);
                block_offset += TILE_ITEMS;

                __syncthreads();
            }


            if (block_offset < block_end)
            {
                ProcessTile<false>(block_offset, block_end - block_offset);
            }
        }
    }
};



}
} } } }
# 42 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh" 2







namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 61 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
template <
    typename BlockRadixSortUpsweepPolicy,
    bool DESCENDING,
    typename Key,
    typename Offset>
__attribute__((launch_bounds(int(BlockRadixSortUpsweepPolicy::BLOCK_THREADS))))
__attribute__((global)) void DeviceRadixSortUpsweepKernel(
    Key *d_keys,
    Offset *d_spine,
    Offset num_items,
    int current_bit,
    int num_bits,
    bool first_pass,
    GridEvenShare<Offset> even_share)
{

    typedef BlockRadixSortUpsweep<BlockRadixSortUpsweepPolicy, Key, Offset> BlockRadixSortUpsweepT;


    __attribute__((shared)) typename BlockRadixSortUpsweepT::TempStorage temp_storage;


    even_share.BlockInit();

    Offset bin_count;
    BlockRadixSortUpsweepT(temp_storage, d_keys, current_bit, num_bits).ProcessRegion(
        even_share.block_offset,
        even_share.block_end,
        bin_count);


    if (threadIdx.x < BlockRadixSortUpsweepT::RADIX_DIGITS)
    {
        int bin_idx = (DESCENDING) ?
            BlockRadixSortUpsweepT::RADIX_DIGITS - threadIdx.x - 1 :
            threadIdx.x;

        d_spine[(gridDim.x * bin_idx) + blockIdx.x] = bin_count;
    }
}





template <
    typename BlockScanSweepPolicy,
    typename Offset>
__attribute__((launch_bounds(int(BlockScanSweepPolicy::BLOCK_THREADS), 1)))
__attribute__((global)) void RadixSortScanBinsKernel(
    Offset *d_spine,
    int num_counts)
{

    typedef BlockScanSweep<BlockScanSweepPolicy, Offset*, Offset*, cub_::Sum, Offset, Offset> BlockScanSweepT;


    __attribute__((shared)) typename BlockScanSweepT::TempStorage temp_storage;

    if (blockIdx.x > 0) return;


    BlockScanSweepT block_scan(temp_storage, d_spine, d_spine, cub_::Sum(), Offset(0)) ;


    int block_offset = 0;
    BlockScanRunningPrefixOp<Offset, Sum> prefix_op(0, Sum());
    while (block_offset + BlockScanSweepT::TILE_ITEMS <= num_counts)
    {
        block_scan.ConsumeTile<true, false>(block_offset, prefix_op);
        block_offset += BlockScanSweepT::TILE_ITEMS;
    }
}





template <
    typename BlockRadixSortDownsweepPolicy,
    bool DESCENDING,
    typename Key,
    typename Value,
    typename Offset>
__attribute__((launch_bounds(int(BlockRadixSortDownsweepPolicy::BLOCK_THREADS))))
__attribute__((global)) void DeviceRadixSortDownsweepKernel(
    Key *d_keys_in,
    Key *d_keys_out,
    Value *d_values_in,
    Value *d_values_out,
    Offset *d_spine,
    Offset num_items,
    int current_bit,
    int num_bits,
    bool first_pass,
    bool last_pass,
    GridEvenShare<Offset> even_share)
{

    typedef BlockRadixSortDownsweep<BlockRadixSortDownsweepPolicy, DESCENDING, Key, Value, Offset> BlockRadixSortDownsweepT;


    __attribute__((shared)) typename BlockRadixSortDownsweepT::TempStorage temp_storage;


    even_share.BlockInit();


    BlockRadixSortDownsweepT(temp_storage, num_items, d_spine, d_keys_in, d_keys_out, d_values_in, d_values_out, current_bit, num_bits).ProcessRegion(
        even_share.block_offset,
        even_share.block_end);
}
# 183 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
template <
    bool DESCENDING,
    typename Key,
    typename Value,
    typename Offset>
struct DeviceRadixSortDispatch
{





    struct Policy350
    {
        enum {
            KEYS_ONLY = (Equals<Value, NullType>::VALUE),
            SCALE_FACTOR = ((((sizeof(Value)) > (sizeof(Key))) ? (sizeof(Value)) : (sizeof(Key))) + 3) / 4,
            RADIX_BITS = 5,
        };


        typedef BlockRadixSortUpsweepPolicy <64, (((18 / SCALE_FACTOR) > (1)) ? (18 / SCALE_FACTOR) : (1)), LOAD_LDG, RADIX_BITS> UpsweepPolicyKeys;
        typedef BlockRadixSortUpsweepPolicy <128, (((15 / SCALE_FACTOR) > (1)) ? (15 / SCALE_FACTOR) : (1)), LOAD_LDG, RADIX_BITS> UpsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, UpsweepPolicyKeys, UpsweepPolicyPairs>::Type UpsweepPolicy;


        typedef BlockRadixSortUpsweepPolicy <64, (((22 / SCALE_FACTOR) > (1)) ? (22 / SCALE_FACTOR) : (1)), LOAD_LDG, RADIX_BITS - 1> AltUpsweepPolicyKeys;
        typedef BlockRadixSortUpsweepPolicy <128, (((15 / SCALE_FACTOR) > (1)) ? (15 / SCALE_FACTOR) : (1)), LOAD_LDG, RADIX_BITS - 1> AltUpsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, AltUpsweepPolicyKeys, AltUpsweepPolicyPairs>::Type AltUpsweepPolicy;


        typedef BlockScanSweepPolicy <1024, 4, BLOCK_LOAD_VECTORIZE, false, LOAD_DEFAULT, BLOCK_STORE_VECTORIZE, false, BLOCK_SCAN_WARP_SCANS> ScanPolicy;


        typedef BlockRadixSortDownsweepPolicy <64, (((18 / SCALE_FACTOR) > (1)) ? (18 / SCALE_FACTOR) : (1)), BLOCK_LOAD_DIRECT, LOAD_LDG, false, true, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeEightByte, RADIX_BITS> DownsweepPolicyKeys;
        typedef BlockRadixSortDownsweepPolicy <128, (((15 / SCALE_FACTOR) > (1)) ? (15 / SCALE_FACTOR) : (1)), BLOCK_LOAD_DIRECT, LOAD_LDG, false, true, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeEightByte, RADIX_BITS> DownsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, DownsweepPolicyKeys, DownsweepPolicyPairs>::Type DownsweepPolicy;


        typedef BlockRadixSortDownsweepPolicy <128, (((11 / SCALE_FACTOR) > (1)) ? (11 / SCALE_FACTOR) : (1)), BLOCK_LOAD_DIRECT, LOAD_LDG, false, true, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeEightByte, RADIX_BITS - 1> AltDownsweepPolicyKeys;
        typedef BlockRadixSortDownsweepPolicy <128, (((15 / SCALE_FACTOR) > (1)) ? (15 / SCALE_FACTOR) : (1)), BLOCK_LOAD_DIRECT, LOAD_LDG, false, true, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeEightByte, RADIX_BITS - 1> AltDownsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, AltDownsweepPolicyKeys, AltDownsweepPolicyPairs>::Type AltDownsweepPolicy;
    };



    struct Policy300
    {
        enum {
            KEYS_ONLY = (Equals<Value, NullType>::VALUE),
            SCALE_FACTOR = ((((sizeof(Value)) > (sizeof(Key))) ? (sizeof(Value)) : (sizeof(Key))) + 3) / 4,
            RADIX_BITS = 5,
        };


        typedef BlockRadixSortUpsweepPolicy <256, (((7 / SCALE_FACTOR) > (1)) ? (7 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS> UpsweepPolicyKeys;
        typedef BlockRadixSortUpsweepPolicy <256, (((5 / SCALE_FACTOR) > (1)) ? (5 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS> UpsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, UpsweepPolicyKeys, UpsweepPolicyPairs>::Type UpsweepPolicy;


        typedef BlockRadixSortUpsweepPolicy <256, (((7 / SCALE_FACTOR) > (1)) ? (7 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS - 1> AltUpsweepPolicyKeys;
        typedef BlockRadixSortUpsweepPolicy <256, (((5 / SCALE_FACTOR) > (1)) ? (5 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS - 1> AltUpsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, AltUpsweepPolicyKeys, AltUpsweepPolicyPairs>::Type AltUpsweepPolicy;


        typedef BlockScanSweepPolicy <1024, 4, BLOCK_LOAD_VECTORIZE, false, LOAD_DEFAULT, BLOCK_STORE_VECTORIZE, false, BLOCK_SCAN_RAKING_MEMOIZE> ScanPolicy;


        typedef BlockRadixSortDownsweepPolicy <128, (((14 / SCALE_FACTOR) > (1)) ? (14 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeEightByte, RADIX_BITS> DownsweepPolicyKeys;
        typedef BlockRadixSortDownsweepPolicy <128, (((10 / SCALE_FACTOR) > (1)) ? (10 / SCALE_FACTOR) : (1)), BLOCK_LOAD_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeEightByte, RADIX_BITS> DownsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, DownsweepPolicyKeys, DownsweepPolicyPairs>::Type DownsweepPolicy;


        typedef BlockRadixSortDownsweepPolicy <128, (((14 / SCALE_FACTOR) > (1)) ? (14 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeEightByte, RADIX_BITS - 1> AltDownsweepPolicyKeys;
        typedef BlockRadixSortDownsweepPolicy <128, (((10 / SCALE_FACTOR) > (1)) ? (10 / SCALE_FACTOR) : (1)), BLOCK_LOAD_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeEightByte, RADIX_BITS - 1> AltDownsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, AltDownsweepPolicyKeys, AltDownsweepPolicyPairs>::Type AltDownsweepPolicy;
    };



    struct Policy200
    {
        enum {
            KEYS_ONLY = (Equals<Value, NullType>::VALUE),
            SCALE_FACTOR = ((((sizeof(Value)) > (sizeof(Key))) ? (sizeof(Value)) : (sizeof(Key))) + 3) / 4,
            RADIX_BITS = 5,
        };


        typedef BlockRadixSortUpsweepPolicy <64, (((18 / SCALE_FACTOR) > (1)) ? (18 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS> UpsweepPolicyKeys;
        typedef BlockRadixSortUpsweepPolicy <128, (((13 / SCALE_FACTOR) > (1)) ? (13 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS> UpsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, UpsweepPolicyKeys, UpsweepPolicyPairs>::Type UpsweepPolicy;


        typedef BlockRadixSortUpsweepPolicy <64, (((18 / SCALE_FACTOR) > (1)) ? (18 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS - 1> AltUpsweepPolicyKeys;
        typedef BlockRadixSortUpsweepPolicy <128, (((13 / SCALE_FACTOR) > (1)) ? (13 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS - 1> AltUpsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, AltUpsweepPolicyKeys, AltUpsweepPolicyPairs>::Type AltUpsweepPolicy;


        typedef BlockScanSweepPolicy <512, 4, BLOCK_LOAD_VECTORIZE, false, LOAD_DEFAULT, BLOCK_STORE_VECTORIZE, false, BLOCK_SCAN_RAKING_MEMOIZE> ScanPolicy;


        typedef BlockRadixSortDownsweepPolicy <64, (((18 / SCALE_FACTOR) > (1)) ? (18 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS> DownsweepPolicyKeys;
        typedef BlockRadixSortDownsweepPolicy <128, (((13 / SCALE_FACTOR) > (1)) ? (13 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS> DownsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, DownsweepPolicyKeys, DownsweepPolicyPairs>::Type DownsweepPolicy;


        typedef BlockRadixSortDownsweepPolicy <64, (((18 / SCALE_FACTOR) > (1)) ? (18 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS - 1> AltDownsweepPolicyKeys;
        typedef BlockRadixSortDownsweepPolicy <128, (((13 / SCALE_FACTOR) > (1)) ? (13 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS - 1> AltDownsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, AltDownsweepPolicyKeys, AltDownsweepPolicyPairs>::Type AltDownsweepPolicy;
    };



    struct Policy130
    {
        enum {
            KEYS_ONLY = (Equals<Value, NullType>::VALUE),
            SCALE_FACTOR = ((((sizeof(Value)) > (sizeof(Key))) ? (sizeof(Value)) : (sizeof(Key))) + 3) / 4,
            RADIX_BITS = 5,
        };


        typedef BlockRadixSortUpsweepPolicy <128, (((19 / SCALE_FACTOR) > (1)) ? (19 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS> UpsweepPolicyKeys;
        typedef BlockRadixSortUpsweepPolicy <128, (((19 / SCALE_FACTOR) > (1)) ? (19 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS> UpsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, UpsweepPolicyKeys, UpsweepPolicyPairs>::Type UpsweepPolicy;


        typedef BlockRadixSortUpsweepPolicy <128, (((15 / SCALE_FACTOR) > (1)) ? (15 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS - 1> AltUpsweepPolicyKeys;
        typedef BlockRadixSortUpsweepPolicy <128, (((15 / SCALE_FACTOR) > (1)) ? (15 / SCALE_FACTOR) : (1)), LOAD_DEFAULT, RADIX_BITS - 1> AltUpsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, AltUpsweepPolicyKeys, AltUpsweepPolicyPairs>::Type AltUpsweepPolicy;


        typedef BlockScanSweepPolicy <256, 4, BLOCK_LOAD_VECTORIZE, false, LOAD_DEFAULT, BLOCK_STORE_VECTORIZE, false, BLOCK_SCAN_WARP_SCANS> ScanPolicy;


        typedef BlockRadixSortDownsweepPolicy <64, (((19 / SCALE_FACTOR) > (1)) ? (19 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS> DownsweepPolicyKeys;
        typedef BlockRadixSortDownsweepPolicy <64, (((19 / SCALE_FACTOR) > (1)) ? (19 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS> DownsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, DownsweepPolicyKeys, DownsweepPolicyPairs>::Type DownsweepPolicy;


        typedef BlockRadixSortDownsweepPolicy <128, (((15 / SCALE_FACTOR) > (1)) ? (15 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS - 1> AltDownsweepPolicyKeys;
        typedef BlockRadixSortDownsweepPolicy <128, (((15 / SCALE_FACTOR) > (1)) ? (15 / SCALE_FACTOR) : (1)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS - 1> AltDownsweepPolicyPairs;
        typedef typename If<KEYS_ONLY, AltDownsweepPolicyKeys, AltDownsweepPolicyPairs>::Type AltDownsweepPolicy;
    };



    struct Policy100
    {
        enum {
            RADIX_BITS = 4,
        };


        typedef BlockRadixSortUpsweepPolicy <64, 9, LOAD_DEFAULT, RADIX_BITS> UpsweepPolicy;


        typedef BlockRadixSortUpsweepPolicy <64, 9, LOAD_DEFAULT, RADIX_BITS - 1> AltUpsweepPolicy;


        typedef BlockScanSweepPolicy <256, 4, BLOCK_LOAD_VECTORIZE, false, LOAD_DEFAULT, BLOCK_STORE_VECTORIZE, false, BLOCK_SCAN_RAKING_MEMOIZE> ScanPolicy;


        typedef BlockRadixSortDownsweepPolicy <64, 9, BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS> DownsweepPolicy;


        typedef BlockRadixSortDownsweepPolicy <64, 9, BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, false, false, BLOCK_SCAN_WARP_SCANS, RADIX_SORT_SCATTER_TWO_PHASE, cudaSharedMemBankSizeFourByte, RADIX_BITS - 1> AltDownsweepPolicy;
    };
# 371 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
    typedef Policy100 PtxPolicy;




    struct PtxUpsweepPolicy : PtxPolicy::UpsweepPolicy {};
    struct PtxAltUpsweepPolicy : PtxPolicy::AltUpsweepPolicy {};
    struct PtxScanPolicy : PtxPolicy::ScanPolicy {};
    struct PtxDownsweepPolicy : PtxPolicy::DownsweepPolicy {};
    struct PtxAltDownsweepPolicy : PtxPolicy::AltDownsweepPolicy {};
# 390 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
    template <
        typename Policy,
        typename KernelConfig,
        typename UpsweepKernelPtr,
        typename ScanKernelPtr,
        typename DownsweepKernelPtr>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t InitConfigs(
        int sm_version,
        int sm_count,
        KernelConfig &upsweep_config,
        KernelConfig &alt_upsweep_config,
        KernelConfig &scan_config,
        KernelConfig &downsweep_config,
        KernelConfig &alt_downsweep_config,
        UpsweepKernelPtr upsweep_kernel,
        UpsweepKernelPtr alt_upsweep_kernel,
        ScanKernelPtr scan_kernel,
        DownsweepKernelPtr downsweep_kernel,
        DownsweepKernelPtr alt_downsweep_kernel)
    {
        cudaError_t error;
        do {
            if (cub_::Debug((error = upsweep_config.template InitUpsweepPolicy<typename Policy::UpsweepPolicy>( sm_version, sm_count, upsweep_kernel)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 413)) break;
            if (cub_::Debug((error = alt_upsweep_config.template InitUpsweepPolicy<typename Policy::AltUpsweepPolicy>( sm_version, sm_count, alt_upsweep_kernel)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 414)) break;
            if (cub_::Debug((error = scan_config.template InitScanPolicy<typename Policy::ScanPolicy>( sm_version, sm_count, scan_kernel)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 415)) break;
            if (cub_::Debug((error = downsweep_config.template InitDownsweepPolicy<typename Policy::DownsweepPolicy>( sm_version, sm_count, downsweep_kernel)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 416)) break;
            if (cub_::Debug((error = alt_downsweep_config.template InitDownsweepPolicy<typename Policy::AltDownsweepPolicy>( sm_version, sm_count, alt_downsweep_kernel)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 417)) break;

        } while (0);

        return error;
    }





    template <
        typename KernelConfig,
        typename UpsweepKernelPtr,
        typename ScanKernelPtr,
        typename DownsweepKernelPtr>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t InitConfigs(
        int ptx_version,
        int sm_version,
        int sm_count,
        KernelConfig &upsweep_config,
        KernelConfig &alt_upsweep_config,
        KernelConfig &scan_config,
        KernelConfig &downsweep_config,
        KernelConfig &alt_downsweep_config,
        UpsweepKernelPtr upsweep_kernel,
        UpsweepKernelPtr alt_upsweep_kernel,
        ScanKernelPtr scan_kernel,
        DownsweepKernelPtr downsweep_kernel,
        DownsweepKernelPtr alt_downsweep_kernel)
    {
# 468 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
        cudaError_t error;
        if (ptx_version >= 350)
        {
            error = InitConfigs<Policy350>(sm_version, sm_count, upsweep_config, alt_upsweep_config, scan_config, downsweep_config, alt_downsweep_config, upsweep_kernel, alt_upsweep_kernel, scan_kernel, downsweep_kernel, alt_downsweep_kernel);
        }
        else if (ptx_version >= 300)
        {
            error = InitConfigs<Policy300>(sm_version, sm_count, upsweep_config, alt_upsweep_config, scan_config, downsweep_config, alt_downsweep_config, upsweep_kernel, alt_upsweep_kernel, scan_kernel, downsweep_kernel, alt_downsweep_kernel);
        }
        else if (ptx_version >= 200)
        {
            error = InitConfigs<Policy200>(sm_version, sm_count, upsweep_config, alt_upsweep_config, scan_config, downsweep_config, alt_downsweep_config, upsweep_kernel, alt_upsweep_kernel, scan_kernel, downsweep_kernel, alt_downsweep_kernel);
        }
        else if (ptx_version >= 130)
        {
            error = InitConfigs<Policy130>(sm_version, sm_count, upsweep_config, alt_upsweep_config, scan_config, downsweep_config, alt_downsweep_config, upsweep_kernel, alt_upsweep_kernel, scan_kernel, downsweep_kernel, alt_downsweep_kernel);
        }
        else
        {
            error = InitConfigs<Policy100>(sm_version, sm_count, upsweep_config, alt_upsweep_config, scan_config, downsweep_config, alt_downsweep_config, upsweep_kernel, alt_upsweep_kernel, scan_kernel, downsweep_kernel, alt_downsweep_kernel);
        }

        return error;


    }






    struct KernelConfig
    {
        int block_threads;
        int items_per_thread;
        int tile_size;
        cudaSharedMemConfig smem_config;
        int radix_bits;
        int sm_occupancy;
        int max_grid_size;
        int subscription_factor;

        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) KernelConfig()
          : block_threads(0), items_per_thread(0), tile_size(0), smem_config(cudaSharedMemBankSizeDefault), radix_bits(0), sm_occupancy(0), max_grid_size(0), subscription_factor(0)
        {
        }

        template <typename UpsweepPolicy, typename UpsweepKernelPtr>
        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t InitUpsweepPolicy(
            int sm_version, int sm_count, UpsweepKernelPtr upsweep_kernel)
        {
            block_threads = UpsweepPolicy::BLOCK_THREADS;
            items_per_thread = UpsweepPolicy::ITEMS_PER_THREAD;
            radix_bits = UpsweepPolicy::RADIX_BITS;
            smem_config = cudaSharedMemBankSizeFourByte;
            tile_size = block_threads * items_per_thread;
            cudaError_t retval = MaxSmOccupancy(sm_occupancy, sm_version, upsweep_kernel, block_threads);
            subscription_factor = ((sm_version >= 300) ? (5) : ((sm_version >= 200) ? (3) : (10)));
            max_grid_size = (sm_occupancy * sm_count) * subscription_factor;

            return retval;
        }

        template <typename ScanPolicy, typename ScanKernelPtr>
        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t InitScanPolicy(
            int sm_version, int sm_count, ScanKernelPtr scan_kernel)
        {
            block_threads = ScanPolicy::BLOCK_THREADS;
            items_per_thread = ScanPolicy::ITEMS_PER_THREAD;
            radix_bits = 0;
            smem_config = cudaSharedMemBankSizeFourByte;
            tile_size = block_threads * items_per_thread;
            sm_occupancy = 1;
            subscription_factor = 1;
            max_grid_size = 1;

            return cudaSuccess;
        }

        template <typename DownsweepPolicy, typename DownsweepKernelPtr>
        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) cudaError_t InitDownsweepPolicy(
            int sm_version, int sm_count, DownsweepKernelPtr downsweep_kernel)
        {
            block_threads = DownsweepPolicy::BLOCK_THREADS;
            items_per_thread = DownsweepPolicy::ITEMS_PER_THREAD;
            radix_bits = DownsweepPolicy::RADIX_BITS;
            smem_config = DownsweepPolicy::SMEM_CONFIG;
            tile_size = block_threads * items_per_thread;
            cudaError_t retval = MaxSmOccupancy(sm_occupancy, sm_version, downsweep_kernel, block_threads);
            subscription_factor = ((sm_version >= 300) ? (5) : ((sm_version >= 200) ? (3) : (10)));
            max_grid_size = (sm_occupancy * sm_count) * subscription_factor;

            return retval;
        }
    };






    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t AllocateTemporaries(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        Offset* &d_spine,
        KernelConfig &scan_config,
        KernelConfig &downsweep_config)
    {
        cudaError error = cudaSuccess;
        do
        {

            int spine_size = (downsweep_config.max_grid_size * (1 << downsweep_config.radix_bits)) + scan_config.tile_size;


            void* allocations[1];
            size_t allocation_sizes[1] =
            {
                spine_size * sizeof(Offset),
            };


            if (cub_::Debug((error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 592)) break;


            if (d_temp_storage == __null)
                return cudaSuccess;


            d_spine = (Offset*) allocations[0];

        } while(0);

        return error;
    }
# 615 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
    template <
        typename UpsweepKernelPtr,
        typename ScanKernelPtr,
        typename DownsweepKernelPtr>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        DoubleBuffer<Key> &d_keys,
        DoubleBuffer<Value> &d_values,
        Offset *d_spine,
        int spine_size,
        Offset num_items,
        int begin_bit,
        int end_bit,
        cudaStream_t stream,
        bool debug_synchronous,
        KernelConfig &upsweep_config,
        KernelConfig &scan_config,
        KernelConfig &downsweep_config,
        UpsweepKernelPtr upsweep_kernel,
        ScanKernelPtr scan_kernel,
        DownsweepKernelPtr downsweep_kernel)
    {







        cudaError error = cudaSuccess;
        do
        {

            GridEvenShare<Offset> even_share(num_items, downsweep_config.max_grid_size, (((upsweep_config.tile_size) > (downsweep_config.tile_size)) ? (upsweep_config.tile_size) : (downsweep_config.tile_size)));



            cudaSharedMemConfig original_smem_config;
            if (cub_::Debug((error = cudaDeviceGetSharedMemConfig(&original_smem_config)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 653)) break;
            cudaSharedMemConfig current_smem_config = original_smem_config;


            int current_bit = begin_bit;
            while (current_bit < end_bit)
            {
                int num_bits = (((downsweep_config.radix_bits) < (end_bit - current_bit)) ? (downsweep_config.radix_bits) : (end_bit - current_bit));



                if (current_smem_config != upsweep_config.smem_config)
                {
                    if (cub_::Debug((error = cudaDeviceSetSharedMemConfig(upsweep_config.smem_config)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 666)) break;
                    current_smem_config = upsweep_config.smem_config;
                }



                if (debug_synchronous)
                    printf("Invoking upsweep_kernel<<<%d, %d, 0, %lld>>>(), %d smem config, %d items per thread, %d SM occupancy, selector %d, current bit %d, bit_grain %d\n",even_share.grid_size, upsweep_config.block_threads, (long long) stream, upsweep_config.smem_config, upsweep_config.items_per_thread, upsweep_config.sm_occupancy, d_keys.selector, current_bit, downsweep_config.radix_bits);
                                                                                                                                                                                                                                                ;


                upsweep_kernel<<<even_share.grid_size, upsweep_config.block_threads, 0, stream>>>(
                    d_keys.d_buffers[d_keys.selector],
                    d_spine,
                    num_items,
                    current_bit,
                    num_bits,
                    (current_bit == begin_bit),
                    even_share);


                if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 687)) break;


                if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 690))) break;


                if (debug_synchronous) printf("Invoking scan_kernel<<<%d, %d, 0, %lld>>>(), %d items per thread\n",1, scan_config.block_threads, (long long) stream, scan_config.items_per_thread);
                                                                                                   ;


                scan_kernel<<<1, scan_config.block_threads, 0, stream>>>(
                    d_spine,
                    spine_size);


                if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 702)) break;


                if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 705))) break;




                if (current_smem_config != downsweep_config.smem_config)
                {
                    if (cub_::Debug((error = cudaDeviceSetSharedMemConfig(downsweep_config.smem_config)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 712)) break;
                    current_smem_config = downsweep_config.smem_config;
                }


                if (debug_synchronous) printf("Invoking downsweep_kernel<<<%d, %d, 0, %lld>>>(), %d smem config, %d items per thread, %d SM occupancy\n",even_share.grid_size, downsweep_config.block_threads, (long long) stream, downsweep_config.smem_config, downsweep_config.items_per_thread, downsweep_config.sm_occupancy);
                                                                                                                                                                                             ;


                downsweep_kernel<<<even_share.grid_size, downsweep_config.block_threads, 0, stream>>>(
                    d_keys.d_buffers[d_keys.selector],
                    d_keys.d_buffers[d_keys.selector ^ 1],
                    d_values.d_buffers[d_values.selector],
                    d_values.d_buffers[d_values.selector ^ 1],
                    d_spine,
                    num_items,
                    current_bit,
                    num_bits,
                    (current_bit == begin_bit),
                    (current_bit + downsweep_config.radix_bits >= end_bit),
                    even_share);


                if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 735)) break;


                if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 738))) break;


                d_keys.selector ^= 1;
                d_values.selector ^= 1;


                current_bit += downsweep_config.radix_bits;
            }



            if (current_smem_config != original_smem_config)
            {
                if (cub_::Debug((error = cudaDeviceSetSharedMemConfig(original_smem_config)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 752)) break;
            }


        }
        while (0);

        return error;


    }





    template <
        typename UpsweepKernelPtr,
        typename ScanKernelPtr,
        typename DownsweepKernelPtr>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        DoubleBuffer<Key> &d_keys,
        DoubleBuffer<Value> &d_values,
        Offset num_items,
        int begin_bit,
        int end_bit,
        cudaStream_t stream,
        bool debug_synchronous,
        UpsweepKernelPtr upsweep_kernel,
        UpsweepKernelPtr alt_upsweep_kernel,
        ScanKernelPtr scan_kernel,
        DownsweepKernelPtr downsweep_kernel,
        DownsweepKernelPtr alt_downsweep_kernel)
    {







        cudaError error = cudaSuccess;

        do
        {

            int ptx_version;

            if (cub_::Debug((error = PtxVersion(ptx_version)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 803)) break;





            int device_ordinal;
            if (cub_::Debug((error = cudaGetDevice(&device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 810)) break;


            int sm_version;
            if (cub_::Debug((error = SmVersion(sm_version, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 814)) break;


            int sm_count;
            if (cub_::Debug((error = cudaDeviceGetAttribute (&sm_count, cudaDevAttrMultiProcessorCount, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 818)) break;


            KernelConfig upsweep_config;
            KernelConfig alt_upsweep_config;
            KernelConfig scan_config;
            KernelConfig downsweep_config;
            KernelConfig alt_downsweep_config;

            if (cub_::Debug((error = InitConfigs(ptx_version, sm_version, sm_count, upsweep_config, alt_upsweep_config, scan_config, downsweep_config, alt_downsweep_config, upsweep_kernel, alt_upsweep_kernel, scan_kernel, downsweep_kernel, alt_downsweep_kernel)),

 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
# 827 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
                ,

 829
# 827 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
                )

                                                                                                         ) break;


            int spine_size = (downsweep_config.max_grid_size * (1 << downsweep_config.radix_bits)) + scan_config.tile_size;
            int alt_spine_size = (alt_downsweep_config.max_grid_size * (1 << alt_downsweep_config.radix_bits)) + scan_config.tile_size;


            Offset *d_spine = 0;
            if (spine_size > alt_spine_size)
            {
                if (cub_::Debug((error = AllocateTemporaries(d_temp_storage, temp_storage_bytes, d_spine, scan_config, downsweep_config)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 839)) break;
            }
            else
            {
                if (cub_::Debug((error = AllocateTemporaries(d_temp_storage, temp_storage_bytes, d_spine, scan_config, alt_downsweep_config)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh", 843)) break;
            }


            if (d_temp_storage == __null)
                return cudaSuccess;


            int num_bits = end_bit - begin_bit;
            int remaining_bits = num_bits % downsweep_config.radix_bits;

            if (remaining_bits != 0)
            {

                int max_alt_passes = downsweep_config.radix_bits - remaining_bits;
                int alt_end_bit = (((begin_bit + (max_alt_passes * alt_downsweep_config.radix_bits)) < (end_bit)) ? (begin_bit + (max_alt_passes * alt_downsweep_config.radix_bits)) : (end_bit));

                if (cub_::Debug((error = Dispatch( d_keys, d_values, d_spine, alt_spine_size, num_items, begin_bit, alt_end_bit, stream, debug_synchronous, alt_upsweep_config, scan_config, alt_downsweep_config, alt_upsweep_kernel, scan_kernel, alt_downsweep_kernel)),
# 875 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
# 860 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
                    ,
# 875 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
 875
# 860 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
                    )
# 875 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
                                          ) break;

                begin_bit = alt_end_bit;
            }


            if (cub_::Debug((error = Dispatch( d_keys, d_values, d_spine, spine_size, num_items, begin_bit, end_bit, stream, debug_synchronous, upsweep_config, scan_config, downsweep_config, upsweep_kernel, scan_kernel, downsweep_kernel)),
# 896 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
# 881 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
                ,
# 896 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
 896
# 881 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
                )
# 896 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_radix_sort_dispatch.cuh"
                                  ) break;
        }
        while (0);

        return error;


    }






    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        DoubleBuffer<Key> &d_keys,
        DoubleBuffer<Value> &d_values,
        Offset num_items,
        int begin_bit,
        int end_bit,
        cudaStream_t stream,
        bool debug_synchronous)
    {
        return Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_keys,
            d_values,
            num_items,
            begin_bit,
            end_bit,
            stream,
            debug_synchronous,
            DeviceRadixSortUpsweepKernel<PtxUpsweepPolicy, DESCENDING, Key, Offset>,
            DeviceRadixSortUpsweepKernel<PtxAltUpsweepPolicy, DESCENDING, Key, Offset>,
            RadixSortScanBinsKernel<PtxScanPolicy, Offset>,
            DeviceRadixSortDownsweepKernel<PtxDownsweepPolicy, DESCENDING, Key, Value, Offset>,
            DeviceRadixSortDownsweepKernel<PtxAltDownsweepPolicy, DESCENDING, Key, Value, Offset>);
    }

};

}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_radix_sort.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 81 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_radix_sort.cuh"
struct DeviceRadixSort
{
# 140 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_radix_sort.cuh"
    template <
        typename Key,
        typename Value>
    __attribute__((host)) __attribute__((device))
    static cudaError_t SortPairs(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        DoubleBuffer<Key> &d_keys,
        DoubleBuffer<Value> &d_values,
        int num_items,
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;

        return DeviceRadixSortDispatch<false, Key, Value, Offset>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_keys,
            d_values,
            num_items,
            begin_bit,
            end_bit,
            stream,
            debug_synchronous);
    }
# 223 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_radix_sort.cuh"
    template <
        typename Key,
        typename Value>
    __attribute__((host)) __attribute__((device))
    static cudaError_t SortPairsDescending(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        DoubleBuffer<Key> &d_keys,
        DoubleBuffer<Value> &d_values,
        int num_items,
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;

        return DeviceRadixSortDispatch<true, Key, Value, Offset>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_keys,
            d_values,
            num_items,
            begin_bit,
            end_bit,
            stream,
            debug_synchronous);
    }
# 304 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_radix_sort.cuh"
    template <typename Key>
    __attribute__((host)) __attribute__((device))
    static cudaError_t SortKeys(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        DoubleBuffer<Key> &d_keys,
        int num_items,
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        DoubleBuffer<NullType> d_values;

        return DeviceRadixSortDispatch<false, Key, NullType, Offset>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_keys,
            d_values,
            num_items,
            begin_bit,
            end_bit,
            stream,
            debug_synchronous);
    }
# 381 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_radix_sort.cuh"
    template <typename Key>
    __attribute__((host)) __attribute__((device))
    static cudaError_t SortKeysDescending(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        DoubleBuffer<Key> &d_keys,
        int num_items,
        int begin_bit = 0,
        int end_bit = sizeof(Key) * 8,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        DoubleBuffer<NullType> d_values;

        return DeviceRadixSortDispatch<true, Key, NullType, Offset>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_keys,
            d_values,
            num_items,
            begin_bit,
            end_bit,
            stream,
            debug_synchronous);
    }

};





}
} } } }
# 53 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
       




# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_sweep.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_sweep.cuh"
       
# 49 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_sweep.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 62 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_sweep.cuh"
template <
    int _BLOCK_THREADS,
    int _ITEMS_PER_THREAD,
    int _VECTOR_LOAD_LENGTH,
    BlockReduceAlgorithm _BLOCK_ALGORITHM,
    CacheLoadModifier _LOAD_MODIFIER,
    GridMappingStrategy _GRID_MAPPING>
struct BlockReduceSweepPolicy
{
    enum
    {
        BLOCK_THREADS = _BLOCK_THREADS,
        ITEMS_PER_THREAD = _ITEMS_PER_THREAD,
        VECTOR_LOAD_LENGTH = _VECTOR_LOAD_LENGTH,
    };

    static const BlockReduceAlgorithm BLOCK_ALGORITHM = _BLOCK_ALGORITHM;
    static const CacheLoadModifier LOAD_MODIFIER = _LOAD_MODIFIER;
    static const GridMappingStrategy GRID_MAPPING = _GRID_MAPPING;
};
# 96 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_sweep.cuh"
template <
    typename BlockReduceSweepPolicy,
    typename InputIterator,
    typename Offset,
    typename ReductionOp>
struct BlockReduceSweep
{






    typedef typename std::iterator_traits<InputIterator>::value_type T;


    typedef typename CubVector<T, BlockReduceSweepPolicy::VECTOR_LOAD_LENGTH>::Type VectorT;


    typedef typename If<IsPointer<InputIterator>::VALUE,
            CacheModifiedInputIterator<BlockReduceSweepPolicy::LOAD_MODIFIER, T, Offset>,
            InputIterator>::Type
        WrappedInputIterator;


    enum
    {
        BLOCK_THREADS = BlockReduceSweepPolicy::BLOCK_THREADS,
        ITEMS_PER_THREAD = BlockReduceSweepPolicy::ITEMS_PER_THREAD,
        VECTOR_LOAD_LENGTH = (((BlockReduceSweepPolicy::VECTOR_LOAD_LENGTH) < (ITEMS_PER_THREAD)) ? (BlockReduceSweepPolicy::VECTOR_LOAD_LENGTH) : (ITEMS_PER_THREAD)),
        TILE_ITEMS = BLOCK_THREADS * ITEMS_PER_THREAD,


        CAN_VECTORIZE = (VECTOR_LOAD_LENGTH > 1) &&
                                (IsPointer<InputIterator>::VALUE) &&
                                Traits<T>::PRIMITIVE,

    };

    static const CacheLoadModifier LOAD_MODIFIER = BlockReduceSweepPolicy::LOAD_MODIFIER;
    static const BlockReduceAlgorithm BLOCK_ALGORITHM = BlockReduceSweepPolicy::BLOCK_ALGORITHM;


    typedef BlockReduce<T, BLOCK_THREADS, BlockReduceSweepPolicy::BLOCK_ALGORITHM> BlockReduceT;


    typedef typename BlockReduceT::TempStorage _TempStorage;


    struct TempStorage : Uninitialized<_TempStorage> {};






    T thread_aggregate;
    _TempStorage& temp_storage;
    InputIterator d_in;
    WrappedInputIterator d_wrapped_in;
    ReductionOp reduction_op;
    int first_tile_size;
    bool is_aligned;
# 167 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_sweep.cuh"
    template <typename Iterator>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) bool IsAligned(
        Iterator d_in,
        Int2Type<true> can_vectorize)
    {
        return (size_t(d_in) & (sizeof(VectorT) - 1)) == 0;
    }


    template <typename Iterator>
    static __attribute__((device)) __inline__ __attribute__((always_inline)) bool IsAligned(
        Iterator d_in,
        Int2Type<false> can_vectorize)
    {
        return false;
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) BlockReduceSweep(
        TempStorage& temp_storage,
        InputIterator d_in,
        ReductionOp reduction_op)
    :
        temp_storage(temp_storage.Alias()),
        d_in(d_in),
        d_wrapped_in(d_in),
        reduction_op(reduction_op),
        first_tile_size(0),
        is_aligned(IsAligned(d_in, Int2Type<CAN_VECTORIZE>()))
    {}





    template <typename _Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T ConsumeFullTile(
        _Offset block_offset,
        Int2Type<false> can_vectorize)
    {
        T items[ITEMS_PER_THREAD];


        LoadDirectStriped<BLOCK_THREADS>(threadIdx.x, d_wrapped_in + block_offset, items);


        return ThreadReduce(items, reduction_op);
    }





    template <typename _Offset>
    __attribute__((device)) __inline__ __attribute__((always_inline)) T ConsumeFullTile(
        _Offset block_offset,
        Int2Type<true> can_vectorize)
    {
        if (!is_aligned)
        {

            return ConsumeFullTile(block_offset, Int2Type<false>());
        }
        else
        {

            enum { WORDS = ITEMS_PER_THREAD / VECTOR_LOAD_LENGTH };

            T items[ITEMS_PER_THREAD];

            VectorT *vec_items = reinterpret_cast<VectorT*>(items);


            CacheModifiedInputIterator<BlockReduceSweepPolicy::LOAD_MODIFIER, VectorT, Offset> d_vec_in(
                reinterpret_cast<VectorT*>(d_in + block_offset + (threadIdx.x * VECTOR_LOAD_LENGTH)));

#pragma unroll
            for (int i = 0; i < WORDS; ++i)
                vec_items[i] = d_vec_in[BLOCK_THREADS * i];


            return ThreadReduce(items, reduction_op);
        }
    }






    template <bool FULL_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeTile(
        Offset block_offset,
        int valid_items = TILE_ITEMS)
    {
        if (FULL_TILE)
        {

            T partial = ConsumeFullTile(block_offset, Int2Type<CAN_VECTORIZE>());


            thread_aggregate = (first_tile_size) ?
                reduction_op(thread_aggregate, partial) :
                partial;
        }
        else
        {

            int thread_offset = threadIdx.x;

            if (!first_tile_size && (thread_offset < valid_items))
            {

                thread_aggregate = d_wrapped_in[block_offset + thread_offset];
                thread_offset += BLOCK_THREADS;
            }

            while (thread_offset < valid_items)
            {

                T item = d_wrapped_in[block_offset + thread_offset];
                thread_aggregate = reduction_op(thread_aggregate, item);
                thread_offset += BLOCK_THREADS;
            }
        }


        if (!first_tile_size)
            first_tile_size = valid_items;
    }
# 309 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_sweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        Offset block_offset,
        Offset block_end,
        T &block_aggregate)
    {

        while (block_offset + TILE_ITEMS <= block_end)
        {
            ConsumeTile<true>(block_offset);
            block_offset += TILE_ITEMS;
        }


        if (block_offset < block_end)
        {
            int valid_items = block_end - block_offset;
            ConsumeTile<false>(block_offset, valid_items);
        }


        block_aggregate = (first_tile_size < TILE_ITEMS) ?
            BlockReduceT(temp_storage).Reduce(thread_aggregate, reduction_op, first_tile_size) :
            BlockReduceT(temp_storage).Reduce(thread_aggregate, reduction_op);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        Offset num_items,
        GridEvenShare<Offset> &even_share,
        GridQueue<Offset> &queue,
        T &block_aggregate,
        Int2Type<GRID_MAPPING_EVEN_SHARE> is_even_share)
    {

        even_share.BlockInit();


        ConsumeRange(even_share.block_offset, even_share.block_end, block_aggregate);
    }
# 360 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_sweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        int num_items,
        GridQueue<Offset> queue,
        T &block_aggregate)
    {

        __attribute__((shared)) Offset dequeue_offset;


        Offset block_offset = blockIdx.x * TILE_ITEMS;
        Offset even_share_base = gridDim.x * TILE_ITEMS;

        if (block_offset + TILE_ITEMS <= num_items)
        {

            ConsumeTile<true>(block_offset);


            while (true)
            {

                if (threadIdx.x == 0)
                    dequeue_offset = queue.Drain(TILE_ITEMS) + even_share_base;

                __syncthreads();


                block_offset = dequeue_offset;

                __syncthreads();

                if (block_offset + TILE_ITEMS > num_items)
                    break;


                ConsumeTile<true>(block_offset);
            }
        }

        if (block_offset < num_items)
        {
            int valid_items = num_items - block_offset;
            ConsumeTile<false>(block_offset, valid_items);
        }


        block_aggregate = (first_tile_size < TILE_ITEMS) ?
            BlockReduceT(temp_storage).Reduce(thread_aggregate, reduction_op, first_tile_size) :
            BlockReduceT(temp_storage).Reduce(thread_aggregate, reduction_op);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        Offset num_items,
        GridEvenShare<Offset> &even_share,
        GridQueue<Offset> &queue,
        T &block_aggregate,
        Int2Type<GRID_MAPPING_DYNAMIC> is_dynamic)
    {
        ConsumeRange(num_items, queue, block_aggregate);
    }

};


}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../iterator/constant_input_iterator.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../iterator/constant_input_iterator.cuh"
       
# 51 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../iterator/constant_input_iterator.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 93 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../iterator/constant_input_iterator.cuh"
template <
    typename ValueType,
    typename Offset = ptrdiff_t>
class ConstantInputIterator
{
public:


    typedef ConstantInputIterator self_type;
    typedef Offset difference_type;
    typedef ValueType value_type;
    typedef ValueType* pointer;
    typedef ValueType reference;



    typedef typename thrust::detail::iterator_facade_category<
        thrust::any_system_tag,
        thrust::random_access_traversal_tag,
        value_type,
        reference
      >::type iterator_category;




private:

    ValueType val;
    Offset offset;




public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) ConstantInputIterator(
        ValueType val,
        Offset offset = 0)
    :
        val(val),
        offset(offset)
    {}


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++(int)
    {
        self_type retval = *this;
        offset++;
        return retval;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++()
    {
        offset++;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator*() const
    {
        return val;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator+(Distance n) const
    {
        self_type retval(val, offset + n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator+=(Distance n)
    {
        offset += n;
        return *this;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator-(Distance n) const
    {
        self_type retval(val, offset - n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator-=(Distance n)
    {
        offset -= n;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) difference_type operator-(self_type other) const
    {
        return offset - other.offset;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator[](Distance n) const
    {
        return val;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) pointer operator->()
    {
        return &val;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator==(const self_type& rhs)
    {
        return (offset == rhs.offset) && ((val == rhs.val));
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator!=(const self_type& rhs)
    {
        return (offset != rhs.offset) || (val!= rhs.val);
    }


    friend std::ostream& operator<<(std::ostream& os, const self_type& itr)
    {
        os << "[" << itr.val << "," << itr.offset << "]";
        return os;
    }

};




}
} } } }
# 42 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh" 2



# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../iterator/arg_index_input_iterator.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../iterator/arg_index_input_iterator.cuh"
       
# 53 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../iterator/arg_index_input_iterator.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 108 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../iterator/arg_index_input_iterator.cuh"
template <
    typename InputIterator,
    typename Offset = ptrdiff_t>
class ArgIndexInputIterator
{
private:


    typedef typename std::iterator_traits<InputIterator>::value_type T;

public:



    typedef ArgIndexInputIterator self_type;
    typedef Offset difference_type;
    typedef ItemOffsetPair<T, difference_type> value_type;
    typedef value_type* pointer;
    typedef value_type reference;



    typedef typename thrust::detail::iterator_facade_category<
        thrust::any_system_tag,
        thrust::random_access_traversal_tag,
        value_type,
        reference
      >::type iterator_category;




private:

    InputIterator itr;
    difference_type offset;

public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) ArgIndexInputIterator(
        InputIterator itr,
        difference_type offset = 0)
    :
        itr(itr),
        offset(offset)
    {}


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++(int)
    {
        self_type retval = *this;
        offset++;
        return retval;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++()
    {
        offset++;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator*() const
    {
        value_type retval;
        retval.value = itr[offset];
        retval.offset = offset;
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator+(Distance n) const
    {
        self_type retval(itr, offset + n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator+=(Distance n)
    {
        offset += n;
        return *this;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator-(Distance n) const
    {
        self_type retval(itr, offset - n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator-=(Distance n)
    {
        offset -= n;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) difference_type operator-(self_type other) const
    {
        return offset - other.offset;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator[](Distance n) const
    {
        return *(*this + n);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) pointer operator->()
    {
        return &(*(*this));
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator==(const self_type& rhs)
    {
        return ((itr == rhs.itr) && (offset == rhs.offset));
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator!=(const self_type& rhs)
    {
        return ((itr != rhs.itr) || (offset != rhs.offset));
    }


    friend std::ostream& operator<<(std::ostream& os, const self_type& itr)
    {
        return os;
    }
};





}
} } } }
# 46 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh" 2





namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 63 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
template <
    typename BlockReduceSweepPolicy,
    typename InputIterator,
    typename OutputIterator,
    typename Offset,
    typename ReductionOp>
__attribute__((launch_bounds(int(BlockReduceSweepPolicy::BLOCK_THREADS))))
__attribute__((global)) void DeviceReduceSweepKernel(
    InputIterator d_in,
    OutputIterator d_out,
    Offset num_items,
    GridEvenShare<Offset> even_share,
    GridQueue<Offset> queue,
    ReductionOp reduction_op)
{

    typedef typename std::iterator_traits<InputIterator>::value_type T;


    typedef BlockReduceSweep<BlockReduceSweepPolicy, InputIterator, Offset, ReductionOp> BlockReduceSweepT;


    T block_aggregate;


    __attribute__((shared)) typename BlockReduceSweepT::TempStorage temp_storage;


    BlockReduceSweepT(temp_storage, d_in, reduction_op).ConsumeRange(
        num_items,
        even_share,
        queue,
        block_aggregate,
        Int2Type<BlockReduceSweepPolicy::GRID_MAPPING>());


    if (threadIdx.x == 0)
    {
        d_out[blockIdx.x] = block_aggregate;
    }
}





template <
    typename BlockReduceSweepPolicy,
    typename InputIterator,
    typename OutputIterator,
    typename Offset,
    typename ReductionOp>
__attribute__((launch_bounds(int(BlockReduceSweepPolicy::BLOCK_THREADS), 1)))
__attribute__((global)) void SingleReduceSweepKernel(
    InputIterator d_in,
    OutputIterator d_out,
    Offset num_items,
    ReductionOp reduction_op)
{

    typedef typename std::iterator_traits<InputIterator>::value_type T;


    typedef BlockReduceSweep<BlockReduceSweepPolicy, InputIterator, Offset, ReductionOp> BlockReduceSweepT;


    T block_aggregate;


    __attribute__((shared)) typename BlockReduceSweepT::TempStorage temp_storage;


    BlockReduceSweepT(temp_storage, d_in, reduction_op).ConsumeRange(
        Offset(0),
        Offset(num_items),
        block_aggregate);


    if (threadIdx.x == 0)
    {
        d_out[blockIdx.x] = block_aggregate;
    }
}
# 157 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
template <
    typename InputIterator,
    typename OutputIterator,
    typename Offset,
    typename ReductionOp>
struct DeviceReduceDispatch
{

    typedef typename std::iterator_traits<InputIterator>::value_type T;







    struct Policy350
    {

        typedef BlockReduceSweepPolicy<
                128,
                24,
                4,
                BLOCK_REDUCE_RAKING,
                LOAD_LDG,
                GRID_MAPPING_DYNAMIC>
            RangeReducePolicy1B;

        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 20,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };


        typedef BlockReduceSweepPolicy<
                256,
                ITEMS_PER_THREAD,
                2,
                BLOCK_REDUCE_RAKING,
                LOAD_LDG,
                GRID_MAPPING_DYNAMIC>
            RangeReducePolicy4B;


        typedef typename If<(sizeof(T) >= 4),
            RangeReducePolicy4B,
            RangeReducePolicy1B>::Type RangeReducePolicy;


        typedef BlockReduceSweepPolicy<
                256,
                8,
                1,
                BLOCK_REDUCE_WARP_REDUCTIONS,
                LOAD_DEFAULT,
                GRID_MAPPING_EVEN_SHARE>
            SingleTilePolicy;
    };


    struct Policy300
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 2,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };


        typedef BlockReduceSweepPolicy<
                256,
                ITEMS_PER_THREAD,
                1,
                BLOCK_REDUCE_WARP_REDUCTIONS,
                LOAD_DEFAULT,
                GRID_MAPPING_EVEN_SHARE>
            RangeReducePolicy;


        typedef BlockReduceSweepPolicy<
                256,
                24,
                4,
                BLOCK_REDUCE_WARP_REDUCTIONS,
                LOAD_DEFAULT,
                GRID_MAPPING_EVEN_SHARE>
            SingleTilePolicy;
    };


    struct Policy200
    {

        typedef BlockReduceSweepPolicy<
                192,
                24,
                4,
                BLOCK_REDUCE_RAKING,
                LOAD_DEFAULT,
                (sizeof(T) == 1) ?
                    GRID_MAPPING_EVEN_SHARE :
                    GRID_MAPPING_DYNAMIC>
            RangeReducePolicy1B;

        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 8,
            NOMINAL_4B_VEC_ITEMS = 4,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
            VEC_ITEMS = (((((((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_VEC_ITEMS)) ? (((((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_VEC_ITEMS)),
        };


        typedef BlockReduceSweepPolicy<
                128,
                ITEMS_PER_THREAD,
                VEC_ITEMS,
                BLOCK_REDUCE_RAKING,
                LOAD_DEFAULT,
                GRID_MAPPING_DYNAMIC>
            RangeReducePolicy4B;


        typedef typename If<(sizeof(T) < 4),
            RangeReducePolicy1B,
            RangeReducePolicy4B>::Type RangeReducePolicy;


        typedef BlockReduceSweepPolicy<
                192,
                7,
                1,
                BLOCK_REDUCE_RAKING,
                LOAD_DEFAULT,
                GRID_MAPPING_EVEN_SHARE>
            SingleTilePolicy;
    };


    struct Policy130
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 8,
            NOMINAL_4B_VEC_ITEMS = 2,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
            VEC_ITEMS = (((((((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_VEC_ITEMS)) ? (((((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_VEC_ITEMS)),
        };


        typedef BlockReduceSweepPolicy<
                128,
                ITEMS_PER_THREAD,
                VEC_ITEMS,
                BLOCK_REDUCE_RAKING,
                LOAD_DEFAULT,
                GRID_MAPPING_EVEN_SHARE>
            RangeReducePolicy;


        typedef BlockReduceSweepPolicy<
                32,
                4,
                VEC_ITEMS,
                BLOCK_REDUCE_RAKING,
                LOAD_DEFAULT,
                GRID_MAPPING_EVEN_SHARE>
            SingleTilePolicy;
    };


    struct Policy100
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 8,
            NOMINAL_4B_VEC_ITEMS = 2,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
            VEC_ITEMS = (((((((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) : (1))) < (NOMINAL_4B_VEC_ITEMS)) ? (((((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) > (1)) ? ((NOMINAL_4B_VEC_ITEMS * 4 / sizeof(T))) : (1))) : (NOMINAL_4B_VEC_ITEMS)),
        };


        typedef BlockReduceSweepPolicy<
                128,
                ITEMS_PER_THREAD,
                VEC_ITEMS,
                BLOCK_REDUCE_RAKING,
                LOAD_DEFAULT,
                GRID_MAPPING_EVEN_SHARE>
            RangeReducePolicy;


        typedef BlockReduceSweepPolicy<
                32,
                4,
                4,
                BLOCK_REDUCE_RAKING,
                LOAD_DEFAULT,
                GRID_MAPPING_EVEN_SHARE>
            SingleTilePolicy;
    };
# 373 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
    typedef Policy100 PtxPolicy;




    struct PtxRangeReducePolicy : PtxPolicy::RangeReducePolicy {};
    struct PtxSingleTilePolicy : PtxPolicy::SingleTilePolicy {};
# 389 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
    template <typename KernelConfig>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static void InitConfigs(
        int ptx_version,
        KernelConfig &device_reduce_sweep_config,
        KernelConfig &single_reduce_sweep_config)
    {
# 405 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
        if (ptx_version >= 350)
        {
            device_reduce_sweep_config.template Init<typename Policy350::RangeReducePolicy>();
            single_reduce_sweep_config.template Init<typename Policy350::SingleTilePolicy>();
        }
        else if (ptx_version >= 300)
        {
            device_reduce_sweep_config.template Init<typename Policy300::RangeReducePolicy>();
            single_reduce_sweep_config.template Init<typename Policy300::SingleTilePolicy>();
        }
        else if (ptx_version >= 200)
        {
            device_reduce_sweep_config.template Init<typename Policy200::RangeReducePolicy>();
            single_reduce_sweep_config.template Init<typename Policy200::SingleTilePolicy>();
        }
        else if (ptx_version >= 130)
        {
            device_reduce_sweep_config.template Init<typename Policy130::RangeReducePolicy>();
            single_reduce_sweep_config.template Init<typename Policy130::SingleTilePolicy>();
        }
        else
        {
            device_reduce_sweep_config.template Init<typename Policy100::RangeReducePolicy>();
            single_reduce_sweep_config.template Init<typename Policy100::SingleTilePolicy>();
        }


    }





    struct KernelConfig
    {
        int block_threads;
        int items_per_thread;
        int vector_load_length;
        BlockReduceAlgorithm block_algorithm;
        CacheLoadModifier load_modifier;
        GridMappingStrategy grid_mapping;

        template <typename BlockPolicy>
        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Init()
        {
            block_threads = BlockPolicy::BLOCK_THREADS;
            items_per_thread = BlockPolicy::ITEMS_PER_THREAD;
            vector_load_length = BlockPolicy::VECTOR_LOAD_LENGTH;
            block_algorithm = BlockPolicy::BLOCK_ALGORITHM;
            load_modifier = BlockPolicy::LOAD_MODIFIER;
            grid_mapping = BlockPolicy::GRID_MAPPING;
        }

        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Print()
        {
            printf("%d threads, %d per thread, %d veclen, %d algo, %d loadmod, %d mapping",
                block_threads,
                items_per_thread,
                vector_load_length,
                block_algorithm,
                load_modifier,
                grid_mapping);
        }
    };
# 483 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
    template <
        typename DeviceReduceSweepKernelPtr,
        typename SingleReducePartialsKernelPtr,
        typename SingleReduceSweepKernelPtr,
        typename FillAndResetDrainKernelPtr>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        Offset num_items,
        ReductionOp reduction_op,
        cudaStream_t stream,
        bool debug_synchronous,
        FillAndResetDrainKernelPtr prepare_drain_kernel,
        DeviceReduceSweepKernelPtr device_reduce_sweep_kernel,
        SingleReducePartialsKernelPtr single_reduce_partials_kernel,
        SingleReduceSweepKernelPtr single_reduce_sweep_kernel,
        KernelConfig device_reduce_sweep_config,
        KernelConfig single_reduce_sweep_config)
    {






        cudaError error = cudaSuccess;
        do
        {

            int device_ordinal;
            if (cub_::Debug((error = cudaGetDevice(&device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 516)) break;


            int sm_version;
            if (cub_::Debug((error = SmVersion(sm_version, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 520)) break;


            int sm_count;
            if (cub_::Debug((error = cudaDeviceGetAttribute (&sm_count, cudaDevAttrMultiProcessorCount, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 524)) break;


            int tile_size = device_reduce_sweep_config.block_threads * device_reduce_sweep_config.items_per_thread;

            if ((device_reduce_sweep_kernel == __null) || (num_items <= tile_size))
            {



                if (d_temp_storage == __null)
                {
                    temp_storage_bytes = 1;
                    return cudaSuccess;
                }


                if (debug_synchronous) printf("Invoking ReduceSingle<<<1, %d, 0, %lld>>>(), %d items per thread\n",single_reduce_sweep_config.block_threads, (long long) stream, single_reduce_sweep_config.items_per_thread);
                                                                                                                              ;


                single_reduce_sweep_kernel<<<1, single_reduce_sweep_config.block_threads>>>(
                    d_in,
                    d_out,
                    num_items,
                    reduction_op);


                if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 552)) break;


                if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 555))) break;

            }
            else
            {





                int range_reduce_sm_occupancy;
                if (cub_::Debug((error = MaxSmOccupancy( range_reduce_sm_occupancy, sm_version, device_reduce_sweep_kernel, device_reduce_sweep_config.block_threads)),



 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
# 566 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
                    ,



 570
# 566 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
                    )



                                                              ) break;


                int range_reduce_occupancy = range_reduce_sm_occupancy * sm_count;


                int subscription_factor = range_reduce_sm_occupancy;
                GridEvenShare<Offset> even_share(
                    num_items,
                    range_reduce_occupancy * subscription_factor,
                    tile_size);


                int range_reduce_grid_size;
                switch (device_reduce_sweep_config.grid_mapping)
                {
                case GRID_MAPPING_EVEN_SHARE:


                    range_reduce_grid_size = even_share.grid_size;
                    break;

                case GRID_MAPPING_DYNAMIC:


                    int num_tiles = (num_items + tile_size - 1) / tile_size;
                    range_reduce_grid_size = (num_tiles < range_reduce_occupancy) ?
                        num_tiles :
                        range_reduce_occupancy;
                    break;
                };


                void* allocations[2];
                size_t allocation_sizes[2] =
                {
                    range_reduce_grid_size * sizeof(T),
                    GridQueue<int>::AllocationSize()
                };


                if (cub_::Debug((error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 611)) break;
                if (d_temp_storage == __null)
                {

                    return cudaSuccess;
                }


                T *d_block_reductions = (T*) allocations[0];


                GridQueue<Offset> queue(allocations[1]);


                if (device_reduce_sweep_config.grid_mapping == GRID_MAPPING_DYNAMIC)
                {

                    if (debug_synchronous) printf("Invoking prepare_drain_kernel<<<1, 1, 0, %lld>>>()\n",(long long) stream);;


                    prepare_drain_kernel<<<1, 1, 0, stream>>>(queue, num_items);


                    if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 634)) break;


                    if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 637))) break;
                }


                if (debug_synchronous) printf("Invoking device_reduce_sweep_kernel<<<%d, %d, 0, %lld>>>(), %d items per thread, %d SM occupancy\n",range_reduce_grid_size, device_reduce_sweep_config.block_threads, (long long) stream, device_reduce_sweep_config.items_per_thread, range_reduce_sm_occupancy);
                                                                                                                                                                                 ;


                device_reduce_sweep_kernel<<<range_reduce_grid_size, device_reduce_sweep_config.block_threads, 0, stream>>>(
                    d_in,
                    d_block_reductions,
                    num_items,
                    even_share,
                    queue,
                    reduction_op);


                if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 654)) break;


                if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 657))) break;


                if (debug_synchronous) printf("Invoking single_reduce_sweep_kernel<<<%d, %d, 0, %lld>>>(), %d items per thread\n",1, single_reduce_sweep_config.block_threads, (long long) stream, single_reduce_sweep_config.items_per_thread);
                                                                                                                                 ;


                single_reduce_partials_kernel<<<1, single_reduce_sweep_config.block_threads, 0, stream>>>(
                    d_block_reductions,
                    d_out,
                    range_reduce_grid_size,
                    reduction_op);


                if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 671)) break;


                if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 674))) break;
            }
        }
        while (0);

        return error;


    }





    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        Offset num_items,
        ReductionOp reduction_op,
        cudaStream_t stream,
        bool debug_synchronous)
    {
        cudaError error = cudaSuccess;
        do
        {

            int ptx_version;

            if (cub_::Debug((error = PtxVersion(ptx_version)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh", 705)) break;





            KernelConfig device_reduce_sweep_config;
            KernelConfig single_reduce_sweep_config;
            InitConfigs(ptx_version, device_reduce_sweep_config, single_reduce_sweep_config);


            if (cub_::Debug((error = Dispatch( d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, reduction_op, stream, debug_synchronous, FillAndResetDrainKernel<Offset>, DeviceReduceSweepKernel<PtxRangeReducePolicy, InputIterator, T*, Offset, ReductionOp>, SingleReduceSweepKernel<PtxSingleTilePolicy, T*, OutputIterator, Offset, ReductionOp>, SingleReduceSweepKernel<PtxSingleTilePolicy, InputIterator, OutputIterator, Offset, ReductionOp>, device_reduce_sweep_config, single_reduce_sweep_config)),
# 730 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
# 716 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
                ,
# 730 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
 730
# 716 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
                )
# 730 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_dispatch.cuh"
                                            ) break;
        }
        while (0);

        return error;
    }
};


}
} } } }
# 41 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
       





# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh"
       
# 50 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 63 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh"
template <
    int _BLOCK_THREADS,
    int _ITEMS_PER_THREAD,
    BlockLoadAlgorithm _LOAD_ALGORITHM,
    CacheLoadModifier _LOAD_MODIFIER,
    bool _TWO_PHASE_SCATTER,
    BlockScanAlgorithm _SCAN_ALGORITHM>
struct BlockReduceSweepByKeyPolicy
{
    enum
    {
        BLOCK_THREADS = _BLOCK_THREADS,
        ITEMS_PER_THREAD = _ITEMS_PER_THREAD,
        TWO_PHASE_SCATTER = _TWO_PHASE_SCATTER,
    };

    static const BlockLoadAlgorithm LOAD_ALGORITHM = _LOAD_ALGORITHM;
    static const CacheLoadModifier LOAD_MODIFIER = _LOAD_MODIFIER;
    static const BlockScanAlgorithm SCAN_ALGORITHM = _SCAN_ALGORITHM;
};
# 92 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh"
template <
    typename BlockReduceSweepByKeyPolicy,
    typename KeysInputIterator,
    typename UniqueOutputIterator,
    typename ValuesInputIterator,
    typename AggregatesOutputIterator,
    typename EqualityOp,
    typename ReductionOp,
    typename Offset>
struct BlockReduceSweepByKey
{





    typedef typename std::iterator_traits<KeysInputIterator>::value_type Key;


    typedef typename std::iterator_traits<ValuesInputIterator>::value_type Value;


    typedef ItemOffsetPair<Value, Offset> ReductionOffsetPair;


    typedef ReduceByKeyScanTileState<Value, Offset> ScanTileState;


    enum
    {
        BLOCK_THREADS = BlockReduceSweepByKeyPolicy::BLOCK_THREADS,
        WARPS = BLOCK_THREADS / (1 << (5)),
        ITEMS_PER_THREAD = BlockReduceSweepByKeyPolicy::ITEMS_PER_THREAD,
        TWO_PHASE_SCATTER = (BlockReduceSweepByKeyPolicy::TWO_PHASE_SCATTER) && (ITEMS_PER_THREAD > 1),
        TILE_ITEMS = BLOCK_THREADS * ITEMS_PER_THREAD,


        HAS_IDENTITY_ZERO = (Equals<ReductionOp, cub_::Sum>::VALUE) && (Traits<Value>::PRIMITIVE),


        SYNC_AFTER_LOAD = (BlockReduceSweepByKeyPolicy::LOAD_ALGORITHM != BLOCK_LOAD_DIRECT),


        IS_RUN_LENGTH_ENCODE = (Equals<ValuesInputIterator, ConstantInputIterator<Value, size_t> >::VALUE) || (Equals<ValuesInputIterator, ConstantInputIterator<Value, int> >::VALUE) || (Equals<ValuesInputIterator, ConstantInputIterator<Value, unsigned int> >::VALUE),

    };


    typedef typename If<IsPointer<KeysInputIterator>::VALUE,
            CacheModifiedInputIterator<BlockReduceSweepByKeyPolicy::LOAD_MODIFIER, Key, Offset>,
            KeysInputIterator>::Type
        WrappedKeysInputIterator;


    typedef typename If<IsPointer<ValuesInputIterator>::VALUE,
            CacheModifiedInputIterator<BlockReduceSweepByKeyPolicy::LOAD_MODIFIER, Value, Offset>,
            ValuesInputIterator>::Type
        WrappedValuesInputIterator;


    typedef ReduceBySegmentOp<ReductionOp, ReductionOffsetPair> ReduceBySegmentOp;


    typedef BlockLoad<
            WrappedKeysInputIterator,
            BlockReduceSweepByKeyPolicy::BLOCK_THREADS,
            BlockReduceSweepByKeyPolicy::ITEMS_PER_THREAD,
            BlockReduceSweepByKeyPolicy::LOAD_ALGORITHM>
        BlockLoadKeys;


    typedef BlockLoad<
            WrappedValuesInputIterator,
            BlockReduceSweepByKeyPolicy::BLOCK_THREADS,
            BlockReduceSweepByKeyPolicy::ITEMS_PER_THREAD,
            (IS_RUN_LENGTH_ENCODE) ?
                BLOCK_LOAD_DIRECT :
                (BlockLoadAlgorithm) BlockReduceSweepByKeyPolicy::LOAD_ALGORITHM>
        BlockLoadValues;


    typedef BlockExchange<
            Key,
            BLOCK_THREADS,
            ITEMS_PER_THREAD>
        BlockExchangeKeys;


    typedef BlockExchange<
            Value,
            BLOCK_THREADS,
            ITEMS_PER_THREAD>
        BlockExchangeValues;


    typedef BlockDiscontinuity<Key, BLOCK_THREADS> BlockDiscontinuityKeys;


    typedef BlockScan<
            ReductionOffsetPair,
            BlockReduceSweepByKeyPolicy::BLOCK_THREADS,
            BlockReduceSweepByKeyPolicy::SCAN_ALGORITHM>
        BlockScanAllocations;


    typedef BlockScanLookbackPrefixOp<
            ReductionOffsetPair,
            ReduceBySegmentOp,
            ScanTileState>
        LookbackPrefixCallbackOp;


    struct _TempStorage
    {

        union
        {
            struct
            {
                typename BlockScanAllocations::TempStorage scan;
                typename LookbackPrefixCallbackOp::TempStorage prefix;
                typename BlockDiscontinuityKeys::TempStorage discontinuity;
                typename BlockLoadKeys::TempStorage load_keys;

                Offset tile_idx;
                Offset tile_num_flags_prefix;
            };


            typename BlockLoadValues::TempStorage load_values;


            typename BlockExchangeValues::TempStorage exchange_values;


            typename BlockExchangeKeys::TempStorage exchange_keys;
        };

    };


    struct TempStorage : Uninitialized<_TempStorage> {};






    _TempStorage &temp_storage;

    WrappedKeysInputIterator d_keys_in;
    UniqueOutputIterator d_unique_out;

    WrappedValuesInputIterator d_values_in;
    AggregatesOutputIterator d_aggregates_out;

    InequalityWrapper<EqualityOp> inequality_op;
    ReduceBySegmentOp scan_op;
    Offset num_items;







    __attribute__((device)) __inline__ __attribute__((always_inline))
    BlockReduceSweepByKey(
        TempStorage &temp_storage,
        KeysInputIterator d_keys_in,
        UniqueOutputIterator d_unique_out,
        ValuesInputIterator d_values_in,
        AggregatesOutputIterator d_aggregates_out,
        EqualityOp equality_op,
        ReductionOp reduction_op,
        Offset num_items)
    :
        temp_storage(temp_storage.Alias()),
        d_keys_in(d_keys_in),
        d_unique_out(d_unique_out),
        d_values_in(d_values_in),
        d_aggregates_out(d_aggregates_out),
        inequality_op(equality_op),
        scan_op(reduction_op),
        num_items(num_items)
    {}
# 287 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh"
    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(
        ReductionOffsetPair (&values_and_segments)[ITEMS_PER_THREAD],
        ReductionOffsetPair &block_aggregate,
        Int2Type<true> has_identity)
    {
        ReductionOffsetPair identity;
        identity.value = 0;
        identity.offset = 0;
        BlockScanAllocations(temp_storage.scan).ExclusiveScan(values_and_segments, values_and_segments, identity, scan_op, block_aggregate);
    }





    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(
        ReductionOffsetPair (&values_and_segments)[ITEMS_PER_THREAD],
        ReductionOffsetPair &block_aggregate,
        Int2Type<false> has_identity)
    {
        BlockScanAllocations(temp_storage.scan).ExclusiveScan(values_and_segments, values_and_segments, scan_op, block_aggregate);
    }




    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(
        ReductionOffsetPair (&values_and_segments)[ITEMS_PER_THREAD],
        ReductionOffsetPair &block_aggregate,
        LookbackPrefixCallbackOp &prefix_op,
        Int2Type<true> has_identity)
    {
        ReductionOffsetPair identity;
        identity.value = 0;
        identity.offset = 0;
        BlockScanAllocations(temp_storage.scan).ExclusiveScan(values_and_segments, values_and_segments, identity, scan_op, block_aggregate, prefix_op);
    }




    __attribute__((device)) __inline__ __attribute__((always_inline))
    void ScanBlock(
        ReductionOffsetPair (&values_and_segments)[ITEMS_PER_THREAD],
        ReductionOffsetPair &block_aggregate,
        LookbackPrefixCallbackOp &prefix_op,
        Int2Type<false> has_identity)
    {
        BlockScanAllocations(temp_storage.scan).ExclusiveScan(values_and_segments, values_and_segments, scan_op, block_aggregate, prefix_op);
    }






    template <bool LAST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ZipValuesAndFlags(
        Offset num_remaining,
        Value (&values)[ITEMS_PER_THREAD],
        Offset (&flags)[ITEMS_PER_THREAD],
        ReductionOffsetPair (&values_and_segments)[ITEMS_PER_THREAD])
    {

#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
        {

            if ((LAST_TILE) && (Offset(threadIdx.x * ITEMS_PER_THREAD) + ITEM >= num_remaining))
                flags[ITEM] = 0;

            values_and_segments[ITEM].value = values[ITEM];
            values_and_segments[ITEM].offset = flags[ITEM];
        }
    }
# 382 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh"
    template <bool LAST_TILE, bool FIRST_TILE, int ITEM>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterDirect(
        Offset num_remaining,
        Key (&keys)[ITEMS_PER_THREAD],
        ReductionOffsetPair (&values_and_segments)[ITEMS_PER_THREAD],
        Offset (&flags)[ITEMS_PER_THREAD],
        Offset tile_num_flags,
        Int2Type<ITEM> iteration)
    {

        if (flags[ITEM])
        {
            d_unique_out[values_and_segments[ITEM].offset] = keys[ITEM];
        }

        bool is_first_flag = FIRST_TILE && (ITEM == 0) && (threadIdx.x == 0);
        bool is_oob_value = (LAST_TILE) && (Offset(threadIdx.x * ITEMS_PER_THREAD) + ITEM == num_remaining);


        if (((flags[ITEM] || is_oob_value)) && (!is_first_flag))
        {
            d_aggregates_out[values_and_segments[ITEM].offset - 1] = values_and_segments[ITEM].value;
        }

        ScatterDirect<LAST_TILE, FIRST_TILE>(num_remaining, keys, values_and_segments, flags, tile_num_flags, Int2Type<ITEM + 1>());
    }

    template <bool LAST_TILE, bool FIRST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterDirect(
        Offset num_remaining,
        Key (&keys)[ITEMS_PER_THREAD],
        ReductionOffsetPair (&values_and_segments)[ITEMS_PER_THREAD],
        Offset (&flags)[ITEMS_PER_THREAD],
        Offset tile_num_flags,
        Int2Type<ITEMS_PER_THREAD> iteration)
    {}
# 429 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh"
    template <bool LAST_TILE, bool FIRST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ScatterTwoPhase(
        Offset num_remaining,
        Key (&keys)[ITEMS_PER_THREAD],
        ReductionOffsetPair (&values_and_segments)[ITEMS_PER_THREAD],
        Offset (&flags)[ITEMS_PER_THREAD],
        Offset tile_num_flags,
        Offset tile_num_flags_prefix)
    {
        int local_ranks[ITEMS_PER_THREAD];
        Value values[ITEMS_PER_THREAD];


        if (threadIdx.x == 0)
        {
            temp_storage.tile_num_flags_prefix = tile_num_flags_prefix;
        }

        __syncthreads();


        tile_num_flags_prefix = temp_storage.tile_num_flags_prefix;

        __syncthreads();


#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
        {
            local_ranks[ITEM] = values_and_segments[ITEM].offset - tile_num_flags_prefix;
        }


        BlockExchangeKeys(temp_storage.exchange_keys).ScatterToStriped(keys, local_ranks, flags);


        StoreDirectStriped<BLOCK_THREADS>(threadIdx.x, d_unique_out + tile_num_flags_prefix, keys, tile_num_flags);


#pragma unroll
        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
        {
            values[ITEM] = values_and_segments[ITEM].value;

            if (FIRST_TILE)
                local_ranks[ITEM]--;

            if (LAST_TILE && (Offset(threadIdx.x * ITEMS_PER_THREAD) + ITEM == num_remaining))
                flags[ITEM] = 1;
        }


        if (FIRST_TILE && (threadIdx.x == 0))
            flags[0] = 0;

        __syncthreads();


        BlockExchangeValues(temp_storage.exchange_values).ScatterToStriped(values, local_ranks, flags);


        Offset exchange_count = tile_num_flags;

        if (LAST_TILE && (num_remaining < TILE_ITEMS))
            exchange_count++;

        if (FIRST_TILE)
        {
            exchange_count--;
        }
        else
        {
            tile_num_flags_prefix--;
        }


        StoreDirectStriped<BLOCK_THREADS>(threadIdx.x, d_aggregates_out + tile_num_flags_prefix, values, exchange_count);

        __syncthreads();
    }





    template <bool LAST_TILE, bool FIRST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void Scatter(
        Offset num_remaining,
        Key (&keys)[ITEMS_PER_THREAD],
        ReductionOffsetPair (&values_and_segments)[ITEMS_PER_THREAD],
        Offset (&flags)[ITEMS_PER_THREAD],
        Offset tile_num_flags,
        Offset tile_num_flags_prefix)
    {

        if (TWO_PHASE_SCATTER && (tile_num_flags > BLOCK_THREADS))
        {
            ScatterTwoPhase<LAST_TILE, FIRST_TILE>(
                num_remaining,
                keys,
                values_and_segments,
                flags,
                tile_num_flags,
                tile_num_flags_prefix);
        }
        else
        {
            ScatterDirect<LAST_TILE, FIRST_TILE>(
                num_remaining,
                keys,
                values_and_segments,
                flags,
                tile_num_flags,
                Int2Type<0>());
        }
    }
# 554 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh"
    template <
        bool LAST_TILE>
    __attribute__((device)) __inline__ __attribute__((always_inline)) ReductionOffsetPair ConsumeTile(
        Offset num_items,
        Offset num_remaining,
        int tile_idx,
        Offset block_offset,
        ScanTileState &tile_status)
    {
        Key keys[ITEMS_PER_THREAD];
        Value values[ITEMS_PER_THREAD];
        Offset flags[ITEMS_PER_THREAD];
        ReductionOffsetPair values_and_segments[ITEMS_PER_THREAD];
        ReductionOffsetPair running_total;


        if (LAST_TILE)
            BlockLoadKeys(temp_storage.load_keys).Load(d_keys_in + block_offset, keys, num_remaining);
        else
            BlockLoadKeys(temp_storage.load_keys).Load(d_keys_in + block_offset, keys);

        if (tile_idx == 0)
        {

            __syncthreads();


            if (LAST_TILE)
                BlockLoadValues(temp_storage.load_values).Load(d_values_in + block_offset, values, num_remaining);
            else
                BlockLoadValues(temp_storage.load_values).Load(d_values_in + block_offset, values);

            __syncthreads();


            BlockDiscontinuityKeys(temp_storage.discontinuity).FlagHeads(flags, keys, inequality_op);


            ZipValuesAndFlags<LAST_TILE>(num_remaining, values, flags, values_and_segments);


            ReductionOffsetPair block_aggregate;
            ScanBlock(values_and_segments, block_aggregate, Int2Type<HAS_IDENTITY_ZERO>());


            if (!LAST_TILE && (threadIdx.x == 0))
                tile_status.SetInclusive(0, block_aggregate);


            if (!HAS_IDENTITY_ZERO && (threadIdx.x == 0))
                values_and_segments[0].offset = 0;

            running_total = block_aggregate;


            Scatter<LAST_TILE, true>(num_remaining, keys, values_and_segments, flags, block_aggregate.offset, 0);
        }
        else
        {


            Key tile_predecessor_key = (threadIdx.x == 0) ?
                d_keys_in[block_offset - 1] :
                ZeroInitialize<Key>();

            __syncthreads();


            if (LAST_TILE)
                BlockLoadValues(temp_storage.load_values).Load(d_values_in + block_offset, values, num_remaining);
            else
                BlockLoadValues(temp_storage.load_values).Load(d_values_in + block_offset, values);

            __syncthreads();


            BlockDiscontinuityKeys(temp_storage.discontinuity).FlagHeads(flags, keys, inequality_op, tile_predecessor_key);


            ZipValuesAndFlags<LAST_TILE>(num_remaining, values, flags, values_and_segments);


            ReductionOffsetPair block_aggregate;
            LookbackPrefixCallbackOp prefix_op(tile_status, temp_storage.prefix, scan_op, tile_idx);

            ScanBlock(values_and_segments, block_aggregate, prefix_op, Int2Type<HAS_IDENTITY_ZERO>());
            running_total = prefix_op.inclusive_prefix;


            Scatter<LAST_TILE, false>(num_remaining, keys, values_and_segments, flags, block_aggregate.offset, prefix_op.exclusive_prefix.offset);
        }

        return running_total;
    }





    template <typename NumRunsIterator>
    __attribute__((device)) __inline__ __attribute__((always_inline)) void ConsumeRange(
        int num_tiles,
        GridQueue<int> queue,
        ScanTileState &tile_status,
        NumRunsIterator d_num_runs_out)
    {



        int tile_idx = (blockIdx.y * 32 * 1024) + blockIdx.x;
        Offset block_offset = Offset(TILE_ITEMS) * tile_idx;
        Offset num_remaining = num_items - block_offset;

        if (num_remaining > TILE_ITEMS)
        {

            ConsumeTile<false>(num_items, num_remaining, tile_idx, block_offset, tile_status);
        }
        else if (num_remaining > 0)
        {

            ReductionOffsetPair running_total = ConsumeTile<true>(num_items, num_remaining, tile_idx, block_offset, tile_status);


            if (threadIdx.x == 0)
            {
                *d_num_runs_out = running_total.offset;


                if (num_remaining == TILE_ITEMS)
                {
                    d_aggregates_out[running_total.offset - 1] = running_total.value;
                }
            }
        }
# 736 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/../../block_sweep/block_reduce_by_key_sweep.cuh"
    }

};


}
} } } }
# 42 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh" 2






namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 60 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
template <
    typename BlockReduceSweepByKeyPolicy,
    typename KeysInputIterator,
    typename UniqueOutputIterator,
    typename ValuesInputIterator,
    typename AggregatesOutputIterator,
    typename NumRunsOutputIterator,
    typename ScanTileState,
    typename EqualityOp,
    typename ReductionOp,
    typename Offset>
__attribute__((launch_bounds(int(BlockReduceSweepByKeyPolicy::BLOCK_THREADS))))
__attribute__((global)) void DeviceReduceByKeySweepKernel(
    KeysInputIterator d_keys_in,
    UniqueOutputIterator d_unique_out,
    ValuesInputIterator d_values_in,
    AggregatesOutputIterator d_aggregates_out,
    NumRunsOutputIterator d_num_runs_out,
    ScanTileState tile_status,
    EqualityOp equality_op,
    ReductionOp reduction_op,
    Offset num_items,
    int num_tiles,
    GridQueue<int> queue)
{

    typedef BlockReduceSweepByKey<
        BlockReduceSweepByKeyPolicy,
        KeysInputIterator,
        UniqueOutputIterator,
        ValuesInputIterator,
        AggregatesOutputIterator,
        EqualityOp,
        ReductionOp,
        Offset> BlockReduceSweepByKeyT;


    __attribute__((shared)) typename BlockReduceSweepByKeyT::TempStorage temp_storage;


    BlockReduceSweepByKeyT(temp_storage, d_keys_in, d_unique_out, d_values_in, d_aggregates_out, equality_op, reduction_op, num_items).ConsumeRange(
        num_tiles,
        queue,
        tile_status,
        d_num_runs_out);
}
# 117 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
template <
    typename KeysInputIterator,
    typename UniqueOutputIterator,
    typename ValuesInputIterator,
    typename AggregatesOutputIterator,
    typename NumRunsOutputIterator,
    typename EqualityOp,
    typename ReductionOp,
    typename Offset>
struct DeviceReduceByKeyDispatch
{





    typedef typename std::iterator_traits<KeysInputIterator>::value_type Key;


    typedef typename std::iterator_traits<ValuesInputIterator>::value_type Value;

    enum
    {
        INIT_KERNEL_THREADS = 128,
        MAX_INPUT_BYTES = (((sizeof(Value)) > (sizeof(Key))) ? (sizeof(Value)) : (sizeof(Key))),
        COMBINED_INPUT_BYTES = sizeof(Key) + sizeof(Value),
    };


    typedef ReduceByKeyScanTileState<Value, Offset> ScanTileState;







    struct Policy350
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 8,
            ITEMS_PER_THREAD = (MAX_INPUT_BYTES <= 8) ? 8 : ((((((((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) > (1)) ? (((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? ((((((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) > (1)) ? (((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockReduceSweepByKeyPolicy<
                128,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_DIRECT,
                LOAD_LDG,
                true,
                BLOCK_SCAN_WARP_SCANS>
            ReduceByKeyPolicy;
    };


    struct Policy300
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 6,
            ITEMS_PER_THREAD = ((((((((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) > (1)) ? (((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? ((((((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) > (1)) ? (((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockReduceSweepByKeyPolicy<
                128,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                LOAD_DEFAULT,
                true,
                BLOCK_SCAN_WARP_SCANS>
            ReduceByKeyPolicy;
    };


    struct Policy200
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 13,
            ITEMS_PER_THREAD = ((((((((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) > (1)) ? (((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? ((((((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) > (1)) ? (((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockReduceSweepByKeyPolicy<
                128,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                LOAD_DEFAULT,
                true,
                BLOCK_SCAN_WARP_SCANS>
            ReduceByKeyPolicy;
    };


    struct Policy130
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 7,
            ITEMS_PER_THREAD = ((((((((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) > (1)) ? (((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? ((((((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) > (1)) ? (((NOMINAL_4B_ITEMS_PER_THREAD * 8) + COMBINED_INPUT_BYTES - 1) / COMBINED_INPUT_BYTES) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockReduceSweepByKeyPolicy<
                128,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                LOAD_DEFAULT,
                true,
                BLOCK_SCAN_WARP_SCANS>
            ReduceByKeyPolicy;
    };


    struct Policy100
    {
        enum {
            NOMINAL_4B_ITEMS_PER_THREAD = 5,
            ITEMS_PER_THREAD = (((((((NOMINAL_4B_ITEMS_PER_THREAD * 8) / COMBINED_INPUT_BYTES) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 8) / COMBINED_INPUT_BYTES) : (1))) < (NOMINAL_4B_ITEMS_PER_THREAD)) ? (((((NOMINAL_4B_ITEMS_PER_THREAD * 8) / COMBINED_INPUT_BYTES) > (1)) ? ((NOMINAL_4B_ITEMS_PER_THREAD * 8) / COMBINED_INPUT_BYTES) : (1))) : (NOMINAL_4B_ITEMS_PER_THREAD)),
        };

        typedef BlockReduceSweepByKeyPolicy<
                64,
                ITEMS_PER_THREAD,
                BLOCK_LOAD_WARP_TRANSPOSE,
                LOAD_DEFAULT,
                true,
                BLOCK_SCAN_RAKING>
            ReduceByKeyPolicy;
    };
# 261 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
    typedef Policy100 PtxPolicy;




    struct PtxReduceByKeyPolicy : PtxPolicy::ReduceByKeyPolicy {};
# 276 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
    template <typename KernelConfig>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static void InitConfigs(
        int ptx_version,
        KernelConfig &device_reduce_by_key_sweep_config)
    {
# 290 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
        if (ptx_version >= 350)
        {
            device_reduce_by_key_sweep_config.template Init<typename Policy350::ReduceByKeyPolicy>();
        }
        else if (ptx_version >= 300)
        {
            device_reduce_by_key_sweep_config.template Init<typename Policy300::ReduceByKeyPolicy>();
        }
        else if (ptx_version >= 200)
        {
            device_reduce_by_key_sweep_config.template Init<typename Policy200::ReduceByKeyPolicy>();
        }
        else if (ptx_version >= 130)
        {
            device_reduce_by_key_sweep_config.template Init<typename Policy130::ReduceByKeyPolicy>();
        }
        else
        {
            device_reduce_by_key_sweep_config.template Init<typename Policy100::ReduceByKeyPolicy>();
        }


    }





    struct KernelConfig
    {
        int block_threads;
        int items_per_thread;
        BlockLoadAlgorithm load_policy;
        bool two_phase_scatter;
        BlockScanAlgorithm scan_algorithm;
        cudaSharedMemConfig smem_config;

        template <typename BlockReduceSweepByKeyPolicy>
        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Init()
        {
            block_threads = BlockReduceSweepByKeyPolicy::BLOCK_THREADS;
            items_per_thread = BlockReduceSweepByKeyPolicy::ITEMS_PER_THREAD;
            load_policy = BlockReduceSweepByKeyPolicy::LOAD_ALGORITHM;
            two_phase_scatter = BlockReduceSweepByKeyPolicy::TWO_PHASE_SCATTER;
            scan_algorithm = BlockReduceSweepByKeyPolicy::SCAN_ALGORITHM;
            smem_config = cudaSharedMemBankSizeEightByte;
        }

        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
        void Print()
        {
            printf("%d, %d, %d, %d, %d, %d",
                block_threads,
                items_per_thread,
                load_policy,
                two_phase_scatter,
                scan_algorithm,
                smem_config);
        }
    };
# 361 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
    template <
        typename DeviceScanInitKernelPtr,
        typename DeviceReduceByKeySweepKernelPtr>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        KeysInputIterator d_keys_in,
        UniqueOutputIterator d_unique_out,
        ValuesInputIterator d_values_in,
        AggregatesOutputIterator d_aggregates_out,
        NumRunsOutputIterator d_num_runs_out,
        EqualityOp equality_op,
        ReductionOp reduction_op,
        Offset num_items,
        cudaStream_t stream,
        bool debug_synchronous,
        int ptx_version,
        DeviceScanInitKernelPtr device_scan_init_kernel,
        DeviceReduceByKeySweepKernelPtr range_reduce_by_key_kernel,
        KernelConfig device_reduce_by_key_sweep_config)
    {
# 391 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
        cudaError error = cudaSuccess;
        do
        {

            int device_ordinal;
            if (cub_::Debug((error = cudaGetDevice(&device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 396)) break;


            int sm_version;
            if (cub_::Debug((error = SmVersion(sm_version, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 400)) break;


            int sm_count;
            if (cub_::Debug((error = cudaDeviceGetAttribute (&sm_count, cudaDevAttrMultiProcessorCount, device_ordinal)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 404)) break;


            int tile_size = device_reduce_by_key_sweep_config.block_threads * device_reduce_by_key_sweep_config.items_per_thread;
            int num_tiles = (num_items + tile_size - 1) / tile_size;


            size_t allocation_sizes[2];
            if (cub_::Debug((error = ScanTileState::AllocationSize(num_tiles, allocation_sizes[0])), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 412)) break;
            allocation_sizes[1] = GridQueue<int>::AllocationSize();


            void* allocations[2];
            if (cub_::Debug((error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 417)) break;
            if (d_temp_storage == __null)
            {

                return cudaSuccess;
            }


            ScanTileState tile_status;
            if (cub_::Debug((error = tile_status.Init(num_tiles, allocations[0], allocation_sizes[0])), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 426)) break;


            GridQueue<int> queue(allocations[1]);


            int init_grid_size = (num_tiles + INIT_KERNEL_THREADS - 1) / INIT_KERNEL_THREADS;
            if (debug_synchronous) printf("Invoking device_scan_init_kernel<<<%d, %d, 0, %lld>>>()\n",init_grid_size, INIT_KERNEL_THREADS, (long long) stream);;


            device_scan_init_kernel<<<init_grid_size, INIT_KERNEL_THREADS, 0, stream>>>(
                queue,
                tile_status,
                num_tiles);


            if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 442)) break;


            if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 445))) break;


            int range_reduce_by_key_sm_occupancy;
            if (cub_::Debug((error = MaxSmOccupancy( range_reduce_by_key_sm_occupancy, sm_version, range_reduce_by_key_kernel, device_reduce_by_key_sweep_config.block_threads)),



 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
# 449 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
                ,



 453
# 449 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
                )



                                                                 ) break;


            dim3 reduce_by_key_grid_size;
            if (ptx_version <= 130)
            {

                int max_dim_x = 32 * 1024;
                reduce_by_key_grid_size.z = 1;
                reduce_by_key_grid_size.y = (num_tiles + max_dim_x - 1) / max_dim_x;
                reduce_by_key_grid_size.x = (((max_dim_x) < (num_tiles)) ? (max_dim_x) : (num_tiles));
            }
            else
            {

                int range_reduce_by_key_occupancy = range_reduce_by_key_sm_occupancy * sm_count;
                reduce_by_key_grid_size.z = 1;
                reduce_by_key_grid_size.y = 1;
                reduce_by_key_grid_size.x = (num_tiles < range_reduce_by_key_occupancy) ?
                    num_tiles :
                    range_reduce_by_key_occupancy;
            }



            cudaSharedMemConfig original_smem_config;
            if (cub_::Debug((error = cudaDeviceGetSharedMemConfig(&original_smem_config)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 479)) break;
            cudaSharedMemConfig current_smem_config = original_smem_config;


            if (current_smem_config != device_reduce_by_key_sweep_config.smem_config)
            {
                if (cub_::Debug((error = cudaDeviceSetSharedMemConfig(device_reduce_by_key_sweep_config.smem_config)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 485)) break;
                current_smem_config = device_reduce_by_key_sweep_config.smem_config;
            }



            if (debug_synchronous) printf("Invoking range_reduce_by_key_kernel<<<{%d,%d,%d}, %d, 0, %lld>>>(), %d items per thread, %d SM occupancy\n",reduce_by_key_grid_size.x, reduce_by_key_grid_size.y, reduce_by_key_grid_size.z, device_reduce_by_key_sweep_config.block_threads, (long long) stream, device_reduce_by_key_sweep_config.items_per_thread, range_reduce_by_key_sm_occupancy);
                                                                                                                                                                                                                                                           ;


            range_reduce_by_key_kernel<<<reduce_by_key_grid_size, device_reduce_by_key_sweep_config.block_threads, 0, stream>>>(
                d_keys_in,
                d_unique_out,
                d_values_in,
                d_aggregates_out,
                d_num_runs_out,
                tile_status,
                equality_op,
                reduction_op,
                num_items,
                num_tiles,
                queue);


            if (cub_::Debug((error = cudaPeekAtLastError()), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 509)) break;


            if (debug_synchronous && (cub_::Debug((error = SyncStream(stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 512))) break;



            if (current_smem_config != original_smem_config)
            {
                if (cub_::Debug((error = cudaDeviceSetSharedMemConfig(original_smem_config)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 518)) break;
            }


        }
        while (0);

        return error;


    }





    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Dispatch(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        KeysInputIterator d_keys_in,
        UniqueOutputIterator d_unique_out,
        ValuesInputIterator d_values_in,
        AggregatesOutputIterator d_aggregates_out,
        NumRunsOutputIterator d_num_runs_out,
        EqualityOp equality_op,
        ReductionOp reduction_op,
        Offset num_items,
        cudaStream_t stream,
        bool debug_synchronous)
    {
        cudaError error = cudaSuccess;
        do
        {

            int ptx_version;

            if (cub_::Debug((error = PtxVersion(ptx_version)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh", 555)) break;





            KernelConfig device_reduce_by_key_sweep_config;
            InitConfigs(ptx_version, device_reduce_by_key_sweep_config);


            if (cub_::Debug((error = Dispatch( d_temp_storage, temp_storage_bytes, d_keys_in, d_unique_out, d_values_in, d_aggregates_out, d_num_runs_out, equality_op, reduction_op, num_items, stream, debug_synchronous, ptx_version, DeviceScanInitKernel<Offset, ScanTileState>, DeviceReduceByKeySweepKernel<PtxReduceByKeyPolicy, KeysInputIterator, UniqueOutputIterator, ValuesInputIterator, AggregatesOutputIterator, NumRunsOutputIterator, ScanTileState, EqualityOp, ReductionOp, Offset>, device_reduce_by_key_sweep_config)),
# 581 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
# 565 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
                ,
# 581 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
 581
# 565 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
                )
# 581 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/dispatch/device_reduce_by_key_dispatch.cuh"
                                                   ) break;
        }
        while (0);

        return error;
    }
};

}
} } } }
# 42 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh" 2



namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 82 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh"
struct DeviceReduce
{
# 137 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh"
    template <
        typename InputIterator,
        typename OutputIterator,
        typename ReductionOp>
    __attribute__((host)) __attribute__((device))
    static cudaError_t Reduce(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        int num_items,
        ReductionOp reduction_op,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceReduceDispatch<InputIterator, OutputIterator, Offset, ReductionOp> DeviceReduceDispatch;

        return DeviceReduceDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_out,
            num_items,
            reduction_op,
            stream,
            debug_synchronous);
    }
# 215 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh"
    template <
        typename InputIterator,
        typename OutputIterator>
    __attribute__((host)) __attribute__((device))
    static cudaError_t Sum(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceReduceDispatch<InputIterator, OutputIterator, Offset, cub_::Sum> DeviceReduceDispatch;

        return DeviceReduceDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_out,
            num_items,
            cub_::Sum(),
            stream,
            debug_synchronous);
    }
# 287 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh"
    template <
        typename InputIterator,
        typename OutputIterator>
    __attribute__((host)) __attribute__((device))
    static cudaError_t Min(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceReduceDispatch<InputIterator, OutputIterator, Offset, cub_::Min> DeviceReduceDispatch;

        return DeviceReduceDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_out,
            num_items,
            cub_::Min(),
            stream,
            debug_synchronous);
    }
# 364 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh"
    template <
        typename InputIterator,
        typename OutputIterator>
    __attribute__((host)) __attribute__((device))
    static cudaError_t ArgMin(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef ArgIndexInputIterator<InputIterator, int> ArgIndexInputIterator;
        ArgIndexInputIterator d_argmin_in(d_in, 0);


        typedef DeviceReduceDispatch<ArgIndexInputIterator, OutputIterator, Offset, cub_::ArgMin> DeviceReduceDispatch;

        return DeviceReduceDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_argmin_in,
            d_out,
            num_items,
            cub_::ArgMin(),
            stream,
            debug_synchronous);
    }
# 440 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh"
    template <
        typename InputIterator,
        typename OutputIterator>
    __attribute__((host)) __attribute__((device))
    static cudaError_t Max(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef DeviceReduceDispatch<InputIterator, OutputIterator, Offset, cub_::Max> DeviceReduceDispatch;

        return DeviceReduceDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_out,
            num_items,
            cub_::Max(),
            stream,
            debug_synchronous);
    }
# 517 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh"
    template <
        typename InputIterator,
        typename OutputIterator>
    __attribute__((host)) __attribute__((device))
    static cudaError_t ArgMax(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef ArgIndexInputIterator<InputIterator, int> ArgIndexInputIterator;
        ArgIndexInputIterator d_argmax_in(d_in, 0);


        typedef DeviceReduceDispatch<ArgIndexInputIterator, OutputIterator, Offset, cub_::ArgMax> DeviceReduceDispatch;

        return DeviceReduceDispatch::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_argmax_in,
            d_out,
            num_items,
            cub_::ArgMax(),
            stream,
            debug_synchronous);
    }
# 634 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_reduce.cuh"
    template <
        typename KeysInputIterator,
        typename UniqueOutputIterator,
        typename ValuesInputIterator,
        typename AggregatesOutputIterator,
        typename NumRunsOutputIterator,
        typename ReductionOp>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t ReduceByKey(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        KeysInputIterator d_keys_in,
        UniqueOutputIterator d_unique_out,
        ValuesInputIterator d_values_in,
        AggregatesOutputIterator d_aggregates_out,
        NumRunsOutputIterator d_num_runs_out,
        ReductionOp reduction_op,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {
        typedef int Offset;
        typedef NullType* FlagIterator;
        typedef NullType SelectOp;
        typedef Equality EqualityOp;

        return DeviceReduceByKeyDispatch<KeysInputIterator, UniqueOutputIterator, ValuesInputIterator, AggregatesOutputIterator, NumRunsOutputIterator, EqualityOp, ReductionOp, Offset>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_keys_in,
            d_unique_out,
            d_values_in,
            d_aggregates_out,
            d_num_runs_out,
            EqualityOp(),
            reduction_op,
            num_items,
            stream,
            debug_synchronous);
    }

};





}
} } } }
# 54 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_scan.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_scan.cuh"
       
# 44 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_scan.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 77 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_scan.cuh"
struct DeviceScan
{
# 129 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_scan.cuh"
    template <
        typename InputIterator,
        typename OutputIterator>
    __attribute__((host)) __attribute__((device))
    static cudaError_t ExclusiveSum(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;


        typedef typename std::iterator_traits<InputIterator>::value_type T;

        return DeviceScanDispatch<InputIterator, OutputIterator, Sum, T, Offset>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_out,
            Sum(),
            T(),
            num_items,
            stream,
            debug_synchronous);
    }
# 215 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_scan.cuh"
    template <
        typename InputIterator,
        typename OutputIterator,
        typename ScanOp,
        typename Identity>
    __attribute__((host)) __attribute__((device))
    static cudaError_t ExclusiveScan(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        ScanOp scan_op,
        Identity identity,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;

        return DeviceScanDispatch<InputIterator, OutputIterator, ScanOp, Identity, Offset>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_out,
            scan_op,
            identity,
            num_items,
            stream,
            debug_synchronous);
    }
# 296 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_scan.cuh"
    template <
        typename InputIterator,
        typename OutputIterator>
    __attribute__((host)) __attribute__((device))
    static cudaError_t InclusiveSum(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;

        return DeviceScanDispatch<InputIterator, OutputIterator, Sum, NullType, Offset>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_out,
            Sum(),
            NullType(),
            num_items,
            stream,
            debug_synchronous);
    }
# 378 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_scan.cuh"
    template <
        typename InputIterator,
        typename OutputIterator,
        typename ScanOp>
    __attribute__((host)) __attribute__((device))
    static cudaError_t InclusiveScan(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        ScanOp scan_op,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {

        typedef int Offset;

        return DeviceScanDispatch<InputIterator, OutputIterator, ScanOp, NullType, Offset>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_out,
            scan_op,
            NullType(),
            num_items,
            stream,
            debug_synchronous);
    }



};





}
} } } }
# 55 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_select.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_select.cuh"
       
# 44 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_select.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 82 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_select.cuh"
struct DeviceSelect
{
# 128 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_select.cuh"
    template <
        typename InputIterator,
        typename FlagIterator,
        typename OutputIterator,
        typename NumSelectedIterator>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Flagged(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        FlagIterator d_flags,
        OutputIterator d_out,
        NumSelectedIterator d_num_selected_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {
        typedef int Offset;
        typedef NullType SelectOp;
        typedef NullType EqualityOp;

        return DeviceSelectDispatch<InputIterator, FlagIterator, OutputIterator, NumSelectedIterator, SelectOp, EqualityOp, Offset, false>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            d_flags,
            d_out,
            d_num_selected_out,
            SelectOp(),
            EqualityOp(),
            num_items,
            stream,
            debug_synchronous);
    }
# 235 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_select.cuh"
    template <
        typename InputIterator,
        typename OutputIterator,
        typename NumSelectedIterator,
        typename SelectOp>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t If(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        NumSelectedIterator d_num_selected_out,
        int num_items,
        SelectOp select_op,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {
        typedef int Offset;
        typedef NullType* FlagIterator;
        typedef NullType EqualityOp;

        return DeviceSelectDispatch<InputIterator, FlagIterator, OutputIterator, NumSelectedIterator, SelectOp, EqualityOp, Offset, false>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            __null,
            d_out,
            d_num_selected_out,
            select_op,
            EqualityOp(),
            num_items,
            stream,
            debug_synchronous);
    }
# 327 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/device/device_select.cuh"
    template <
        typename InputIterator,
        typename OutputIterator,
        typename NumSelectedIterator>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline))
    static cudaError_t Unique(
        void *d_temp_storage,
        size_t &temp_storage_bytes,
        InputIterator d_in,
        OutputIterator d_out,
        NumSelectedIterator d_num_selected_out,
        int num_items,
        cudaStream_t stream = 0,
        bool debug_synchronous = false)
    {
        typedef int Offset;
        typedef NullType* FlagIterator;
        typedef NullType SelectOp;
        typedef Equality EqualityOp;

        return DeviceSelectDispatch<InputIterator, FlagIterator, OutputIterator, NumSelectedIterator, SelectOp, EqualityOp, Offset, false>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_in,
            __null,
            d_out,
            d_num_selected_out,
            SelectOp(),
            EqualityOp(),
            num_items,
            stream,
            debug_synchronous);
    }

};







}
} } } }
# 56 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 64 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/host/spinlock.cuh" 1
# 35 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/host/spinlock.cuh"
       
# 52 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/host/spinlock.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 66 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/host/spinlock.cuh"
    typedef int Spinlock;




    __inline__ __attribute__((always_inline)) void _ReadWriteBarrier()
    {
        __sync_synchronize();
    }




    __inline__ __attribute__((always_inline)) long _InterlockedExchange(volatile int * const Target, const int Value)
    {

        _ReadWriteBarrier();
        return __sync_lock_test_and_set(Target, Value);
    }




    __inline__ __attribute__((always_inline)) void YieldProcessor()
    {

        asm volatile("pause\n": : :"memory");

    }






__inline__ __attribute__((always_inline)) void Lock(volatile Spinlock *lock)
{
    while (1)
    {
        if (!_InterlockedExchange(lock, 1)) return;
        while (*lock) YieldProcessor();
    }
}





__inline__ __attribute__((always_inline)) void Unlock(volatile Spinlock *lock)
{
    _ReadWriteBarrier();
    *lock = 0;
}


}
} } } }
# 65 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 80 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/cache_modified_output_iterator.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/cache_modified_output_iterator.cuh"
       
# 52 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/cache_modified_output_iterator.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 105 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/cache_modified_output_iterator.cuh"
template <
    CacheStoreModifier MODIFIER,
    typename ValueType,
    typename Offset = ptrdiff_t>
class CacheModifiedOutputIterator
{
private:


    struct Reference
    {
        ValueType* ptr;


        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) Reference(ValueType* ptr) : ptr(ptr) {}


        __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) ValueType operator =(ValueType val)
        {
            ThreadStore<MODIFIER>(ptr, val);
            return val;
        }
    };

public:


    typedef CacheModifiedOutputIterator self_type;
    typedef Offset difference_type;
    typedef ValueType value_type;
    typedef ValueType* pointer;
    typedef Reference reference;



    typedef typename thrust::detail::iterator_facade_category<
        thrust::device_system_tag,
        thrust::random_access_traversal_tag,
        value_type,
        reference
      >::type iterator_category;




private:

    ValueType* ptr;

public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CacheModifiedOutputIterator(
        ValueType* ptr)
    :
        ptr(ptr)
    {}


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++(int)
    {
        self_type retval = *this;
        ptr++;
        return retval;
    }



    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++()
    {
        ptr++;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator*() const
    {
        return Reference(ptr);
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator+(Distance n) const
    {
        self_type retval(ptr + n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator+=(Distance n)
    {
        ptr += n;
        return *this;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator-(Distance n) const
    {
        self_type retval(ptr - n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator-=(Distance n)
    {
        ptr -= n;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) difference_type operator-(self_type other) const
    {
        return ptr - other.ptr;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator[](Distance n) const
    {
        return Reference(ptr + n);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator==(const self_type& rhs)
    {
        return (ptr == rhs.ptr);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator!=(const self_type& rhs)
    {
        return (ptr != rhs.ptr);
    }


    friend std::ostream& operator<<(std::ostream& os, const self_type& itr)
    {
        return os;
    }
};




}
} } } }
# 81 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2

# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/counting_input_iterator.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/counting_input_iterator.cuh"
       
# 52 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/counting_input_iterator.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 91 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/counting_input_iterator.cuh"
template <
    typename ValueType,
    typename Offset = ptrdiff_t>
class CountingInputIterator
{
public:


    typedef CountingInputIterator self_type;
    typedef Offset difference_type;
    typedef ValueType value_type;
    typedef ValueType* pointer;
    typedef ValueType reference;



    typedef typename thrust::detail::iterator_facade_category<
        thrust::any_system_tag,
        thrust::random_access_traversal_tag,
        value_type,
        reference
      >::type iterator_category;




private:

    ValueType val;

public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) CountingInputIterator(
        const ValueType &val)
    :
        val(val)
    {}


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++(int)
    {
        self_type retval = *this;
        val++;
        return retval;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++()
    {
        val++;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator*() const
    {
        return val;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator+(Distance n) const
    {
        self_type retval(val + n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator+=(Distance n)
    {
        val += n;
        return *this;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator-(Distance n) const
    {
        self_type retval(val - n);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator-=(Distance n)
    {
        val -= n;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) difference_type operator-(self_type other) const
    {
        return val - other.val;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator[](Distance n) const
    {
        return val + n;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) pointer operator->()
    {
        return &val;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator==(const self_type& rhs)
    {
        return (val == rhs.val);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator!=(const self_type& rhs)
    {
        return (val != rhs.val);
    }


    friend std::ostream& operator<<(std::ostream& os, const self_type& itr)
    {
        os << "[" << itr.val << "]";
        return os;
    }

};





}
} } } }
# 83 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_obj_input_iterator.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_obj_input_iterator.cuh"
       
# 53 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_obj_input_iterator.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 108 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_obj_input_iterator.cuh"
template <
    typename T,
    typename Offset = ptrdiff_t>
class TexObjInputIterator
{
public:


    typedef TexObjInputIterator self_type;
    typedef Offset difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef T reference;



    typedef typename thrust::detail::iterator_facade_category<
        thrust::device_system_tag,
        thrust::random_access_traversal_tag,
        value_type,
        reference
      >::type iterator_category;




private:


    typedef typename UnitWord<T>::TextureWord TextureWord;


    enum {
        TEXTURE_MULTIPLE = sizeof(T) / sizeof(TextureWord)
    };

private:

    T* ptr;
    difference_type tex_offset;
    cudaTextureObject_t tex_obj;

public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) TexObjInputIterator()
    :
        ptr(__null),
        tex_offset(0),
        tex_obj(0)
    {}


    cudaError_t BindTexture(
        T *ptr,
        size_t bytes,
        size_t tex_offset = 0)
    {
        this->ptr = ptr;
        this->tex_offset = tex_offset;

        cudaChannelFormatDesc channel_desc = cudaCreateChannelDesc<TextureWord>();
        cudaResourceDesc res_desc;
        cudaTextureDesc tex_desc;
        memset(&res_desc, 0, sizeof(cudaResourceDesc));
        memset(&tex_desc, 0, sizeof(cudaTextureDesc));
        res_desc.resType = cudaResourceTypeLinear;
        res_desc.res.linear.devPtr = ptr;
        res_desc.res.linear.desc = channel_desc;
        res_desc.res.linear.sizeInBytes = bytes;
        tex_desc.readMode = cudaReadModeElementType;
        return cudaCreateTextureObject(&tex_obj, &res_desc, &tex_desc, __null);
    }


    cudaError_t UnbindTexture()
    {
        return cudaDestroyTextureObject(tex_obj);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++(int)
    {
        self_type retval = *this;
        tex_offset++;
        return retval;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++()
    {
        tex_offset++;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator*() const
    {


        return ptr[tex_offset];
# 224 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_obj_input_iterator.cuh"
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator+(Distance n) const
    {
        self_type retval;
        retval.ptr = ptr;
        retval.tex_obj = tex_obj;
        retval.tex_offset = tex_offset + n;
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator+=(Distance n)
    {
        tex_offset += n;
        return *this;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator-(Distance n) const
    {
        self_type retval;
        retval.ptr = ptr;
        retval.tex_obj = tex_obj;
        retval.tex_offset = tex_offset - n;
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator-=(Distance n)
    {
        tex_offset -= n;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) difference_type operator-(self_type other) const
    {
        return tex_offset - other.tex_offset;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator[](Distance n) const
    {
        return *(*this + n);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) pointer operator->()
    {
        return &(*(*this));
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator==(const self_type& rhs)
    {
        return ((ptr == rhs.ptr) && (tex_offset == rhs.tex_offset) && (tex_obj == rhs.tex_obj));
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator!=(const self_type& rhs)
    {
        return ((ptr != rhs.ptr) || (tex_offset != rhs.tex_offset) || (tex_obj != rhs.tex_obj));
    }


    friend std::ostream& operator<<(std::ostream& os, const self_type& itr)
    {
        return os;
    }

};





}
} } } }
# 84 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_ref_input_iterator.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_ref_input_iterator.cuh"
       
# 54 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_ref_input_iterator.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 67 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_ref_input_iterator.cuh"
namespace {


template <typename T>
struct IteratorTexRef
{

    template <int UNIQUE_ID>
    struct TexId
    {

        typedef typename UnitWord<T>::DeviceWord DeviceWord;
        typedef typename UnitWord<T>::TextureWord TextureWord;


        enum {
            DEVICE_MULTIPLE = sizeof(T) / sizeof(DeviceWord),
            TEXTURE_MULTIPLE = sizeof(T) / sizeof(TextureWord)
        };


        typedef texture<TextureWord> TexRef;


        static TexRef ref;


        static cudaError_t BindTexture(void *d_in)
        {
            if (d_in)
            {
                cudaChannelFormatDesc tex_desc = cudaCreateChannelDesc<TextureWord>();
                ref.channelDesc = tex_desc;
                return (cub_::Debug((cudaBindTexture(__null, ref, d_in)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_ref_input_iterator.cuh", 100));
            }

            return cudaSuccess;
        }


        static cudaError_t UnbindTexture()
        {
            return cub_::Debug((cudaUnbindTexture(ref)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_ref_input_iterator.cuh", 109);
        }


        template <typename Distance>
        static __attribute__((device)) __inline__ __attribute__((always_inline)) T Fetch(Distance tex_offset)
        {
            DeviceWord temp[DEVICE_MULTIPLE];
            TextureWord *words = reinterpret_cast<TextureWord*>(temp);

#pragma unroll
            for (int i = 0; i < TEXTURE_MULTIPLE; ++i)
            {
                words[i] = tex1Dfetch(ref, (tex_offset * TEXTURE_MULTIPLE) + i);
            }

            return reinterpret_cast<T&>(temp);
        }
    };
};


template <typename T>
template <int UNIQUE_ID>
typename IteratorTexRef<T>::template TexId<UNIQUE_ID>::TexRef IteratorTexRef<T>::template TexId<UNIQUE_ID>::ref = 0;


}
# 200 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/tex_ref_input_iterator.cuh"
template <
    typename T,
    int UNIQUE_ID,
    typename Offset = ptrdiff_t>
class TexRefInputIterator
{
public:


    typedef TexRefInputIterator self_type;
    typedef Offset difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef T reference;



    typedef typename thrust::detail::iterator_facade_category<
        thrust::device_system_tag,
        thrust::random_access_traversal_tag,
        value_type,
        reference
      >::type iterator_category;




private:

    T* ptr;
    difference_type tex_offset;


    typedef typename IteratorTexRef<T>::template TexId<UNIQUE_ID> TexId;

public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) TexRefInputIterator()
    :
        ptr(__null),
        tex_offset(0)
    {}


    cudaError_t BindTexture(
        T *ptr,
        size_t bytes,
        size_t tex_offset = 0)
    {
        this->ptr = ptr;
        this->tex_offset = (difference_type) tex_offset;
        return TexId::BindTexture(ptr);
    }


    cudaError_t UnbindTexture()
    {
        return TexId::UnbindTexture();
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++(int)
    {
        self_type retval = *this;
        tex_offset++;
        return retval;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++()
    {
        tex_offset++;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator*() const
    {


        return ptr[tex_offset];




    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator+(Distance n) const
    {
        self_type retval;
        retval.ptr = ptr;
        retval.tex_offset = tex_offset + n;
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator+=(Distance n)
    {
        tex_offset += n;
        return *this;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator-(Distance n) const
    {
        self_type retval;
        retval.ptr = ptr;
        retval.tex_offset = tex_offset - n;
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator-=(Distance n)
    {
        tex_offset -= n;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) difference_type operator-(self_type other) const
    {
        return tex_offset - other.tex_offset;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator[](Distance n) const
    {
        return *(*this + n);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) pointer operator->()
    {
        return &(*(*this));
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator==(const self_type& rhs)
    {
        return ((ptr == rhs.ptr) && (tex_offset == rhs.tex_offset));
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator!=(const self_type& rhs)
    {
        return ((ptr != rhs.ptr) || (tex_offset != rhs.tex_offset));
    }


    friend std::ostream& operator<<(std::ostream& os, const self_type& itr)
    {
        return os;
    }

};





}
} } } }
# 85 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/transform_input_iterator.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/transform_input_iterator.cuh"
       
# 52 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/transform_input_iterator.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 112 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/iterator/transform_input_iterator.cuh"
template <
    typename ValueType,
    typename ConversionOp,
    typename InputIterator,
    typename Offset = ptrdiff_t>
class TransformInputIterator
{
public:


    typedef TransformInputIterator self_type;
    typedef Offset difference_type;
    typedef ValueType value_type;
    typedef ValueType* pointer;
    typedef ValueType reference;



    typedef typename thrust::detail::iterator_facade_category<
        thrust::any_system_tag,
        thrust::random_access_traversal_tag,
        value_type,
        reference
      >::type iterator_category;




private:

    ConversionOp conversion_op;
    InputIterator input_itr;

public:


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) TransformInputIterator(
        InputIterator input_itr,
        ConversionOp conversion_op)
    :
        conversion_op(conversion_op),
        input_itr(input_itr)
    {}


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++(int)
    {
        self_type retval = *this;
        input_itr++;
        return retval;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator++()
    {
        input_itr++;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator*() const
    {
        return conversion_op(*input_itr);
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator+(Distance n) const
    {
        self_type retval(input_itr + n, conversion_op);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator+=(Distance n)
    {
        input_itr += n;
        return *this;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type operator-(Distance n) const
    {
        self_type retval(input_itr - n, conversion_op);
        return retval;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) self_type& operator-=(Distance n)
    {
        input_itr -= n;
        return *this;
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) difference_type operator-(self_type other) const
    {
        return input_itr - other.input_itr;
    }


    template <typename Distance>
    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) reference operator[](Distance n) const
    {
        return conversion_op(input_itr[n]);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) pointer operator->()
    {
        return &conversion_op(*input_itr);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator==(const self_type& rhs)
    {
        return (input_itr == rhs.input_itr);
    }


    __attribute__((host)) __attribute__((device)) __inline__ __attribute__((always_inline)) bool operator!=(const self_type& rhs)
    {
        return (input_itr != rhs.input_itr);
    }


    friend std::ostream& operator<<(std::ostream& os, const self_type& itr)
    {
        return os;
    }
};





}
} } } }
# 86 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh" 1
# 34 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh"
       


# 1 "/usr/include/c++/4.8.2/set" 1 3
# 58 "/usr/include/c++/4.8.2/set" 3
       
# 59 "/usr/include/c++/4.8.2/set" 3

# 1 "/usr/include/c++/4.8.2/bits/stl_tree.h" 1 3
# 69 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;







    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

     
     
# 217 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
     
# 216 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

     
     
# 221 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
     
# 220 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const
      { return iterator(static_cast<typename iterator::_Link_type>
   (const_cast<typename iterator::_Base_ptr>(_M_node))); }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

     
     
# 298 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
     
# 297 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

     
     
# 302 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
     
# 301 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline
   
# 310 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
   
# 309 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
           bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline
   
# 316 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
   
# 315 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
           bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }


      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct
       (std::__addressof(__tmp->_M_value_field), __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(std::__addressof(__p->_M_value_field));
 _M_put_node(__p);
      }
# 426 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }
# 462 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return reinterpret_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);
# 611 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      iterator
      _M_insert_(_Base_ptr __x, _Base_ptr __y,
   const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);


      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }





      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

     
     
# 723 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
     
# 722 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }

      void
      swap(_Rb_tree& __t);
# 771 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);


      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:
# 824 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      void
      erase(iterator __position)
      { _M_erase_aux(__position); }

      void
      erase(const_iterator __position)
      { _M_erase_aux(__position); }

      size_type
      erase(const key_type& __x);
# 846 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_erase_aux(__first, __last); }

      void
      erase(const_iterator __first, const_iterator __last)
      { _M_erase_aux(__first, __last); }

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


     
     
# 901 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
     
# 900 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
   
# 907 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
   
# 906 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
           bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
   
# 917 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
   
# 916 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
           bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
   
# 927 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
   
# 926 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
           bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
   
# 934 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
   
# 933 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
           bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
   
# 941 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
   
# 940 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
           bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
   
# 948 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
   
# 947 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
           bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 984 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_(_Base_ptr __x, _Base_ptr __p, const _Val& __v)

    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node((__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_lower(_Base_ptr __p, const _Val& __v)

    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node((__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal_lower(const _Val& __v)

    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, (__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_unique(const _Val& __v)

    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 return _Res(_M_insert_(__res.first, __res.second,
          (__v)),
      true);

      return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal(const _Val& __v)

    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      return _M_insert_(__res.first, __res.second, (__v));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_unique_(const_iterator __position, const _Val& __v)

    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     (__v));
      return iterator(static_cast<_Link_type>(__res.first));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal_(const_iterator __position, const _Val& __v)

    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     (__v));

      return _M_insert_equal_lower((__v));
    }
# 1714 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
   
   
# 1829 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
   
# 1828 "/usr/include/c++/4.8.2/bits/stl_tree.h" 3
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }


}
# 61 "/usr/include/c++/4.8.2/set" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_set.h" 1 3
# 64 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()
      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 162 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
# 179 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
# 193 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      set(const set& __x)
      : _M_t(__x._M_t) { }
# 232 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 280 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 367 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
     
     
# 368 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
     
# 367 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 392 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      void
      swap(set& __x)
      { _M_t.swap(__x._M_t); }
# 459 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 496 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 515 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
# 564 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 580 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 618 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 629 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      void
      clear()
      { _M_t.clear(); }
# 643 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 661 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 682 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 698 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 723 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
 friend

# 734 "/usr/include/c++/4.8.2/bits/stl_set.h" 3

# 733 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
        bool
 operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend

# 738 "/usr/include/c++/4.8.2/bits/stl_set.h" 3

# 737 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
        bool
 operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 752 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 754 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
   
# 753 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
           bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 769 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 771 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
   
# 770 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
           bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 778 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
   
# 777 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
           bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 785 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
   
# 784 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
           bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 792 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
   
# 791 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
           bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 799 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
   
# 798 "/usr/include/c++/4.8.2/bits/stl_set.h" 3
           bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 62 "/usr/include/c++/4.8.2/set" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 1 3
# 64 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 90 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()
      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 159 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 175 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
# 189 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
# 228 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 277 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 364 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
     
     
# 365 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
     
# 364 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 389 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      void
      swap(multiset& __x)
      { _M_t.swap(__x._M_t); }
# 453 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 483 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 501 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 550 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 566 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 604 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 615 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      void
      clear()
      { _M_t.clear(); }
# 626 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 644 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 665 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 681 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 706 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
        friend
       
# 717 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
       
# 716 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
               bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend
       
# 722 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
       
# 721 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
               bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 737 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 739 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
   
# 738 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
           bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 754 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 756 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
   
# 755 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
           bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 763 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
   
# 762 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
           bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 770 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
   
# 769 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
           bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 777 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
   
# 776 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
           bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline
   
# 784 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
   
# 783 "/usr/include/c++/4.8.2/bits/stl_multiset.h" 3
           bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 63 "/usr/include/c++/4.8.2/set" 2 3
# 38 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh" 2
# 1 "/usr/include/c++/4.8.2/map" 1 3
# 58 "/usr/include/c++/4.8.2/map" 3
       
# 59 "/usr/include/c++/4.8.2/map" 3


# 1 "/usr/include/c++/4.8.2/bits/stl_map.h" 1 3
# 66 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 94 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 180 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 223 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 240 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
# 263 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 309 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      allocator_type
      get_allocator() const
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 428 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
     
     
# 429 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
     
# 428 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 455 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))





          __i = insert(__i, value_type(__k, mapped_type()));

 return (*__i).second;
      }
# 500 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 593 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 642 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      iterator



      insert(iterator __position, const value_type& __x)

      { return _M_t._M_insert_unique_(__position, __x); }
# 668 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 709 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 725 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 761 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 777 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 820 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 835 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 847 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 862 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 877 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 916 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 935 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend
       
# 941 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
       
# 940 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
               bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend
       
# 946 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
       
# 945 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
               bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 960 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 962 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
   
# 961 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
           bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 977 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 979 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
   
# 978 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
           bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 986 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
   
# 985 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
           bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 993 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
   
# 992 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
           bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 1000 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
   
# 999 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
           bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 1007 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
   
# 1006 "/usr/include/c++/4.8.2/bits/stl_map.h" 3
           bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 62 "/usr/include/c++/4.8.2/map" 2 3
# 1 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 1 3
# 64 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 92 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 177 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 218 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 234 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
# 257 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 303 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      allocator_type
      get_allocator() const
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 420 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
     
     
# 421 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
     
# 420 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 500 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 533 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      iterator



      insert(iterator __position, const value_type& __x)

      { return _M_t._M_insert_equal_(__position, __x); }
# 560 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 614 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 630 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 670 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 686 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 729 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 744 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 768 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 783 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 820 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 837 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend
       
# 843 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
       
# 842 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
               bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend
       
# 848 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
       
# 847 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
               bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 862 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 864 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
   
# 863 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
           bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 879 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 881 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
   
# 880 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
           bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 888 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
   
# 887 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
           bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 895 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
   
# 894 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
           bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 902 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
   
# 901 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
           bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline
   
# 909 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
   
# 908 "/usr/include/c++/4.8.2/bits/stl_multimap.h" 3
           bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 63 "/usr/include/c++/4.8.2/map" 2 3
# 39 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh" 2
# 49 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh"
namespace thrust { namespace system { namespace cuda { namespace detail {


namespace cub_ {
# 104 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh"
struct CachingDeviceAllocator
{







    enum
    {

        INVALID_DEVICE_ORDINAL = -1,
    };




    static unsigned int IntPow(
        unsigned int base,
        unsigned int exp)
    {
        unsigned int retval = 1;
        while (exp > 0)
        {
            if (exp & 1) {
                retval = retval * base;
            }
            base = base * base;
            exp = exp >> 1;
        }
        return retval;
    }





    static void NearestPowerOf(
        unsigned int &power,
        size_t &rounded_bytes,
        unsigned int base,
        size_t value)
    {
        power = 0;
        rounded_bytes = 1;

        while (rounded_bytes < value)
        {
            rounded_bytes *= base;
            power++;
        }
    }




    struct BlockDescriptor
    {
        int device;
        void* d_ptr;
        cudaStream_t associated_stream;
        cudaEvent_t ready_event;
        size_t bytes;
        unsigned int bin;


        BlockDescriptor(void *d_ptr, int device) :
            d_ptr(d_ptr),
            bytes(0),
            bin(0),
            device(device),
            associated_stream(0),
            ready_event(0)
        {}


        BlockDescriptor(size_t bytes, unsigned int bin, int device, cudaStream_t associated_stream) :
            d_ptr(__null),
            bytes(bytes),
            bin(bin),
            device(device),
            associated_stream(associated_stream),
            ready_event(0)
        {}


        static bool PtrCompare(const BlockDescriptor &a, const BlockDescriptor &b)
        {
            if (a.device == b.device)
                return (a.d_ptr < b.d_ptr);
            else
                return (a.device < b.device);
        }


        static bool SizeCompare(const BlockDescriptor &a, const BlockDescriptor &b)
        {
            if (a.device == b.device)
                return (a.bytes < b.bytes);
            else
                return (a.device < b.device);
        }
    };


    typedef bool (*Compare)(const BlockDescriptor &, const BlockDescriptor &);




    typedef std::multiset<BlockDescriptor, Compare> CachedBlocks;


    typedef std::multiset<BlockDescriptor, Compare> BusyBlocks;


    typedef std::map<int, size_t> GpuCachedBytes;







    Spinlock spin_lock;

    unsigned int bin_growth;
    unsigned int min_bin;
    unsigned int max_bin;

    size_t min_bin_bytes;
    size_t max_bin_bytes;
    size_t max_cached_bytes;

    bool debug;
    bool skip_cleanup;



    GpuCachedBytes cached_bytes;
    CachedBlocks cached_blocks;
    BusyBlocks live_blocks;
# 259 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh"
    CachingDeviceAllocator(
        unsigned int bin_growth,
        unsigned int min_bin,
        unsigned int max_bin,
        size_t max_cached_bytes,
        bool skip_cleanup = false)
    :

            cached_blocks(BlockDescriptor::SizeCompare),
            live_blocks(BlockDescriptor::PtrCompare),

            debug(false),
            spin_lock(0),
            bin_growth(bin_growth),
            min_bin(min_bin),
            max_bin(max_bin),
            min_bin_bytes(IntPow(bin_growth, min_bin)),
            max_bin_bytes(IntPow(bin_growth, max_bin)),
            max_cached_bytes(max_cached_bytes)
    {}
# 294 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh"
    CachingDeviceAllocator(
        bool skip_cleanup = false)
    :

        cached_blocks(BlockDescriptor::SizeCompare),
        live_blocks(BlockDescriptor::PtrCompare),

        skip_cleanup(skip_cleanup),
        debug(false),
        spin_lock(0),
        bin_growth(8),
        min_bin(3),
        max_bin(7),
        min_bin_bytes(IntPow(bin_growth, min_bin)),
        max_bin_bytes(IntPow(bin_growth, max_bin)),
        max_cached_bytes((max_bin_bytes * 3) - 1)
    {}





    cudaError_t SetMaxCachedBytes(
        size_t max_cached_bytes)
    {






        Lock(&spin_lock);

        this->max_cached_bytes = max_cached_bytes;

        if (debug) printf("New max_cached_bytes(%lld)\n",(long long) max_cached_bytes);;


        Unlock(&spin_lock);

        return cudaSuccess;


    }
# 347 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh"
    cudaError_t DeviceAllocate(
        int device,
        void **d_ptr,
        size_t bytes,
        cudaStream_t active_stream = 0)
    {





        *d_ptr = __null;
        bool locked = false;
        int entrypoint_device = INVALID_DEVICE_ORDINAL;
        cudaError_t error = cudaSuccess;

        do {

            if (cub_::Debug((error = cudaGetDevice(&entrypoint_device)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 365)) break;
            if (device == INVALID_DEVICE_ORDINAL)
                device = entrypoint_device;


            unsigned int bin;
            size_t bin_bytes;
            NearestPowerOf(bin, bin_bytes, bin_growth, bytes);
            if (bin < min_bin) {
                bin = min_bin;
                bin_bytes = min_bin_bytes;
            }


            if (bin > max_bin)
            {

                bin = (unsigned int) -1;
                bin_bytes = bytes;
            }

            BlockDescriptor search_key(bin_bytes, bin, device, active_stream);


            if (!locked) {
                Lock(&spin_lock);
                locked = true;
            }


            CachedBlocks::iterator block_itr = cached_blocks.lower_bound(search_key);


            bool found = false;
            while ((block_itr != cached_blocks.end()) &&
                (block_itr->device == device) &&
                (block_itr->bin == search_key.bin))
            {
                cudaStream_t prev_stream = block_itr->associated_stream;
                if ((active_stream == prev_stream) || (cudaEventQuery(block_itr->ready_event) != cudaErrorNotReady))
                {

                    found = true;
                    search_key = *block_itr;
                    search_key.associated_stream = active_stream;
                    live_blocks.insert(search_key);


                    cached_blocks.erase(block_itr);
                    cached_bytes[device] -= search_key.bytes;

                    if (debug) printf("\tdevice %d reused cached block for stream %lld (%lld bytes, previously associated with stream %lld).\n\t\t %lld available blocks cached (%lld bytes), %lld live blocks outstanding.\n",device, (long long) active_stream, (long long) search_key.bytes, (long long) prev_stream, (long long) cached_blocks.size(), (long long) cached_bytes[device], (long long) live_blocks.size());
                                                                                                                                                                                                                     ;

                    break;
                }

                block_itr++;
            }

            if (!found)
            {

                if (locked) {
                    Unlock(&spin_lock);
                    locked = false;
                }


                if (device != entrypoint_device) {
                    if (cub_::Debug((error = cudaSetDevice(device)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 435)) break;
                }


                if (cub_::Debug((error = cudaMalloc(&search_key.d_ptr, search_key.bytes)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 439)) break;
                if (cub_::Debug((error = cudaEventCreateWithFlags(&search_key.ready_event, 0x02)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 440)) break;


                if (!locked) {
                    Lock(&spin_lock);
                    locked = true;
                }


                live_blocks.insert(search_key);

                if (debug) printf("\tdevice %d allocating new device block %lld bytes associated with stream %lld.\n\t\t %lld available blocks cached (%lld bytes), %lld live blocks outstanding.\n",device, (long long) search_key.bytes, (long long) search_key.associated_stream, (long long) cached_blocks.size(), (long long) cached_bytes[device], (long long) live_blocks.size());
                                                                                                                                                                                                       ;
            }


            *d_ptr = search_key.d_ptr;

        } while(0);


        if (locked) {
            Unlock(&spin_lock);
            locked = false;
        }


        if ((entrypoint_device != INVALID_DEVICE_ORDINAL) && (entrypoint_device != device))
        {
            if (cub_::Debug((error = cudaSetDevice(entrypoint_device)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 469)) return error;
        }

        return error;


    }
# 485 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh"
    cudaError_t DeviceAllocate(
        void **d_ptr,
        size_t bytes,
        cudaStream_t active_stream = 0)
    {




        return DeviceAllocate(INVALID_DEVICE_ORDINAL, d_ptr, bytes, active_stream);

    }
# 506 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh"
    cudaError_t DeviceFree(
        int device,
        void* d_ptr)
    {





        bool locked = false;
        int entrypoint_device = INVALID_DEVICE_ORDINAL;
        cudaError_t error = cudaSuccess;

        do {
            if (cub_::Debug((error = cudaGetDevice(&entrypoint_device)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 520)) break;
            if (device == INVALID_DEVICE_ORDINAL)
                device = entrypoint_device;


            if (device != entrypoint_device) {
                if (cub_::Debug((error = cudaSetDevice(device)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 526)) break;
            }


            if (!locked) {
                Lock(&spin_lock);
                locked = true;
            }


            BlockDescriptor search_key(d_ptr, device);
            BusyBlocks::iterator block_itr = live_blocks.find(search_key);
            if (block_itr == live_blocks.end())
            {

                if (cub_::Debug((error = cudaErrorUnknown), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 541)) break;
            }
            else
            {

                search_key = *block_itr;
                live_blocks.erase(block_itr);


                if (cached_bytes[device] + search_key.bytes <= max_cached_bytes)
                {

                    if (cub_::Debug((error = cudaEventRecord(search_key.ready_event, search_key.associated_stream)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 553)) break;


                    cached_blocks.insert(search_key);
                    cached_bytes[device] += search_key.bytes;

                    if (debug) printf("\tdevice %d returned %lld bytes from associated stream %lld.\n\t\t %lld available blocks cached (%lld bytes), %lld live blocks outstanding.\n",device, (long long) search_key.bytes, (long long) search_key.associated_stream, (long long) cached_blocks.size(), (long long) cached_bytes[device], (long long) live_blocks.size());
                                                                                                                                                                                                           ;
                }
                else
                {

                    if (locked) {
                        Unlock(&spin_lock);
                        locked = false;
                    }


                    if (cub_::Debug((error = cudaFree(d_ptr)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 571)) break;
                    if (cub_::Debug((error = cudaEventDestroy(search_key.ready_event)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 572)) break;

                    if (debug) printf("\tdevice %d freed %lld bytes from associated stream %lld.\n\t\t  %lld available blocks cached (%lld bytes), %lld live blocks outstanding.\n",device, (long long) search_key.bytes, (long long) search_key.associated_stream, (long long) cached_blocks.size(), (long long) cached_bytes[device], (long long) live_blocks.size());
                                                                                                                                                                                                           ;
                }
            }
        } while (0);


        if (locked) {
            Unlock(&spin_lock);
            locked = false;
        }

        if ((entrypoint_device != INVALID_DEVICE_ORDINAL) && (entrypoint_device != device))
        {
            if (cub_::Debug((error = cudaSetDevice(entrypoint_device)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 588)) return error;
        }

        return error;


    }
# 604 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh"
    cudaError_t DeviceFree(
        void* d_ptr)
    {




        return DeviceFree(INVALID_DEVICE_ORDINAL, d_ptr);

    }





    cudaError_t FreeAllCached()
    {





        cudaError_t error = cudaSuccess;
        bool locked = false;
        int entrypoint_device = INVALID_DEVICE_ORDINAL;
        int current_device = INVALID_DEVICE_ORDINAL;


        if (!locked) {
            Lock(&spin_lock);
            locked = true;
        }

        while (!cached_blocks.empty())
        {

            CachedBlocks::iterator begin = cached_blocks.begin();


            if (entrypoint_device == INVALID_DEVICE_ORDINAL)
            {
                if (cub_::Debug((error = cudaGetDevice(&entrypoint_device)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 645)) break;
            }


            if (begin->device != current_device)
            {
                if (cub_::Debug((error = cudaSetDevice(begin->device)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 651)) break;
                current_device = begin->device;
            }


            if (cub_::Debug((error = cudaFree(begin->d_ptr)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 656)) break;
            if (cub_::Debug((error = cudaEventDestroy(begin->ready_event)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 657)) break;


            cached_bytes[current_device] -= begin->bytes;
            cached_blocks.erase(begin);

            if (debug) printf("\tdevice %d freed %lld bytes.\n\t\t  %lld available blocks cached (%lld bytes), %lld live blocks outstanding.\n",current_device, (long long) begin->bytes, (long long) cached_blocks.size(), (long long) cached_bytes[current_device], (long long) live_blocks.size());
                                                                                                                                                                     ;
        }


        if (locked) {
            Unlock(&spin_lock);
            locked = false;
        }


        if (entrypoint_device != INVALID_DEVICE_ORDINAL)
        {
            if (cub_::Debug((error = cudaSetDevice(entrypoint_device)), "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/util_allocator.cuh", 676)) return error;
        }

        return error;


    }





    virtual ~CachingDeviceAllocator()
    {
        if (!skip_cleanup)
            FreeAllCached();
    }

};






}
} } } }
# 89 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub/cub.cuh" 2
# 64 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/cub.h" 2
# 29 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_radix_sort.inl" 2



namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{
namespace stable_radix_sort_detail
{



template<typename Key>
__attribute__((host)) __attribute__((device))
cudaError_t cub_sort_keys_wrapper(void *d_temp_storage,
                                  size_t &temp_storage_bytes,
                                  cub_::DoubleBuffer<Key> &d_keys,
                                  int num_items,
                                  thrust::less<Key> comp,
                                  int begin_bit = 0,
                                  int end_bit = sizeof(Key) * 8,
                                  cudaStream_t stream = 0,
                                  bool debug_synchronous = false)
{
  struct workaround
  {
    __attribute__((host))
    static cudaError_t host_path(void *d_temp_storage,
                                 size_t &temp_storage_bytes,
                                 cub_::DoubleBuffer<Key> &d_keys,
                                 int num_items,
                                 thrust::less<Key>,
                                 int begin_bit,
                                 int end_bit,
                                 cudaStream_t stream,
                                 bool debug_synchronous)
    {
      return cub_::DeviceRadixSort::SortKeys(d_temp_storage, temp_storage_bytes, d_keys, num_items, begin_bit, end_bit, stream, debug_synchronous);
    }

    __attribute__((device))
    static cudaError_t device_path(void *d_temp_storage,
                                   size_t &temp_storage_bytes,
                                   cub_::DoubleBuffer<Key> &d_keys,
                                   int num_items,
                                   thrust::less<Key>,
                                   int begin_bit,
                                   int end_bit,
                                   cudaStream_t stream,
                                   bool debug_synchronous)
    {

      return cub_::DeviceRadixSort::SortKeys(d_temp_storage, temp_storage_bytes, d_keys, num_items, begin_bit, end_bit, stream, debug_synchronous);



    }
  };


  return workaround::host_path(d_temp_storage, temp_storage_bytes, d_keys, num_items, comp, begin_bit, end_bit, stream, debug_synchronous);



}



template<typename Key>
__attribute__((host)) __attribute__((device))
cudaError_t cub_sort_keys_wrapper(void *d_temp_storage,
                                  size_t &temp_storage_bytes,
                                  cub_::DoubleBuffer<Key> &d_keys,
                                  int num_items,
                                  thrust::greater<Key> comp,
                                  int begin_bit = 0,
                                  int end_bit = sizeof(Key) * 8,
                                  cudaStream_t stream = 0,
                                  bool debug_synchronous = false)
{
  struct workaround
  {
    __attribute__((host))
    static cudaError_t host_path(void *d_temp_storage,
                                 size_t &temp_storage_bytes,
                                 cub_::DoubleBuffer<Key> &d_keys,
                                 int num_items,
                                 thrust::greater<Key>,
                                 int begin_bit,
                                 int end_bit,
                                 cudaStream_t stream,
                                 bool debug_synchronous)
    {
      return cub_::DeviceRadixSort::SortKeysDescending(d_temp_storage, temp_storage_bytes, d_keys, num_items, begin_bit, end_bit, stream, debug_synchronous);
    }

    __attribute__((device))
    static cudaError_t device_path(void *d_temp_storage,
                                   size_t &temp_storage_bytes,
                                   cub_::DoubleBuffer<Key> &d_keys,
                                   int num_items,
                                   thrust::greater<Key>,
                                   int begin_bit,
                                   int end_bit,
                                   cudaStream_t stream,
                                   bool debug_synchronous)
    {

      return cub_::DeviceRadixSort::SortKeys(d_temp_storage, temp_storage_bytes, d_keys, num_items, begin_bit, end_bit, stream, debug_synchronous);



    }
  };


  return workaround::host_path(d_temp_storage, temp_storage_bytes, d_keys, num_items, comp, begin_bit, end_bit, stream, debug_synchronous);



}





template<typename T, typename Compare>
__attribute__((host)) __attribute__((device))
thrust::tuple<size_t, size_t, size_t> compute_temporary_storage_requirements_for_radix_sort_n(size_t n, Compare comp, cudaStream_t stream)
{
  cub_::DoubleBuffer<T> dummy;


  size_t num_additional_temp_storage_bytes = 0;
  thrust::system::cuda::detail::throw_on_error(cub_sort_keys_wrapper(0, num_additional_temp_storage_bytes, dummy, static_cast<int>(n), comp, 0, sizeof(T)*8, stream),
                                               "after cub_::DeviceRadixSort::SortKeys(0)");



  typedef typename bulk_::detail::aligned_type<16>::type aligned_type;

  size_t num_double_buffer_bytes = n * sizeof(T);
  size_t num_aligned_double_buffer_bytes = thrust::detail::util::round_i(num_double_buffer_bytes, sizeof(aligned_type));
  size_t num_aligned_total_temporary_storage_bytes = num_aligned_double_buffer_bytes + num_additional_temp_storage_bytes;

  return thrust::make_tuple(num_aligned_total_temporary_storage_bytes, num_aligned_double_buffer_bytes, num_additional_temp_storage_bytes);
}


template<typename DerivedPolicy, typename T, typename Compare>
__attribute__((host)) __attribute__((device))
void stable_radix_sort_n(execution_policy<DerivedPolicy> &exec, T* first, size_t n, Compare comp)
{
  if(n > 1)
  {
    cudaStream_t s = stream(thrust::detail::derived_cast<DerivedPolicy>(exec));


    size_t num_temporary_storage_bytes = 0;
    size_t offset_to_additional_temp_storage = 0;
    size_t num_additional_temp_storage_bytes = 0;
    thrust::tie(num_temporary_storage_bytes, offset_to_additional_temp_storage, num_additional_temp_storage_bytes) =
      compute_temporary_storage_requirements_for_radix_sort_n<T>(n, comp, s);


    thrust::detail::temporary_array<char,DerivedPolicy> temporary_storage(exec, num_temporary_storage_bytes);


    cub_::DoubleBuffer<T> double_buffer;
    double_buffer.d_buffers[0] = thrust::raw_pointer_cast(&*first);
    double_buffer.d_buffers[1] = reinterpret_cast<T*>(reinterpret_cast<void*>(thrust::raw_pointer_cast(&temporary_storage[0])));

    thrust::system::cuda::detail::throw_on_error(cub_sort_keys_wrapper(thrust::raw_pointer_cast(&temporary_storage[offset_to_additional_temp_storage]),
                                                                       num_additional_temp_storage_bytes,
                                                                       double_buffer,
                                                                       static_cast<int>(n),
                                                                       comp,
                                                                       0,
                                                                       sizeof(T)*8,
                                                                       s),
                                                 "after cub_::DeviceRadixSort::SortKeys(1)");

    thrust::system::cuda::detail::synchronize_if_enabled("stable_radix_sort_n(): after cub_::DeviceRadixSort::SortKeys(1)");

    if(double_buffer.selector != 0)
    {
      T* temp_ptr = reinterpret_cast<T*>(double_buffer.d_buffers[1]);
      thrust::copy(exec, temp_ptr, temp_ptr + n, first);
    }
  }
}


}


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_radix_sort(execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator first,
                       RandomAccessIterator last,
                       thrust::less<typename thrust::iterator_value<RandomAccessIterator>::type> comp)
{
  stable_radix_sort_detail::stable_radix_sort_n(exec, thrust::raw_pointer_cast(&*first), last - first, comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_radix_sort(execution_policy<DerivedPolicy> &exec,
                       RandomAccessIterator first,
                       RandomAccessIterator last,
                       thrust::greater<typename thrust::iterator_value<RandomAccessIterator>::type> comp)
{
  stable_radix_sort_detail::stable_radix_sort_n(exec, thrust::raw_pointer_cast(&*first), last - first, comp);
}







namespace stable_radix_sort_detail
{



template<typename Key, typename Value>
__attribute__((host)) __attribute__((device))
cudaError_t cub_sort_pairs_wrapper(void *d_temp_storage,
                                   size_t &temp_storage_bytes,
                                   cub_::DoubleBuffer<Key> &d_keys,
                                   cub_::DoubleBuffer<Value> &d_values,
                                   int num_items,
                                   thrust::less<Key> comp,
                                   int begin_bit = 0,
                                   int end_bit = sizeof(Key) * 8,
                                   cudaStream_t stream = 0,
                                   bool debug_synchronous = false)
{
  struct workaround
  {
    __attribute__((host))
    static cudaError_t host_path(void *d_temp_storage,
                                 size_t &temp_storage_bytes,
                                 cub_::DoubleBuffer<Key> &d_keys,
                                 cub_::DoubleBuffer<Value> &d_values,
                                 int num_items,
                                 thrust::less<Key>,
                                 int begin_bit,
                                 int end_bit,
                                 cudaStream_t stream,
                                 bool debug_synchronous)
    {
      return cub_::DeviceRadixSort::SortPairs(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, stream, debug_synchronous);
    }

    __attribute__((device))
    static cudaError_t device_path(void *d_temp_storage,
                                   size_t &temp_storage_bytes,
                                   cub_::DoubleBuffer<Key> &d_keys,
                                   cub_::DoubleBuffer<Value> &d_values,
                                   int num_items,
                                   thrust::less<Key>,
                                   int begin_bit,
                                   int end_bit,
                                   cudaStream_t stream,
                                   bool debug_synchronous)
    {

      return cub_::DeviceRadixSort::SortPairs(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, stream, debug_synchronous);



    }
  };


  return workaround::host_path(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, comp, begin_bit, end_bit, stream, debug_synchronous);



}



template<typename Key, typename Value>
__attribute__((host)) __attribute__((device))
cudaError_t cub_sort_pairs_wrapper(void *d_temp_storage,
                                   size_t &temp_storage_bytes,
                                   cub_::DoubleBuffer<Key> &d_keys,
                                   cub_::DoubleBuffer<Value> &d_values,
                                   int num_items,
                                   thrust::greater<Key> comp,
                                   int begin_bit = 0,
                                   int end_bit = sizeof(Key) * 8,
                                   cudaStream_t stream = 0,
                                   bool debug_synchronous = false)
{
  struct workaround
  {
    __attribute__((host))
    static cudaError_t host_path(void *d_temp_storage,
                                 size_t &temp_storage_bytes,
                                 cub_::DoubleBuffer<Key> &d_keys,
                                 cub_::DoubleBuffer<Value> &d_values,
                                 int num_items,
                                 thrust::greater<Key>,
                                 int begin_bit,
                                 int end_bit,
                                 cudaStream_t stream,
                                 bool debug_synchronous)
    {
      return cub_::DeviceRadixSort::SortPairsDescending(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, stream, debug_synchronous);
    }

    __attribute__((device))
    static cudaError_t device_path(void *d_temp_storage,
                                   size_t &temp_storage_bytes,
                                   cub_::DoubleBuffer<Key> &d_keys,
                                   cub_::DoubleBuffer<Value> &d_values,
                                   int num_items,
                                   thrust::greater<Key>,
                                   int begin_bit,
                                   int end_bit,
                                   cudaStream_t stream,
                                   bool debug_synchronous)
    {

      return cub_::DeviceRadixSort::SortPairsDescending(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, stream, debug_synchronous);



    }
  };


  return workaround::host_path(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, comp, begin_bit, end_bit, stream, debug_synchronous);



}






template<typename Key, typename Value, typename Compare>
__attribute__((host)) __attribute__((device))
thrust::tuple<size_t, size_t, size_t, size_t> compute_temporary_storage_requirements_for_radix_sort_by_key_n(size_t n, Compare comp, cudaStream_t stream)
{
  cub_::DoubleBuffer<Key> dummy_keys;
  cub_::DoubleBuffer<Value> dummy_values;


  size_t num_additional_temp_storage_bytes = 0;
  thrust::system::cuda::detail::throw_on_error(cub_sort_pairs_wrapper(0, num_additional_temp_storage_bytes, dummy_keys, dummy_values, static_cast<int>(n), comp, 0, sizeof(Key)*8, stream),
                                               "after cub_::DeviceRadixSort::SortPairs(0)");



  typedef typename bulk_::detail::aligned_type<16>::type aligned_type;

  size_t num_keys_double_buffer_bytes = n * sizeof(Key);


  size_t num_aligned_keys_double_buffer_bytes = thrust::detail::util::round_i(num_keys_double_buffer_bytes, sizeof(aligned_type));

  size_t num_values_double_buffer_bytes = n * sizeof(Value);


  size_t num_aligned_double_buffer_bytes = thrust::detail::util::round_i(num_aligned_keys_double_buffer_bytes + num_values_double_buffer_bytes, sizeof(aligned_type));

  size_t num_aligned_total_temporary_storage_bytes = num_aligned_double_buffer_bytes + num_additional_temp_storage_bytes;

  return thrust::make_tuple(num_aligned_total_temporary_storage_bytes, num_aligned_keys_double_buffer_bytes, num_aligned_double_buffer_bytes, num_additional_temp_storage_bytes);
}



template<typename DerivedPolicy,
         typename Key,
         typename Value,
         typename Compare>
__attribute__((host)) __attribute__((device))
void stable_radix_sort_by_key_n(execution_policy<DerivedPolicy> &exec,
                                Key* first1,
                                size_t n,
                                Value* first2,
                                Compare comp)
{
  if(n > 1)
  {
    cudaStream_t s = stream(thrust::detail::derived_cast<DerivedPolicy>(exec));


    size_t num_temporary_storage_bytes = 0;
    size_t offset_to_values_buffer = 0;
    size_t offset_to_additional_temp_storage = 0;
    size_t num_additional_temp_storage_bytes = 0;
    thrust::tie(num_temporary_storage_bytes, offset_to_values_buffer, offset_to_additional_temp_storage, num_additional_temp_storage_bytes) =
      compute_temporary_storage_requirements_for_radix_sort_by_key_n<Key,Value>(n, comp, s);


    thrust::detail::temporary_array<char,DerivedPolicy> temporary_storage(exec, num_temporary_storage_bytes);


    cub_::DoubleBuffer<Key> double_buffer_keys;
    double_buffer_keys.d_buffers[0] = thrust::raw_pointer_cast(&*first1);
    double_buffer_keys.d_buffers[1] = reinterpret_cast<Key*>(reinterpret_cast<void*>(thrust::raw_pointer_cast(&temporary_storage[0])));

    cub_::DoubleBuffer<Value> double_buffer_values;
    double_buffer_values.d_buffers[0] = thrust::raw_pointer_cast(&*first2);
    double_buffer_values.d_buffers[1] = reinterpret_cast<Value*>(reinterpret_cast<void*>(thrust::raw_pointer_cast(&temporary_storage[offset_to_values_buffer])));

    thrust::system::cuda::detail::throw_on_error(cub_sort_pairs_wrapper(thrust::raw_pointer_cast(&temporary_storage[offset_to_additional_temp_storage]),
                                                                        num_additional_temp_storage_bytes,
                                                                        double_buffer_keys,
                                                                        double_buffer_values,
                                                                        static_cast<int>(n),
                                                                        comp,
                                                                        0,
                                                                        sizeof(Key)*8,
                                                                        s),
                                                 "after cub_::DeviceRadixSort::SortPairs(1)");

    thrust::system::cuda::detail::synchronize_if_enabled("stable_radix_sort_by_key_n(): after cub_::DeviceRadixSort::SortPairs(1)");

    if(double_buffer_keys.selector != 0)
    {
      Key* temp_ptr = reinterpret_cast<Key*>(double_buffer_keys.d_buffers[1]);
      thrust::copy(exec, temp_ptr, temp_ptr + n, first1);
    }

    if(double_buffer_values.selector != 0)
    {
      Value* temp_ptr = reinterpret_cast<Value*>(double_buffer_values.d_buffers[1]);
      thrust::copy(exec, temp_ptr, temp_ptr + n, first2);
    }
  }
}


}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_radix_sort_by_key(execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 first1,
                              RandomAccessIterator1 last1,
                              RandomAccessIterator2 first2,
                              thrust::less<typename thrust::iterator_value<RandomAccessIterator1>::type> comp)
{
  stable_radix_sort_detail::stable_radix_sort_by_key_n(exec,
                                                       thrust::raw_pointer_cast(&*first1),
                                                       last1 - first1,
                                                       thrust::raw_pointer_cast(&*first2),
                                                       comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_radix_sort_by_key(execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 first1,
                              RandomAccessIterator1 last1,
                              RandomAccessIterator2 first2,
                              thrust::greater<typename thrust::iterator_value<RandomAccessIterator1>::type> comp)
{
  stable_radix_sort_detail::stable_radix_sort_by_key_n(exec,
                                                       thrust::raw_pointer_cast(&*first1),
                                                       last1 - first1,
                                                       thrust::raw_pointer_cast(&*first2),
                                                       comp);
}


}
}
}
}
}
# 87 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_radix_sort.h" 2
# 22 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_primitive_sort.inl" 2

# 1 "/usr/local/cuda-8.0/include/thrust/partition.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/partition.h"
       





namespace thrust
{
# 97 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred);
# 157 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename ForwardIterator,
         typename Predicate>
  ForwardIterator partition(ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred);
# 225 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred);
# 293 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
  ForwardIterator partition(ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred);
# 369 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   InputIterator first,
                   InputIterator last,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred);
# 446 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(InputIterator first,
                   InputIterator last,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred);
# 523 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   InputIterator1 first,
                   InputIterator1 last,
                   InputIterator2 stencil,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred);
# 599 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(InputIterator1 first,
                   InputIterator1 last,
                   InputIterator2 stencil,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred);
# 672 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   Predicate pred);
# 735 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename ForwardIterator,
         typename Predicate>
  ForwardIterator stable_partition(ForwardIterator first,
                                   ForwardIterator last,
                                   Predicate pred);
# 805 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   InputIterator stencil,
                                   Predicate pred);
# 875 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
  ForwardIterator stable_partition(ForwardIterator first,
                                   ForwardIterator last,
                                   InputIterator stencil,
                                   Predicate pred);
# 953 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          InputIterator first,
                          InputIterator last,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred);
# 1032 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(InputIterator first,
                          InputIterator last,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred);
# 1110 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          InputIterator1 first,
                          InputIterator1 last,
                          InputIterator2 stencil,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred);
# 1188 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(InputIterator1 first,
                          InputIterator1 last,
                          InputIterator2 stencil,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred);
# 1263 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy, typename ForwardIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition_point(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last,
                                  Predicate pred);
# 1315 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename ForwardIterator, typename Predicate>
  ForwardIterator partition_point(ForwardIterator first,
                                  ForwardIterator last,
                                  Predicate pred);
# 1376 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
  bool is_partitioned(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      Predicate pred);
# 1425 "/usr/local/cuda-8.0/include/thrust/partition.h"
template<typename InputIterator, typename Predicate>
  bool is_partitioned(InputIterator first,
                      InputIterator last,
                      Predicate pred);







}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/partition.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/partition.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/partition.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/partition.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename ExecutionPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(thrust::execution_policy<ExecutionPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   Predicate pred);

template<typename ExecutionPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(thrust::execution_policy<ExecutionPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   InputIterator stencil,
                                   Predicate pred);


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(thrust::execution_policy<ExecutionPolicy> &exec,
                          InputIterator first,
                          InputIterator last,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred);


template<typename ExecutionPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(thrust::execution_policy<ExecutionPolicy> &exec,
                          InputIterator1 first,
                          InputIterator1 last,
                          InputIterator2 stencil,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred);


template<typename ExecutionPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(thrust::execution_policy<ExecutionPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred);


template<typename ExecutionPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(thrust::execution_policy<ExecutionPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred);


template<typename ExecutionPolicy,
         typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(thrust::execution_policy<ExecutionPolicy> &exec,
                   InputIterator first,
                   InputIterator last,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred);


template<typename ExecutionPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(thrust::execution_policy<ExecutionPolicy> &exec,
                   InputIterator1 first,
                   InputIterator1 last,
                   InputIterator2 stencil,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred);


template<typename ExecutionPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition_point(thrust::execution_policy<ExecutionPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last,
                                  Predicate pred);


template<typename ExecutionPolicy,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  bool is_partitioned(thrust::execution_policy<ExecutionPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      Predicate pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/partition.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/partition.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/remove.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/remove.h"
       




namespace thrust
{
# 95 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         ForwardIterator first,
                         ForwardIterator last,
                         const T &value);
# 157 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename ForwardIterator,
         typename T>
  ForwardIterator remove(ForwardIterator first,
                         ForwardIterator last,
                         const T &value);
# 211 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                             InputIterator first,
                             InputIterator last,
                             OutputIterator result,
                             const T &value);
# 264 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename InputIterator,
         typename OutputIterator,
         typename T>
  OutputIterator remove_copy(InputIterator first,
                             InputIterator last,
                             OutputIterator result,
                             const T &value);
# 342 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred);
# 415 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename ForwardIterator,
         typename Predicate>
  ForwardIterator remove_if(ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred);
# 479 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                Predicate pred);
# 542 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename InputIterator,
         typename OutputIterator,
         typename Predicate>
  OutputIterator remove_copy_if(InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                Predicate pred);
# 605 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred);
# 665 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
  ForwardIterator remove_if(ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred);
# 727 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator1 first,
                                InputIterator1 last,
                                InputIterator2 stencil,
                                OutputIterator result,
                                Predicate pred);
# 788 "/usr/local/cuda-8.0/include/thrust/remove.h"
template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
  OutputIterator remove_copy_if(InputIterator1 first,
                                InputIterator1 last,
                                InputIterator2 stencil,
                                OutputIterator result,
                                Predicate pred);






}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/remove.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/remove.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/remove.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/remove.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove(thrust::execution_policy<DerivedPolicy> &exec,
                         ForwardIterator first,
                         ForwardIterator last,
                         const T &value);


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy(thrust::execution_policy<DerivedPolicy> &exec,
                             InputIterator first,
                             InputIterator last,
                             OutputIterator result,
                             const T &value);


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(thrust::execution_policy<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred);


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(thrust::execution_policy<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred);


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                Predicate pred);


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                                InputIterator1 first,
                                InputIterator1 last,
                                InputIterator2 stencil,
                                OutputIterator result,
                                Predicate pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/remove.inl" 1
# 30 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/remove.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove(thrust::execution_policy<DerivedPolicy> &exec,
                         ForwardIterator first,
                         ForwardIterator last,
                         const T &value)
{
  thrust::detail::equal_to_value<T> pred(value);


  return thrust::remove_if(exec, first, last, pred);
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy(thrust::execution_policy<DerivedPolicy> &exec,
                             InputIterator first,
                             InputIterator last,
                             OutputIterator result,
                             const T &value)
{
  thrust::detail::equal_to_value<T> pred(value);


  return thrust::remove_copy_if(exec, first, last, result, pred);
}


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(thrust::execution_policy<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred)
{
  typedef typename thrust::iterator_traits<ForwardIterator>::value_type InputType;


  thrust::detail::temporary_array<InputType,DerivedPolicy> temp(exec, first, last);


  return thrust::remove_copy_if(exec, temp.begin(), temp.end(), temp.begin(), first, pred);
}


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(thrust::execution_policy<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred)
{
  typedef typename thrust::iterator_traits<ForwardIterator>::value_type InputType;


  thrust::detail::temporary_array<InputType,DerivedPolicy> temp(exec, first, last);


  return thrust::remove_copy_if(exec, temp.begin(), temp.end(), stencil, first, pred);
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                Predicate pred)
{
  return thrust::remove_copy_if(exec, first, last, first, result, pred);
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(thrust::execution_policy<DerivedPolicy> &exec,
                                InputIterator1 first,
                                InputIterator1 last,
                                InputIterator2 stencil,
                                OutputIterator result,
                                Predicate pred)
{
  return thrust::copy_if(exec, first, last, stencil, result, thrust::detail::not1(pred));
}


}
}
}
}
# 113 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/remove.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/remove.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/remove.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/remove.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h"
       





namespace thrust
{
namespace system
{
namespace detail
{
namespace sequential
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(sequential::execution_policy<DerivedPolicy> &,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred)
{

  thrust::detail::wrapped_function<
    Predicate,
   
 
# 52 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h"
 
# 51 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h"
    bool
  > wrapped_pred(pred);


  while(first != last && !wrapped_pred(*first))
    ++first;

  if(first == last)
    return first;


  ForwardIterator result = first;

  ++first;

  while(first != last)
  {
    if(!wrapped_pred(*first))
    {
      *result = *first;
      ++result;
    }
    ++first;
  }

  return result;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(sequential::execution_policy<DerivedPolicy> &,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred)
{

  thrust::detail::wrapped_function<
    Predicate,
   
 
# 96 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h"
 
# 95 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h"
    bool
  > wrapped_pred(pred);


  while(first != last && !wrapped_pred(*stencil))
  {
    ++first;
    ++stencil;
  }

  if(first == last)
    return first;


  ForwardIterator result = first;

  ++first;
  ++stencil;

  while(first != last)
  {
    if(!wrapped_pred(*stencil))
    {
      *result = *first;
      ++result;
    }
    ++first;
    ++stencil;
  }

  return result;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(sequential::execution_policy<DerivedPolicy> &,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                Predicate pred)
{

  thrust::detail::wrapped_function<
    Predicate,
   
 
# 145 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h"
 
# 144 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h"
    bool
  > wrapped_pred(pred);

  while (first != last)
  {
    if (!wrapped_pred(*first))
    {
      *result = *first;
      ++result;
    }

    ++first;
  }

  return result;
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(sequential::execution_policy<DerivedPolicy> &,
                                InputIterator1 first,
                                InputIterator1 last,
                                InputIterator2 stencil,
                                OutputIterator result,
                                Predicate pred)
{

  thrust::detail::wrapped_function<
    Predicate,
   
 
# 180 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h"
 
# 179 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/remove.h"
    bool
  > wrapped_pred(pred);

  while (first != last)
  {
    if (!wrapped_pred(*stencil))
    {
      *result = *first;
      ++result;
    }

    ++first;
    ++stencil;
  }

  return result;
}


}
}
}
}
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/remove.h" 2


# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/remove.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/remove.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/remove.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/remove.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                         ForwardIterator first,
                         ForwardIterator last,
                         const T &value)
{
  using thrust::system::detail::generic::remove;
  return remove(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename T>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                             InputIterator first,
                             InputIterator last,
                             OutputIterator result,
                             const T &value)
{
  using thrust::system::detail::generic::remove_copy;
  return remove_copy(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred)
{
  using thrust::system::detail::generic::remove_if;
  return remove_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                Predicate pred)
{
  using thrust::system::detail::generic::remove_copy_if;
  return remove_copy_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, result, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator remove_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred)
{
  using thrust::system::detail::generic::remove_if;
  return remove_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  OutputIterator remove_copy_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                InputIterator1 first,
                                InputIterator1 last,
                                InputIterator2 stencil,
                                OutputIterator result,
                                Predicate pred)
{
  using thrust::system::detail::generic::remove_copy_if;
  return remove_copy_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, result, pred);
}


template<typename ForwardIterator,
         typename T>
  ForwardIterator remove(ForwardIterator first,
                         ForwardIterator last,
                         const T &value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::remove(select_system(system), first, last, value);
}


template<typename InputIterator,
         typename OutputIterator,
         typename T>
  OutputIterator remove_copy(InputIterator first,
                             InputIterator last,
                             OutputIterator result,
                             const T &value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::remove_copy(select_system(system1,system2), first, last, result, value);
}


template<typename ForwardIterator,
         typename Predicate>
  ForwardIterator remove_if(ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::remove_if(select_system(system), first, last, pred);
}


template<typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
  ForwardIterator remove_if(ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System1;
  typedef typename thrust::iterator_system<InputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::remove_if(select_system(system1,system2), first, last, stencil, pred);
}


template<typename InputIterator,
         typename OutputIterator,
         typename Predicate>
  OutputIterator remove_copy_if(InputIterator first,
                                InputIterator last,
                                OutputIterator result,
                                Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::remove_copy_if(select_system(system1,system2), first, last, result, pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator,
         typename Predicate>
  OutputIterator remove_copy_if(InputIterator1 first,
                                InputIterator1 last,
                                InputIterator2 stencil,
                                OutputIterator result,
                                Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::remove_copy_if(select_system(system1,system2,system3), first, last, stencil, result, pred);
}


}
# 806 "/usr/local/cuda-8.0/include/thrust/remove.h" 2
# 23 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/partition.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/count.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/count.h"
       





namespace thrust
{
# 83 "/usr/local/cuda-8.0/include/thrust/count.h"
template<typename DerivedPolicy, typename InputIterator, typename EqualityComparable>
__attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    count(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, InputIterator first, InputIterator last, const EqualityComparable& value);
# 121 "/usr/local/cuda-8.0/include/thrust/count.h"
template <typename InputIterator, typename EqualityComparable>
  typename thrust::iterator_traits<InputIterator>::difference_type
    count(InputIterator first, InputIterator last, const EqualityComparable& value);
# 174 "/usr/local/cuda-8.0/include/thrust/count.h"
template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    count_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, InputIterator first, InputIterator last, Predicate pred);
# 222 "/usr/local/cuda-8.0/include/thrust/count.h"
template <typename InputIterator, typename Predicate>
  typename thrust::iterator_traits<InputIterator>::difference_type
    count_if(InputIterator first, InputIterator last, Predicate pred);







}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/count.inl" 1
# 26 "/usr/local/cuda-8.0/include/thrust/detail/count.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/count.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/count.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template <typename DerivedPolicy, typename InputIterator, typename EqualityComparable>
__attribute__((host)) __attribute__((device))
typename thrust::iterator_traits<InputIterator>::difference_type
count(thrust::execution_policy<DerivedPolicy> &exec, InputIterator first, InputIterator last, const EqualityComparable& value);


template <typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
typename thrust::iterator_traits<InputIterator>::difference_type
count_if(thrust::execution_policy<DerivedPolicy> &exec, InputIterator first, InputIterator last, Predicate pred);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/count.inl" 1
# 19 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/count.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/transform_reduce.h" 1
# 22 "/usr/local/cuda-8.0/include/thrust/transform_reduce.h"
       




namespace thrust
{
# 105 "/usr/local/cuda-8.0/include/thrust/transform_reduce.h"
template<typename DerivedPolicy,
         typename InputIterator,
         typename UnaryFunction,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputType transform_reduce(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              UnaryFunction unary_op,
                              OutputType init,
                              BinaryFunction binary_op);
# 179 "/usr/local/cuda-8.0/include/thrust/transform_reduce.h"
template<typename InputIterator,
         typename UnaryFunction,
         typename OutputType,
         typename BinaryFunction>
  OutputType transform_reduce(InputIterator first,
                              InputIterator last,
                              UnaryFunction unary_op,
                              OutputType init,
                              BinaryFunction binary_op);







}

# 1 "/usr/local/cuda-8.0/include/thrust/detail/transform_reduce.inl" 1
# 25 "/usr/local/cuda-8.0/include/thrust/detail/transform_reduce.inl"
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform_reduce.h" 1
# 18 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform_reduce.h"
       




namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename ExecutionPolicy,
         typename InputIterator,
         typename UnaryFunction,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputType transform_reduce(thrust::execution_policy<ExecutionPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              UnaryFunction unary_op,
                              OutputType init,
                              BinaryFunction binary_op);


}
}
}
}

# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform_reduce.inl" 1
# 22 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform_reduce.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename InputIterator,
         typename UnaryFunction,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputType transform_reduce(thrust::execution_policy<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              UnaryFunction unary_op,
                              OutputType init,
                              BinaryFunction binary_op)
{
  thrust::transform_iterator<UnaryFunction, InputIterator, OutputType> xfrm_first(first, unary_op);
  thrust::transform_iterator<UnaryFunction, InputIterator, OutputType> xfrm_last(last, unary_op);

  return thrust::reduce(exec, xfrm_first, xfrm_last, init, binary_op);
}


}
}
}
}
# 53 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/transform_reduce.h" 2
# 26 "/usr/local/cuda-8.0/include/thrust/detail/transform_reduce.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/transform_reduce.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/transform_reduce.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/transform_reduce.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/transform_reduce.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/transform_reduce.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/transform_reduce.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename UnaryFunction,
         typename OutputType,
         typename BinaryFunction>
__attribute__((host)) __attribute__((device))
  OutputType transform_reduce(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                              InputIterator first,
                              InputIterator last,
                              UnaryFunction unary_op,
                              OutputType init,
                              BinaryFunction binary_op)
{
  using thrust::system::detail::generic::transform_reduce;
  return transform_reduce(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, unary_op, init, binary_op);
}


template<typename InputIterator,
         typename UnaryFunction,
         typename OutputType,
         typename BinaryFunction>
  OutputType transform_reduce(InputIterator first,
                              InputIterator last,
                              UnaryFunction unary_op,
                              OutputType init,
                              BinaryFunction binary_op)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::transform_reduce(select_system(system), first, last, unary_op, init, binary_op);
}


}
# 198 "/usr/local/cuda-8.0/include/thrust/transform_reduce.h" 2
# 20 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/count.inl" 2


namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template <typename InputType, typename Predicate, typename CountType>
struct count_if_transform
{
  __attribute__((host)) __attribute__((device))
  count_if_transform(Predicate _pred) : pred(_pred){}

  #pragma nv_exec_check_disable
  __attribute__((host)) __attribute__((device))
  CountType operator()(const InputType& val)
  {
    if(pred(val))
      return 1;
    else
      return 0;
  }

  Predicate pred;
};


template <typename DerivedPolicy, typename InputIterator, typename EqualityComparable>
__attribute__((host)) __attribute__((device))
typename thrust::iterator_traits<InputIterator>::difference_type
count(thrust::execution_policy<DerivedPolicy> &exec, InputIterator first, InputIterator last, const EqualityComparable& value)
{

  return thrust::count_if(exec, first, last, thrust::detail::equal_to_value<EqualityComparable>(value));
}


template <typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
typename thrust::iterator_traits<InputIterator>::difference_type
count_if(thrust::execution_policy<DerivedPolicy> &exec, InputIterator first, InputIterator last, Predicate pred)
{
  typedef typename thrust::iterator_traits<InputIterator>::value_type InputType;
  typedef typename thrust::iterator_traits<InputIterator>::difference_type CountType;

  thrust::system::detail::generic::count_if_transform<InputType, Predicate, CountType> unary_op(pred);
  thrust::plus<CountType> binary_op;
  return thrust::transform_reduce(exec, first, last, unary_op, CountType(0), binary_op);
}


}
}
}
}
# 51 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/count.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/count.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/count.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/count.h"
       







# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/count.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/sequential/count.h"
       
# 26 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/count.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/count.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename EqualityComparable>
__attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    count(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, InputIterator first, InputIterator last, const EqualityComparable& value)
{
  using thrust::system::detail::generic::count;
  return count(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, value);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
  typename thrust::iterator_traits<InputIterator>::difference_type
    count_if(const thrust::detail::execution_policy_base<DerivedPolicy> &exec, InputIterator first, InputIterator last, Predicate pred)
{
  using thrust::system::detail::generic::count_if;
  return count_if(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, pred);
}


template <typename InputIterator, typename EqualityComparable>
typename thrust::iterator_traits<InputIterator>::difference_type
count(InputIterator first, InputIterator last, const EqualityComparable& value)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::count(select_system(system), first, last, value);
}


template <typename InputIterator, typename Predicate>
typename thrust::iterator_traits<InputIterator>::difference_type
count_if(InputIterator first, InputIterator last, Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::count_if(select_system(system), first, last, pred);
}


}
# 235 "/usr/local/cuda-8.0/include/thrust/count.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/partition.inl" 2
# 32 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/partition.inl"
namespace thrust
{
namespace system
{
namespace detail
{
namespace generic
{


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(thrust::execution_policy<DerivedPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   Predicate pred)
{
  typedef typename thrust::iterator_traits<ForwardIterator>::value_type InputType;


  thrust::detail::temporary_array<InputType,DerivedPolicy> temp(exec, first, last);


  typename thrust::iterator_difference<ForwardIterator>::type num_true = thrust::count_if(exec, first,last,pred);


  ForwardIterator out_false = first;
  thrust::advance(out_false, num_true);

  return thrust::stable_partition_copy(exec, temp.begin(), temp.end(), first, out_false, pred).first;
}


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(thrust::execution_policy<DerivedPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   InputIterator stencil,
                                   Predicate pred)
{
  typedef typename thrust::iterator_traits<ForwardIterator>::value_type InputType;


  thrust::detail::temporary_array<InputType,DerivedPolicy> temp(exec, first, last);


  InputIterator stencil_last = stencil;
  thrust::advance(stencil_last, temp.size());
  typename thrust::iterator_difference<InputIterator>::type num_true = thrust::count_if(exec, stencil, stencil_last, pred);


  ForwardIterator out_false = first;
  thrust::advance(out_false, num_true);

  return thrust::stable_partition_copy(exec, temp.begin(), temp.end(), stencil, first, out_false, pred).first;
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(thrust::execution_policy<DerivedPolicy> &exec,
                          InputIterator first,
                          InputIterator last,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred)
{
  thrust::detail::unary_negate<Predicate> not_pred(pred);


  OutputIterator1 end_of_true_partition = thrust::remove_copy_if(exec, first, last, out_true, not_pred);


  OutputIterator2 end_of_false_partition = thrust::remove_copy_if(exec, first, last, out_false, pred);

  return thrust::make_pair(end_of_true_partition, end_of_false_partition);
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(thrust::execution_policy<DerivedPolicy> &exec,
                          InputIterator1 first,
                          InputIterator1 last,
                          InputIterator2 stencil,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred)
{
  thrust::detail::unary_negate<Predicate> not_pred(pred);


  OutputIterator1 end_of_true_partition = thrust::remove_copy_if(exec, first, last, stencil, out_true, not_pred);


  OutputIterator2 end_of_false_partition = thrust::remove_copy_if(exec, first, last, stencil, out_false, pred);

  return thrust::make_pair(end_of_true_partition, end_of_false_partition);
}


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(thrust::execution_policy<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred)
{
  return thrust::stable_partition(exec, first, last, pred);
}


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(thrust::execution_policy<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred)
{
  return thrust::stable_partition(exec, first, last, stencil, pred);
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(thrust::execution_policy<DerivedPolicy> &exec,
                   InputIterator first,
                   InputIterator last,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred)
{
  return thrust::stable_partition_copy(exec,first,last,out_true,out_false,pred);
}


template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(thrust::execution_policy<DerivedPolicy> &exec,
                   InputIterator1 first,
                   InputIterator1 last,
                   InputIterator2 stencil,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred)
{
  return thrust::stable_partition_copy(exec,first,last,stencil,out_true,out_false,pred);
}


template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition_point(thrust::execution_policy<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last,
                                  Predicate pred)
{
  return thrust::find_if_not(exec, first, last, pred);
}


template<typename DerivedPolicy,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  bool is_partitioned(thrust::execution_policy<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      Predicate pred)
{
  return thrust::is_sorted(exec,
                           thrust::make_transform_iterator(first, thrust::detail::not1(pred)),
                           thrust::make_transform_iterator(last, thrust::detail::not1(pred)));
}


}
}
}
}
# 170 "/usr/local/cuda-8.0/include/thrust/system/detail/generic/partition.h" 2
# 27 "/usr/local/cuda-8.0/include/thrust/detail/partition.inl" 2
# 1 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/partition.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/partition.h"
       
# 28 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/partition.h"
# 1 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/partition.h" 1
# 17 "/usr/local/cuda-8.0/include/thrust/system/cpp/detail/partition.h"
       
# 29 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/partition.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/partition.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred)
{
  using thrust::system::detail::generic::partition;
  return partition(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                            ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred)
{
  using thrust::system::detail::generic::partition;
  return partition(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   InputIterator first,
                   InputIterator last,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred)
{
  using thrust::system::detail::generic::partition_copy;
  return partition_copy(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, out_true, out_false, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   InputIterator1 first,
                   InputIterator1 last,
                   InputIterator2 stencil,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred)
{
  using thrust::system::detail::generic::partition_copy;
  return partition_copy(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, out_true, out_false, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   Predicate pred)
{
  using thrust::system::detail::generic::stable_partition;
  return stable_partition(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator stable_partition(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                   ForwardIterator first,
                                   ForwardIterator last,
                                   InputIterator stencil,
                                   Predicate pred)
{
  using thrust::system::detail::generic::stable_partition;
  return stable_partition(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          InputIterator first,
                          InputIterator last,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred)
{
  using thrust::system::detail::generic::stable_partition_copy;
  return stable_partition_copy(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, out_true, out_false, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
__attribute__((host)) __attribute__((device))
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          InputIterator1 first,
                          InputIterator1 last,
                          InputIterator2 stencil,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred)
{
  using thrust::system::detail::generic::stable_partition_copy;
  return stable_partition_copy(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, stencil, out_true, out_false, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
  ForwardIterator partition_point(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last,
                                  Predicate pred)
{
  using thrust::system::detail::generic::partition_point;
  return partition_point(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, pred);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename InputIterator, typename Predicate>
__attribute__((host)) __attribute__((device))
  bool is_partitioned(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                      InputIterator first,
                      InputIterator last,
                      Predicate pred)
{
  using thrust::system::detail::generic::is_partitioned;
  return is_partitioned(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, pred);
}


template<typename ForwardIterator,
         typename Predicate>
  ForwardIterator partition(ForwardIterator first,
                            ForwardIterator last,
                            Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::partition(select_system(system), first, last, pred);
}


template<typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
  ForwardIterator partition(ForwardIterator first,
                            ForwardIterator last,
                            InputIterator stencil,
                            Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System1;
  typedef typename thrust::iterator_system<InputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::partition(select_system(system1,system2), first, last, stencil, pred);
}


template<typename ForwardIterator,
         typename Predicate>
  ForwardIterator stable_partition(ForwardIterator first,
                                   ForwardIterator last,
                                   Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::stable_partition(select_system(system), first, last, pred);
}


template<typename ForwardIterator,
         typename InputIterator,
         typename Predicate>
  ForwardIterator stable_partition(ForwardIterator first,
                                   ForwardIterator last,
                                   InputIterator stencil,
                                   Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System1;
  typedef typename thrust::iterator_system<InputIterator>::type System2;

  System1 system1;
  System2 system2;

  return thrust::stable_partition(select_system(system1,system2), first, last, stencil, pred);
}


template<typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(InputIterator first,
                   InputIterator last,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator1>::type System2;
  typedef typename thrust::iterator_system<OutputIterator2>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::partition_copy(select_system(system1,system2,system3), first, last, out_true, out_false, pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
  thrust::pair<OutputIterator1,OutputIterator2>
    partition_copy(InputIterator1 first,
                   InputIterator1 last,
                   InputIterator2 stencil,
                   OutputIterator1 out_true,
                   OutputIterator2 out_false,
                   Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator1>::type System2;
  typedef typename thrust::iterator_system<OutputIterator1>::type System3;
  typedef typename thrust::iterator_system<OutputIterator2>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::partition_copy(select_system(system1,system2,system3,system4), first, last, stencil, out_true, out_false, pred);
}


template<typename InputIterator,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(InputIterator first,
                          InputIterator last,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System1;
  typedef typename thrust::iterator_system<OutputIterator1>::type System2;
  typedef typename thrust::iterator_system<OutputIterator2>::type System3;

  System1 system1;
  System2 system2;
  System3 system3;

  return thrust::stable_partition_copy(select_system(system1,system2,system3), first, last, out_true, out_false, pred);
}


template<typename InputIterator1,
         typename InputIterator2,
         typename OutputIterator1,
         typename OutputIterator2,
         typename Predicate>
  thrust::pair<OutputIterator1,OutputIterator2>
    stable_partition_copy(InputIterator1 first,
                          InputIterator1 last,
                          InputIterator2 stencil,
                          OutputIterator1 out_true,
                          OutputIterator2 out_false,
                          Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator1>::type System1;
  typedef typename thrust::iterator_system<InputIterator2>::type System2;
  typedef typename thrust::iterator_system<OutputIterator1>::type System3;
  typedef typename thrust::iterator_system<OutputIterator2>::type System4;

  System1 system1;
  System2 system2;
  System3 system3;
  System4 system4;

  return thrust::stable_partition_copy(select_system(system1,system2,system3,system4), first, last, stencil, out_true, out_false, pred);
}


template<typename ForwardIterator, typename Predicate>
  ForwardIterator partition_point(ForwardIterator first,
                                  ForwardIterator last,
                                  Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::partition_point(select_system(system), first, last, pred);
}


template<typename InputIterator, typename Predicate>
  bool is_partitioned(InputIterator first,
                      InputIterator last,
                      Predicate pred)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<InputIterator>::type System;

  System system;

  return thrust::is_partitioned(select_system(system), first, last, pred);
}


}
# 1439 "/usr/local/cuda-8.0/include/thrust/partition.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_primitive_sort.inl" 2



namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace detail
{
namespace stable_primitive_sort_detail
{


template<typename Iterator>
  struct enable_if_bool_sort
    : thrust::detail::enable_if<
        thrust::detail::is_same<
          bool,
          typename thrust::iterator_value<Iterator>::type
        >::value
      >
{};


template<typename Iterator>
  struct disable_if_bool_sort
    : thrust::detail::disable_if<
        thrust::detail::is_same<
          bool,
          typename thrust::iterator_value<Iterator>::type
        >::value
      >
{};


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
typename enable_if_bool_sort<RandomAccessIterator>::type
  stable_primitive_sort(execution_policy<DerivedPolicy> &exec,
                        RandomAccessIterator first,
                        RandomAccessIterator last,
                        thrust::less<typename thrust::iterator_value<RandomAccessIterator>::type>)
{


  thrust::stable_partition(exec, first, last, thrust::logical_not<bool>());
}


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
typename enable_if_bool_sort<RandomAccessIterator>::type
  stable_primitive_sort(execution_policy<DerivedPolicy> &exec,
                        RandomAccessIterator first,
                        RandomAccessIterator last,
                        thrust::greater<typename thrust::iterator_value<RandomAccessIterator>::type>)
{


  thrust::stable_partition(exec, first, last, thrust::identity<bool>());
}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename Compare>
__attribute__((host)) __attribute__((device))
typename disable_if_bool_sort<RandomAccessIterator>::type
  stable_primitive_sort(execution_policy<DerivedPolicy> &exec,
                        RandomAccessIterator first,
                        RandomAccessIterator last,
                        Compare comp)
{

  thrust::system::cuda::detail::detail::stable_radix_sort(exec,first,last,comp);
}


struct logical_not_first
{
  template<typename Tuple>
  __attribute__((host)) __attribute__((device))
  bool operator()(Tuple t)
  {
    return !thrust::get<0>(t);
  }
};


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
typename enable_if_bool_sort<RandomAccessIterator1>::type
  stable_primitive_sort_by_key(execution_policy<DerivedPolicy> &exec,
                               RandomAccessIterator1 keys_first,
                               RandomAccessIterator1 keys_last,
                               RandomAccessIterator2 values_first,
                               thrust::less<typename thrust::iterator_value<RandomAccessIterator1>::type>)
{


  thrust::stable_partition(exec,
                           thrust::make_zip_iterator(thrust::make_tuple(keys_first, values_first)),
                           thrust::make_zip_iterator(thrust::make_tuple(keys_last, values_first)),
                           logical_not_first());
}


struct first_tuple_element
{
  template<typename Tuple>
  __attribute__((host)) __attribute__((device))
  bool operator()(Tuple t)
  {
    return thrust::get<0>(t);
  }
};


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
typename enable_if_bool_sort<RandomAccessIterator1>::type
  stable_primitive_sort_by_key(execution_policy<DerivedPolicy> &exec,
                               RandomAccessIterator1 keys_first,
                               RandomAccessIterator1 keys_last,
                               RandomAccessIterator2 values_first,
                               thrust::greater<typename thrust::iterator_value<RandomAccessIterator1>::type>)
{



  thrust::stable_partition(exec,
                           thrust::make_zip_iterator(thrust::make_tuple(keys_first, values_first)),
                           thrust::make_zip_iterator(thrust::make_tuple(keys_last, values_first)),
                           first_tuple_element());
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename Compare>
__attribute__((host)) __attribute__((device))
typename disable_if_bool_sort<RandomAccessIterator1>::type
  stable_primitive_sort_by_key(execution_policy<DerivedPolicy> &exec,
                               RandomAccessIterator1 keys_first,
                               RandomAccessIterator1 keys_last,
                               RandomAccessIterator2 values_first,
                               Compare comp)
{

  thrust::system::cuda::detail::detail::stable_radix_sort_by_key(exec, keys_first, keys_last, values_first, comp);
}


}


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort(execution_policy<DerivedPolicy> &exec,
                           RandomAccessIterator first,
                           RandomAccessIterator last,
                           thrust::less<typename thrust::iterator_value<RandomAccessIterator>::type> comp)
{
  thrust::system::cuda::detail::detail::stable_primitive_sort_detail::stable_primitive_sort(exec,first,last, comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort(execution_policy<DerivedPolicy> &exec,
                           RandomAccessIterator first,
                           RandomAccessIterator last,
                           thrust::greater<typename thrust::iterator_value<RandomAccessIterator>::type> comp)
{
  thrust::system::cuda::detail::detail::stable_primitive_sort_detail::stable_primitive_sort(exec,first,last, comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort_by_key(execution_policy<DerivedPolicy> &exec,
                                  RandomAccessIterator1 keys_first,
                                  RandomAccessIterator1 keys_last,
                                  RandomAccessIterator2 values_first,
                                  thrust::less<typename thrust::iterator_value<RandomAccessIterator1>::type> comp)
{
  thrust::system::cuda::detail::detail::stable_primitive_sort_detail::stable_primitive_sort_by_key(exec, keys_first, keys_last, values_first, comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
void stable_primitive_sort_by_key(execution_policy<DerivedPolicy> &exec,
                                  RandomAccessIterator1 keys_first,
                                  RandomAccessIterator1 keys_last,
                                  RandomAccessIterator2 values_first,
                                  thrust::greater<typename thrust::iterator_value<RandomAccessIterator1>::type> comp)
{
  thrust::system::cuda::detail::detail::stable_primitive_sort_detail::stable_primitive_sort_by_key(exec, keys_first, keys_last, values_first, comp);
}


}
}
}
}
}
# 82 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/detail/stable_primitive_sort.h" 2
# 24 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/sort.inl" 2





# 1 "/usr/local/cuda-8.0/include/thrust/detail/trivial_sequence.h" 1
# 24 "/usr/local/cuda-8.0/include/thrust/detail/trivial_sequence.h"
       






namespace thrust
{

namespace detail
{


template<typename Iterator, typename DerivedPolicy, typename is_trivial> struct _trivial_sequence { };


template<typename Iterator, typename DerivedPolicy>
struct _trivial_sequence<Iterator, DerivedPolicy, thrust::detail::true_type>
{
    typedef Iterator iterator_type;
    Iterator first, last;

    __attribute__((host)) __attribute__((device))
    _trivial_sequence(thrust::execution_policy<DerivedPolicy> &, Iterator _first, Iterator _last) : first(_first), last(_last)
    {

    }

    __attribute__((host)) __attribute__((device))
    iterator_type begin() { return first; }

    __attribute__((host)) __attribute__((device))
    iterator_type end() { return last; }
};


template<typename Iterator, typename DerivedPolicy>
struct _trivial_sequence<Iterator, DerivedPolicy, thrust::detail::false_type>
{
    typedef typename thrust::iterator_value<Iterator>::type iterator_value;
    typedef typename thrust::detail::temporary_array<iterator_value, DerivedPolicy>::iterator iterator_type;

    thrust::detail::temporary_array<iterator_value, DerivedPolicy> buffer;

    __attribute__((host)) __attribute__((device))
    _trivial_sequence(thrust::execution_policy<DerivedPolicy> &exec, Iterator first, Iterator last)
      : buffer(exec, first, last)
    {

    }

    __attribute__((host)) __attribute__((device))
    iterator_type begin() { return buffer.begin(); }

    __attribute__((host)) __attribute__((device))
    iterator_type end() { return buffer.end(); }
};

template <typename Iterator, typename DerivedPolicy>
struct trivial_sequence
  : detail::_trivial_sequence<Iterator, DerivedPolicy, typename thrust::detail::is_trivial_iterator<Iterator>::type>
{
    typedef _trivial_sequence<Iterator, DerivedPolicy, typename thrust::detail::is_trivial_iterator<Iterator>::type> super_t;

    __attribute__((host)) __attribute__((device))
    trivial_sequence(thrust::execution_policy<DerivedPolicy> &exec, Iterator first, Iterator last) : super_t(exec, first, last) { }
};

}

}
# 30 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/sort.inl" 2
# 56 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/sort.inl"
namespace thrust
{
namespace system
{
namespace cuda
{
namespace detail
{
namespace stable_sort_detail
{


template<typename KeyType, typename StrictWeakCompare>
  struct can_use_primitive_sort
    : thrust::detail::and_<
        thrust::detail::is_arithmetic<KeyType>,
        thrust::detail::or_<
          thrust::detail::is_same<StrictWeakCompare,thrust::less<KeyType> >,
          thrust::detail::is_same<StrictWeakCompare,thrust::greater<KeyType> >
        >
      >
{};


template<typename RandomAccessIterator, typename StrictWeakCompare>
  struct enable_if_primitive_sort
    : thrust::detail::enable_if<
        can_use_primitive_sort<
          typename iterator_value<RandomAccessIterator>::type,
          StrictWeakCompare
        >::value
      >
{};


template<typename RandomAccessIterator, typename StrictWeakCompare>
  struct enable_if_comparison_sort
    : thrust::detail::disable_if<
        can_use_primitive_sort<
          typename iterator_value<RandomAccessIterator>::type,
          StrictWeakCompare
        >::value
      >
{};


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
typename enable_if_primitive_sort<RandomAccessIterator,StrictWeakOrdering>::type
  stable_sort(execution_policy<DerivedPolicy> &exec,
              RandomAccessIterator first,
              RandomAccessIterator last,
              StrictWeakOrdering comp)
{

  thrust::detail::trivial_sequence<RandomAccessIterator,DerivedPolicy> keys(exec, first, last);

  thrust::system::cuda::detail::detail::stable_primitive_sort(exec, keys.begin(), keys.end(), comp);


  if(!thrust::detail::is_trivial_iterator<RandomAccessIterator>::value)
  {
    thrust::copy(exec, keys.begin(), keys.end(), first);
  }
}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
typename enable_if_comparison_sort<RandomAccessIterator,StrictWeakOrdering>::type
  stable_sort(execution_policy<DerivedPolicy> &exec,
              RandomAccessIterator first,
              RandomAccessIterator last,
              StrictWeakOrdering comp)
{
  thrust::system::cuda::detail::detail::stable_merge_sort(exec, first, last, comp);
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
typename enable_if_primitive_sort<RandomAccessIterator1,StrictWeakOrdering>::type
  stable_sort_by_key(execution_policy<DerivedPolicy> &exec,
                     RandomAccessIterator1 keys_first,
                     RandomAccessIterator1 keys_last,
                     RandomAccessIterator2 values_first,
                     StrictWeakOrdering comp)
{

  thrust::detail::trivial_sequence<RandomAccessIterator1,DerivedPolicy> keys(exec, keys_first, keys_last);
  thrust::detail::trivial_sequence<RandomAccessIterator2,DerivedPolicy> values(exec, values_first, values_first + (keys_last - keys_first));

  thrust::system::cuda::detail::detail::stable_primitive_sort_by_key(exec, keys.begin(), keys.end(), values.begin(), comp);


  if(!thrust::detail::is_trivial_iterator<RandomAccessIterator1>::value)
  {
    thrust::copy(exec, keys.begin(), keys.end(), keys_first);
  }

  if(!thrust::detail::is_trivial_iterator<RandomAccessIterator2>::value)
  {
    thrust::copy(exec, values.begin(), values.end(), values_first);
  }
}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
typename enable_if_comparison_sort<RandomAccessIterator1,StrictWeakOrdering>::type
  stable_sort_by_key(execution_policy<DerivedPolicy> &exec,
                     RandomAccessIterator1 keys_first,
                     RandomAccessIterator1 keys_last,
                     RandomAccessIterator2 values_first,
                     StrictWeakOrdering comp)
{
  thrust::system::cuda::detail::detail::stable_merge_sort_by_key(exec, keys_first, keys_last, values_first, comp);
}


}


template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort(execution_policy<DerivedPolicy> &exec,
                 RandomAccessIterator first,
                 RandomAccessIterator last,
                 StrictWeakOrdering comp)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<RandomAccessIterator, 3 == 3>::value) ) >)> thrust_static_assert_typedef_203 __attribute__((unused));

  struct workaround
  {
    __attribute__((host)) __attribute__((device))
    static void parallel_path(execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator first,
                              RandomAccessIterator last,
                              StrictWeakOrdering comp)
    {
      stable_sort_detail::stable_sort(exec, first, last, comp);
    }

    __attribute__((host)) __attribute__((device))
    static void sequential_path(RandomAccessIterator first,
                                RandomAccessIterator last,
                                StrictWeakOrdering comp)
    {
      thrust::sort(thrust::seq, first, last, comp);
    }
  };


  workaround::parallel_path(exec, first, last, comp);



}


template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
void stable_sort_by_key(execution_policy<DerivedPolicy> &exec,
                        RandomAccessIterator1 keys_first,
                        RandomAccessIterator1 keys_last,
                        RandomAccessIterator2 values_first,
                        StrictWeakOrdering comp)
{





  typedef ::thrust::detail::static_assert_test< sizeof(::thrust::detail::STATIC_ASSERTION_FAILURE< (bool)( (thrust::detail::depend_on_instantiation<RandomAccessIterator1, 3 == 3>::value) ) >)> thrust_static_assert_typedef_249 __attribute__((unused));

  struct workaround
  {
    __attribute__((host)) __attribute__((device))
    static void parallel_path(execution_policy<DerivedPolicy> &exec,
                              RandomAccessIterator1 keys_first,
                              RandomAccessIterator1 keys_last,
                              RandomAccessIterator2 values_first,
                              StrictWeakOrdering comp)
    {
      stable_sort_detail::stable_sort_by_key(exec, keys_first, keys_last, values_first, comp);
    }

    __attribute__((host)) __attribute__((device))
    static void sequential_path(RandomAccessIterator1 keys_first,
                                RandomAccessIterator1 keys_last,
                                RandomAccessIterator2 values_first,
                                StrictWeakOrdering comp)
    {
      thrust::stable_sort_by_key(thrust::seq, keys_first, keys_last, values_first, comp);
    }
  };


  workaround::parallel_path(exec, keys_first, keys_last, values_first, comp);



}


}
}
}
}
# 60 "/usr/local/cuda-8.0/include/thrust/system/cuda/detail/sort.h" 2
# 33 "/usr/local/cuda-8.0/include/thrust/system/detail/adl/sort.h" 2
# 28 "/usr/local/cuda-8.0/include/thrust/detail/sort.inl" 2

namespace thrust
{


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void sort(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
            RandomAccessIterator first,
            RandomAccessIterator last)
{
  using thrust::system::detail::generic::sort;
  return sort(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void sort(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
            RandomAccessIterator first,
            RandomAccessIterator last,
            StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::sort;
  return sort(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, comp);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename RandomAccessIterator>
__attribute__((host)) __attribute__((device))
  void stable_sort(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   RandomAccessIterator first,
                   RandomAccessIterator last)
{
  using thrust::system::detail::generic::stable_sort;
  return stable_sort(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename RandomAccessIterator,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void stable_sort(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   RandomAccessIterator first,
                   RandomAccessIterator last,
                   StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::stable_sort;
  return stable_sort(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, comp);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
  void sort_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first)
{
  using thrust::system::detail::generic::sort_by_key;
  return sort_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), keys_first, keys_last, values_first);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void sort_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                   RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first,
                   StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::sort_by_key;
  return sort_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), keys_first, keys_last, values_first, comp);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2>
__attribute__((host)) __attribute__((device))
  void stable_sort_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first)
{
  using thrust::system::detail::generic::stable_sort_by_key;
  return stable_sort_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), keys_first, keys_last, values_first);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy,
         typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
__attribute__((host)) __attribute__((device))
  void stable_sort_by_key(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                          RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first,
                          StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::stable_sort_by_key;
  return stable_sort_by_key(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), keys_first, keys_last, values_first, comp);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  bool is_sorted(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                 ForwardIterator first,
                 ForwardIterator last)
{
  using thrust::system::detail::generic::is_sorted;
  return is_sorted(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename Compare>
__attribute__((host)) __attribute__((device))
  bool is_sorted(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                 ForwardIterator first,
                 ForwardIterator last,
                 Compare comp)
{
  using thrust::system::detail::generic::is_sorted;
  return is_sorted(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, comp);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator>
__attribute__((host)) __attribute__((device))
  ForwardIterator is_sorted_until(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last)
{
  using thrust::system::detail::generic::is_sorted_until;
  return is_sorted_until(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last);
}


 #pragma nv_exec_check_disable
template<typename DerivedPolicy, typename ForwardIterator, typename Compare>
__attribute__((host)) __attribute__((device))
  ForwardIterator is_sorted_until(const thrust::detail::execution_policy_base<DerivedPolicy> &exec,
                                  ForwardIterator first,
                                  ForwardIterator last,
                                  Compare comp)
{
  using thrust::system::detail::generic::is_sorted_until;
  return is_sorted_until(thrust::detail::derived_cast(thrust::detail::strip_const(exec)), first, last, comp);
}






template<typename RandomAccessIterator>
  void sort(RandomAccessIterator first,
            RandomAccessIterator last)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<RandomAccessIterator>::type System;

  System system;

  return thrust::sort(select_system(system), first, last);
}


template<typename RandomAccessIterator,
         typename StrictWeakOrdering>
  void sort(RandomAccessIterator first,
            RandomAccessIterator last,
            StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<RandomAccessIterator>::type System;

  System system;

  return thrust::sort(select_system(system), first, last, comp);
}


template<typename RandomAccessIterator>
  void stable_sort(RandomAccessIterator first,
                   RandomAccessIterator last)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<RandomAccessIterator>::type System;

  System system;

  return thrust::stable_sort(select_system(system), first, last);
}


template<typename RandomAccessIterator,
         typename StrictWeakOrdering>
  void stable_sort(RandomAccessIterator first,
                   RandomAccessIterator last,
                   StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<RandomAccessIterator>::type System;

  System system;

  return thrust::stable_sort(select_system(system), first, last, comp);
}







template<typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  void sort_by_key(RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<RandomAccessIterator1>::type System1;
  typedef typename thrust::iterator_system<RandomAccessIterator2>::type System2;

  System1 system1;
  System2 system2;

  return thrust::sort_by_key(select_system(system1,system2), keys_first, keys_last, values_first);
}


template<typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
  void sort_by_key(RandomAccessIterator1 keys_first,
                   RandomAccessIterator1 keys_last,
                   RandomAccessIterator2 values_first,
                   StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<RandomAccessIterator1>::type System1;
  typedef typename thrust::iterator_system<RandomAccessIterator2>::type System2;

  System1 system1;
  System2 system2;

  return thrust::sort_by_key(select_system(system1,system2), keys_first, keys_last, values_first, comp);
}


template<typename RandomAccessIterator1,
         typename RandomAccessIterator2>
  void stable_sort_by_key(RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<RandomAccessIterator1>::type System1;
  typedef typename thrust::iterator_system<RandomAccessIterator2>::type System2;

  System1 system1;
  System2 system2;

  return thrust::stable_sort_by_key(select_system(system1,system2), keys_first, keys_last, values_first);
}


template<typename RandomAccessIterator1,
         typename RandomAccessIterator2,
         typename StrictWeakOrdering>
  void stable_sort_by_key(RandomAccessIterator1 keys_first,
                          RandomAccessIterator1 keys_last,
                          RandomAccessIterator2 values_first,
                          StrictWeakOrdering comp)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<RandomAccessIterator1>::type System1;
  typedef typename thrust::iterator_system<RandomAccessIterator2>::type System2;

  System1 system1;
  System2 system2;

  return thrust::stable_sort_by_key(select_system(system1,system2), keys_first, keys_last, values_first, comp);
}


template<typename ForwardIterator>
  bool is_sorted(ForwardIterator first,
                 ForwardIterator last)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::is_sorted(select_system(system), first, last);
}


template<typename ForwardIterator,
         typename Compare>
  bool is_sorted(ForwardIterator first,
                 ForwardIterator last,
                 Compare comp)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::is_sorted(select_system(system), first, last, comp);
}


template<typename ForwardIterator>
  ForwardIterator is_sorted_until(ForwardIterator first,
                                  ForwardIterator last)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::is_sorted_until(select_system(system), first, last);
}


template<typename ForwardIterator,
         typename Compare>
  ForwardIterator is_sorted_until(ForwardIterator first,
                                  ForwardIterator last,
                                  Compare comp)
{
  using thrust::system::detail::generic::select_system;

  typedef typename thrust::iterator_system<ForwardIterator>::type System;

  System system;

  return thrust::is_sorted_until(select_system(system), first, last, comp);
}


}
# 1362 "/usr/local/cuda-8.0/include/thrust/sort.h" 2
# 5 "./gpu_bin_shift.cu" 2
# 1 "/usr/include/c++/4.8.2/cstdlib" 1 3
# 39 "/usr/include/c++/4.8.2/cstdlib" 3
       
# 40 "/usr/include/c++/4.8.2/cstdlib" 3
# 6 "./gpu_bin_shift.cu" 2
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 7 "./gpu_bin_shift.cu" 2
# 1 "/usr/include/assert.h" 1 3 4
# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 8 "./gpu_bin_shift.cu" 2
# 1 "/usr/lib/gcc/ppc64le-redhat-linux/4.8.5/include/limits.h" 1 3 4
# 9 "./gpu_bin_shift.cu" 2




__attribute__((device)) int d_start_shift[3];

 static inline __attribute__((device)) void init_shift_bounds(int mi)
{
  d_start_shift[0] = mi;
  d_start_shift[1] = mi;
  d_start_shift[2] = mi;
}



__attribute__((global)) static void calculate_sort_keypair(gtc_particle_data_t *zion, int *seq, int *psi_theta)
{
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nthreads = blockDim.x;
    const int m = tid + bid*nthreads;

    real * z0 = zion->z0;
    real * z1 = zion->z1;

    int mi = params.mi;
    real a0 = params.a0;
    real delr = params.delr;
    int mpsi = params.mpsi;
    real r;

    if (m < mi){
      if(m==0)
 init_shift_bounds(mi);

      seq[m]=m;
      real pi2_inv = params.pi2_inv;
      real psi = z0[m];
      real theta = z1[m];
      real zetamin = params.zetamin;
      real zetamax = params.zetamax;

      real pi2 = 2*params.pi;
      real * zion2 = zion->z2;
      real zetatmp = zion2[m];
      real zetaright=min(pi2,zetatmp)-zetamax;
      real zetaleft = zetatmp - zetamin;
      int shift = zetaright*zetaleft>0;
      zetaright = zetaright*pi2_inv;
      zetaright = zetaright-floor(zetaright);
      int right = zetaright<0.5;


      r = psi;




      int iptmp = (int) ((r-a0)*delr+0.5);
      int ip = d_abs_min_int(mpsi, iptmp);



      psi_theta[m] = ip + shift * (1+ right)* 0x10000000;



    }
}

__attribute__((global)) static void calculate_sort_keypair_radial(gtc_particle_data_t *zion, int *seq, int *psi_theta)
{
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nthreads = blockDim.x;
    const int m = tid + bid*nthreads;
    real * z0 = zion->z0;
    real * z1 = zion->z1;

    const real a_nover_in = radial_decomp.a_nover_in;
    const real a_nover_out = radial_decomp.a_nover_out;
    const int myrank_radiald = radial_decomp.myrank_radiald;
    const int nradial_dom = radial_decomp.nradial_dom;

    int mi = params.mi;
    real a0 = params.a0;
    real delr = params.delr;
    int mpsi = params.mpsi;
    real r;

    if (m < mi){
      if(m==0)
 init_shift_bounds(mi);

      seq[m]=m;
      real pi2_inv = params.pi2_inv;
      real psi = z0[m];
      real theta = z1[m];



      real pi2 = 2*params.pi;




      r = psi;
# 127 "./gpu_bin_shift.cu"
      int shift = ((r<a_nover_in && myrank_radiald > 0)||(r>a_nover_out && myrank_radiald < (nradial_dom-1)));
      int right = (r>a_nover_out && myrank_radiald < (nradial_dom-1));

      int iptmp = (int) ((r-a0)*delr+0.5);
      int ip = d_abs_min_int(mpsi, iptmp);



      psi_theta[m] = ip + shift*(1 + right)* 0x10000000;



 }
}

__attribute__((global)) static void calculate_sort_keypair_shift(gtc_particle_data_t *zion, int *seq, int *psi_theta)
{
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nthreads = blockDim.x;
    const int m = tid + bid*nthreads;
    int mi = params.mi;

    if (m < mi){
      if(m==0)
 init_shift_bounds(mi);
      seq[m]=m;
      real pi2_inv = params.pi2_inv;
      real zetamin = params.zetamin;
      real zetamax = params.zetamax;
      real pi2 = 2.0*params.pi;
      real *zion2 = zion->z2;
      real zetatmp = zion2[m];
      real zetaright=min(pi2,zetatmp)-zetamax;
      real zetaleft = zetatmp - zetamin;
      int shift = (zetaright*zetaleft)>0.0;
      zetaright = zetaright*pi2_inv;
      zetaright = zetaright-floor(zetaright);
      int right = zetaright<0.5;

      psi_theta[m] = shift? (right?2:1):0;

    }
}

__attribute__((global)) static void calculate_sort_keypair_radial_shift(gtc_particle_data_t *zion, int *seq, int *psi_theta)
{
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nthreads = blockDim.x;
    const int m = tid + bid*nthreads;

    const real a_nover_in = radial_decomp.a_nover_in;
    const real a_nover_out = radial_decomp.a_nover_out;
    const int myrank_radiald = radial_decomp.myrank_radiald;
    const int nradial_dom = radial_decomp.nradial_dom;

    int mi = params.mi;

    if (m < mi){
      if(m==0)
 init_shift_bounds(mi);
      seq[m]=m;
      real pi2_inv = params.pi2_inv;
      real zetamin = params.zetamin;
      real zetamax = params.zetamax;
      real pi2 = 2*params.pi;

      real * zion0 = zion->z0;
      real z0 = zion0[m];


      real r = z0;
# 209 "./gpu_bin_shift.cu"
      int shift = ((r<a_nover_in && myrank_radiald > 0)||(r>a_nover_out && myrank_radiald < (nradial_dom-1)));
      int right = (r>a_nover_out && myrank_radiald < (nradial_dom-1));

      psi_theta[m] = shift? (right?2:1):0;

    }
}

__attribute__((global)) static void permute_particles_zion_ph1(gtc_particle_data_t *d_zion, gtc_particle_data_t *d_auxs_zion, int *permutation, int irk) {
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nthreads = blockDim.x;
    const int gid = tid + bid*nthreads;
    int mi = params.mi;

    if (gid < mi){
      int pos = permutation[gid];


      real z0, z1, z2, z3, z4, z00, z01, z02, z03, z04;
      z0 = TunedTexLoad<real,CA>::Ld(d_zion->z0+pos);
      z1 = TunedTexLoad<real,CA>::Ld(d_zion->z1+pos);
      z2 = TunedTexLoad<real,CA>::Ld(d_zion->z2+pos);
      z3 = TunedTexLoad<real,CA>::Ld(d_zion->z3+pos);
      z4 = TunedTexLoad<real,CA>::Ld(d_zion->z4+pos);

      TunedStore<real,CS>::St(z0,d_auxs_zion->z0+gid);
      TunedStore<real,CS>::St(z1,d_auxs_zion->z1+gid);
      TunedStore<real,CS>::St(z2,d_auxs_zion->z2+gid);
      TunedStore<real,CS>::St(z3,d_auxs_zion->z3+gid);
      TunedStore<real,CS>::St(z4,d_auxs_zion->z4+gid);

      if (irk==1) {
         z00 = TunedTexLoad<real,CA>::Ld(d_zion->z00+pos);
         z01 = TunedTexLoad<real,CA>::Ld(d_zion->z01+pos);
         z02 = TunedTexLoad<real,CA>::Ld(d_zion->z02+pos);
         z03 = TunedTexLoad<real,CA>::Ld(d_zion->z03+pos);
         z04 = TunedTexLoad<real,CA>::Ld(d_zion->z04+pos);

         TunedStore<real,CS>::St(z00,d_auxs_zion->z00+gid);
         TunedStore<real,CS>::St(z01,d_auxs_zion->z01+gid);
         TunedStore<real,CS>::St(z02,d_auxs_zion->z02+gid);
         TunedStore<real,CS>::St(z03,d_auxs_zion->z03+gid);
         TunedStore<real,CS>::St(z04,d_auxs_zion->z04+gid);
      }
# 269 "./gpu_bin_shift.cu"
    }
}

__attribute__((global)) static void permute_particles_zion_ph2(gtc_particle_data_t *d_zion, gtc_particle_data_t *d_auxs_zion, int *permutation,int *keys) {
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nthreads = blockDim.x;
    const int gid = tid + bid*nthreads;
    int mi = params.mi;

    if (gid < mi){
      int pos = permutation[gid];
      int key_val = keys[gid];
      int prev_key_val = gid>0?keys[gid-1]:keys[0];

      if(key_val >= 1 * 0x10000000 && key_val < 2 * 0x10000000 && prev_key_val < 1*0x10000000)
 d_start_shift[1] = gid;
      if(key_val >= 2*0x10000000 && prev_key_val < 2*0x10000000)
 d_start_shift[2] = gid;


      real z5, z05;
      z5 = TunedTexLoad<real,CA>::Ld(d_zion->z5+pos);
      z05 = TunedTexLoad<real,CA>::Ld(d_zion->z05+pos);
      TunedStore<real,CS>::St(z5,d_auxs_zion->z5+gid);
      TunedStore<real,CS>::St(z05,d_auxs_zion->z05+gid);




    }
}

__attribute__((global)) static void permute_particles_zion_shift_ph2(gtc_particle_data_t *d_zion, gtc_particle_data_t *d_auxs_zion, int *permutation,int *keys) {
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nthreads = blockDim.x;
    const int gid = tid + bid*nthreads;
    int mi = params.mi;

    if (gid < mi){
      int pos = permutation[gid];
      int key_val = keys[gid];
      int prev_key_val = gid>0?keys[gid-1]:keys[0];
      if(key_val == 1 && prev_key_val == 0)
 d_start_shift[1] = gid;

      if((key_val == 2 && prev_key_val == 1)||
  (key_val == 2 && prev_key_val == 0))
 d_start_shift[2] = gid;


      real z5, z05;
      z5 = TunedTexLoad<real,CA>::Ld(d_zion->z5+pos);
      z05 = TunedTexLoad<real,CA>::Ld(d_zion->z05+pos);
      TunedStore<real,CS>::St(z5,d_auxs_zion->z5+gid);
      TunedStore<real,CS>::St(z05,d_auxs_zion->z05+gid);




    }
}

__attribute__((global)) static void update_particle_zion_ph1(gtc_particle_data_t *d_zion, gtc_particle_data_t *d_auxs_zion, int irk) {
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nthreads = blockDim.x;
    const int gid = tid + bid*nthreads;
    int mi = params.mi;

    if (gid < mi){
      (d_zion->z0)[gid] = (d_auxs_zion->z0)[gid];
      (d_zion->z1)[gid] = (d_auxs_zion->z1)[gid];
      (d_zion->z2)[gid] = (d_auxs_zion->z2)[gid];
      (d_zion->z3)[gid] = (d_auxs_zion->z3)[gid];
      (d_zion->z4)[gid] = (d_auxs_zion->z4)[gid];

      if (irk==1){
         (d_zion->z00)[gid] = (d_auxs_zion->z00)[gid];
         (d_zion->z01)[gid] = (d_auxs_zion->z01)[gid];
         (d_zion->z02)[gid] = (d_auxs_zion->z02)[gid];
         (d_zion->z03)[gid] = (d_auxs_zion->z03)[gid];
         (d_zion->z04)[gid] = (d_auxs_zion->z04)[gid];
      }
    }
}

__attribute__((global)) static void update_particle_zion_ph2(gtc_particle_data_t *d_zion, gtc_particle_data_t *d_auxs_zion) {
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int nthreads = blockDim.x;
    const int gid = tid + bid*nthreads;
    int mi = params.mi;

    if (gid < mi) {
      (d_zion->z5)[gid] = (d_auxs_zion->z5)[gid];
      (d_zion->z05)[gid] = (d_auxs_zion->z05)[gid];
    }
}


void call_gpu_bin_particles_kernel(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int shift_direction)
{
     gpu_timer_start(gpu_kernel_input);
     int mi = gtc_input->global_params.mi;
     int nt = 512;
     int nb = (mi + nt - 1)/nt;
     int irk = gpu_kernel_input->irk;
     int istep = gpu_kernel_input->istep;

     gtc_sort_particle_t *d_sort = &(gpu_kernel_input->d_sort);



     int shift_only = (irk!=2) || (istep%10!=0) || shift_direction==1;



     if(shift_only)
       if (shift_direction == 0)
  calculate_sort_keypair_shift<<<nb, nt>>>(gpu_kernel_input->ptr_d_zion, d_sort->d_value, d_sort->d_sort_key);
       else if (shift_direction == 1)
  calculate_sort_keypair_radial_shift<<<nb, nt>>>(gpu_kernel_input->ptr_d_zion, d_sort->d_value, d_sort->d_sort_key);
       else
  printf("other shift_direction options are not available\n");
     else {

       if (shift_direction == 0)
  calculate_sort_keypair<<<nb, nt>>>(gpu_kernel_input->ptr_d_zion, d_sort->d_value, d_sort->d_sort_key);
       else if (shift_direction == 1)
  calculate_sort_keypair_radial<<<nb, nt>>>(gpu_kernel_input->ptr_d_zion, d_sort->d_value, d_sort->d_sort_key);
       else
  printf("other shift_direction options are not available\n");

     }

     thrust::device_ptr<int32_t> d_key(d_sort->d_sort_key);
     thrust::device_ptr<int32_t> d_value(d_sort->d_value);
     thrust::stable_sort_by_key(d_key, d_key + mi, d_value);
     gpu_kernel_input->gpu_timing.device_particle_sort_time += gpu_timer_measure(gpu_kernel_input);


     if(shift_only)
       permute_particles_zion_shift_ph2<<<nb, nt>>>(gpu_kernel_input->ptr_d_zion, gpu_kernel_input->ptr_d_auxs_zion, d_sort->d_value,d_sort->d_sort_key);
     else

       permute_particles_zion_ph2<<<nb, nt>>>(gpu_kernel_input->ptr_d_zion, gpu_kernel_input->ptr_d_auxs_zion, d_sort->d_value,d_sort->d_sort_key);
     update_particle_zion_ph2<<<nb, nt>>>(gpu_kernel_input->ptr_d_zion, gpu_kernel_input->ptr_d_auxs_zion);

     permute_particles_zion_ph1<<<nb, nt>>>(gpu_kernel_input->ptr_d_zion, gpu_kernel_input->ptr_d_auxs_zion, d_sort->d_value, irk);
     update_particle_zion_ph1<<<nb, nt>>>(gpu_kernel_input->ptr_d_zion, gpu_kernel_input->ptr_d_auxs_zion, irk);

     gpu_kernel_input->gpu_timing.device_particle_bin_time += gpu_timer_measure_end(gpu_kernel_input);
}

static int h_start_shift[3];


extern "C"
void call_gpu_shifti_extract_kernel (gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, unsigned int tops[3], real *sends[3], int shift_direction)
{
     gpu_timer_start(gpu_kernel_input);

     { cudaError err = cudaMemcpyFromSymbol(h_start_shift, d_start_shift, sizeof(int)*3,0,cudaMemcpyDeviceToHost); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 433, cudaGetErrorString( err) ); exit(1); } };;
     int shift_left_size, shift_right_size,total_shift;
     int start_shift_left;
     int mi = gtc_input->global_params.mi;

     ((mi == h_start_shift[0]) ? static_cast<void> (0) : __assert_fail ("mi == h_start_shift[0]", "./gpu_bin_shift.cu", 438, __PRETTY_FUNCTION__));
     if(h_start_shift[1] == mi)
       h_start_shift[1] = h_start_shift[2];

     if(h_start_shift[1]< mi) {
       shift_left_size = h_start_shift[2] - h_start_shift[1];
       start_shift_left = h_start_shift[1];
     } else
       shift_left_size = 0;

     if (h_start_shift[2] < mi) {
       shift_right_size = mi - h_start_shift[2];
     } else
       shift_right_size = 0;

     tops[1] = shift_left_size;
     tops[2] = shift_right_size;
     total_shift = shift_left_size + shift_right_size;

     if(total_shift == 0) {
       gpu_kernel_input->gpu_timing.memtransfer_shift_time += gpu_timer_measure_end(gpu_kernel_input);
       return;
     }

     gtc_particle_decomp_t *parallel_decomp =&(gtc_input->parallel_decomp);

     if (2*total_shift >= parallel_decomp->sendbuf_size) {
       fprintf(stderr, "Error! GPU PE %d, shift_left_size %d, shift_right_size %d, "
        "sendbuf_size %d\n", parallel_decomp->mype,
        shift_left_size, shift_right_size,
        parallel_decomp->sendbuf_size);
       exit(1);
     } else {
       sends[1] = parallel_decomp->sendbuf;
       sends[2] = parallel_decomp->sendbuf + 12*shift_left_size;
       sends[0] = parallel_decomp->sendbuf + 12*total_shift;
     }

     cudaStream_t stream;
     { cudaError err = cudaStreamCreate(&stream); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 477, cudaGetErrorString( err) ); exit(1); } };;
     int d_mimax = gpu_kernel_input->d_mimax;
     int i,j,k;
# 496 "./gpu_bin_shift.cu"
     for (i=0; i<12; i++){
          { cudaError err = cudaMemcpyAsync((void*)(sends[1]+i*shift_left_size), gpu_kernel_input->d_zion.z0+i*d_mimax+start_shift_left, shift_left_size * sizeof(real), cudaMemcpyDeviceToHost,stream); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 497, cudaGetErrorString( err) ); exit(1); } };;
          { cudaError err = cudaMemcpyAsync((void*)(sends[2]+i*shift_right_size), gpu_kernel_input->d_zion.z0+i*d_mimax+start_shift_left+shift_left_size, shift_right_size * sizeof(real), cudaMemcpyDeviceToHost,stream); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 498, cudaGetErrorString( err) ); exit(1); } };;
     }

     gtc_input->global_params.mi -= total_shift;
     { cudaError err = cudaStreamSynchronize(stream); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 502, cudaGetErrorString( err) ); exit(1); } };;
     { cudaError err = cudaStreamDestroy(stream); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 503, cudaGetErrorString( err) ); exit(1); } };;

     gpu_kernel_input->gpu_timing.memtransfer_shift_time += gpu_timer_measure_end(gpu_kernel_input);

}

extern "C"
void call_gpu_shifti_append_kernel (gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int mi_append, real *particle_data)
{
     if(mi_append==0)
       return;
     gpu_timer_start(gpu_kernel_input);
     cudaStream_t stream;
     { cudaError err = cudaStreamCreate(&stream); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 516, cudaGetErrorString( err) ); exit(1); } };;
     int d_mimax = gpu_kernel_input->d_mimax;
     int mimax_shift = gpu_kernel_input->d_max_shift_mi;
     int i, j;
# 533 "./gpu_bin_shift.cu"
     for(i=0;i<12;i++)
       { cudaError err = cudaMemcpyAsync(gpu_kernel_input->d_zion.z0+i*d_mimax+h_start_shift[1],particle_data+i*mimax_shift, mi_append* sizeof(real),cudaMemcpyHostToDevice,stream); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n",
 "./gpu_bin_shift.cu"
# 534 "./gpu_bin_shift.cu"
       ,
 535
# 534 "./gpu_bin_shift.cu"
       , cudaGetErrorString( err) ); exit(1); } };
                                                            ;

     { cudaError err = cudaStreamSynchronize(stream); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 537, cudaGetErrorString( err) ); exit(1); } };;
     { cudaError err = cudaStreamDestroy(stream); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 538, cudaGetErrorString( err) ); exit(1); } };;

     gpu_kernel_input->gpu_timing.memtransfer_shift_time += gpu_timer_measure(gpu_kernel_input);

     gtc_input->global_params.mi += mi_append;



     { cudaError err = cudaMemcpyToSymbol(params, &gtc_input->global_params.mi, sizeof(int),__builtin_offsetof (gtc_global_params_t, mi) ,cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_bin_shift.cu", 546, cudaGetErrorString( err) ); exit(1); } };;

     gpu_kernel_input->gpu_timing.device_shift_time += gpu_timer_measure_end(gpu_kernel_input);

}
# 280 "gpu_setup.cu" 2
# 288 "gpu_setup.cu"
# 1 "./gpu_push_kernel.cu" 1
# 30 "./gpu_push_kernel.cu"
static __inline__ __attribute__((device)) real fetch_evector(int i)
{
    int2 e = tex1Dfetch(evectorTexRef,i);
    return __hiloint2double(e.y,e.x);
}
# 44 "./gpu_push_kernel.cu"
__attribute__((global)) static void

__attribute__((launch_bounds(64 , 1)))
  gpu_pushi_kernel(gtc_particle_data_t *zion, gtc_aux_particle_data_t *aux_zion, gtc_field_data_t *grid, gtc_diagnosis_data_t *diagnosis, int irk, int istep, int idiag)
{
  const int tid = threadIdx.x;
  const int bid = blockIdx.x;
  const int nblocks = gridDim.x;
  const int nthreads = blockDim.x;
  const int gid = tid + bid*nthreads;
  const int np = nblocks * nthreads;

  const int mflux = 5;
  extern __attribute__((shared)) real shared_buffer_gyro[];
  real *vdrtmp = shared_buffer_gyro;

  real *scalar_data_s = &vdrtmp[mflux];
  real *flux_s = &scalar_data_s[7*nthreads];

  if (idiag==0){
    for (int i=tid; i<7*nthreads; i+=nthreads){
      scalar_data_s[i] = 0.0;
    }
    for (int i=tid; i<4*mflux*nthreads; i+=nthreads){
      flux_s[i] = 0.0;
    }
    __syncthreads();
  }

  int mi = params.mi;



  int mpsi = params.mpsi;

  const real a = params.a;
  const real a0 = params.a0;
  const real a1 = params.a1;
  const real delr = params.delr;
  const real pi2 = 2.0*params.pi;
  const real pi2_inv = params.pi2_inv;
  const int nbound = params.nbound;
  const real gyroradius = params.gyroradius;
  const real qion = params.qion;
  const real aion = params.aion;
  const real tstep =params.tstep;
  const real nonlinear = params.nonlinear;
  const real paranl = params.paranl;

  real* __restrict__ scalar_data = diagnosis->scalar_data;
  real* __restrict__ flux_data = diagnosis->flux_data;
# 113 "./gpu_push_kernel.cu"
  real delz, a_diff, zetamin;






  const real* pgyro; const real* tgyro;
  int ipjt;


  int mpsi_max;
  real wzt, r_diff, rdum, rhotmp, tflr, tdumtmp, tdumtmp2, tdum, tdum2;
  real wtion0tmp, wtion1tmp;
  int iptmp, im, im2, idxpg, jt, jttmp;
  int jtion0tmp, jtion1tmp, j00, j01;
  real r, wz1, wz0;

  int ip;




  const real * __restrict__ pfluxpsi = grid->pfluxpsi;

  const int igrid_in = radial_decomp.igrid_in;
  const int ipsi_valid_in = radial_decomp.ipsi_valid_in;
  const int ipsi_valid_out = radial_decomp.ipsi_valid_out;
  const int nloc_over = radial_decomp.nloc_over;
  const real rho_max = radial_decomp.rho_max;

  real * __restrict__ zion1 = zion->z0;
  real * __restrict__ zion2 = zion->z1;
  real * __restrict__ zion3 = zion->z2;
  real * __restrict__ zion4 = zion->z3;
  real * __restrict__ zion5 = zion->z4;
  real * __restrict__ zion6 = zion->z5;

  real * __restrict__ zion01 = zion->z00;
  real * __restrict__ zion02 = zion->z01;
  real * __restrict__ zion03 = zion->z02;
  real * __restrict__ zion04 = zion->z03;
  real * __restrict__ zion05 = zion->z04;
  real * __restrict__ zion06 = zion->z05;
# 165 "./gpu_push_kernel.cu"
  real zion1m, zion2m, zion3m, zion4m, zion5m, zion6m;

  real dtime;
  real sbound=1.0;
  if (nbound==0) sbound=0.0;
  real psimax=0.5*a1*a1;
  real psimin=0.5*a0*a0;
  real cmratio=qion/aion;
  real cinv=1.0/qion;
  real vthi=gyroradius*fabs(qion)/aion;
  real d_inv=real(mflux)/(a1-a0);

  for (int m=gid; m<mi; m+=np){

    if(irk==1) {
      dtime=0.5*tstep;
      if(tid<mflux)
 vdrtmp[tid] = 0.0;


 TunedLoad<real,CS>::Ld(zion1m,zion1+m);
 TunedLoad<real,CS>::Ld(zion2m,zion2+m);
 TunedLoad<real,CS>::Ld(zion3m,zion3+m);
 TunedLoad<real,CS>::Ld(zion4m,zion4+m);
 TunedLoad<real,CS>::Ld(zion5m,zion5+m);

 TunedStore<real,CS>::St(zion1m,zion01+m);
 TunedStore<real,CS>::St(zion2m,zion02+m);
 TunedStore<real,CS>::St(zion3m,zion03+m);
 TunedStore<real,CS>::St(zion4m,zion04+m);
 TunedStore<real,CS>::St(zion5m,zion05+m);
# 204 "./gpu_push_kernel.cu"
    } else {
      dtime=tstep;
      if(nonlinear<0.5) {
 printf("Error! decoupling modes for "
        "nonlinear = 0.0 not implemented\n");
 if(tid<mflux)
   vdrtmp[tid] = 0.0;
      } else {
 if(tid<mflux)
   vdrtmp[tid] = pfluxpsi[tid];
      }
    }
    __syncthreads();
    real wp0, wp1, wt00, wt01, wt10, wt11;
    int kk, larmor;

    int ii, ij1, ij2, ij3, ij4, idx1, idx2, idx3, idx4;



    if (irk!=1) {
      TunedLoad<real,CS>::Ld(zion1m,zion1+m);
      TunedLoad<real,CS>::Ld(zion2m,zion2+m);
      TunedLoad<real,CS>::Ld(zion3m,zion3+m);
      TunedLoad<real,CS>::Ld(zion4m,zion4+m);
      TunedLoad<real,CS>::Ld(zion5m,zion5+m);
    }
    TunedLoad<real,CS>::Ld(zion6m,zion6+m);
# 240 "./gpu_push_kernel.cu"
    real e1=0.0;
    real e2=0.0;
    real e3=0.0;



    kk = 0;
# 259 "./gpu_push_kernel.cu"
    a_diff = a1 - a0;
    zetamin = params.zetamin;
    real smu_inv = params.smu_inv;
# 271 "./gpu_push_kernel.cu"
    pgyro = grid->pgyro; tgyro = grid->tgyro;


    real psitmp = zion1m;
    real thetatmp = zion2m;
    real zetatmp = zion3m;
    real rhoi = zion6m*smu_inv;

    delz = params.delz;
    mpsi_max = mpsi-1;


    r = psitmp;



    iptmp = (int) ((r-a0)*delr+0.5);
    ip = d_abs_min_int(mpsi, iptmp);
# 298 "./gpu_push_kernel.cu"
    jttmp = (int) (thetatmp*pi2_inv*delt[ip]+0.5);
    jt = d_abs_min_int(mtheta[ip], jttmp);

    wzt = (zetatmp-zetamin)*delz;
    wz1 = wzt - (real) kk;
    wz0 = 1.0 - wz1;
    r_diff = r-a0;
# 326 "./gpu_push_kernel.cu"
    ipjt = igrid[ip]+jt;







    int ind = m;
    for(larmor=0;larmor<4;larmor++) {
# 351 "./gpu_push_kernel.cu"
      idxpg = larmor + 4*(ipjt-igrid_in);
      rhotmp = rhoi*pgyro[idxpg];
      if (fabs(rhotmp)>rho_max) {
        printf("rhotmp=%e rhoi=%e rho_max=%e pgyro=%e\n", rhotmp, rhoi, rho_max, pgyro[idxpg]);
 printf("warning: push sub reducing rhoi to %e from %e\n", (rhotmp/fabs(rhotmp))*rho_max/pgyro[idxpg], rhoi);
 rhotmp = (rhotmp/fabs(rhotmp))*rho_max;
 rhoi = rhotmp/pgyro[idxpg];
      }
      rdum = delr * d_abs_min_real(a_diff,
              r_diff+rhotmp);
      tflr = thetatmp + rhoi*tgyro[idxpg];


      ii = d_abs_min_int(mpsi_max, (int) rdum);

      wp1 = rdum - (real) ii;
      wp0 = 1.0 - wp1;



      im = ii;
      im2 = ii + 1;

      tdumtmp = pi2_inv * (tflr - zetatmp * qtinv[im]) + 10.0;
      tdumtmp2 = pi2_inv * (tflr - zetatmp * qtinv[im2]) + 10.0;

      tdum = (tdumtmp - (int) tdumtmp) * delt[im];
      tdum2 = (tdumtmp2 - (int) tdumtmp2) * delt[im2];

      j00 = d_abs_min_int(mtheta[im]-1, (int) tdum);
      j01 = d_abs_min_int(mtheta[im2]-1, (int) tdum2);

      jtion0tmp = igrid[im] + j00;
      jtion1tmp = igrid[im2] + j01;

      wtion0tmp = tdum - (real) j00;
      wtion1tmp = tdum2 - (real) j01;

      ij1 = jtion0tmp - igrid_in;
      ij3 = jtion1tmp - igrid_in;

      wp0 = 1.0 - wp1;
      wt10 = wtion0tmp;
      wt11 = wtion1tmp;
      wt01 = 1.0 - wt11;
      wt00 = 1.0 - wt10;
      ij2 = ij1 + 1;
      ij4 = ij3 + 1;
# 423 "./gpu_push_kernel.cu"
      idx1 = 6*ij1;

      idx3 = 6*ij3;
# 465 "./gpu_push_kernel.cu"
      e1 =e1+wp0*wt00*(wz0*(fetch_evector(idx1+0))+wz1*(fetch_evector(idx1+3)));
      e2 =e2+wp0*wt00*(wz0*(fetch_evector(idx1+1))+wz1*(fetch_evector(idx1+4)));
      e3 =e3+wp0*wt00*(wz0*(fetch_evector(idx1+2))+wz1*(fetch_evector(idx1+5)));
      e1 =e1+wp0*wt10*(wz0*(fetch_evector(idx1+6+0))+wz1*(fetch_evector(idx1+6+3)));
      e2 =e2+wp0*wt10*(wz0*(fetch_evector(idx1+6+1))+wz1*(fetch_evector(idx1+6+4)));
      e3 =e3+wp0*wt10*(wz0*(fetch_evector(idx1+6+2))+wz1*(fetch_evector(idx1+6+5)));

      e1 =e1+wp1*wt01*(wz0*(fetch_evector(idx3+0))+wz1*(fetch_evector(idx3+3)));
      e2 =e2+wp1*wt01*(wz0*(fetch_evector(idx3+1))+wz1*(fetch_evector(idx3+4)));
      e3 =e3+wp1*wt01*(wz0*(fetch_evector(idx3+2))+wz1*(fetch_evector(idx3+5)));
      e1 =e1+wp1*wt11*(wz0*(fetch_evector(idx3+6+0))+wz1*(fetch_evector(idx3+6+3)));
      e2 =e2+wp1*wt11*(wz0*(fetch_evector(idx3+6+1))+wz1*(fetch_evector(idx3+6+4)));
      e3 =e3+wp1*wt11*(wz0*(fetch_evector(idx3+6+2))+wz1*(fetch_evector(idx3+6+5)));
# 513 "./gpu_push_kernel.cu"
      ind += mi;
    }

    real wpi1=0.25*e1;
    real wpi2=0.25*e2;
    real wpi3=0.25*e3;

    real zion01m, zion02m, zion03m, zion04m, zion05m;

    if(irk ==1){
      zion01m = zion1m;
      zion02m = zion2m;
      zion03m = zion3m;
      zion04m = zion4m;
      zion05m = zion5m;
    } else {

      TunedLoad<real,CS>::Ld(zion01m,zion01+m);
      TunedLoad<real,CS>::Ld(zion02m,zion02+m);
      TunedLoad<real,CS>::Ld(zion03m,zion03+m);
      TunedLoad<real,CS>::Ld(zion04m,zion04+m);
      TunedLoad<real,CS>::Ld(zion05m,zion05+m);







    }


    real ainv=1.0/a;
# 557 "./gpu_push_kernel.cu"
    real rinv=1.0/r;

    const real q0 = params.q0;
    const real q1 = params.q1;
    const real q2 = params.q2;
    const real rw = params.rw;
    const real rc = params.rc;
    ii=d_abs_min_int(mpsi-1,int((r-a0)*delr));
    ip=d_abs_min_int(mflux-1,1+int((r-a0)*d_inv));
    wp0=real(ii+1)-(r-a0)*delr;
    wp1=1.0-wp0;
    real tem=wp0*temp[ii]+wp1*temp[ii+1];
    real q=q0+q1*r*ainv+q2*r*r*ainv*ainv;
    real qinv=1.0/q;
    real cost=cos(zion2m);
    real sint=sin(zion2m);
    real b=1.0/(1.0+r*cost);
    real g=1.0;
    real gp=0.0;
    real ri=0.0;
    real rip=0.0;
    real dbdp=-1.0*b*b*cost*rinv;
    real dbdt=b*b*r*sint;
    real dedb=cinv*(zion4m*zion4m*qion*b*cmratio+zion6m*zion6m);
    real deni=1.0/(g*q + ri + zion4m*(g*rip-ri*gp));
    real upara=zion4m*b*cmratio;
    real energy=0.5*aion*upara*upara+zion6m*zion6m*b;
    real rfac=rw*(r-rc);

    rfac=rfac*rfac;
    rfac=rfac*rfac*rfac;
    rfac=exp(-1*rfac);





    real kappa=1.0-sbound+sbound*rfac;
    const real kappati = params.kappati;
    const real kappan = params.kappan;
    kappa=((energy*tem-1.5)*kappati+kappan)*kappa*rinv;


    real dptdp=wpi1;
    real dptdt=wpi2;
    real dptdz=wpi3-wpi2*qinv;
    real epara=-1.0*wpi3*b*q*deni;

    dptdt=dptdt+vdrtmp[ip];


    real vdr=q*(ri*dptdz-g*dptdt)*deni;
    real wdrive=vdr*kappa;
    real wpara=epara*(upara-dtemp[ii])*qion*tem;

    real wdrift=q*(g*dbdt*dptdp-g*dbdp*dptdt+ri*dbdp*dptdz)*deni*dedb*qion*tem;

    real wdot = (zion06[m]-zion5m)*(wdrive+wpara+wdrift);

    const real flow0 = params.flow0;
    const real flow1 = params.flow1;
    const real flow2 = params.flow2;
    dptdp=dptdp*nonlinear+gyroradius*(flow0+flow1*r*ainv+flow2*r*r*ainv*ainv);
    dptdt=dptdt*nonlinear;
    dptdz=dptdz*nonlinear;


    real pdot = q*(-g*dedb*dbdt - g*dptdt + ri*dptdz)*deni;
    real tdot = (upara*b*(1.0-q*gp*zion4m) + q*g*(dedb*dbdp + dptdp))*deni;
    real zdot = (upara*b*q*(1.0+rip*zion4m) - q*ri*(dedb*dbdp + dptdp))*deni;
    real rdot = ((gp*zion4m-1.0)*(dedb*dbdt + paranl*dptdt)-paranl*q*(1.0+rip*zion4m)*dptdz)*deni;



    zion1m = max(1.0e-8*psimax,0.5*zion01m*zion01m + dtime*pdot);
    zion1m = sqrt(2.0*zion1m);



    TunedStore<real,CS>::St(zion1m,zion1+m);
    zion2m = zion02m+dtime*tdot;
    zion3m = zion03m+dtime*zdot;
    zion4m = zion04m + dtime*rdot;
    TunedStore<real,CS>::St(zion4m,zion4+m);
    zion5m = zion05m + dtime*wdot;
    TunedStore<real,CS>::St(zion5m,zion5+m);
    real z1t = zion2m *pi2_inv+10;
    zion2m = pi2*(z1t-((int)z1t));
    TunedStore<real,CS>::St(zion2m,zion2+m);
    z1t = zion3m*pi2_inv+10;
    zion3m = pi2*(z1t - ((int)z1t));
    TunedStore<real,CS>::St(zion3m,zion3+m);

    if(irk==2) {

      if((zion1m > a1)||(zion1m < a0)) {



 TunedStore<real,CS>::St(zion01m,zion1+m);
 TunedStore<real,CS>::St(pi2-zion02m,zion2+m);
 TunedStore<real,CS>::St(zion03m,zion3+m);
 TunedStore<real,CS>::St(zion04m,zion4+m);
 TunedStore<real,CS>::St(zion05m,zion5+m);

 TunedStore<real,CS>::St(pi2-zion02m,zion02+m);
      }






    }
# 723 "./gpu_push_kernel.cu"
    if (idiag==0){
      ip = d_abs_min_int(mflux-1, (int)((r-a0)*d_inv));


      real vdrenergy = vdr*rinv*(energy-1.5*aion*vthi*vthi*rtemi[ii])*zion05m;



      flux_s[ip*nthreads+tid] += vdrenergy;
      flux_s[mflux*nthreads+ip*nthreads+tid] += 1.0;
      flux_s[2*mflux*nthreads + ip*nthreads+tid] += vdr*rinv*r;
      flux_s[3*mflux*nthreads + ip*nthreads+tid] += 1.0;

      scalar_data_s[0*nthreads+tid] += vdrenergy;
      scalar_data_s[1*nthreads+tid] += vdr*rinv*zion05m;
      scalar_data_s[2*nthreads+tid] += b*zion04m*zion05m;
      scalar_data_s[3*nthreads+tid] += zion05m*zion05m;
      scalar_data_s[4*nthreads+tid] += energy*zion05m;
      scalar_data_s[5*nthreads+tid] += energy;
      scalar_data_s[6*nthreads+tid] += zion05m;
     }

}
  __syncthreads();

  if (idiag==0){

    int nTotalThreads = nthreads;
    while (nTotalThreads>1){
      int half = (nTotalThreads >> 1);
      if (tid < half){
 for (int i=0; i<7; i++){
   scalar_data_s[i*nthreads+tid] += scalar_data_s[i*nthreads+tid+half];
 }

 for (int i=0; i<mflux; i++)
   {


     flux_s[i*nthreads+tid] += flux_s[i*nthreads+tid+half];
     flux_s[mflux*nthreads+i*nthreads+tid] += flux_s[mflux*nthreads+i*nthreads+tid+half];
     flux_s[2*mflux*nthreads+i*nthreads+tid] += flux_s[2*mflux*nthreads+i*nthreads+tid+half];
     flux_s[3*mflux*nthreads+i*nthreads+tid] += flux_s[3*mflux*nthreads+i*nthreads+tid+half];
   }
      }
      __syncthreads();
      nTotalThreads = (nTotalThreads >> 1);
    }
    if (tid==0){
      atomicDPupdate(scalar_data, scalar_data_s[0]);
      atomicDPupdate(scalar_data+2, scalar_data_s[nthreads]);
      atomicDPupdate(scalar_data+6, scalar_data_s[2*nthreads]);
      atomicDPupdate(scalar_data+8, scalar_data_s[3*nthreads]);
      atomicDPupdate(scalar_data+12, scalar_data_s[4*nthreads]);
      atomicDPupdate(scalar_data+13, scalar_data_s[5*nthreads]);
      atomicDPupdate(scalar_data+15, scalar_data_s[6*nthreads]);
    }
# 797 "./gpu_push_kernel.cu"
    if (tid<5)

      atomicDPupdate(flux_data+tid, flux_s[tid*nthreads]);

    if (tid>=5&&tid<10)

      atomicDPupdate(flux_data+tid, flux_s[mflux*nthreads+(tid-5)*nthreads]);

    if (tid>=10&&tid<15)
      atomicDPupdate(flux_data+tid, flux_s[2*mflux*nthreads+(tid-10)*nthreads]);

    if (tid>=15&&tid<20)
      atomicDPupdate(flux_data+tid, flux_s[3*mflux*nthreads+(tid-15)*nthreads]);

  }
}

bool findGridDims(dim3 &Dg, int nblocks, int max_dim)
{
  if((nblocks > max_dim) && (nblocks%max_dim==0)) {
    Dg.x = max_dim;
    Dg.y = nblocks/max_dim;
    return true;
  }
  int guess_a = int(sqrt(nblocks));
  int guess_b = int(sqrt(nblocks));
  int best_error = abs(guess_a * guess_b - nblocks);
  int best_guess_a = guess_a;
  int best_guess_b = guess_b;
  guess_a++;
  while(guess_a < max_dim) {
    while(guess_b*guess_a > nblocks)
      guess_b--;
    int error = abs(guess_a * guess_b - nblocks);
    if(error< best_error) {
      best_error = error;
      best_guess_a = guess_a;
      best_guess_b = guess_b;
    }
    guess_a++;
  }
  Dg.x = best_guess_a;
  Dg.y = best_guess_b;
  if(best_error==0)
    return true;
  else {
    if(guess_a * guess_b - nblocks<0)
      Dg.x+=1;
    return false;
  }
}

extern "C"
void call_gpu_push_kernel (gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_input, int idiag)
{
  int mi = (gtc_input->global_params).mi;
  int nthreads = gpu_kernel_input->nthreads*4;
  gtc_global_params_t *h_params = &(gtc_input->global_params);
  gtc_diagnosis_data_t *h_diagnosis = &(gtc_input->diagnosis_data);
  gtc_diagnosis_data_t *d_diagnosis = &(gpu_kernel_input->d_diagnosis);
  gtc_radial_decomp_t *h_radial_decomp = &(gtc_input->radial_decomp);

  int mzeta= h_params->mzeta; int nloc_over = h_radial_decomp->nloc_over;
  int mype = gtc_input->parallel_decomp.mype;

  dim3 Db = dim3(nthreads,1);
  dim3 Dg;
  int nblocks = (mi + nthreads - 1) / nthreads;



  gtc_field_data_t *h_grid = &(gtc_input->field_data);
  gtc_field_data_t *d_grid = &(gpu_kernel_input->d_grid);
  gpu_timer_start(gpu_kernel_input);

  { cudaError err = cudaMemcpy((void *)d_grid->evector, h_grid->evector, 3*(mzeta+1)*nloc_over*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_push_kernel.cu", 872, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_grid->pfluxpsi, h_grid->pfluxpsi, 5*sizeof(real), cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_push_kernel.cu", 873, cudaGetErrorString( err) ); exit(1); } };;


  if (idiag==0){

    { cudaError err = cudaMemcpy((void*)(d_diagnosis->scalar_data), (h_diagnosis->scalar_data), 16*sizeof(real),cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_push_kernel.cu", 878, cudaGetErrorString( err) ); exit(1); } };;

    { cudaError err = cudaMemset(d_diagnosis->flux_data, 0, 4*5*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_push_kernel.cu", 880, cudaGetErrorString( err) ); exit(1); } };;
  }
  gpu_kernel_input->gpu_timing.memtransfer_push_time += gpu_timer_measure(gpu_kernel_input);

  if(nblocks < gpu_kernel_input->deviceProp.maxGridSize[0])
    Dg.x = nblocks;
  else {
    if(!findGridDims(Dg,nblocks,gpu_kernel_input->deviceProp.maxGridSize[0])) ;

  }

  int mi_per_thread = gpu_kernel_input->charge_mi_per_thread;
  nthreads = gpu_kernel_input->nthreads/2;
  int mp = gpu_kernel_input->deviceProp.multiProcessorCount;
  int m = (mi + nthreads*mp - 1)/ (nthreads*mp);
  m = (m + mi_per_thread - 1)/mi_per_thread;
  nblocks = mp*m;
  mi_per_thread = (mi + nblocks*nthreads - 1)/ mi_per_thread;


  int shared_buffer = 5*sizeof(real) + (7*nthreads+4*5*nthreads)*sizeof(real);
  gpu_pushi_kernel<<< nblocks, nthreads, shared_buffer>>>(gpu_kernel_input->ptr_d_zion, gpu_kernel_input->ptr_d_aux_zion,gpu_kernel_input->ptr_d_grid, gpu_kernel_input->ptr_d_diagnosis, gpu_kernel_input->irk,gpu_kernel_input->istep, idiag);
  cudaError_t lasterror = cudaGetLastError();
  if(lasterror != cudaSuccess) {
    printf("Error in launching gpu_pushi_kernel routine: %s\n", cudaGetErrorString(lasterror));
  }

  gpu_kernel_input->gpu_timing.device_push_time += gpu_timer_measure(gpu_kernel_input);


  if (idiag==0){

    { cudaError err = cudaMemcpy((void*)(h_diagnosis->scalar_data), (d_diagnosis->scalar_data), 16*sizeof(real),cudaMemcpyDeviceToHost); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_push_kernel.cu", 912, cudaGetErrorString( err) ); exit(1); } };;
# 923 "./gpu_push_kernel.cu"
    { cudaError err = cudaMemcpy((void*)(h_diagnosis->flux_data), (d_diagnosis->flux_data), 4*5*sizeof(real),cudaMemcpyDeviceToHost); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "./gpu_push_kernel.cu", 923, cudaGetErrorString( err) ); exit(1); } };;
  }
  gpu_kernel_input->gpu_timing.memtransfer_push_time += gpu_timer_measure_end(gpu_kernel_input);

}
# 289 "gpu_setup.cu" 2




extern "C"
void cpy_gtc_data_to_device(gtc_bench_data_t *gtc_input, gpu_kernel_args_t* gpu_kernel_args)
{
  gtc_global_params_t *h_params = &(gtc_input->global_params);
  gtc_field_data_t *h_grid = &(gtc_input->field_data);
  gtc_field_data_t *d_grid = &(gpu_kernel_args->d_grid);
  gtc_particle_data_t *d_zion = &(gpu_kernel_args->d_zion);
  gtc_particle_data_t *h_zion = &(gtc_input->particle_data);
  gtc_radial_decomp_t *h_radial_decomp = &(gtc_input->radial_decomp);


  int mpsi = h_params->mpsi;
  int mi = h_params->mi;
  int nloc_over = h_radial_decomp->nloc_over;
  int d_mimax = mi;


  { cudaError err = cudaMemcpy((void *)gpu_kernel_args->ptr_d_zion, (void *)d_zion, sizeof(gtc_particle_data_t) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 310, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z0, h_zion->z0, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 311, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z1, h_zion->z1, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 312, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z2, h_zion->z2, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 313, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z3, h_zion->z3, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 314, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z4, h_zion->z4, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 315, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z5, h_zion->z5, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 316, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z00, h_zion->z0, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 317, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z01, h_zion->z1, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 318, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z02, h_zion->z2, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 319, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z03, h_zion->z3, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 320, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z04, h_zion->z4, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 321, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void *)d_zion->z05, h_zion->z05, (d_mimax)*sizeof(real) , cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 322, cudaGetErrorString( err) ); exit(1); } };;


  gtc_particle_data_t *d_auxs_zion = &(gpu_kernel_args->d_auxs_zion);
  { cudaError err = cudaMemcpy((void *)gpu_kernel_args->ptr_d_auxs_zion, (void *)d_auxs_zion, sizeof(gtc_particle_data_t), cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 326, cudaGetErrorString( err) ); exit(1); } };;
# 349 "gpu_setup.cu"
  gtc_diagnosis_data_t *d_diagnosis = &(gpu_kernel_args->d_diagnosis);
  { cudaError err = cudaMemcpy((void*)gpu_kernel_args->ptr_d_diagnosis, (void *)d_diagnosis, sizeof(gtc_diagnosis_data_t), cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 350, cudaGetErrorString( err) ); exit(1); } };;


  int tmp = h_params->mimax;
  h_params->mimax = gpu_kernel_args->d_mimax;
  { cudaError err = cudaMemcpyToSymbol(params,h_params, sizeof(gtc_global_params_t),0,cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 355, cudaGetErrorString( err) ); exit(1); } };;
  h_params->mimax = tmp;
  { cudaError err = cudaMemcpyToSymbol(radial_decomp, h_radial_decomp, sizeof(gtc_radial_decomp_t), 0, cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 357, cudaGetErrorString( err) ); exit(1); } };;

  real vthi = h_params->gyroradius*fabs(h_params->qion)/h_params->aion;

  int i;
  for (i=0; i<mpsi+1; i++) {
    h_grid->temp[i] = 1.0;
    h_grid->dtemp[i] = 0.0;
    h_grid->temp[i] = 1.0/(h_grid->temp[i] * h_grid->rtemi[i] * h_params->aion * vthi * vthi);

  }



  { cudaError err = cudaMemcpyToSymbol(temp, (h_grid->temp), (mpsi+1)*sizeof(real),0,cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 371, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpyToSymbol(rtemi, h_grid->rtemi, (mpsi+1)*sizeof(real),0,cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 372, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpyToSymbol(igrid, (h_grid->igrid), (mpsi+1)*sizeof(int),0,cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 373, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpyToSymbol(delt, (h_grid->delt), (mpsi+1)*sizeof(real),0,cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 374, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpyToSymbol(qtinv, (h_grid->qtinv), (mpsi+1)*sizeof(real),0,cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 375, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpyToSymbol(mtheta, (h_grid->mtheta), (mpsi+1)*sizeof(int),0,cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 376, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpyToSymbol(max_shift_mi, &(gpu_kernel_args->d_max_shift_mi), sizeof(int),0,cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 377, cudaGetErrorString( err) ); exit(1); } };;

  { cudaError err = cudaMemcpy((void *)gpu_kernel_args->ptr_d_grid,d_grid, sizeof(gtc_field_data_t), cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 379, cudaGetErrorString( err) ); exit(1); } };;

  { cudaError err = cudaMemcpy((void*)d_grid->pgyro, h_grid->pgyro, 4*nloc_over*sizeof(real), cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 381, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaMemcpy((void*)d_grid->tgyro, h_grid->tgyro, 4*nloc_over*sizeof(real), cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 382, cudaGetErrorString( err) ); exit(1); } };;




  int mzeta= h_params->mzeta;
  { cudaError err = cudaBindTexture(0, evectorTexRef, (void *)(d_grid->evector), nloc_over*3*(mzeta+1)*sizeof(real)); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 388, cudaGetErrorString( err) ); exit(1); } };;


  { cudaError err = cudaMemcpy((void*)d_grid->pfluxpsi, h_grid->pfluxpsi, 5*sizeof(real), cudaMemcpyHostToDevice); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 391, cudaGetErrorString( err) ); exit(1); } };;

}

extern "C"
void gpu_atexit(void)
{



}

extern "C"
void gpu_setup(gtc_bench_data_t* gtc_input, gpu_kernel_args_t* gpu_kernel_args)
{
  gtc_global_params_t *h_params = &(gtc_input->global_params);
  gpu_kernel_args->d_mimax = h_params->mi + 100*int(ceil(sqrt(h_params->mi)));
  gpu_kernel_args->d_mimax = (gpu_kernel_args->d_mimax/64 + 1) * 64;

  gpu_kernel_args->d_max_shift_mi = gpu_kernel_args->d_mimax / (100/10);
  gpu_kernel_args->d_nloc_over_cluster = (gtc_input->radial_decomp.nloc_over+4 -1)/4;
  gpu_kernel_args->d_nloc_over_cluster = (gpu_kernel_args->d_nloc_over_cluster/64 + 1) * 64;
  gpu_kernel_args->d_extra_mimax = (int)(3.0*gtc_input->radial_decomp.nloc_over*gtc_input->global_params.micell);
  gpu_kernel_args->d_extra_mimax = (gpu_kernel_args->d_extra_mimax/64 + 1) * 64;

  int device_count = 0;
  int pe = gtc_input->parallel_decomp.mype;

  { cudaError err = cudaGetDeviceCount(&device_count); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 419, cudaGetErrorString( err) ); exit(1); } };;
  int gpu_device = pe%device_count;
  { cudaError err = cudaSetDevice(gpu_device); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 421, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaGetDevice(&gpu_device); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 422, cudaGetErrorString( err) ); exit(1); } };;
  cudaGetDeviceProperties(&gpu_kernel_args->deviceProp, gpu_device);
  int nblocks=1;
  if (pe==0) printf("multiProcessorCount=%d\n", gpu_kernel_args->deviceProp.multiProcessorCount);
  while(nblocks < gpu_kernel_args->deviceProp.multiProcessorCount)
    nblocks *= 2;

  gpu_kernel_args->nblocks = 2*nblocks;

  if(pe == 0) {
    char *name[] = {"no","yes"};
    fprintf(stderr, "PE %d: Running on cuda device %d, total devices %d, Warpsize: %d, Min block count: %d\n",pe,gpu_device,device_count, gpu_kernel_args->deviceProp.warpSize, gpu_kernel_args->nblocks);
    fprintf(stderr, "GPU Run Configuration\n========================\n"
     "Prefer L1: %s\n"
     "Use of PTX intrinsics: %s\n"
     "Particle binning: %s (period %d)\n"
     "On the fly aux computation: %s\n"
     "Gyro local compute: %s\n"
     "Use cooperative threading for charge deposition: %s\n"
            "Use four-point algorithm: %s\n"
     "Use synergestic_sort_shift: %s\n=======================\n",
     name[0], name[1], name[1],10,name[1],name[0],name[1], name[0], name[1]);
  }

  gpu_kernel_args->nthreads = 64;
  gpu_kernel_args->charge_mi_per_thread = 64;
  allocate_device_data(gtc_input,gpu_kernel_args);
  memset(&gpu_kernel_args->gpu_timing,0,sizeof(gpu_timing_t));
# 458 "gpu_setup.cu"
  { cudaError err = cudaDeviceSetSharedMemConfig(cudaSharedMemBankSizeEightByte); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 458, cudaGetErrorString( err) ); exit(1); } };;
# 479 "gpu_setup.cu"
  { cudaError err = cudaFuncSetCacheConfig(gpu_pushi_kernel, cudaFuncCachePreferShared); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 479, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaFuncSetCacheConfig(gpu_charge_cooperative, cudaFuncCachePreferShared); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 480, cudaGetErrorString( err) ); exit(1); } };;
  { cudaError err = cudaFuncSetCacheConfig(gpu_charge_multi, cudaFuncCachePreferShared); if( cudaSuccess != err) { fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", "gpu_setup.cu", 481, cudaGetErrorString( err) ); exit(1); } };;
# 490 "gpu_setup.cu"
  atexit (gpu_atexit);
}

void print_gpu_timing(gpu_kernel_args_t* gpu_kernel_args)
{
  fprintf(stderr, "\nGPU PCIe time summary:\n"
   "Charge			%9.6f s\n"
    "Push			%9.6f s\n"
   "Shift			%9.6f s\n"
   "\nExecution time summary on GPU device:\n"
   "Charge			%9.6f s\n"
   "Push			%9.6f s\n"
   "Shift			%9.6f s\n"
   "Particle sort	%9.6f s\n"
    "Particle bin	%9.6f s\n"
   "charge reset   %9.6f s\n"
   "charge initialization %9.6f s\n"
   "charge interpolation  %9.6f s\n"
   "push point interpolation %9.6f s\n"
   "push gyro interpolation  %9.6f s\n",
   gpu_kernel_args->gpu_timing.memtransfer_charge_time,
   gpu_kernel_args->gpu_timing.memtransfer_push_time,
   gpu_kernel_args->gpu_timing.memtransfer_shift_time,
   gpu_kernel_args->gpu_timing.device_charge_time,
   gpu_kernel_args->gpu_timing.device_push_time,
   gpu_kernel_args->gpu_timing.device_shift_time,
   gpu_kernel_args->gpu_timing.device_particle_sort_time,
   gpu_kernel_args->gpu_timing.device_particle_bin_time,
   gpu_kernel_args->gpu_timing.memreset_charge_time,
   gpu_kernel_args->gpu_timing.initialization_charge_time,
   gpu_kernel_args->gpu_timing.interpolation_charge_time,
   gpu_kernel_args->gpu_timing.interpolation_push_point_time,
   gpu_kernel_args->gpu_timing.interpolation_push_gyro_time);
}
